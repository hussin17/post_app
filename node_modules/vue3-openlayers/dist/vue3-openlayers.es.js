import { toRefs as uh, reactive as mQ, watch as at, ref as Mo, onMounted as tr, onUnmounted as nr, provide as Ur, openBlock as xn, createElementBlock as Cn, renderSlot as mr, inject as _t, createCommentVNode as ur, computed as cr, watchEffect as vQ } from "vue";
class yQ {
  /**
   * @param {string} type Type.
   */
  constructor(e) {
    this.propagationStopped, this.defaultPrevented, this.type = e, this.target = null;
  }
  /**
   * Prevent default. This means that no emulated `click`, `singleclick` or `doubleclick` events
   * will be fired.
   * @api
   */
  preventDefault() {
    this.defaultPrevented = !0;
  }
  /**
   * Stop event propagation.
   * @api
   */
  stopPropagation() {
    this.propagationStopped = !0;
  }
}
function _Q(i) {
  i.stopPropagation();
}
const _s = yQ, fh = {
  /**
   * Triggered when a property is changed.
   * @event module:ol/Object.ObjectEvent#propertychange
   * @api
   */
  PROPERTYCHANGE: "propertychange"
};
class wQ {
  constructor() {
    this.disposed = !1;
  }
  /**
   * Clean up.
   */
  dispose() {
    this.disposed || (this.disposed = !0, this.disposeInternal());
  }
  /**
   * Extension point for disposable objects.
   * @protected
   */
  disposeInternal() {
  }
}
const Fv = wQ;
function xQ(i, e, t) {
  let r, n;
  t = t || Al;
  let s = 0, a = i.length, o = !1;
  for (; s < a; )
    r = s + (a - s >> 1), n = +t(i[r], e), n < 0 ? s = r + 1 : (a = r, o = !n);
  return o ? s : ~s;
}
function Al(i, e) {
  return i > e ? 1 : i < e ? -1 : 0;
}
function Lv(i, e, t) {
  const r = i.length;
  if (i[0] <= e)
    return 0;
  if (e <= i[r - 1])
    return r - 1;
  let n;
  if (t > 0) {
    for (n = 1; n < r; ++n)
      if (i[n] < e)
        return n - 1;
  } else if (t < 0) {
    for (n = 1; n < r; ++n)
      if (i[n] <= e)
        return n;
  } else
    for (n = 1; n < r; ++n) {
      if (i[n] == e)
        return n;
      if (i[n] < e)
        return typeof t == "function" ? t(e, i[n - 1], i[n]) > 0 ? n - 1 : n : i[n - 1] - e < e - i[n] ? n - 1 : n;
    }
  return r - 1;
}
function CQ(i, e, t) {
  for (; e < t; ) {
    const r = i[e];
    i[e] = i[t], i[t] = r, ++e, --t;
  }
}
function Er(i, e) {
  const t = Array.isArray(e) ? e : [e], r = t.length;
  for (let n = 0; n < r; n++)
    i[i.length] = t[n];
}
function Za(i, e) {
  const t = i.length;
  if (t !== e.length)
    return !1;
  for (let r = 0; r < t; r++)
    if (i[r] !== e[r])
      return !1;
  return !0;
}
function EQ(i, e, t) {
  const r = e || Al;
  return i.every(function(n, s) {
    if (s === 0)
      return !0;
    const a = r(i[s - 1], n);
    return !(a > 0 || t && a === 0);
  });
}
function Xo() {
  return !0;
}
function Eh() {
  return !1;
}
function hu() {
}
function BQ(i) {
  let e = !1, t, r, n;
  return function() {
    const s = Array.prototype.slice.call(arguments);
    return (!e || this !== n || !Za(s, r)) && (e = !0, n = this, r = s, t = i.apply(this, arguments)), t;
  };
}
function Bh(i) {
  for (const e in i)
    delete i[e];
}
function dh(i) {
  let e;
  for (e in i)
    return !1;
  return !e;
}
class bQ extends Fv {
  /**
   * @param {*} [target] Default event target for dispatched events.
   */
  constructor(e) {
    super(), this.eventTarget_ = e, this.pendingRemovals_ = null, this.dispatching_ = null, this.listeners_ = null;
  }
  /**
   * @param {string} type Type.
   * @param {import("../events.js").Listener} listener Listener.
   */
  addEventListener(e, t) {
    if (!e || !t)
      return;
    const r = this.listeners_ || (this.listeners_ = {}), n = r[e] || (r[e] = []);
    n.includes(t) || n.push(t);
  }
  /**
   * Dispatches an event and calls all listeners listening for events
   * of this type. The event parameter can either be a string or an
   * Object with a `type` property.
   *
   * @param {import("./Event.js").default|string} event Event object.
   * @return {boolean|undefined} `false` if anyone called preventDefault on the
   *     event object or if any of the listeners returned false.
   * @api
   */
  dispatchEvent(e) {
    const t = typeof e == "string", r = t ? e : e.type, n = this.listeners_ && this.listeners_[r];
    if (!n)
      return;
    const s = t ? new _s(e) : (
      /** @type {Event} */
      e
    );
    s.target || (s.target = this.eventTarget_ || this);
    const a = this.dispatching_ || (this.dispatching_ = {}), o = this.pendingRemovals_ || (this.pendingRemovals_ = {});
    r in a || (a[r] = 0, o[r] = 0), ++a[r];
    let A;
    for (let l = 0, h = n.length; l < h; ++l)
      if ("handleEvent" in n[l] ? A = /** @type {import("../events.js").ListenerObject} */
      n[l].handleEvent(s) : A = /** @type {import("../events.js").ListenerFunction} */
      n[l].call(this, s), A === !1 || s.propagationStopped) {
        A = !1;
        break;
      }
    if (--a[r] === 0) {
      let l = o[r];
      for (delete o[r]; l--; )
        this.removeEventListener(r, hu);
      delete a[r];
    }
    return A;
  }
  /**
   * Clean up.
   */
  disposeInternal() {
    this.listeners_ && Bh(this.listeners_);
  }
  /**
   * Get the listeners for a specified event type. Listeners are returned in the
   * order that they will be called in.
   *
   * @param {string} type Type.
   * @return {Array<import("../events.js").Listener>|undefined} Listeners.
   */
  getListeners(e) {
    return this.listeners_ && this.listeners_[e] || void 0;
  }
  /**
   * @param {string} [type] Type. If not provided,
   *     `true` will be returned if this event target has any listeners.
   * @return {boolean} Has listeners.
   */
  hasListener(e) {
    return this.listeners_ ? e ? e in this.listeners_ : Object.keys(this.listeners_).length > 0 : !1;
  }
  /**
   * @param {string} type Type.
   * @param {import("../events.js").Listener} listener Listener.
   */
  removeEventListener(e, t) {
    const r = this.listeners_ && this.listeners_[e];
    if (r) {
      const n = r.indexOf(t);
      n !== -1 && (this.pendingRemovals_ && e in this.pendingRemovals_ ? (r[n] = hu, ++this.pendingRemovals_[e]) : (r.splice(n, 1), r.length === 0 && delete this.listeners_[e]));
    }
  }
}
const bu = bQ, ut = {
  /**
   * Generic change event. Triggered when the revision counter is increased.
   * @event module:ol/events/Event~BaseEvent#change
   * @api
   */
  CHANGE: "change",
  /**
   * Generic error event. Triggered when an error occurs.
   * @event module:ol/events/Event~BaseEvent#error
   * @api
   */
  ERROR: "error",
  BLUR: "blur",
  CLEAR: "clear",
  CONTEXTMENU: "contextmenu",
  CLICK: "click",
  DBLCLICK: "dblclick",
  DRAGENTER: "dragenter",
  DRAGOVER: "dragover",
  DROP: "drop",
  FOCUS: "focus",
  KEYDOWN: "keydown",
  KEYPRESS: "keypress",
  LOAD: "load",
  RESIZE: "resize",
  TOUCHMOVE: "touchmove",
  WHEEL: "wheel"
};
function St(i, e, t, r, n) {
  if (r && r !== i && (t = t.bind(r)), n) {
    const a = t;
    t = function() {
      i.removeEventListener(e, t), a.apply(this, arguments);
    };
  }
  const s = {
    target: i,
    type: e,
    listener: t
  };
  return i.addEventListener(e, t), s;
}
function Sd(i, e, t, r) {
  return St(i, e, t, r, !0);
}
function pr(i) {
  i && i.target && (i.target.removeEventListener(i.type, i.listener), Bh(i));
}
class ag extends bu {
  constructor() {
    super(), this.on = /** @type {ObservableOnSignature<import("./events").EventsKey>} */
    this.onInternal, this.once = /** @type {ObservableOnSignature<import("./events").EventsKey>} */
    this.onceInternal, this.un = /** @type {ObservableOnSignature<void>} */
    this.unInternal, this.revision_ = 0;
  }
  /**
   * Increases the revision counter and dispatches a 'change' event.
   * @api
   */
  changed() {
    ++this.revision_, this.dispatchEvent(ut.CHANGE);
  }
  /**
   * Get the version number for this object.  Each time the object is modified,
   * its version number will be incremented.
   * @return {number} Revision.
   * @api
   */
  getRevision() {
    return this.revision_;
  }
  /**
   * @param {string|Array<string>} type Type.
   * @param {function((Event|import("./events/Event").default)): ?} listener Listener.
   * @return {import("./events.js").EventsKey|Array<import("./events.js").EventsKey>} Event key.
   * @protected
   */
  onInternal(e, t) {
    if (Array.isArray(e)) {
      const r = e.length, n = new Array(r);
      for (let s = 0; s < r; ++s)
        n[s] = St(this, e[s], t);
      return n;
    }
    return St(
      this,
      /** @type {string} */
      e,
      t
    );
  }
  /**
   * @param {string|Array<string>} type Type.
   * @param {function((Event|import("./events/Event").default)): ?} listener Listener.
   * @return {import("./events.js").EventsKey|Array<import("./events.js").EventsKey>} Event key.
   * @protected
   */
  onceInternal(e, t) {
    let r;
    if (Array.isArray(e)) {
      const n = e.length;
      r = new Array(n);
      for (let s = 0; s < n; ++s)
        r[s] = Sd(this, e[s], t);
    } else
      r = Sd(
        this,
        /** @type {string} */
        e,
        t
      );
    return t.ol_key = r, r;
  }
  /**
   * Unlisten for a certain type of event.
   * @param {string|Array<string>} type Type.
   * @param {function((Event|import("./events/Event").default)): ?} listener Listener.
   * @protected
   */
  unInternal(e, t) {
    const r = (
      /** @type {Object} */
      t.ol_key
    );
    if (r)
      Js(r);
    else if (Array.isArray(e))
      for (let n = 0, s = e.length; n < s; ++n)
        this.removeEventListener(e[n], t);
    else
      this.removeEventListener(e, t);
  }
}
ag.prototype.on;
ag.prototype.once;
ag.prototype.un;
function Js(i) {
  if (Array.isArray(i))
    for (let e = 0, t = i.length; e < t; ++e)
      pr(i[e]);
  else
    pr(
      /** @type {import("./events.js").EventsKey} */
      i
    );
}
function pt() {
  throw new Error("Unimplemented abstract method.");
}
let SQ = 0;
function st(i) {
  return i.ol_uid || (i.ol_uid = String(++SQ));
}
const TQ = "7.3.0";
class yS extends _s {
  /**
   * @param {string} type The event type.
   * @param {string} key The property name.
   * @param {*} oldValue The old value for `key`.
   */
  constructor(e, t, r) {
    super(e), this.key = t, this.oldValue = r;
  }
}
class FQ extends ag {
  /**
   * @param {Object<string, *>} [values] An object with key-value pairs.
   */
  constructor(e) {
    super(), this.on, this.once, this.un, st(this), this.values_ = null, e !== void 0 && this.setProperties(e);
  }
  /**
   * Gets a value.
   * @param {string} key Key name.
   * @return {*} Value.
   * @api
   */
  get(e) {
    let t;
    return this.values_ && this.values_.hasOwnProperty(e) && (t = this.values_[e]), t;
  }
  /**
   * Get a list of object property names.
   * @return {Array<string>} List of property names.
   * @api
   */
  getKeys() {
    return this.values_ && Object.keys(this.values_) || [];
  }
  /**
   * Get an object of all property names and values.
   * @return {Object<string, *>} Object.
   * @api
   */
  getProperties() {
    return this.values_ && Object.assign({}, this.values_) || {};
  }
  /**
   * @return {boolean} The object has properties.
   */
  hasProperties() {
    return !!this.values_;
  }
  /**
   * @param {string} key Key name.
   * @param {*} oldValue Old value.
   */
  notify(e, t) {
    let r;
    r = `change:${e}`, this.hasListener(r) && this.dispatchEvent(new yS(r, e, t)), r = fh.PROPERTYCHANGE, this.hasListener(r) && this.dispatchEvent(new yS(r, e, t));
  }
  /**
   * @param {string} key Key name.
   * @param {import("./events.js").Listener} listener Listener.
   */
  addChangeListener(e, t) {
    this.addEventListener(`change:${e}`, t);
  }
  /**
   * @param {string} key Key name.
   * @param {import("./events.js").Listener} listener Listener.
   */
  removeChangeListener(e, t) {
    this.removeEventListener(`change:${e}`, t);
  }
  /**
   * Sets a value.
   * @param {string} key Key name.
   * @param {*} value Value.
   * @param {boolean} [silent] Update without triggering an event.
   * @api
   */
  set(e, t, r) {
    const n = this.values_ || (this.values_ = {});
    if (r)
      n[e] = t;
    else {
      const s = n[e];
      n[e] = t, s !== t && this.notify(e, s);
    }
  }
  /**
   * Sets a collection of key-value pairs.  Note that this changes any existing
   * properties and adds new ones (it does not remove any existing properties).
   * @param {Object<string, *>} values Values.
   * @param {boolean} [silent] Update without triggering an event.
   * @api
   */
  setProperties(e, t) {
    for (const r in e)
      this.set(r, e[r], t);
  }
  /**
   * Apply any properties from another object without triggering events.
   * @param {BaseObject} source The source object.
   * @protected
   */
  applyProperties(e) {
    e.values_ && Object.assign(this.values_ || (this.values_ = {}), e.values_);
  }
  /**
   * Unsets a property.
   * @param {string} key Key name.
   * @param {boolean} [silent] Unset without triggering an event.
   * @api
   */
  unset(e, t) {
    if (this.values_ && e in this.values_) {
      const r = this.values_[e];
      delete this.values_[e], dh(this.values_) && (this.values_ = null), t || this.notify(e, r);
    }
  }
}
const ws = FQ, LQ = {
  1: "The view center is not defined",
  2: "The view resolution is not defined",
  3: "The view rotation is not defined",
  4: "`image` and `src` cannot be provided at the same time",
  5: "`imgSize` must be set when `image` is provided",
  7: "`format` must be set when `url` is set",
  8: "Unknown `serverType` configured",
  9: "`url` must be configured or set using `#setUrl()`",
  10: "The default `geometryFunction` can only handle `Point` geometries",
  11: "`options.featureTypes` must be an Array",
  12: "`options.geometryName` must also be provided when `options.bbox` is set",
  13: "Invalid corner",
  14: "Invalid color",
  15: "Tried to get a value for a key that does not exist in the cache",
  16: "Tried to set a value for a key that is used already",
  17: "`resolutions` must be sorted in descending order",
  18: "Either `origin` or `origins` must be configured, never both",
  19: "Number of `tileSizes` and `resolutions` must be equal",
  20: "Number of `origins` and `resolutions` must be equal",
  22: "Either `tileSize` or `tileSizes` must be configured, never both",
  24: "Invalid extent or geometry provided as `geometry`",
  25: "Cannot fit empty extent provided as `geometry`",
  26: "Features must have an id set",
  27: "Features must have an id set",
  28: '`renderMode` must be `"hybrid"` or `"vector"`',
  30: "The passed `feature` was already added to the source",
  31: "Tried to enqueue an `element` that was already added to the queue",
  32: "Transformation matrix cannot be inverted",
  33: "Invalid units",
  34: "Invalid geometry layout",
  36: "Unknown SRS type",
  37: "Unknown geometry type found",
  38: "`styleMapValue` has an unknown type",
  39: "Unknown geometry type",
  40: "Expected `feature` to have a geometry",
  41: "Expected an `ol/style/Style` or an array of `ol/style/Style.js`",
  42: "Question unknown, the answer is 42",
  43: "Expected `layers` to be an array or a `Collection`",
  47: "Expected `controls` to be an array or an `ol/Collection`",
  48: "Expected `interactions` to be an array or an `ol/Collection`",
  49: "Expected `overlays` to be an array or an `ol/Collection`",
  50: "`options.featureTypes` should be an Array",
  51: "Either `url` or `tileJSON` options must be provided",
  52: "Unknown `serverType` configured",
  53: "Unknown `tierSizeCalculation` configured",
  55: "The {-y} placeholder requires a tile grid with extent",
  56: "mapBrowserEvent must originate from a pointer event",
  57: "At least 2 conditions are required",
  59: "Invalid command found in the PBF",
  60: "Missing or invalid `size`",
  61: "Cannot determine IIIF Image API version from provided image information JSON",
  62: "A `WebGLArrayBuffer` must either be of type `ELEMENT_ARRAY_BUFFER` or `ARRAY_BUFFER`",
  64: "Layer opacity must be a number",
  66: "`forEachFeatureAtCoordinate` cannot be used on a WebGL layer if the hit detection logic has not been enabled. This is done by providing adequate shaders using the `hitVertexShader` and `hitFragmentShader` properties of `WebGLPointsLayerRenderer`",
  67: "A layer can only be added to the map once. Use either `layer.setMap()` or `map.addLayer()`, not both",
  68: "A VectorTile source can only be rendered if it has a projection compatible with the view projection",
  69: "`width` or `height` cannot be provided together with `scale`"
};
class IQ extends Error {
  /**
   * @param {number} code Error code.
   */
  constructor(e) {
    const t = LQ[e];
    super(t), this.code = e, this.name = "AssertionError", this.message = t;
  }
}
const gR = IQ, Si = {
  /**
   * Triggered when an item is added to the collection.
   * @event module:ol/Collection.CollectionEvent#add
   * @api
   */
  ADD: "add",
  /**
   * Triggered when an item is removed from the collection.
   * @event module:ol/Collection.CollectionEvent#remove
   * @api
   */
  REMOVE: "remove"
}, _S = {
  LENGTH: "length"
};
class Bp extends _s {
  /**
   * @param {import("./CollectionEventType.js").default} type Type.
   * @param {T} element Element.
   * @param {number} index The index of the added or removed element.
   */
  constructor(e, t, r) {
    super(e), this.element = t, this.index = r;
  }
}
class RQ extends ws {
  /**
   * @param {Array<T>} [array] Array.
   * @param {Options} [options] Collection options.
   */
  constructor(e, t) {
    if (super(), this.on, this.once, this.un, t = t || {}, this.unique_ = !!t.unique, this.array_ = e || [], this.unique_)
      for (let r = 0, n = this.array_.length; r < n; ++r)
        this.assertUnique_(this.array_[r], r);
    this.updateLength_();
  }
  /**
   * Remove all elements from the collection.
   * @api
   */
  clear() {
    for (; this.getLength() > 0; )
      this.pop();
  }
  /**
   * Add elements to the collection.  This pushes each item in the provided array
   * to the end of the collection.
   * @param {!Array<T>} arr Array.
   * @return {Collection<T>} This collection.
   * @api
   */
  extend(e) {
    for (let t = 0, r = e.length; t < r; ++t)
      this.push(e[t]);
    return this;
  }
  /**
   * Iterate over each element, calling the provided callback.
   * @param {function(T, number, Array<T>): *} f The function to call
   *     for every element. This function takes 3 arguments (the element, the
   *     index and the array). The return value is ignored.
   * @api
   */
  forEach(e) {
    const t = this.array_;
    for (let r = 0, n = t.length; r < n; ++r)
      e(t[r], r, t);
  }
  /**
   * Get a reference to the underlying Array object. Warning: if the array
   * is mutated, no events will be dispatched by the collection, and the
   * collection's "length" property won't be in sync with the actual length
   * of the array.
   * @return {!Array<T>} Array.
   * @api
   */
  getArray() {
    return this.array_;
  }
  /**
   * Get the element at the provided index.
   * @param {number} index Index.
   * @return {T} Element.
   * @api
   */
  item(e) {
    return this.array_[e];
  }
  /**
   * Get the length of this collection.
   * @return {number} The length of the array.
   * @observable
   * @api
   */
  getLength() {
    return this.get(_S.LENGTH);
  }
  /**
   * Insert an element at the provided index.
   * @param {number} index Index.
   * @param {T} elem Element.
   * @api
   */
  insertAt(e, t) {
    if (e < 0 || e > this.getLength())
      throw new Error("Index out of bounds: " + e);
    this.unique_ && this.assertUnique_(t), this.array_.splice(e, 0, t), this.updateLength_(), this.dispatchEvent(
      new Bp(Si.ADD, t, e)
    );
  }
  /**
   * Remove the last element of the collection and return it.
   * Return `undefined` if the collection is empty.
   * @return {T|undefined} Element.
   * @api
   */
  pop() {
    return this.removeAt(this.getLength() - 1);
  }
  /**
   * Insert the provided element at the end of the collection.
   * @param {T} elem Element.
   * @return {number} New length of the collection.
   * @api
   */
  push(e) {
    this.unique_ && this.assertUnique_(e);
    const t = this.getLength();
    return this.insertAt(t, e), this.getLength();
  }
  /**
   * Remove the first occurrence of an element from the collection.
   * @param {T} elem Element.
   * @return {T|undefined} The removed element or undefined if none found.
   * @api
   */
  remove(e) {
    const t = this.array_;
    for (let r = 0, n = t.length; r < n; ++r)
      if (t[r] === e)
        return this.removeAt(r);
  }
  /**
   * Remove the element at the provided index and return it.
   * Return `undefined` if the collection does not contain this index.
   * @param {number} index Index.
   * @return {T|undefined} Value.
   * @api
   */
  removeAt(e) {
    if (e < 0 || e >= this.getLength())
      return;
    const t = this.array_[e];
    return this.array_.splice(e, 1), this.updateLength_(), this.dispatchEvent(
      /** @type {CollectionEvent<T>} */
      new Bp(Si.REMOVE, t, e)
    ), t;
  }
  /**
   * Set the element at the provided index.
   * @param {number} index Index.
   * @param {T} elem Element.
   * @api
   */
  setAt(e, t) {
    const r = this.getLength();
    if (e >= r) {
      this.insertAt(e, t);
      return;
    }
    if (e < 0)
      throw new Error("Index out of bounds: " + e);
    this.unique_ && this.assertUnique_(t, e);
    const n = this.array_[e];
    this.array_[e] = t, this.dispatchEvent(
      /** @type {CollectionEvent<T>} */
      new Bp(Si.REMOVE, n, e)
    ), this.dispatchEvent(
      /** @type {CollectionEvent<T>} */
      new Bp(Si.ADD, t, e)
    );
  }
  /**
   * @private
   */
  updateLength_() {
    this.set(_S.LENGTH, this.array_.length);
  }
  /**
   * @private
   * @param {T} elem Element.
   * @param {number} [except] Optional index to ignore.
   */
  assertUnique_(e, t) {
    for (let r = 0, n = this.array_.length; r < n; ++r)
      if (this.array_[r] === e && r !== t)
        throw new gR(58);
  }
}
const Yi = RQ, ll = typeof navigator < "u" && typeof navigator.userAgent < "u" ? navigator.userAgent.toLowerCase() : "", MQ = ll.includes("firefox"), NQ = ll.includes("safari") && !ll.includes("chrom"), PQ = NQ && (ll.includes("version/15.4") || /cpu (os|iphone os) 15_4 like mac os x/.test(ll)), OQ = ll.includes("webkit") && !ll.includes("edge"), pR = ll.includes("macintosh"), mR = typeof devicePixelRatio < "u" ? devicePixelRatio : 1, rE = typeof WorkerGlobalScope < "u" && typeof OffscreenCanvas < "u" && self instanceof WorkerGlobalScope, UQ = typeof Image < "u" && Image.prototype.decode, vR = function() {
  let i = !1;
  try {
    const e = Object.defineProperty({}, "passive", {
      get: function() {
        i = !0;
      }
    });
    window.addEventListener("_", null, e), window.removeEventListener("_", null, e);
  } catch {
  }
  return i;
}();
function lt(i, e) {
  if (!i)
    throw new gR(e);
}
const iE = new Array(6);
function qi() {
  return [1, 0, 0, 1, 0, 0];
}
function Wc(i) {
  return og(i, 1, 0, 0, 1, 0, 0);
}
function gh(i, e) {
  const t = i[0], r = i[1], n = i[2], s = i[3], a = i[4], o = i[5], A = e[0], l = e[1], h = e[2], c = e[3], u = e[4], f = e[5];
  return i[0] = t * A + n * l, i[1] = r * A + s * l, i[2] = t * h + n * c, i[3] = r * h + s * c, i[4] = t * u + n * f + a, i[5] = r * u + s * f + o, i;
}
function og(i, e, t, r, n, s, a) {
  return i[0] = e, i[1] = t, i[2] = r, i[3] = n, i[4] = s, i[5] = a, i;
}
function QQ(i, e) {
  return i[0] = e[0], i[1] = e[1], i[2] = e[2], i[3] = e[3], i[4] = e[4], i[5] = e[5], i;
}
function vi(i, e) {
  const t = e[0], r = e[1];
  return e[0] = i[0] * t + i[2] * r + i[4], e[1] = i[1] * t + i[3] * r + i[5], e;
}
function yR(i, e) {
  const t = Math.cos(e), r = Math.sin(e);
  return gh(i, og(iE, t, r, -r, t, 0, 0));
}
function Yc(i, e, t) {
  return gh(i, og(iE, e, 0, 0, t, 0, 0));
}
function DQ(i, e, t) {
  return og(i, e, 0, 0, t, 0, 0);
}
function hm(i, e, t) {
  return gh(i, og(iE, 1, 0, 0, 1, e, t));
}
function Qs(i, e, t, r, n, s, a, o) {
  const A = Math.sin(s), l = Math.cos(s);
  return i[0] = r * l, i[1] = n * A, i[2] = -r * A, i[3] = n * l, i[4] = a * r * l - o * r * A + e, i[5] = a * n * A + o * n * l + t, i;
}
function Ag(i, e) {
  const t = kQ(e);
  lt(t !== 0, 32);
  const r = e[0], n = e[1], s = e[2], a = e[3], o = e[4], A = e[5];
  return i[0] = a / t, i[1] = -n / t, i[2] = -s / t, i[3] = r / t, i[4] = (s * A - a * o) / t, i[5] = -(r * A - n * o) / t, i;
}
function kQ(i) {
  return i[0] * i[3] - i[1] * i[2];
}
let wS;
function nE(i) {
  const e = "matrix(" + i.join(", ") + ")";
  if (rE)
    return e;
  const t = wS || (wS = document.createElement("div"));
  return t.style.transform = e, t.style.transform;
}
const vn = {
  UNKNOWN: 0,
  INTERSECTING: 1,
  ABOVE: 2,
  RIGHT: 4,
  BELOW: 8,
  LEFT: 16
};
function Xi(i) {
  const e = Ji();
  for (let t = 0, r = i.length; t < r; ++t)
    eh(e, i[t]);
  return e;
}
function HQ(i, e, t) {
  const r = Math.min.apply(null, i), n = Math.min.apply(null, e), s = Math.max.apply(null, i), a = Math.max.apply(null, e);
  return ms(r, n, s, a, t);
}
function zn(i, e, t) {
  return t ? (t[0] = i[0] - e, t[1] = i[1] - e, t[2] = i[2] + e, t[3] = i[3] + e, t) : [
    i[0] - e,
    i[1] - e,
    i[2] + e,
    i[3] + e
  ];
}
function sE(i, e) {
  return e ? (e[0] = i[0], e[1] = i[1], e[2] = i[2], e[3] = i[3], e) : i.slice();
}
function yl(i, e, t) {
  let r, n;
  return e < i[0] ? r = i[0] - e : i[2] < e ? r = e - i[2] : r = 0, t < i[1] ? n = i[1] - t : i[3] < t ? n = t - i[3] : n = 0, r * r + n * n;
}
function Wo(i, e) {
  return Iv(i, e[0], e[1]);
}
function Ps(i, e) {
  return i[0] <= e[0] && e[2] <= i[2] && i[1] <= e[1] && e[3] <= i[3];
}
function Iv(i, e, t) {
  return i[0] <= e && e <= i[2] && i[1] <= t && t <= i[3];
}
function cm(i, e) {
  const t = i[0], r = i[1], n = i[2], s = i[3], a = e[0], o = e[1];
  let A = vn.UNKNOWN;
  return a < t ? A = A | vn.LEFT : a > n && (A = A | vn.RIGHT), o < r ? A = A | vn.BELOW : o > s && (A = A | vn.ABOVE), A === vn.UNKNOWN && (A = vn.INTERSECTING), A;
}
function Ji() {
  return [1 / 0, 1 / 0, -1 / 0, -1 / 0];
}
function ms(i, e, t, r, n) {
  return n ? (n[0] = i, n[1] = e, n[2] = t, n[3] = r, n) : [i, e, t, r];
}
function _l(i) {
  return ms(1 / 0, 1 / 0, -1 / 0, -1 / 0, i);
}
function Zl(i, e) {
  const t = i[0], r = i[1];
  return ms(t, r, t, r, e);
}
function GQ(i, e) {
  const t = _l(e);
  return aE(t, i);
}
function Rv(i, e, t, r, n) {
  const s = _l(n);
  return oE(s, i, e, t, r);
}
function $Q(i, e) {
  const t = _l(e);
  return _R(t, i);
}
function Xa(i, e) {
  return i[0] == e[0] && i[2] == e[2] && i[1] == e[1] && i[3] == e[3];
}
function VQ(i, e, t) {
  return Math.abs(i[0] - e[0]) < t && Math.abs(i[2] - e[2]) < t && Math.abs(i[1] - e[1]) < t && Math.abs(i[3] - e[3]) < t;
}
function Jl(i, e) {
  return e[0] < i[0] && (i[0] = e[0]), e[2] > i[2] && (i[2] = e[2]), e[1] < i[1] && (i[1] = e[1]), e[3] > i[3] && (i[3] = e[3]), i;
}
function eh(i, e) {
  e[0] < i[0] && (i[0] = e[0]), e[0] > i[2] && (i[2] = e[0]), e[1] < i[1] && (i[1] = e[1]), e[1] > i[3] && (i[3] = e[1]);
}
function aE(i, e) {
  for (let t = 0, r = e.length; t < r; ++t)
    eh(i, e[t]);
  return i;
}
function oE(i, e, t, r, n) {
  for (; t < r; t += n)
    wR(i, e[t], e[t + 1]);
  return i;
}
function _R(i, e) {
  for (let t = 0, r = e.length; t < r; ++t)
    aE(i, e[t]);
  return i;
}
function wR(i, e, t) {
  i[0] = Math.min(i[0], e), i[1] = Math.min(i[1], t), i[2] = Math.max(i[2], e), i[3] = Math.max(i[3], t);
}
function Mv(i, e) {
  let t;
  return t = e(lg(i)), t || (t = e(Su(i)), t) || (t = e(hg(i)), t) || (t = e(Sa(i)), t) ? t : !1;
}
function ph(i) {
  let e = 0;
  return Tu(i) || (e = ir(i) * _i(i)), e;
}
function lg(i) {
  return [i[0], i[1]];
}
function Su(i) {
  return [i[2], i[1]];
}
function Xn(i) {
  return [(i[0] + i[2]) / 2, (i[1] + i[3]) / 2];
}
function xR(i, e) {
  let t;
  return e === "bottom-left" ? t = lg(i) : e === "bottom-right" ? t = Su(i) : e === "top-left" ? t = Sa(i) : e === "top-right" ? t = hg(i) : lt(!1, 13), t;
}
function KQ(i, e) {
  const t = Math.min(i[0], e[0]), r = Math.min(i[1], e[1]), n = Math.max(i[2], e[2]), s = Math.max(i[3], e[3]);
  return (n - t) * (s - r);
}
function th(i, e, t, r, n) {
  const [s, a, o, A, l, h, c, u] = um(
    i,
    e,
    t,
    r
  );
  return ms(
    Math.min(s, o, l, c),
    Math.min(a, A, h, u),
    Math.max(s, o, l, c),
    Math.max(a, A, h, u),
    n
  );
}
function um(i, e, t, r) {
  const n = e * r[0] / 2, s = e * r[1] / 2, a = Math.cos(t), o = Math.sin(t), A = n * a, l = n * o, h = s * a, c = s * o, u = i[0], f = i[1];
  return [
    u - A + c,
    f - l - h,
    u - A - c,
    f - l + h,
    u + A - c,
    f + l + h,
    u + A + c,
    f + l - h,
    u - A + c,
    f - l - h
  ];
}
function _i(i) {
  return i[3] - i[1];
}
function jQ(i, e) {
  const t = jn(i, e);
  return ph(t);
}
function jn(i, e, t) {
  const r = t || Ji();
  return ci(i, e) ? (i[0] > e[0] ? r[0] = i[0] : r[0] = e[0], i[1] > e[1] ? r[1] = i[1] : r[1] = e[1], i[2] < e[2] ? r[2] = i[2] : r[2] = e[2], i[3] < e[3] ? r[3] = i[3] : r[3] = e[3]) : _l(r), r;
}
function zQ(i) {
  return ir(i) + _i(i);
}
function XQ(i) {
  return [i[2] - i[0], i[3] - i[1]];
}
function Sa(i) {
  return [i[0], i[3]];
}
function hg(i) {
  return [i[2], i[3]];
}
function ir(i) {
  return i[2] - i[0];
}
function ci(i, e) {
  return i[0] <= e[2] && i[2] >= e[0] && i[1] <= e[3] && i[3] >= e[1];
}
function Tu(i) {
  return i[2] < i[0] || i[3] < i[1];
}
function CR(i, e) {
  return e ? (e[0] = i[0], e[1] = i[1], e[2] = i[2], e[3] = i[3], e) : i;
}
function ER(i, e) {
  const t = (i[2] - i[0]) / 2 * (e - 1), r = (i[3] - i[1]) / 2 * (e - 1);
  i[0] -= t, i[2] += t, i[1] -= r, i[3] += r;
}
function BR(i, e, t) {
  let r = !1;
  const n = cm(i, e), s = cm(i, t);
  if (n === vn.INTERSECTING || s === vn.INTERSECTING)
    r = !0;
  else {
    const a = i[0], o = i[1], A = i[2], l = i[3], h = e[0], c = e[1], u = t[0], f = t[1], g = (f - c) / (u - h);
    let p, y;
    s & vn.ABOVE && !(n & vn.ABOVE) && (p = u - (f - l) / g, r = p >= a && p <= A), !r && s & vn.RIGHT && !(n & vn.RIGHT) && (y = f - (u - A) * g, r = y >= o && y <= l), !r && s & vn.BELOW && !(n & vn.BELOW) && (p = u - (f - o) / g, r = p >= a && p <= A), !r && s & vn.LEFT && !(n & vn.LEFT) && (y = f - (u - a) * g, r = y >= o && y <= l);
  }
  return r;
}
function AE(i, e, t, r) {
  let n = [];
  if (r > 1) {
    const o = i[2] - i[0], A = i[3] - i[1];
    for (let l = 0; l < r; ++l)
      n.push(
        i[0] + o * l / r,
        i[1],
        i[2],
        i[1] + A * l / r,
        i[2] - o * l / r,
        i[3],
        i[0],
        i[3] - A * l / r
      );
  } else
    n = [
      i[0],
      i[1],
      i[2],
      i[1],
      i[2],
      i[3],
      i[0],
      i[3]
    ];
  e(n, n, 2);
  const s = [], a = [];
  for (let o = 0, A = n.length; o < A; o += 2)
    s.push(n[o]), a.push(n[o + 1]);
  return HQ(s, a, t);
}
function lE(i, e) {
  const t = e.getExtent(), r = Xn(i);
  if (e.canWrapX() && (r[0] < t[0] || r[0] >= t[2])) {
    const n = ir(t), a = Math.floor(
      (r[0] - t[0]) / n
    ) * n;
    i[0] -= a, i[2] -= a;
  }
  return i;
}
function bR(i, e) {
  if (e.canWrapX()) {
    const t = e.getExtent();
    if (!isFinite(i[0]) || !isFinite(i[2]))
      return [[t[0], i[1], t[2], i[3]]];
    lE(i, e);
    const r = ir(t);
    if (ir(i) > r)
      return [[t[0], i[1], t[2], i[3]]];
    if (i[0] < t[0])
      return [
        [i[0] + r, i[1], t[2], i[3]],
        [t[0], i[1], i[2], i[3]]
      ];
    if (i[2] > t[2])
      return [
        [i[0], i[1], t[2], i[3]],
        [t[0], i[1], i[2] - r, i[3]]
      ];
  }
  return [i];
}
const WQ = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  applyTransform: AE,
  approximatelyEquals: VQ,
  boundingExtent: Xi,
  buffer: zn,
  clone: sE,
  closestSquaredDistanceXY: yl,
  containsCoordinate: Wo,
  containsExtent: Ps,
  containsXY: Iv,
  coordinateRelationship: cm,
  createEmpty: Ji,
  createOrUpdate: ms,
  createOrUpdateEmpty: _l,
  createOrUpdateFromCoordinate: Zl,
  createOrUpdateFromCoordinates: GQ,
  createOrUpdateFromFlatCoordinates: Rv,
  createOrUpdateFromRings: $Q,
  equals: Xa,
  extend: Jl,
  extendCoordinate: eh,
  extendCoordinates: aE,
  extendFlatCoordinates: oE,
  extendRings: _R,
  extendXY: wR,
  forEachCorner: Mv,
  getArea: ph,
  getBottomLeft: lg,
  getBottomRight: Su,
  getCenter: Xn,
  getCorner: xR,
  getEnlargedArea: KQ,
  getForViewAndSize: th,
  getHeight: _i,
  getIntersection: jn,
  getIntersectionArea: jQ,
  getMargin: zQ,
  getRotatedViewport: um,
  getSize: XQ,
  getTopLeft: Sa,
  getTopRight: hg,
  getWidth: ir,
  intersects: ci,
  intersectsSegment: BR,
  isEmpty: Tu,
  returnOrUpdate: CR,
  scaleFromCenter: ER,
  wrapAndSliceX: bR,
  wrapX: lE
}, Symbol.toStringTag, { value: "Module" }));
function jr(i, e, t) {
  return Math.min(Math.max(i, e), t);
}
function YQ(i, e, t, r, n, s) {
  const a = n - t, o = s - r;
  if (a !== 0 || o !== 0) {
    const A = ((i - t) * a + (e - r) * o) / (a * a + o * o);
    A > 1 ? (t = n, r = s) : A > 0 && (t += a * A, r += o * A);
  }
  return ko(i, e, t, r);
}
function ko(i, e, t, r) {
  const n = t - i, s = r - e;
  return n * n + s * s;
}
function qQ(i) {
  const e = i.length;
  for (let r = 0; r < e; r++) {
    let n = r, s = Math.abs(i[r][r]);
    for (let o = r + 1; o < e; o++) {
      const A = Math.abs(i[o][r]);
      A > s && (s = A, n = o);
    }
    if (s === 0)
      return null;
    const a = i[n];
    i[n] = i[r], i[r] = a;
    for (let o = r + 1; o < e; o++) {
      const A = -i[o][r] / i[r][r];
      for (let l = r; l < e + 1; l++)
        r == l ? i[o][l] = 0 : i[o][l] += A * i[r][l];
    }
  }
  const t = new Array(e);
  for (let r = e - 1; r >= 0; r--) {
    t[r] = i[r][e] / i[r][r];
    for (let n = r - 1; n >= 0; n--)
      i[n][e] -= i[n][r] * t[r];
  }
  return t;
}
function xS(i) {
  return i * 180 / Math.PI;
}
function el(i) {
  return i * Math.PI / 180;
}
function tl(i, e) {
  const t = i % e;
  return t * e < 0 ? t + e : t;
}
function Ms(i, e, t) {
  return i + t * (e - i);
}
function cg(i, e) {
  const t = Math.pow(10, e);
  return Math.round(i * t) / t;
}
function CS(i, e) {
  return Math.round(cg(i, e));
}
function Nc(i, e) {
  return Math.floor(cg(i, e));
}
function KA(i, e) {
  return Math.ceil(cg(i, e));
}
const SR = /^#([a-f0-9]{3}|[a-f0-9]{4}(?:[a-f0-9]{2}){0,2})$/i, TR = /^([a-z]*)$|^hsla?\(.*\)$/i;
function rl(i) {
  return typeof i == "string" ? i : IR(i);
}
function FR(i) {
  const e = document.createElement("div");
  if (e.style.color = i, e.style.color !== "") {
    document.body.appendChild(e);
    const t = getComputedStyle(e).color;
    return document.body.removeChild(e), t;
  }
  return "";
}
const LR = function() {
  const e = {};
  let t = 0;
  return (
    /**
     * @param {string} s String.
     * @return {Color} Color.
     */
    function(r) {
      let n;
      if (e.hasOwnProperty(r))
        n = e[r];
      else {
        if (t >= 1024) {
          let s = 0;
          for (const a in e)
            s++ & 3 || (delete e[a], --t);
        }
        n = ZQ(r), e[r] = n, ++t;
      }
      return n;
    }
  );
}();
function hl(i) {
  return Array.isArray(i) ? i : LR(i);
}
function ZQ(i) {
  let e, t, r, n, s;
  if (TR.exec(i) && (i = FR(i)), SR.exec(i)) {
    const a = i.length - 1;
    let o;
    a <= 4 ? o = 1 : o = 2;
    const A = a === 4 || a === 8;
    e = parseInt(i.substr(1 + 0 * o, o), 16), t = parseInt(i.substr(1 + 1 * o, o), 16), r = parseInt(i.substr(1 + 2 * o, o), 16), A ? n = parseInt(i.substr(1 + 3 * o, o), 16) : n = 255, o == 1 && (e = (e << 4) + e, t = (t << 4) + t, r = (r << 4) + r, A && (n = (n << 4) + n)), s = [e, t, r, n / 255];
  } else
    i.startsWith("rgba(") ? (s = i.slice(5, -1).split(",").map(Number), ES(s)) : i.startsWith("rgb(") ? (s = i.slice(4, -1).split(",").map(Number), s.push(1), ES(s)) : lt(!1, 14);
  return s;
}
function ES(i) {
  return i[0] = jr(i[0] + 0.5 | 0, 0, 255), i[1] = jr(i[1] + 0.5 | 0, 0, 255), i[2] = jr(i[2] + 0.5 | 0, 0, 255), i[3] = jr(i[3], 0, 1), i;
}
function IR(i) {
  let e = i[0];
  e != (e | 0) && (e = e + 0.5 | 0);
  let t = i[1];
  t != (t | 0) && (t = t + 0.5 | 0);
  let r = i[2];
  r != (r | 0) && (r = r + 0.5 | 0);
  const n = i[3] === void 0 ? 1 : Math.round(i[3] * 100) / 100;
  return "rgba(" + e + "," + t + "," + r + "," + n + ")";
}
function JQ(i) {
  return TR.test(i) && (i = FR(i)), SR.test(i) || i.startsWith("rgba(") || i.startsWith("rgb(");
}
class eD {
  constructor() {
    this.cache_ = {}, this.cacheSize_ = 0, this.maxCacheSize_ = 32;
  }
  /**
   * FIXME empty description for jsdoc
   */
  clear() {
    this.cache_ = {}, this.cacheSize_ = 0;
  }
  /**
   * @return {boolean} Can expire cache.
   */
  canExpireCache() {
    return this.cacheSize_ > this.maxCacheSize_;
  }
  /**
   * FIXME empty description for jsdoc
   */
  expire() {
    if (this.canExpireCache()) {
      let e = 0;
      for (const t in this.cache_) {
        const r = this.cache_[t];
        !(e++ & 3) && !r.hasListener() && (delete this.cache_[t], --this.cacheSize_);
      }
    }
  }
  /**
   * @param {string} src Src.
   * @param {?string} crossOrigin Cross origin.
   * @param {import("../color.js").Color} color Color.
   * @return {import("./IconImage.js").default} Icon image.
   */
  get(e, t, r) {
    const n = BS(e, t, r);
    return n in this.cache_ ? this.cache_[n] : null;
  }
  /**
   * @param {string} src Src.
   * @param {?string} crossOrigin Cross origin.
   * @param {import("../color.js").Color} color Color.
   * @param {import("./IconImage.js").default} iconImage Icon image.
   */
  set(e, t, r, n) {
    const s = BS(e, t, r);
    this.cache_[s] = n, ++this.cacheSize_;
  }
  /**
   * Set the cache size of the icon cache. Default is `32`. Change this value when
   * your map uses more than 32 different icon images and you are not caching icon
   * styles on the application level.
   * @param {number} maxCacheSize Cache max size.
   * @api
   */
  setSize(e) {
    this.maxCacheSize_ = e, this.expire();
  }
}
function BS(i, e, t) {
  const r = t ? rl(t) : "null";
  return e + ":" + i + ":" + r;
}
const fm = new eD(), Fr = {
  OPACITY: "opacity",
  VISIBLE: "visible",
  EXTENT: "extent",
  Z_INDEX: "zIndex",
  MAX_RESOLUTION: "maxResolution",
  MIN_RESOLUTION: "minResolution",
  MAX_ZOOM: "maxZoom",
  MIN_ZOOM: "minZoom",
  SOURCE: "source",
  MAP: "map"
};
let tD = class extends ws {
  /**
   * @param {Options} options Layer options.
   */
  constructor(e) {
    super(), this.on, this.once, this.un, this.background_ = e.background;
    const t = Object.assign({}, e);
    typeof e.properties == "object" && (delete t.properties, Object.assign(t, e.properties)), t[Fr.OPACITY] = e.opacity !== void 0 ? e.opacity : 1, lt(typeof t[Fr.OPACITY] == "number", 64), t[Fr.VISIBLE] = e.visible !== void 0 ? e.visible : !0, t[Fr.Z_INDEX] = e.zIndex, t[Fr.MAX_RESOLUTION] = e.maxResolution !== void 0 ? e.maxResolution : 1 / 0, t[Fr.MIN_RESOLUTION] = e.minResolution !== void 0 ? e.minResolution : 0, t[Fr.MIN_ZOOM] = e.minZoom !== void 0 ? e.minZoom : -1 / 0, t[Fr.MAX_ZOOM] = e.maxZoom !== void 0 ? e.maxZoom : 1 / 0, this.className_ = t.className !== void 0 ? t.className : "ol-layer", delete t.className, this.setProperties(t), this.state_ = null;
  }
  /**
   * Get the background for this layer.
   * @return {BackgroundColor|false} Layer background.
   */
  getBackground() {
    return this.background_;
  }
  /**
   * @return {string} CSS class name.
   */
  getClassName() {
    return this.className_;
  }
  /**
   * This method is not meant to be called by layers or layer renderers because the state
   * is incorrect if the layer is included in a layer group.
   *
   * @param {boolean} [managed] Layer is managed.
   * @return {import("./Layer.js").State} Layer state.
   */
  getLayerState(e) {
    const t = this.state_ || /** @type {?} */
    {
      layer: this,
      managed: e === void 0 ? !0 : e
    }, r = this.getZIndex();
    return t.opacity = jr(Math.round(this.getOpacity() * 100) / 100, 0, 1), t.visible = this.getVisible(), t.extent = this.getExtent(), t.zIndex = r === void 0 && !t.managed ? 1 / 0 : r, t.maxResolution = this.getMaxResolution(), t.minResolution = Math.max(this.getMinResolution(), 0), t.minZoom = this.getMinZoom(), t.maxZoom = this.getMaxZoom(), this.state_ = t, t;
  }
  /**
   * @abstract
   * @param {Array<import("./Layer.js").default>} [array] Array of layers (to be
   *     modified in place).
   * @return {Array<import("./Layer.js").default>} Array of layers.
   */
  getLayersArray(e) {
    return pt();
  }
  /**
   * @abstract
   * @param {Array<import("./Layer.js").State>} [states] Optional list of layer
   *     states (to be modified in place).
   * @return {Array<import("./Layer.js").State>} List of layer states.
   */
  getLayerStatesArray(e) {
    return pt();
  }
  /**
   * Return the {@link module:ol/extent~Extent extent} of the layer or `undefined` if it
   * will be visible regardless of extent.
   * @return {import("../extent.js").Extent|undefined} The layer extent.
   * @observable
   * @api
   */
  getExtent() {
    return (
      /** @type {import("../extent.js").Extent|undefined} */
      this.get(Fr.EXTENT)
    );
  }
  /**
   * Return the maximum resolution of the layer.
   * @return {number} The maximum resolution of the layer.
   * @observable
   * @api
   */
  getMaxResolution() {
    return (
      /** @type {number} */
      this.get(Fr.MAX_RESOLUTION)
    );
  }
  /**
   * Return the minimum resolution of the layer.
   * @return {number} The minimum resolution of the layer.
   * @observable
   * @api
   */
  getMinResolution() {
    return (
      /** @type {number} */
      this.get(Fr.MIN_RESOLUTION)
    );
  }
  /**
   * Return the minimum zoom level of the layer.
   * @return {number} The minimum zoom level of the layer.
   * @observable
   * @api
   */
  getMinZoom() {
    return (
      /** @type {number} */
      this.get(Fr.MIN_ZOOM)
    );
  }
  /**
   * Return the maximum zoom level of the layer.
   * @return {number} The maximum zoom level of the layer.
   * @observable
   * @api
   */
  getMaxZoom() {
    return (
      /** @type {number} */
      this.get(Fr.MAX_ZOOM)
    );
  }
  /**
   * Return the opacity of the layer (between 0 and 1).
   * @return {number} The opacity of the layer.
   * @observable
   * @api
   */
  getOpacity() {
    return (
      /** @type {number} */
      this.get(Fr.OPACITY)
    );
  }
  /**
   * @abstract
   * @return {import("../source/Source.js").State} Source state.
   */
  getSourceState() {
    return pt();
  }
  /**
   * Return the visibility of the layer (`true` or `false`).
   * @return {boolean} The visibility of the layer.
   * @observable
   * @api
   */
  getVisible() {
    return (
      /** @type {boolean} */
      this.get(Fr.VISIBLE)
    );
  }
  /**
   * Return the Z-index of the layer, which is used to order layers before
   * rendering. The default Z-index is 0.
   * @return {number} The Z-index of the layer.
   * @observable
   * @api
   */
  getZIndex() {
    return (
      /** @type {number} */
      this.get(Fr.Z_INDEX)
    );
  }
  /**
   * Sets the background color.
   * @param {BackgroundColor} [background] Background color.
   */
  setBackground(e) {
    this.background_ = e, this.changed();
  }
  /**
   * Set the extent at which the layer is visible.  If `undefined`, the layer
   * will be visible at all extents.
   * @param {import("../extent.js").Extent|undefined} extent The extent of the layer.
   * @observable
   * @api
   */
  setExtent(e) {
    this.set(Fr.EXTENT, e);
  }
  /**
   * Set the maximum resolution at which the layer is visible.
   * @param {number} maxResolution The maximum resolution of the layer.
   * @observable
   * @api
   */
  setMaxResolution(e) {
    this.set(Fr.MAX_RESOLUTION, e);
  }
  /**
   * Set the minimum resolution at which the layer is visible.
   * @param {number} minResolution The minimum resolution of the layer.
   * @observable
   * @api
   */
  setMinResolution(e) {
    this.set(Fr.MIN_RESOLUTION, e);
  }
  /**
   * Set the maximum zoom (exclusive) at which the layer is visible.
   * Note that the zoom levels for layer visibility are based on the
   * view zoom level, which may be different from a tile source zoom level.
   * @param {number} maxZoom The maximum zoom of the layer.
   * @observable
   * @api
   */
  setMaxZoom(e) {
    this.set(Fr.MAX_ZOOM, e);
  }
  /**
   * Set the minimum zoom (inclusive) at which the layer is visible.
   * Note that the zoom levels for layer visibility are based on the
   * view zoom level, which may be different from a tile source zoom level.
   * @param {number} minZoom The minimum zoom of the layer.
   * @observable
   * @api
   */
  setMinZoom(e) {
    this.set(Fr.MIN_ZOOM, e);
  }
  /**
   * Set the opacity of the layer, allowed values range from 0 to 1.
   * @param {number} opacity The opacity of the layer.
   * @observable
   * @api
   */
  setOpacity(e) {
    lt(typeof e == "number", 64), this.set(Fr.OPACITY, e);
  }
  /**
   * Set the visibility of the layer (`true` or `false`).
   * @param {boolean} visible The visibility of the layer.
   * @observable
   * @api
   */
  setVisible(e) {
    this.set(Fr.VISIBLE, e);
  }
  /**
   * Set Z-index of the layer, which is used to order layers before rendering.
   * The default Z-index is 0.
   * @param {number} zindex The z-index of the layer.
   * @observable
   * @api
   */
  setZIndex(e) {
    this.set(Fr.Z_INDEX, e);
  }
  /**
   * Clean up.
   */
  disposeInternal() {
    this.state_ && (this.state_.layer = null, this.state_ = null), super.disposeInternal();
  }
};
const hE = tD, ds = {
  /**
   * Triggered before a layer is rendered.
   * @event module:ol/render/Event~RenderEvent#prerender
   * @api
   */
  PRERENDER: "prerender",
  /**
   * Triggered after a layer is rendered.
   * @event module:ol/render/Event~RenderEvent#postrender
   * @api
   */
  POSTRENDER: "postrender",
  /**
   * Triggered before layers are composed.  When dispatched by the map, the event object will not have
   * a `context` set.  When dispatched by a layer, the event object will have a `context` set.  Only
   * WebGL layers currently dispatch this event.
   * @event module:ol/render/Event~RenderEvent#precompose
   * @api
   */
  PRECOMPOSE: "precompose",
  /**
   * Triggered after layers are composed.  When dispatched by the map, the event object will not have
   * a `context` set.  When dispatched by a layer, the event object will have a `context` set.  Only
   * WebGL layers currently dispatch this event.
   * @event module:ol/render/Event~RenderEvent#postcompose
   * @api
   */
  POSTCOMPOSE: "postcompose",
  /**
   * Triggered when rendering is complete, i.e. all sources and tiles have
   * finished loading for the current viewport, and all tiles are faded in.
   * The event object will not have a `context` set.
   * @event module:ol/render/Event~RenderEvent#rendercomplete
   * @api
   */
  RENDERCOMPLETE: "rendercomplete"
}, ei = {
  ANIMATING: 0,
  INTERACTING: 1
}, Rs = {
  CENTER: "center",
  RESOLUTION: "resolution",
  ROTATION: "rotation"
}, rD = 42, cE = 256, cu = {
  // use the radius of the Normal sphere
  radians: 6370997 / (2 * Math.PI),
  degrees: 2 * Math.PI * 6370997 / 360,
  ft: 0.3048,
  m: 1,
  "us-ft": 1200 / 3937
};
let iD = class {
  /**
   * @param {Options} options Projection options.
   */
  constructor(e) {
    this.code_ = e.code, this.units_ = /** @type {import("./Units.js").Units} */
    e.units, this.extent_ = e.extent !== void 0 ? e.extent : null, this.worldExtent_ = e.worldExtent !== void 0 ? e.worldExtent : null, this.axisOrientation_ = e.axisOrientation !== void 0 ? e.axisOrientation : "enu", this.global_ = e.global !== void 0 ? e.global : !1, this.canWrapX_ = !!(this.global_ && this.extent_), this.getPointResolutionFunc_ = e.getPointResolution, this.defaultTileGrid_ = null, this.metersPerUnit_ = e.metersPerUnit;
  }
  /**
   * @return {boolean} The projection is suitable for wrapping the x-axis
   */
  canWrapX() {
    return this.canWrapX_;
  }
  /**
   * Get the code for this projection, e.g. 'EPSG:4326'.
   * @return {string} Code.
   * @api
   */
  getCode() {
    return this.code_;
  }
  /**
   * Get the validity extent for this projection.
   * @return {import("../extent.js").Extent} Extent.
   * @api
   */
  getExtent() {
    return this.extent_;
  }
  /**
   * Get the units of this projection.
   * @return {import("./Units.js").Units} Units.
   * @api
   */
  getUnits() {
    return this.units_;
  }
  /**
   * Get the amount of meters per unit of this projection.  If the projection is
   * not configured with `metersPerUnit` or a units identifier, the return is
   * `undefined`.
   * @return {number|undefined} Meters.
   * @api
   */
  getMetersPerUnit() {
    return this.metersPerUnit_ || cu[this.units_];
  }
  /**
   * Get the world extent for this projection.
   * @return {import("../extent.js").Extent} Extent.
   * @api
   */
  getWorldExtent() {
    return this.worldExtent_;
  }
  /**
   * Get the axis orientation of this projection.
   * Example values are:
   * enu - the default easting, northing, elevation.
   * neu - northing, easting, up - useful for "lat/long" geographic coordinates,
   *     or south orientated transverse mercator.
   * wnu - westing, northing, up - some planetary coordinate systems have
   *     "west positive" coordinate systems
   * @return {string} Axis orientation.
   * @api
   */
  getAxisOrientation() {
    return this.axisOrientation_;
  }
  /**
   * Is this projection a global projection which spans the whole world?
   * @return {boolean} Whether the projection is global.
   * @api
   */
  isGlobal() {
    return this.global_;
  }
  /**
   * Set if the projection is a global projection which spans the whole world
   * @param {boolean} global Whether the projection is global.
   * @api
   */
  setGlobal(e) {
    this.global_ = e, this.canWrapX_ = !!(e && this.extent_);
  }
  /**
   * @return {import("../tilegrid/TileGrid.js").default} The default tile grid.
   */
  getDefaultTileGrid() {
    return this.defaultTileGrid_;
  }
  /**
   * @param {import("../tilegrid/TileGrid.js").default} tileGrid The default tile grid.
   */
  setDefaultTileGrid(e) {
    this.defaultTileGrid_ = e;
  }
  /**
   * Set the validity extent for this projection.
   * @param {import("../extent.js").Extent} extent Extent.
   * @api
   */
  setExtent(e) {
    this.extent_ = e, this.canWrapX_ = !!(this.global_ && e);
  }
  /**
   * Set the world extent for this projection.
   * @param {import("../extent.js").Extent} worldExtent World extent
   *     [minlon, minlat, maxlon, maxlat].
   * @api
   */
  setWorldExtent(e) {
    this.worldExtent_ = e;
  }
  /**
   * Set the getPointResolution function (see {@link module:ol/proj.getPointResolution}
   * for this projection.
   * @param {function(number, import("../coordinate.js").Coordinate):number} func Function
   * @api
   */
  setGetPointResolution(e) {
    this.getPointResolutionFunc_ = e;
  }
  /**
   * Get the custom point resolution function for this projection (if set).
   * @return {function(number, import("../coordinate.js").Coordinate):number|undefined} The custom point
   * resolution function (if set).
   */
  getPointResolutionFunc() {
    return this.getPointResolutionFunc_;
  }
};
const Ja = iD, ug = 6378137, Pc = Math.PI * ug, nD = [-Pc, -Pc, Pc, Pc], sD = [-180, -85, 180, 85], bp = ug * Math.log(Math.tan(Math.PI / 2));
class ic extends Ja {
  /**
   * @param {string} code Code.
   */
  constructor(e) {
    super({
      code: e,
      units: "m",
      extent: nD,
      global: !0,
      worldExtent: sD,
      getPointResolution: function(t, r) {
        return t / Math.cosh(r[1] / ug);
      }
    });
  }
}
const bS = [
  new ic("EPSG:3857"),
  new ic("EPSG:102100"),
  new ic("EPSG:102113"),
  new ic("EPSG:900913"),
  new ic("http://www.opengis.net/def/crs/EPSG/0/3857"),
  new ic("http://www.opengis.net/gml/srs/epsg.xml#3857")
];
function aD(i, e, t) {
  const r = i.length;
  t = t > 1 ? t : 2, e === void 0 && (t > 2 ? e = i.slice() : e = new Array(r));
  for (let n = 0; n < r; n += t) {
    e[n] = Pc * i[n] / 180;
    let s = ug * Math.log(Math.tan(Math.PI * (+i[n + 1] + 90) / 360));
    s > bp ? s = bp : s < -bp && (s = -bp), e[n + 1] = s;
  }
  return e;
}
function oD(i, e, t) {
  const r = i.length;
  t = t > 1 ? t : 2, e === void 0 && (t > 2 ? e = i.slice() : e = new Array(r));
  for (let n = 0; n < r; n += t)
    e[n] = 180 * i[n] / Pc, e[n + 1] = 360 * Math.atan(Math.exp(i[n + 1] / ug)) / Math.PI - 90;
  return e;
}
const AD = 6378137, SS = [-180, -90, 180, 90], lD = Math.PI * AD / 180;
class Il extends Ja {
  /**
   * @param {string} code Code.
   * @param {string} [axisOrientation] Axis orientation.
   */
  constructor(e, t) {
    super({
      code: e,
      units: "degrees",
      extent: SS,
      axisOrientation: t,
      global: !0,
      metersPerUnit: lD,
      worldExtent: SS
    });
  }
}
const TS = [
  new Il("CRS:84"),
  new Il("EPSG:4326", "neu"),
  new Il("urn:ogc:def:crs:OGC:1.3:CRS84"),
  new Il("urn:ogc:def:crs:OGC:2:84"),
  new Il("http://www.opengis.net/def/crs/OGC/1.3/CRS84"),
  new Il("http://www.opengis.net/gml/srs/epsg.xml#4326", "neu"),
  new Il("http://www.opengis.net/def/crs/EPSG/0/4326", "neu")
];
let Pw = {};
function hD(i) {
  return Pw[i] || Pw[i.replace(/urn:(x-)?ogc:def:crs:EPSG:(.*:)?(\w+)$/, "EPSG:$3")] || null;
}
function cD(i, e) {
  Pw[i] = e;
}
let qc = {};
function uu(i, e, t) {
  const r = i.getCode(), n = e.getCode();
  r in qc || (qc[r] = {}), qc[r][n] = t;
}
function RR(i, e) {
  let t;
  return i in qc && e in qc[i] && (t = qc[i][e]), t;
}
function bf(i, e, t) {
  const r = t !== void 0 ? i.toFixed(t) : "" + i;
  let n = r.indexOf(".");
  return n = n === -1 ? r.length : n, n > e ? r : new Array(1 + e - n).join("0") + r;
}
function MR(i, e) {
  const t = ("" + i).split("."), r = ("" + e).split(".");
  for (let n = 0; n < Math.max(t.length, r.length); n++) {
    const s = parseInt(t[n] || "0", 10), a = parseInt(r[n] || "0", 10);
    if (s > a)
      return 1;
    if (a > s)
      return -1;
  }
  return 0;
}
function NR(i, e) {
  return i[0] += +e[0], i[1] += +e[1], i;
}
function uD(i, e) {
  const t = e.getRadius(), r = e.getCenter(), n = r[0], s = r[1], a = i[0], o = i[1];
  let A = a - n;
  const l = o - s;
  A === 0 && l === 0 && (A = 1);
  const h = Math.sqrt(A * A + l * l), c = n + t * A / h, u = s + t * l / h;
  return [c, u];
}
function uE(i, e) {
  const t = i[0], r = i[1], n = e[0], s = e[1], a = n[0], o = n[1], A = s[0], l = s[1], h = A - a, c = l - o, u = h === 0 && c === 0 ? 0 : (h * (t - a) + c * (r - o)) / (h * h + c * c || 0);
  let f, g;
  return u <= 0 ? (f = a, g = o) : u >= 1 ? (f = A, g = l) : (f = a + u * h, g = o + u * c), [f, g];
}
function ya(i, e) {
  let t = !0;
  for (let r = i.length - 1; r >= 0; --r)
    if (i[r] != e[r]) {
      t = !1;
      break;
    }
  return t;
}
function fE(i, e) {
  const t = Math.cos(e), r = Math.sin(e), n = i[0] * t - i[1] * r, s = i[1] * t + i[0] * r;
  return i[0] = n, i[1] = s, i;
}
function PR(i, e) {
  return i[0] *= e, i[1] *= e, i;
}
function Ho(i, e) {
  const t = i[0] - e[0], r = i[1] - e[1];
  return t * t + r * r;
}
function dm(i, e) {
  return Math.sqrt(Ho(i, e));
}
function fD(i, e) {
  return Ho(i, uE(i, e));
}
function Nv(i, e) {
  if (e.canWrapX()) {
    const t = ir(e.getExtent()), r = OR(i, e, t);
    r && (i[0] -= r * t);
  }
  return i;
}
function OR(i, e, t) {
  const r = e.getExtent();
  let n = 0;
  return e.canWrapX() && (i[0] < r[0] || i[0] > r[2]) && (t = t || ir(r), n = Math.floor(
    (i[0] - r[0]) / t
  )), n;
}
const UR = 63710088e-1;
function gm(i, e, t) {
  t = t || UR;
  const r = el(i[1]), n = el(e[1]), s = (n - r) / 2, a = el(e[0] - i[0]) / 2, o = Math.sin(s) * Math.sin(s) + Math.sin(a) * Math.sin(a) * Math.cos(r) * Math.cos(n);
  return 2 * t * Math.atan2(Math.sqrt(o), Math.sqrt(1 - o));
}
function dD(i, e, t, r) {
  r = r || UR;
  const n = el(i[1]), s = el(i[0]), a = e / r, o = Math.asin(
    Math.sin(n) * Math.cos(a) + Math.cos(n) * Math.sin(a) * Math.cos(t)
  ), A = s + Math.atan2(
    Math.sin(t) * Math.sin(a) * Math.cos(n),
    Math.cos(a) - Math.sin(n) * Math.sin(o)
  );
  return [xS(A), xS(o)];
}
const QR = {
  info: 1,
  warn: 2,
  error: 3,
  none: 4
};
let gD = QR.info;
function DR(...i) {
  gD > QR.warn || console.warn(...i);
}
let Ow = !0;
function pD(i) {
  Ow = !(i === void 0 ? !0 : i);
}
function dE(i, e) {
  if (e !== void 0) {
    for (let t = 0, r = i.length; t < r; ++t)
      e[t] = i[t];
    e = e;
  } else
    e = i.slice();
  return e;
}
function Pv(i, e) {
  if (e !== void 0 && i !== e) {
    for (let t = 0, r = i.length; t < r; ++t)
      e[t] = i[t];
    i = e;
  }
  return i;
}
function kR(i) {
  cD(i.getCode(), i), uu(i, i, dE);
}
function mD(i) {
  i.forEach(kR);
}
function Ct(i) {
  return typeof i == "string" ? hD(
    /** @type {string} */
    i
  ) : (
    /** @type {Projection} */
    i || null
  );
}
function pm(i, e, t, r) {
  i = Ct(i);
  let n;
  const s = i.getPointResolutionFunc();
  if (s) {
    if (n = s(e, t), r && r !== i.getUnits()) {
      const a = i.getMetersPerUnit();
      a && (n = n * a / cu[r]);
    }
  } else {
    const a = i.getUnits();
    if (a == "degrees" && !r || r == "degrees")
      n = e;
    else {
      const o = Fu(
        i,
        Ct("EPSG:4326")
      );
      if (o === Pv && a !== "degrees")
        n = e * i.getMetersPerUnit();
      else {
        let l = [
          t[0] - e / 2,
          t[1],
          t[0] + e / 2,
          t[1],
          t[0],
          t[1] - e / 2,
          t[0],
          t[1] + e / 2
        ];
        l = o(l, l, 2);
        const h = gm(l.slice(0, 2), l.slice(2, 4)), c = gm(l.slice(4, 6), l.slice(6, 8));
        n = (h + c) / 2;
      }
      const A = r ? cu[r] : i.getMetersPerUnit();
      A !== void 0 && (n /= A);
    }
  }
  return n;
}
function Uw(i) {
  mD(i), i.forEach(function(e) {
    i.forEach(function(t) {
      e !== t && uu(e, t, dE);
    });
  });
}
function vD(i, e, t, r) {
  i.forEach(function(n) {
    e.forEach(function(s) {
      uu(n, s, t), uu(s, n, r);
    });
  });
}
function gE(i, e) {
  if (i) {
    if (typeof i == "string")
      return Ct(i);
  } else
    return Ct(e);
  return (
    /** @type {Projection} */
    i
  );
}
function FS(i) {
  return (
    /**
     * @param {Array<number>} input Input.
     * @param {Array<number>} [output] Output.
     * @param {number} [dimension] Dimension.
     * @return {Array<number>} Output.
     */
    function(e, t, r) {
      const n = e.length;
      r = r !== void 0 ? r : 2, t = t !== void 0 ? t : new Array(n);
      for (let s = 0; s < n; s += r) {
        const a = i(e.slice(s, s + r)), o = a.length;
        for (let A = 0, l = r; A < l; ++A)
          t[s + A] = A >= o ? e[s + A] : a[A];
      }
      return t;
    }
  );
}
function yD(i, e, t, r) {
  const n = Ct(i), s = Ct(e);
  uu(
    n,
    s,
    FS(t)
  ), uu(
    s,
    n,
    FS(r)
  );
}
function Da(i, e) {
  if (i === e)
    return !0;
  const t = i.getUnits() === e.getUnits();
  return (i.getCode() === e.getCode() || Fu(i, e) === dE) && t;
}
function Fu(i, e) {
  const t = i.getCode(), r = e.getCode();
  let n = RR(t, r);
  return n || (n = Pv), n;
}
function Td(i, e) {
  const t = Ct(i), r = Ct(e);
  return Fu(t, r);
}
function cl(i, e, t) {
  return Td(e, t)(i, void 0, i.length);
}
function mm(i, e, t, r) {
  const n = Td(e, t);
  return AE(i, n, void 0, r);
}
function fu(i, e) {
  return i;
}
function ai(i, e) {
  return Ow && !ya(i, [0, 0]) && i[0] >= -180 && i[0] <= 180 && i[1] >= -90 && i[1] <= 90 && (Ow = !1, DR(
    "Call useGeographic() from ol/proj once to work with [longitude, latitude] coordinates."
  )), i;
}
function fg(i, e) {
  return i;
}
function Os(i, e) {
  return i;
}
function _D(i, e) {
  return i;
}
function LS(i, e, t) {
  return function(r) {
    let n, s;
    if (i.canWrapX()) {
      const a = i.getExtent(), o = ir(a);
      r = r.slice(0), s = OR(r, i, o), s && (r[0] = r[0] - s * o), r[0] = jr(r[0], a[0], a[2]), r[1] = jr(r[1], a[1], a[3]), n = t(r);
    } else
      n = t(r);
    return s && e.canWrapX() && (n[0] += s * ir(e.getExtent())), n;
  };
}
function wD() {
  Uw(bS), Uw(TS), vD(
    TS,
    bS,
    aD,
    oD
  );
}
wD();
function IS(i, e, t) {
  return (
    /**
     * @param {import("./coordinate.js").Coordinate|undefined} center Center.
     * @param {number|undefined} resolution Resolution.
     * @param {import("./size.js").Size} size Viewport size; unused if `onlyCenter` was specified.
     * @param {boolean} [isMoving] True if an interaction or animation is in progress.
     * @param {Array<number>} [centerShift] Shift between map center and viewport center.
     * @return {import("./coordinate.js").Coordinate|undefined} Center.
     */
    function(r, n, s, a, o) {
      if (!r)
        return;
      if (!n && !e)
        return r;
      const A = e ? 0 : s[0] * n, l = e ? 0 : s[1] * n, h = o ? o[0] : 0, c = o ? o[1] : 0;
      let u = i[0] + A / 2 + h, f = i[2] - A / 2 + h, g = i[1] + l / 2 + c, p = i[3] - l / 2 + c;
      u > f && (u = (f + u) / 2, f = u), g > p && (g = (p + g) / 2, p = g);
      let y = jr(r[0], u, f), v = jr(r[1], g, p);
      if (a && t && n) {
        const w = 30 * n;
        y += -w * Math.log(1 + Math.max(0, u - r[0]) / w) + w * Math.log(1 + Math.max(0, r[0] - f) / w), v += -w * Math.log(1 + Math.max(0, g - r[1]) / w) + w * Math.log(1 + Math.max(0, r[1] - p) / w);
      }
      return [y, v];
    }
  );
}
function xD(i) {
  return i;
}
function pE(i, e, t, r) {
  const n = ir(e) / t[0], s = _i(e) / t[1];
  return r ? Math.min(i, Math.max(n, s)) : Math.min(i, Math.min(n, s));
}
function mE(i, e, t) {
  let r = Math.min(i, e);
  const n = 50;
  return r *= Math.log(1 + n * Math.max(0, i / e - 1)) / n + 1, t && (r = Math.max(r, t), r /= Math.log(1 + n * Math.max(0, t / i - 1)) / n + 1), jr(r, t / 2, e * 2);
}
function CD(i, e, t, r) {
  return e = e !== void 0 ? e : !0, /**
   * @param {number|undefined} resolution Resolution.
   * @param {number} direction Direction.
   * @param {import("./size.js").Size} size Viewport size.
   * @param {boolean} [isMoving] True if an interaction or animation is in progress.
   * @return {number|undefined} Resolution.
   */
  function(n, s, a, o) {
    if (n !== void 0) {
      const A = i[0], l = i[i.length - 1], h = t ? pE(
        A,
        t,
        a,
        r
      ) : A;
      if (o)
        return e ? mE(
          n,
          h,
          l
        ) : jr(n, l, h);
      const c = Math.min(h, n), u = Math.floor(Lv(i, c, s));
      return i[u] > h && u < i.length - 1 ? i[u + 1] : i[u];
    }
  };
}
function ED(i, e, t, r, n, s) {
  return r = r !== void 0 ? r : !0, t = t !== void 0 ? t : 0, /**
   * @param {number|undefined} resolution Resolution.
   * @param {number} direction Direction.
   * @param {import("./size.js").Size} size Viewport size.
   * @param {boolean} [isMoving] True if an interaction or animation is in progress.
   * @return {number|undefined} Resolution.
   */
  function(a, o, A, l) {
    if (a !== void 0) {
      const h = n ? pE(
        e,
        n,
        A,
        s
      ) : e;
      if (l)
        return r ? mE(
          a,
          h,
          t
        ) : jr(a, t, h);
      const c = 1e-9, u = Math.ceil(
        Math.log(e / h) / Math.log(i) - c
      ), f = -o * (0.5 - c) + 0.5, g = Math.min(h, a), p = Math.floor(
        Math.log(e / g) / Math.log(i) + f
      ), y = Math.max(u, p), v = e / Math.pow(i, y);
      return jr(v, t, h);
    }
  };
}
function RS(i, e, t, r, n) {
  return t = t !== void 0 ? t : !0, /**
   * @param {number|undefined} resolution Resolution.
   * @param {number} direction Direction.
   * @param {import("./size.js").Size} size Viewport size.
   * @param {boolean} [isMoving] True if an interaction or animation is in progress.
   * @return {number|undefined} Resolution.
   */
  function(s, a, o, A) {
    if (s !== void 0) {
      const l = r ? pE(
        i,
        r,
        o,
        n
      ) : i;
      return !t || !A ? jr(s, e, l) : mE(
        s,
        l,
        e
      );
    }
  };
}
function vE(i) {
  if (i !== void 0)
    return 0;
}
function MS(i) {
  if (i !== void 0)
    return i;
}
function BD(i) {
  const e = 2 * Math.PI / i;
  return (
    /**
     * @param {number|undefined} rotation Rotation.
     * @param {boolean} [isMoving] True if an interaction or animation is in progress.
     * @return {number|undefined} Rotation.
     */
    function(t, r) {
      if (r)
        return t;
      if (t !== void 0)
        return t = Math.floor(t / e + 0.5) * e, t;
    }
  );
}
function bD(i) {
  return i = i || el(5), /**
   * @param {number|undefined} rotation Rotation.
   * @param {boolean} [isMoving] True if an interaction or animation is in progress.
   * @return {number|undefined} Rotation.
   */
  function(e, t) {
    if (t)
      return e;
    if (e !== void 0)
      return Math.abs(e) <= i ? 0 : e;
  };
}
function yE(i) {
  return Math.pow(i, 3);
}
function ea(i) {
  return 1 - yE(1 - i);
}
function vm(i) {
  return 3 * i * i - 2 * i * i * i;
}
function _E(i) {
  return i;
}
function SD(i) {
  return i < 0.5 ? vm(2 * i) : 1 - vm(2 * (i - 0.5));
}
const TD = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  easeIn: yE,
  easeOut: ea,
  inAndOut: vm,
  linear: _E,
  upAndDown: SD
}, Symbol.toStringTag, { value: "Module" }));
function il(i, e, t, r, n, s) {
  s = s || [];
  let a = 0;
  for (let o = e; o < t; o += r) {
    const A = i[o], l = i[o + 1];
    s[a++] = n[0] * A + n[2] * l + n[4], s[a++] = n[1] * A + n[3] * l + n[5];
  }
  return s && s.length != a && (s.length = a), s;
}
function wE(i, e, t, r, n, s, a) {
  a = a || [];
  const o = Math.cos(n), A = Math.sin(n), l = s[0], h = s[1];
  let c = 0;
  for (let u = e; u < t; u += r) {
    const f = i[u] - l, g = i[u + 1] - h;
    a[c++] = l + f * o - g * A, a[c++] = h + f * A + g * o;
    for (let p = u + 2; p < u + r; ++p)
      a[c++] = i[p];
  }
  return a && a.length != c && (a.length = c), a;
}
function FD(i, e, t, r, n, s, a, o) {
  o = o || [];
  const A = a[0], l = a[1];
  let h = 0;
  for (let c = e; c < t; c += r) {
    const u = i[c] - A, f = i[c + 1] - l;
    o[h++] = A + n * u, o[h++] = l + s * f;
    for (let g = c + 2; g < c + r; ++g)
      o[h++] = i[g];
  }
  return o && o.length != h && (o.length = h), o;
}
function HR(i, e, t, r, n, s, a) {
  a = a || [];
  let o = 0;
  for (let A = e; A < t; A += r) {
    a[o++] = i[A] + n, a[o++] = i[A + 1] + s;
    for (let l = A + 2; l < A + r; ++l)
      a[o++] = i[l];
  }
  return a && a.length != o && (a.length = o), a;
}
const NS = qi();
class LD extends ws {
  constructor() {
    super(), this.extent_ = Ji(), this.extentRevision_ = -1, this.simplifiedGeometryMaxMinSquaredTolerance = 0, this.simplifiedGeometryRevision = 0, this.simplifyTransformedInternal = BQ(function(e, t, r) {
      if (!r)
        return this.getSimplifiedGeometry(t);
      const n = this.clone();
      return n.applyTransform(r), n.getSimplifiedGeometry(t);
    });
  }
  /**
   * Get a transformed and simplified version of the geometry.
   * @abstract
   * @param {number} squaredTolerance Squared tolerance.
   * @param {import("../proj.js").TransformFunction} [transform] Optional transform function.
   * @return {Geometry} Simplified geometry.
   */
  simplifyTransformed(e, t) {
    return this.simplifyTransformedInternal(
      this.getRevision(),
      e,
      t
    );
  }
  /**
   * Make a complete copy of the geometry.
   * @abstract
   * @return {!Geometry} Clone.
   */
  clone() {
    return pt();
  }
  /**
   * @abstract
   * @param {number} x X.
   * @param {number} y Y.
   * @param {import("../coordinate.js").Coordinate} closestPoint Closest point.
   * @param {number} minSquaredDistance Minimum squared distance.
   * @return {number} Minimum squared distance.
   */
  closestPointXY(e, t, r, n) {
    return pt();
  }
  /**
   * @param {number} x X.
   * @param {number} y Y.
   * @return {boolean} Contains (x, y).
   */
  containsXY(e, t) {
    const r = this.getClosestPoint([e, t]);
    return r[0] === e && r[1] === t;
  }
  /**
   * Return the closest point of the geometry to the passed point as
   * {@link module:ol/coordinate~Coordinate coordinate}.
   * @param {import("../coordinate.js").Coordinate} point Point.
   * @param {import("../coordinate.js").Coordinate} [closestPoint] Closest point.
   * @return {import("../coordinate.js").Coordinate} Closest point.
   * @api
   */
  getClosestPoint(e, t) {
    return t = t || [NaN, NaN], this.closestPointXY(e[0], e[1], t, 1 / 0), t;
  }
  /**
   * Returns true if this geometry includes the specified coordinate. If the
   * coordinate is on the boundary of the geometry, returns false.
   * @param {import("../coordinate.js").Coordinate} coordinate Coordinate.
   * @return {boolean} Contains coordinate.
   * @api
   */
  intersectsCoordinate(e) {
    return this.containsXY(e[0], e[1]);
  }
  /**
   * @abstract
   * @param {import("../extent.js").Extent} extent Extent.
   * @protected
   * @return {import("../extent.js").Extent} extent Extent.
   */
  computeExtent(e) {
    return pt();
  }
  /**
   * Get the extent of the geometry.
   * @param {import("../extent.js").Extent} [extent] Extent.
   * @return {import("../extent.js").Extent} extent Extent.
   * @api
   */
  getExtent(e) {
    if (this.extentRevision_ != this.getRevision()) {
      const t = this.computeExtent(this.extent_);
      (isNaN(t[0]) || isNaN(t[1])) && _l(t), this.extentRevision_ = this.getRevision();
    }
    return CR(this.extent_, e);
  }
  /**
   * Rotate the geometry around a given coordinate. This modifies the geometry
   * coordinates in place.
   * @abstract
   * @param {number} angle Rotation angle in radians.
   * @param {import("../coordinate.js").Coordinate} anchor The rotation center.
   * @api
   */
  rotate(e, t) {
    pt();
  }
  /**
   * Scale the geometry (with an optional origin).  This modifies the geometry
   * coordinates in place.
   * @abstract
   * @param {number} sx The scaling factor in the x-direction.
   * @param {number} [sy] The scaling factor in the y-direction (defaults to sx).
   * @param {import("../coordinate.js").Coordinate} [anchor] The scale origin (defaults to the center
   *     of the geometry extent).
   * @api
   */
  scale(e, t, r) {
    pt();
  }
  /**
   * Create a simplified version of this geometry.  For linestrings, this uses
   * the [Douglas Peucker](https://en.wikipedia.org/wiki/Ramer-Douglas-Peucker_algorithm)
   * algorithm.  For polygons, a quantization-based
   * simplification is used to preserve topology.
   * @param {number} tolerance The tolerance distance for simplification.
   * @return {Geometry} A new, simplified version of the original geometry.
   * @api
   */
  simplify(e) {
    return this.getSimplifiedGeometry(e * e);
  }
  /**
   * Create a simplified version of this geometry using the Douglas Peucker
   * algorithm.
   * See https://en.wikipedia.org/wiki/Ramer-Douglas-Peucker_algorithm.
   * @abstract
   * @param {number} squaredTolerance Squared tolerance.
   * @return {Geometry} Simplified geometry.
   */
  getSimplifiedGeometry(e) {
    return pt();
  }
  /**
   * Get the type of this geometry.
   * @abstract
   * @return {Type} Geometry type.
   */
  getType() {
    return pt();
  }
  /**
   * Apply a transform function to the coordinates of the geometry.
   * The geometry is modified in place.
   * If you do not want the geometry modified in place, first `clone()` it and
   * then use this function on the clone.
   * @abstract
   * @param {import("../proj.js").TransformFunction} transformFn Transform function.
   * Called with a flat array of geometry coordinates.
   */
  applyTransform(e) {
    pt();
  }
  /**
   * Test if the geometry and the passed extent intersect.
   * @abstract
   * @param {import("../extent.js").Extent} extent Extent.
   * @return {boolean} `true` if the geometry and the extent intersect.
   */
  intersectsExtent(e) {
    return pt();
  }
  /**
   * Translate the geometry.  This modifies the geometry coordinates in place.  If
   * instead you want a new geometry, first `clone()` this geometry.
   * @abstract
   * @param {number} deltaX Delta X.
   * @param {number} deltaY Delta Y.
   * @api
   */
  translate(e, t) {
    pt();
  }
  /**
   * Transform each coordinate of the geometry from one coordinate reference
   * system to another. The geometry is modified in place.
   * For example, a line will be transformed to a line and a circle to a circle.
   * If you do not want the geometry modified in place, first `clone()` it and
   * then use this function on the clone.
   *
   * @param {import("../proj.js").ProjectionLike} source The current projection.  Can be a
   *     string identifier or a {@link module:ol/proj/Projection~Projection} object.
   * @param {import("../proj.js").ProjectionLike} destination The desired projection.  Can be a
   *     string identifier or a {@link module:ol/proj/Projection~Projection} object.
   * @return {Geometry} This geometry.  Note that original geometry is
   *     modified in place.
   * @api
   */
  transform(e, t) {
    const r = Ct(e), n = r.getUnits() == "tile-pixels" ? function(s, a, o) {
      const A = r.getExtent(), l = r.getWorldExtent(), h = _i(l) / _i(A);
      return Qs(
        NS,
        l[0],
        l[3],
        h,
        -h,
        0,
        0,
        0
      ), il(
        s,
        0,
        s.length,
        o,
        NS,
        a
      ), Td(r, t)(
        s,
        a,
        o
      );
    } : Td(r, t);
    return this.applyTransform(n), this;
  }
}
const dg = LD;
class ID extends dg {
  constructor() {
    super(), this.layout = "XY", this.stride = 2, this.flatCoordinates = null;
  }
  /**
   * @param {import("../extent.js").Extent} extent Extent.
   * @protected
   * @return {import("../extent.js").Extent} extent Extent.
   */
  computeExtent(e) {
    return Rv(
      this.flatCoordinates,
      0,
      this.flatCoordinates.length,
      this.stride,
      e
    );
  }
  /**
   * @abstract
   * @return {Array<*> | null} Coordinates.
   */
  getCoordinates() {
    return pt();
  }
  /**
   * Return the first coordinate of the geometry.
   * @return {import("../coordinate.js").Coordinate} First coordinate.
   * @api
   */
  getFirstCoordinate() {
    return this.flatCoordinates.slice(0, this.stride);
  }
  /**
   * @return {Array<number>} Flat coordinates.
   */
  getFlatCoordinates() {
    return this.flatCoordinates;
  }
  /**
   * Return the last coordinate of the geometry.
   * @return {import("../coordinate.js").Coordinate} Last point.
   * @api
   */
  getLastCoordinate() {
    return this.flatCoordinates.slice(
      this.flatCoordinates.length - this.stride
    );
  }
  /**
   * Return the {@link import("./Geometry.js").GeometryLayout layout} of the geometry.
   * @return {import("./Geometry.js").GeometryLayout} Layout.
   * @api
   */
  getLayout() {
    return this.layout;
  }
  /**
   * Create a simplified version of this geometry using the Douglas Peucker algorithm.
   * @param {number} squaredTolerance Squared tolerance.
   * @return {SimpleGeometry} Simplified geometry.
   */
  getSimplifiedGeometry(e) {
    if (this.simplifiedGeometryRevision !== this.getRevision() && (this.simplifiedGeometryMaxMinSquaredTolerance = 0, this.simplifiedGeometryRevision = this.getRevision()), e < 0 || this.simplifiedGeometryMaxMinSquaredTolerance !== 0 && e <= this.simplifiedGeometryMaxMinSquaredTolerance)
      return this;
    const t = this.getSimplifiedGeometryInternal(e);
    return t.getFlatCoordinates().length < this.flatCoordinates.length ? t : (this.simplifiedGeometryMaxMinSquaredTolerance = e, this);
  }
  /**
   * @param {number} squaredTolerance Squared tolerance.
   * @return {SimpleGeometry} Simplified geometry.
   * @protected
   */
  getSimplifiedGeometryInternal(e) {
    return this;
  }
  /**
   * @return {number} Stride.
   */
  getStride() {
    return this.stride;
  }
  /**
   * @param {import("./Geometry.js").GeometryLayout} layout Layout.
   * @param {Array<number>} flatCoordinates Flat coordinates.
   */
  setFlatCoordinates(e, t) {
    this.stride = Fd(e), this.layout = e, this.flatCoordinates = t;
  }
  /**
   * @abstract
   * @param {!Array<*>} coordinates Coordinates.
   * @param {import("./Geometry.js").GeometryLayout} [layout] Layout.
   */
  setCoordinates(e, t) {
    pt();
  }
  /**
   * @param {import("./Geometry.js").GeometryLayout|undefined} layout Layout.
   * @param {Array<*>} coordinates Coordinates.
   * @param {number} nesting Nesting.
   * @protected
   */
  setLayout(e, t, r) {
    let n;
    if (e)
      n = Fd(e);
    else {
      for (let s = 0; s < r; ++s) {
        if (t.length === 0) {
          this.layout = "XY", this.stride = 2;
          return;
        }
        t = /** @type {Array} */
        t[0];
      }
      n = t.length, e = RD(n);
    }
    this.layout = e, this.stride = n;
  }
  /**
   * Apply a transform function to the coordinates of the geometry.
   * The geometry is modified in place.
   * If you do not want the geometry modified in place, first `clone()` it and
   * then use this function on the clone.
   * @param {import("../proj.js").TransformFunction} transformFn Transform function.
   * Called with a flat array of geometry coordinates.
   * @api
   */
  applyTransform(e) {
    this.flatCoordinates && (e(this.flatCoordinates, this.flatCoordinates, this.stride), this.changed());
  }
  /**
   * Rotate the geometry around a given coordinate. This modifies the geometry
   * coordinates in place.
   * @param {number} angle Rotation angle in counter-clockwise radians.
   * @param {import("../coordinate.js").Coordinate} anchor The rotation center.
   * @api
   */
  rotate(e, t) {
    const r = this.getFlatCoordinates();
    if (r) {
      const n = this.getStride();
      wE(
        r,
        0,
        r.length,
        n,
        e,
        t,
        r
      ), this.changed();
    }
  }
  /**
   * Scale the geometry (with an optional origin).  This modifies the geometry
   * coordinates in place.
   * @param {number} sx The scaling factor in the x-direction.
   * @param {number} [sy] The scaling factor in the y-direction (defaults to sx).
   * @param {import("../coordinate.js").Coordinate} [anchor] The scale origin (defaults to the center
   *     of the geometry extent).
   * @api
   */
  scale(e, t, r) {
    t === void 0 && (t = e), r || (r = Xn(this.getExtent()));
    const n = this.getFlatCoordinates();
    if (n) {
      const s = this.getStride();
      FD(
        n,
        0,
        n.length,
        s,
        e,
        t,
        r,
        n
      ), this.changed();
    }
  }
  /**
   * Translate the geometry.  This modifies the geometry coordinates in place.  If
   * instead you want a new geometry, first `clone()` this geometry.
   * @param {number} deltaX Delta X.
   * @param {number} deltaY Delta Y.
   * @api
   */
  translate(e, t) {
    const r = this.getFlatCoordinates();
    if (r) {
      const n = this.getStride();
      HR(
        r,
        0,
        r.length,
        n,
        e,
        t,
        r
      ), this.changed();
    }
  }
}
function RD(i) {
  let e;
  return i == 2 ? e = "XY" : i == 3 ? e = "XYZ" : i == 4 && (e = "XYZM"), /** @type {import("./Geometry.js").GeometryLayout} */
  e;
}
function Fd(i) {
  let e;
  return i == "XY" ? e = 2 : i == "XYZ" || i == "XYM" ? e = 3 : i == "XYZM" && (e = 4), /** @type {number} */
  e;
}
function MD(i, e, t) {
  const r = i.getFlatCoordinates();
  if (!r)
    return null;
  const n = i.getStride();
  return il(
    r,
    0,
    r.length,
    n,
    e,
    t
  );
}
const Ea = ID;
function PS(i, e, t, r, n, s, a) {
  const o = i[e], A = i[e + 1], l = i[t] - o, h = i[t + 1] - A;
  let c;
  if (l === 0 && h === 0)
    c = e;
  else {
    const u = ((n - o) * l + (s - A) * h) / (l * l + h * h);
    if (u > 1)
      c = t;
    else if (u > 0) {
      for (let f = 0; f < r; ++f)
        a[f] = Ms(
          i[e + f],
          i[t + f],
          u
        );
      a.length = r;
      return;
    } else
      c = e;
  }
  for (let u = 0; u < r; ++u)
    a[u] = i[c + u];
  a.length = r;
}
function xE(i, e, t, r, n) {
  let s = i[e], a = i[e + 1];
  for (e += r; e < t; e += r) {
    const o = i[e], A = i[e + 1], l = ko(s, a, o, A);
    l > n && (n = l), s = o, a = A;
  }
  return n;
}
function CE(i, e, t, r, n) {
  for (let s = 0, a = t.length; s < a; ++s) {
    const o = t[s];
    n = xE(i, e, o, r, n), e = o;
  }
  return n;
}
function ND(i, e, t, r, n) {
  for (let s = 0, a = t.length; s < a; ++s) {
    const o = t[s];
    n = CE(i, e, o, r, n), e = o[o.length - 1];
  }
  return n;
}
function EE(i, e, t, r, n, s, a, o, A, l, h) {
  if (e == t)
    return l;
  let c, u;
  if (n === 0) {
    if (u = ko(
      a,
      o,
      i[e],
      i[e + 1]
    ), u < l) {
      for (c = 0; c < r; ++c)
        A[c] = i[e + c];
      return A.length = r, u;
    }
    return l;
  }
  h = h || [NaN, NaN];
  let f = e + r;
  for (; f < t; )
    if (PS(
      i,
      f - r,
      f,
      r,
      a,
      o,
      h
    ), u = ko(a, o, h[0], h[1]), u < l) {
      for (l = u, c = 0; c < r; ++c)
        A[c] = h[c];
      A.length = r, f += r;
    } else
      f += r * Math.max(
        (Math.sqrt(u) - Math.sqrt(l)) / n | 0,
        1
      );
  if (s && (PS(
    i,
    t - r,
    e,
    r,
    a,
    o,
    h
  ), u = ko(a, o, h[0], h[1]), u < l)) {
    for (l = u, c = 0; c < r; ++c)
      A[c] = h[c];
    A.length = r;
  }
  return l;
}
function BE(i, e, t, r, n, s, a, o, A, l, h) {
  h = h || [NaN, NaN];
  for (let c = 0, u = t.length; c < u; ++c) {
    const f = t[c];
    l = EE(
      i,
      e,
      f,
      r,
      n,
      s,
      a,
      o,
      A,
      l,
      h
    ), e = f;
  }
  return l;
}
function PD(i, e, t, r, n, s, a, o, A, l, h) {
  h = h || [NaN, NaN];
  for (let c = 0, u = t.length; c < u; ++c) {
    const f = t[c];
    l = BE(
      i,
      e,
      f,
      r,
      n,
      s,
      a,
      o,
      A,
      l,
      h
    ), e = f[f.length - 1];
  }
  return l;
}
function GR(i, e, t, r) {
  for (let n = 0, s = t.length; n < s; ++n)
    i[e++] = t[n];
  return e;
}
function gg(i, e, t, r) {
  for (let n = 0, s = t.length; n < s; ++n) {
    const a = t[n];
    for (let o = 0; o < r; ++o)
      i[e++] = a[o];
  }
  return e;
}
function bE(i, e, t, r, n) {
  n = n || [];
  let s = 0;
  for (let a = 0, o = t.length; a < o; ++a) {
    const A = gg(
      i,
      e,
      t[a],
      r
    );
    n[s++] = A, e = A;
  }
  return n.length = s, n;
}
function OD(i, e, t, r, n) {
  n = n || [];
  let s = 0;
  for (let a = 0, o = t.length; a < o; ++a) {
    const A = bE(
      i,
      e,
      t[a],
      r,
      n[s]
    );
    A.length === 0 && (A[0] = e), n[s++] = A, e = A[A.length - 1];
  }
  return n.length = s, n;
}
function SE(i, e, t, r, n, s, a) {
  const o = (t - e) / r;
  if (o < 3) {
    for (; e < t; e += r)
      s[a++] = i[e], s[a++] = i[e + 1];
    return a;
  }
  const A = new Array(o);
  A[0] = 1, A[o - 1] = 1;
  const l = [e, t - r];
  let h = 0;
  for (; l.length > 0; ) {
    const c = l.pop(), u = l.pop();
    let f = 0;
    const g = i[u], p = i[u + 1], y = i[c], v = i[c + 1];
    for (let w = u + r; w < c; w += r) {
      const C = i[w], E = i[w + 1], S = YQ(C, E, g, p, y, v);
      S > f && (h = w, f = S);
    }
    f > n && (A[(h - e) / r] = 1, u + r < h && l.push(u, h), h + r < c && l.push(h, c));
  }
  for (let c = 0; c < o; ++c)
    A[c] && (s[a++] = i[e + c * r], s[a++] = i[e + c * r + 1]);
  return a;
}
function UD(i, e, t, r, n, s, a, o) {
  for (let A = 0, l = t.length; A < l; ++A) {
    const h = t[A];
    a = SE(
      i,
      e,
      h,
      r,
      n,
      s,
      a
    ), o.push(a), e = h;
  }
  return a;
}
function kl(i, e) {
  return e * Math.round(i / e);
}
function QD(i, e, t, r, n, s, a) {
  if (e == t)
    return a;
  let o = kl(i[e], n), A = kl(i[e + 1], n);
  e += r, s[a++] = o, s[a++] = A;
  let l, h;
  do
    if (l = kl(i[e], n), h = kl(i[e + 1], n), e += r, e == t)
      return s[a++] = l, s[a++] = h, a;
  while (l == o && h == A);
  for (; e < t; ) {
    const c = kl(i[e], n), u = kl(i[e + 1], n);
    if (e += r, c == l && u == h)
      continue;
    const f = l - o, g = h - A, p = c - o, y = u - A;
    if (f * y == g * p && (f < 0 && p < f || f == p || f > 0 && p > f) && (g < 0 && y < g || g == y || g > 0 && y > g)) {
      l = c, h = u;
      continue;
    }
    s[a++] = l, s[a++] = h, o = l, A = h, l = c, h = u;
  }
  return s[a++] = l, s[a++] = h, a;
}
function $R(i, e, t, r, n, s, a, o) {
  for (let A = 0, l = t.length; A < l; ++A) {
    const h = t[A];
    a = QD(
      i,
      e,
      h,
      r,
      n,
      s,
      a
    ), o.push(a), e = h;
  }
  return a;
}
function DD(i, e, t, r, n, s, a, o) {
  for (let A = 0, l = t.length; A < l; ++A) {
    const h = t[A], c = [];
    a = $R(
      i,
      e,
      h,
      r,
      n,
      s,
      a,
      c
    ), o.push(c), e = h[h.length - 1];
  }
  return a;
}
function Qo(i, e, t, r, n) {
  n = n !== void 0 ? n : [];
  let s = 0;
  for (let a = e; a < t; a += r)
    n[s++] = i.slice(a, a + r);
  return n.length = s, n;
}
function Ld(i, e, t, r, n) {
  n = n !== void 0 ? n : [];
  let s = 0;
  for (let a = 0, o = t.length; a < o; ++a) {
    const A = t[a];
    n[s++] = Qo(
      i,
      e,
      A,
      r,
      n[s]
    ), e = A;
  }
  return n.length = s, n;
}
function Qw(i, e, t, r, n) {
  n = n !== void 0 ? n : [];
  let s = 0;
  for (let a = 0, o = t.length; a < o; ++a) {
    const A = t[a];
    n[s++] = A.length === 1 && A[0] === e ? [] : Ld(
      i,
      e,
      A,
      r,
      n[s]
    ), e = A[A.length - 1];
  }
  return n.length = s, n;
}
function VR(i, e, t, r) {
  let n = 0, s = i[t - r], a = i[t - r + 1];
  for (; e < t; e += r) {
    const o = i[e], A = i[e + 1];
    n += a * o - s * A, s = o, a = A;
  }
  return n / 2;
}
function KR(i, e, t, r) {
  let n = 0;
  for (let s = 0, a = t.length; s < a; ++s) {
    const o = t[s];
    n += VR(i, e, o, r), e = o;
  }
  return n;
}
function kD(i, e, t, r) {
  let n = 0;
  for (let s = 0, a = t.length; s < a; ++s) {
    const o = t[s];
    n += KR(i, e, o, r), e = o[o.length - 1];
  }
  return n;
}
class ym extends Ea {
  /**
   * @param {Array<import("../coordinate.js").Coordinate>|Array<number>} coordinates Coordinates.
   *     For internal use, flat coordinates in combination with `layout` are also accepted.
   * @param {import("./Geometry.js").GeometryLayout} [layout] Layout.
   */
  constructor(e, t) {
    super(), this.maxDelta_ = -1, this.maxDeltaRevision_ = -1, t !== void 0 && !Array.isArray(e[0]) ? this.setFlatCoordinates(
      t,
      /** @type {Array<number>} */
      e
    ) : this.setCoordinates(
      /** @type {Array<import("../coordinate.js").Coordinate>} */
      e,
      t
    );
  }
  /**
   * Make a complete copy of the geometry.
   * @return {!LinearRing} Clone.
   * @api
   */
  clone() {
    return new ym(this.flatCoordinates.slice(), this.layout);
  }
  /**
   * @param {number} x X.
   * @param {number} y Y.
   * @param {import("../coordinate.js").Coordinate} closestPoint Closest point.
   * @param {number} minSquaredDistance Minimum squared distance.
   * @return {number} Minimum squared distance.
   */
  closestPointXY(e, t, r, n) {
    return n < yl(this.getExtent(), e, t) ? n : (this.maxDeltaRevision_ != this.getRevision() && (this.maxDelta_ = Math.sqrt(
      xE(
        this.flatCoordinates,
        0,
        this.flatCoordinates.length,
        this.stride,
        0
      )
    ), this.maxDeltaRevision_ = this.getRevision()), EE(
      this.flatCoordinates,
      0,
      this.flatCoordinates.length,
      this.stride,
      this.maxDelta_,
      !0,
      e,
      t,
      r,
      n
    ));
  }
  /**
   * Return the area of the linear ring on projected plane.
   * @return {number} Area (on projected plane).
   * @api
   */
  getArea() {
    return VR(
      this.flatCoordinates,
      0,
      this.flatCoordinates.length,
      this.stride
    );
  }
  /**
   * Return the coordinates of the linear ring.
   * @return {Array<import("../coordinate.js").Coordinate>} Coordinates.
   * @api
   */
  getCoordinates() {
    return Qo(
      this.flatCoordinates,
      0,
      this.flatCoordinates.length,
      this.stride
    );
  }
  /**
   * @param {number} squaredTolerance Squared tolerance.
   * @return {LinearRing} Simplified LinearRing.
   * @protected
   */
  getSimplifiedGeometryInternal(e) {
    const t = [];
    return t.length = SE(
      this.flatCoordinates,
      0,
      this.flatCoordinates.length,
      this.stride,
      e,
      t,
      0
    ), new ym(t, "XY");
  }
  /**
   * Get the type of this geometry.
   * @return {import("./Geometry.js").Type} Geometry type.
   * @api
   */
  getType() {
    return "LinearRing";
  }
  /**
   * Test if the geometry and the passed extent intersect.
   * @param {import("../extent.js").Extent} extent Extent.
   * @return {boolean} `true` if the geometry and the extent intersect.
   * @api
   */
  intersectsExtent(e) {
    return !1;
  }
  /**
   * Set the coordinates of the linear ring.
   * @param {!Array<import("../coordinate.js").Coordinate>} coordinates Coordinates.
   * @param {import("./Geometry.js").GeometryLayout} [layout] Layout.
   * @api
   */
  setCoordinates(e, t) {
    this.setLayout(t, e, 1), this.flatCoordinates || (this.flatCoordinates = []), this.flatCoordinates.length = gg(
      this.flatCoordinates,
      0,
      e,
      this.stride
    ), this.changed();
  }
}
const du = ym;
let HD = class jR extends Ea {
  /**
   * @param {import("../coordinate.js").Coordinate} coordinates Coordinates.
   * @param {import("./Geometry.js").GeometryLayout} [layout] Layout.
   */
  constructor(e, t) {
    super(), this.setCoordinates(e, t);
  }
  /**
   * Make a complete copy of the geometry.
   * @return {!Point} Clone.
   * @api
   */
  clone() {
    const e = new jR(this.flatCoordinates.slice(), this.layout);
    return e.applyProperties(this), e;
  }
  /**
   * @param {number} x X.
   * @param {number} y Y.
   * @param {import("../coordinate.js").Coordinate} closestPoint Closest point.
   * @param {number} minSquaredDistance Minimum squared distance.
   * @return {number} Minimum squared distance.
   */
  closestPointXY(e, t, r, n) {
    const s = this.flatCoordinates, a = ko(
      e,
      t,
      s[0],
      s[1]
    );
    if (a < n) {
      const o = this.stride;
      for (let A = 0; A < o; ++A)
        r[A] = s[A];
      return r.length = o, a;
    }
    return n;
  }
  /**
   * Return the coordinate of the point.
   * @return {import("../coordinate.js").Coordinate} Coordinates.
   * @api
   */
  getCoordinates() {
    return this.flatCoordinates ? this.flatCoordinates.slice() : [];
  }
  /**
   * @param {import("../extent.js").Extent} extent Extent.
   * @protected
   * @return {import("../extent.js").Extent} extent Extent.
   */
  computeExtent(e) {
    return Zl(this.flatCoordinates, e);
  }
  /**
   * Get the type of this geometry.
   * @return {import("./Geometry.js").Type} Geometry type.
   * @api
   */
  getType() {
    return "Point";
  }
  /**
   * Test if the geometry and the passed extent intersect.
   * @param {import("../extent.js").Extent} extent Extent.
   * @return {boolean} `true` if the geometry and the extent intersect.
   * @api
   */
  intersectsExtent(e) {
    return Iv(e, this.flatCoordinates[0], this.flatCoordinates[1]);
  }
  /**
   * @param {!Array<*>} coordinates Coordinates.
   * @param {import("./Geometry.js").GeometryLayout} [layout] Layout.
   * @api
   */
  setCoordinates(e, t) {
    this.setLayout(t, e, 0), this.flatCoordinates || (this.flatCoordinates = []), this.flatCoordinates.length = GR(
      this.flatCoordinates,
      0,
      e,
      this.stride
    ), this.changed();
  }
};
const gr = HD;
function GD(i, e, t, r, n) {
  return !Mv(
    n,
    /**
     * @param {import("../../coordinate.js").Coordinate} coordinate Coordinate.
     * @return {boolean} Contains (x, y).
     */
    function(a) {
      return !jl(
        i,
        e,
        t,
        r,
        a[0],
        a[1]
      );
    }
  );
}
function jl(i, e, t, r, n, s) {
  let a = 0, o = i[t - r], A = i[t - r + 1];
  for (; e < t; e += r) {
    const l = i[e], h = i[e + 1];
    A <= s ? h > s && (l - o) * (s - A) - (n - o) * (h - A) > 0 && a++ : h <= s && (l - o) * (s - A) - (n - o) * (h - A) < 0 && a--, o = l, A = h;
  }
  return a !== 0;
}
function TE(i, e, t, r, n, s) {
  if (t.length === 0 || !jl(i, e, t[0], r, n, s))
    return !1;
  for (let a = 1, o = t.length; a < o; ++a)
    if (jl(i, t[a - 1], t[a], r, n, s))
      return !1;
  return !0;
}
function $D(i, e, t, r, n, s) {
  if (t.length === 0)
    return !1;
  for (let a = 0, o = t.length; a < o; ++a) {
    const A = t[a];
    if (TE(i, e, A, r, n, s))
      return !0;
    e = A[A.length - 1];
  }
  return !1;
}
function FE(i, e, t, r, n, s, a) {
  let o, A, l, h, c, u, f;
  const g = n[s + 1], p = [];
  for (let w = 0, C = t.length; w < C; ++w) {
    const E = t[w];
    for (h = i[E - r], u = i[E - r + 1], o = e; o < E; o += r)
      c = i[o], f = i[o + 1], (g <= u && f <= g || u <= g && g <= f) && (l = (g - u) / (f - u) * (c - h) + h, p.push(l)), h = c, u = f;
  }
  let y = NaN, v = -1 / 0;
  for (p.sort(Al), h = p[0], o = 1, A = p.length; o < A; ++o) {
    c = p[o];
    const w = Math.abs(c - h);
    w > v && (l = (h + c) / 2, TE(i, e, t, r, l, g) && (y = l, v = w)), h = c;
  }
  return isNaN(y) && (y = n[s]), a ? (a.push(y, g, v), a) : [y, g, v];
}
function zR(i, e, t, r, n) {
  let s = [];
  for (let a = 0, o = t.length; a < o; ++a) {
    const A = t[a];
    s = FE(
      i,
      e,
      A,
      r,
      n,
      2 * a,
      s
    ), e = A[A.length - 1];
  }
  return s;
}
function XR(i, e, t, r, n) {
  let s;
  for (e += r; e < t; e += r)
    if (s = n(
      i.slice(e - r, e),
      i.slice(e, e + r)
    ), s)
      return s;
  return !1;
}
function Ov(i, e, t, r, n) {
  const s = oE(
    Ji(),
    i,
    e,
    t,
    r
  );
  return ci(n, s) ? Ps(n, s) || s[0] >= n[0] && s[2] <= n[2] || s[1] >= n[1] && s[3] <= n[3] ? !0 : XR(
    i,
    e,
    t,
    r,
    /**
     * @param {import("../../coordinate.js").Coordinate} point1 Start point.
     * @param {import("../../coordinate.js").Coordinate} point2 End point.
     * @return {boolean} `true` if the segment and the extent intersect,
     *     `false` otherwise.
     */
    function(a, o) {
      return BR(n, a, o);
    }
  ) : !1;
}
function VD(i, e, t, r, n) {
  for (let s = 0, a = t.length; s < a; ++s) {
    if (Ov(i, e, t[s], r, n))
      return !0;
    e = t[s];
  }
  return !1;
}
function WR(i, e, t, r, n) {
  return !!(Ov(i, e, t, r, n) || jl(
    i,
    e,
    t,
    r,
    n[0],
    n[1]
  ) || jl(
    i,
    e,
    t,
    r,
    n[0],
    n[3]
  ) || jl(
    i,
    e,
    t,
    r,
    n[2],
    n[1]
  ) || jl(
    i,
    e,
    t,
    r,
    n[2],
    n[3]
  ));
}
function YR(i, e, t, r, n) {
  if (!WR(i, e, t[0], r, n))
    return !1;
  if (t.length === 1)
    return !0;
  for (let s = 1, a = t.length; s < a; ++s)
    if (GD(
      i,
      t[s - 1],
      t[s],
      r,
      n
    ) && !Ov(
      i,
      t[s - 1],
      t[s],
      r,
      n
    ))
      return !1;
  return !0;
}
function KD(i, e, t, r, n) {
  for (let s = 0, a = t.length; s < a; ++s) {
    const o = t[s];
    if (YR(i, e, o, r, n))
      return !0;
    e = o[o.length - 1];
  }
  return !1;
}
function jD(i, e, t, r) {
  for (; e < t - r; ) {
    for (let n = 0; n < r; ++n) {
      const s = i[e + n];
      i[e + n] = i[t - r + n], i[t - r + n] = s;
    }
    e += r, t -= r;
  }
}
function Uv(i, e, t, r) {
  let n = 0, s = i[t - r], a = i[t - r + 1];
  for (; e < t; e += r) {
    const o = i[e], A = i[e + 1];
    n += (o - s) * (A + a), s = o, a = A;
  }
  return n === 0 ? void 0 : n > 0;
}
function qR(i, e, t, r, n) {
  n = n !== void 0 ? n : !1;
  for (let s = 0, a = t.length; s < a; ++s) {
    const o = t[s], A = Uv(
      i,
      e,
      o,
      r
    );
    if (s === 0) {
      if (n && A || !n && !A)
        return !1;
    } else if (n && !A || !n && A)
      return !1;
    e = o;
  }
  return !0;
}
function zD(i, e, t, r, n) {
  for (let s = 0, a = t.length; s < a; ++s) {
    const o = t[s];
    if (!qR(i, e, o, r, n))
      return !1;
    o.length && (e = o[o.length - 1]);
  }
  return !0;
}
function Dw(i, e, t, r, n) {
  n = n !== void 0 ? n : !1;
  for (let s = 0, a = t.length; s < a; ++s) {
    const o = t[s], A = Uv(
      i,
      e,
      o,
      r
    );
    (s === 0 ? n && A || !n && !A : n && !A || !n && A) && jD(i, e, o, r), e = o;
  }
  return e;
}
function OS(i, e, t, r, n) {
  for (let s = 0, a = t.length; s < a; ++s)
    e = Dw(
      i,
      e,
      t[s],
      r,
      n
    );
  return e;
}
function XD(i, e) {
  const t = [];
  let r = 0, n = 0;
  for (let s = 0, a = e.length; s < a; ++s) {
    const o = e[s];
    if (!Uv(i, r, o, 2))
      t.push(e.slice(n, s + 1));
    else {
      if (t.length === 0)
        continue;
      t[t.length - 1].push(e[n]);
    }
    n = s + 1, r = o;
  }
  return t;
}
let Qv = class kw extends Ea {
  /**
   * @param {!Array<Array<import("../coordinate.js").Coordinate>>|!Array<number>} coordinates
   *     Array of linear rings that define the polygon. The first linear ring of the
   *     array defines the outer-boundary or surface of the polygon. Each subsequent
   *     linear ring defines a hole in the surface of the polygon. A linear ring is
   *     an array of vertices' coordinates where the first coordinate and the last are
   *     equivalent. (For internal use, flat coordinates in combination with
   *     `layout` and `ends` are also accepted.)
   * @param {import("./Geometry.js").GeometryLayout} [layout] Layout.
   * @param {Array<number>} [ends] Ends (for internal use with flat coordinates).
   */
  constructor(e, t, r) {
    super(), this.ends_ = [], this.flatInteriorPointRevision_ = -1, this.flatInteriorPoint_ = null, this.maxDelta_ = -1, this.maxDeltaRevision_ = -1, this.orientedRevision_ = -1, this.orientedFlatCoordinates_ = null, t !== void 0 && r ? (this.setFlatCoordinates(
      t,
      /** @type {Array<number>} */
      e
    ), this.ends_ = r) : this.setCoordinates(
      /** @type {Array<Array<import("../coordinate.js").Coordinate>>} */
      e,
      t
    );
  }
  /**
   * Append the passed linear ring to this polygon.
   * @param {LinearRing} linearRing Linear ring.
   * @api
   */
  appendLinearRing(e) {
    this.flatCoordinates ? Er(this.flatCoordinates, e.getFlatCoordinates()) : this.flatCoordinates = e.getFlatCoordinates().slice(), this.ends_.push(this.flatCoordinates.length), this.changed();
  }
  /**
   * Make a complete copy of the geometry.
   * @return {!Polygon} Clone.
   * @api
   */
  clone() {
    const e = new kw(
      this.flatCoordinates.slice(),
      this.layout,
      this.ends_.slice()
    );
    return e.applyProperties(this), e;
  }
  /**
   * @param {number} x X.
   * @param {number} y Y.
   * @param {import("../coordinate.js").Coordinate} closestPoint Closest point.
   * @param {number} minSquaredDistance Minimum squared distance.
   * @return {number} Minimum squared distance.
   */
  closestPointXY(e, t, r, n) {
    return n < yl(this.getExtent(), e, t) ? n : (this.maxDeltaRevision_ != this.getRevision() && (this.maxDelta_ = Math.sqrt(
      CE(
        this.flatCoordinates,
        0,
        this.ends_,
        this.stride,
        0
      )
    ), this.maxDeltaRevision_ = this.getRevision()), BE(
      this.flatCoordinates,
      0,
      this.ends_,
      this.stride,
      this.maxDelta_,
      !0,
      e,
      t,
      r,
      n
    ));
  }
  /**
   * @param {number} x X.
   * @param {number} y Y.
   * @return {boolean} Contains (x, y).
   */
  containsXY(e, t) {
    return TE(
      this.getOrientedFlatCoordinates(),
      0,
      this.ends_,
      this.stride,
      e,
      t
    );
  }
  /**
   * Return the area of the polygon on projected plane.
   * @return {number} Area (on projected plane).
   * @api
   */
  getArea() {
    return KR(
      this.getOrientedFlatCoordinates(),
      0,
      this.ends_,
      this.stride
    );
  }
  /**
   * Get the coordinate array for this geometry.  This array has the structure
   * of a GeoJSON coordinate array for polygons.
   *
   * @param {boolean} [right] Orient coordinates according to the right-hand
   *     rule (counter-clockwise for exterior and clockwise for interior rings).
   *     If `false`, coordinates will be oriented according to the left-hand rule
   *     (clockwise for exterior and counter-clockwise for interior rings).
   *     By default, coordinate orientation will depend on how the geometry was
   *     constructed.
   * @return {Array<Array<import("../coordinate.js").Coordinate>>} Coordinates.
   * @api
   */
  getCoordinates(e) {
    let t;
    return e !== void 0 ? (t = this.getOrientedFlatCoordinates().slice(), Dw(t, 0, this.ends_, this.stride, e)) : t = this.flatCoordinates, Ld(t, 0, this.ends_, this.stride);
  }
  /**
   * @return {Array<number>} Ends.
   */
  getEnds() {
    return this.ends_;
  }
  /**
   * @return {Array<number>} Interior point.
   */
  getFlatInteriorPoint() {
    if (this.flatInteriorPointRevision_ != this.getRevision()) {
      const e = Xn(this.getExtent());
      this.flatInteriorPoint_ = FE(
        this.getOrientedFlatCoordinates(),
        0,
        this.ends_,
        this.stride,
        e,
        0
      ), this.flatInteriorPointRevision_ = this.getRevision();
    }
    return this.flatInteriorPoint_;
  }
  /**
   * Return an interior point of the polygon.
   * @return {Point} Interior point as XYM coordinate, where M is the
   * length of the horizontal intersection that the point belongs to.
   * @api
   */
  getInteriorPoint() {
    return new gr(this.getFlatInteriorPoint(), "XYM");
  }
  /**
   * Return the number of rings of the polygon,  this includes the exterior
   * ring and any interior rings.
   *
   * @return {number} Number of rings.
   * @api
   */
  getLinearRingCount() {
    return this.ends_.length;
  }
  /**
   * Return the Nth linear ring of the polygon geometry. Return `null` if the
   * given index is out of range.
   * The exterior linear ring is available at index `0` and the interior rings
   * at index `1` and beyond.
   *
   * @param {number} index Index.
   * @return {LinearRing|null} Linear ring.
   * @api
   */
  getLinearRing(e) {
    return e < 0 || this.ends_.length <= e ? null : new du(
      this.flatCoordinates.slice(
        e === 0 ? 0 : this.ends_[e - 1],
        this.ends_[e]
      ),
      this.layout
    );
  }
  /**
   * Return the linear rings of the polygon.
   * @return {Array<LinearRing>} Linear rings.
   * @api
   */
  getLinearRings() {
    const e = this.layout, t = this.flatCoordinates, r = this.ends_, n = [];
    let s = 0;
    for (let a = 0, o = r.length; a < o; ++a) {
      const A = r[a], l = new du(
        t.slice(s, A),
        e
      );
      n.push(l), s = A;
    }
    return n;
  }
  /**
   * @return {Array<number>} Oriented flat coordinates.
   */
  getOrientedFlatCoordinates() {
    if (this.orientedRevision_ != this.getRevision()) {
      const e = this.flatCoordinates;
      qR(e, 0, this.ends_, this.stride) ? this.orientedFlatCoordinates_ = e : (this.orientedFlatCoordinates_ = e.slice(), this.orientedFlatCoordinates_.length = Dw(
        this.orientedFlatCoordinates_,
        0,
        this.ends_,
        this.stride
      )), this.orientedRevision_ = this.getRevision();
    }
    return this.orientedFlatCoordinates_;
  }
  /**
   * @param {number} squaredTolerance Squared tolerance.
   * @return {Polygon} Simplified Polygon.
   * @protected
   */
  getSimplifiedGeometryInternal(e) {
    const t = [], r = [];
    return t.length = $R(
      this.flatCoordinates,
      0,
      this.ends_,
      this.stride,
      Math.sqrt(e),
      t,
      0,
      r
    ), new kw(t, "XY", r);
  }
  /**
   * Get the type of this geometry.
   * @return {import("./Geometry.js").Type} Geometry type.
   * @api
   */
  getType() {
    return "Polygon";
  }
  /**
   * Test if the geometry and the passed extent intersect.
   * @param {import("../extent.js").Extent} extent Extent.
   * @return {boolean} `true` if the geometry and the extent intersect.
   * @api
   */
  intersectsExtent(e) {
    return YR(
      this.getOrientedFlatCoordinates(),
      0,
      this.ends_,
      this.stride,
      e
    );
  }
  /**
   * Set the coordinates of the polygon.
   * @param {!Array<Array<import("../coordinate.js").Coordinate>>} coordinates Coordinates.
   * @param {import("./Geometry.js").GeometryLayout} [layout] Layout.
   * @api
   */
  setCoordinates(e, t) {
    this.setLayout(t, e, 2), this.flatCoordinates || (this.flatCoordinates = []);
    const r = bE(
      this.flatCoordinates,
      0,
      e,
      this.stride,
      this.ends_
    );
    this.flatCoordinates.length = r.length === 0 ? 0 : r[r.length - 1], this.changed();
  }
};
const Li = Qv;
function WD(i, e, t, r) {
  t = t || 32;
  const n = [];
  for (let s = 0; s < t; ++s)
    Er(
      n,
      dD(i, e, 2 * Math.PI * s / t, r)
    );
  return n.push(n[0], n[1]), new Qv(n, "XY", [n.length]);
}
function jA(i) {
  const e = i[0], t = i[1], r = i[2], n = i[3], s = [
    e,
    t,
    e,
    n,
    r,
    n,
    r,
    t,
    e,
    t
  ];
  return new Qv(s, "XY", [s.length]);
}
function YD(i, e, t) {
  e = e || 32;
  const r = i.getStride(), n = i.getLayout(), s = i.getCenter(), a = r * (e + 1), o = new Array(a);
  for (let h = 0; h < a; h += r) {
    o[h] = 0, o[h + 1] = 0;
    for (let c = 2; c < r; c++)
      o[h + c] = s[c];
  }
  const A = [o.length], l = new Qv(o, n, A);
  return qD(l, s, i.getRadius(), t), l;
}
function qD(i, e, t, r) {
  const n = i.getFlatCoordinates(), s = i.getStride(), a = n.length / s - 1, o = r || 0;
  for (let A = 0; A <= a; ++A) {
    const l = A * s, h = o + tl(A, a) * 2 * Math.PI / a;
    n[l] = e[0] + t * Math.cos(h), n[l + 1] = e[1] + t * Math.sin(h);
  }
  i.changed();
}
const L1 = 0;
let ZD = class extends ws {
  /**
   * @param {ViewOptions} [options] View options.
   */
  constructor(e) {
    super(), this.on, this.once, this.un, e = Object.assign({}, e), this.hints_ = [0, 0], this.animations_ = [], this.updateAnimationKey_, this.projection_ = gE(e.projection, "EPSG:3857"), this.viewportSize_ = [100, 100], this.targetCenter_ = null, this.targetResolution_, this.targetRotation_, this.nextCenter_ = null, this.nextResolution_, this.nextRotation_, this.cancelAnchor_ = void 0, e.projection && pD(), e.center && (e.center = ai(e.center, this.projection_)), e.extent && (e.extent = Os(e.extent, this.projection_)), this.applyOptions_(e);
  }
  /**
   * Set up the view with the given options.
   * @param {ViewOptions} options View options.
   */
  applyOptions_(e) {
    const t = Object.assign({}, e);
    for (const o in Rs)
      delete t[o];
    this.setProperties(t, !0);
    const r = e6(e);
    this.maxResolution_ = r.maxResolution, this.minResolution_ = r.minResolution, this.zoomFactor_ = r.zoomFactor, this.resolutions_ = e.resolutions, this.padding_ = e.padding, this.minZoom_ = r.minZoom;
    const n = JD(e), s = r.constraint, a = t6(e);
    this.constraints_ = {
      center: n,
      resolution: s,
      rotation: a
    }, this.setRotation(e.rotation !== void 0 ? e.rotation : 0), this.setCenterInternal(
      e.center !== void 0 ? e.center : null
    ), e.resolution !== void 0 ? this.setResolution(e.resolution) : e.zoom !== void 0 && this.setZoom(e.zoom);
  }
  /**
   * Padding (in css pixels).
   * If the map viewport is partially covered with other content (overlays) along
   * its edges, this setting allows to shift the center of the viewport away from that
   * content. The order of the values in the array is top, right, bottom, left.
   * The default is no padding, which is equivalent to `[0, 0, 0, 0]`.
   * @type {Array<number>|undefined}
   * @api
   */
  get padding() {
    return this.padding_;
  }
  set padding(e) {
    let t = this.padding_;
    this.padding_ = e;
    const r = this.getCenterInternal();
    if (r) {
      const n = e || [0, 0, 0, 0];
      t = t || [0, 0, 0, 0];
      const s = this.getResolution(), a = s / 2 * (n[3] - t[3] + t[1] - n[1]), o = s / 2 * (n[0] - t[0] + t[2] - n[2]);
      this.setCenterInternal([r[0] + a, r[1] - o]);
    }
  }
  /**
   * Get an updated version of the view options used to construct the view.  The
   * current resolution (or zoom), center, and rotation are applied to any stored
   * options.  The provided options can be used to apply new min/max zoom or
   * resolution limits.
   * @param {ViewOptions} newOptions New options to be applied.
   * @return {ViewOptions} New options updated with the current view state.
   */
  getUpdatedOptions_(e) {
    const t = this.getProperties();
    return t.resolution !== void 0 ? t.resolution = this.getResolution() : t.zoom = this.getZoom(), t.center = this.getCenterInternal(), t.rotation = this.getRotation(), Object.assign({}, t, e);
  }
  /**
   * Animate the view.  The view's center, zoom (or resolution), and rotation
   * can be animated for smooth transitions between view states.  For example,
   * to animate the view to a new zoom level:
   *
   *     view.animate({zoom: view.getZoom() + 1});
   *
   * By default, the animation lasts one second and uses in-and-out easing.  You
   * can customize this behavior by including `duration` (in milliseconds) and
   * `easing` options (see {@link module:ol/easing}).
   *
   * To chain together multiple animations, call the method with multiple
   * animation objects.  For example, to first zoom and then pan:
   *
   *     view.animate({zoom: 10}, {center: [0, 0]});
   *
   * If you provide a function as the last argument to the animate method, it
   * will get called at the end of an animation series.  The callback will be
   * called with `true` if the animation series completed on its own or `false`
   * if it was cancelled.
   *
   * Animations are cancelled by user interactions (e.g. dragging the map) or by
   * calling `view.setCenter()`, `view.setResolution()`, or `view.setRotation()`
   * (or another method that calls one of these).
   *
   * @param {...(AnimationOptions|function(boolean): void)} var_args Animation
   *     options.  Multiple animations can be run in series by passing multiple
   *     options objects.  To run multiple animations in parallel, call the method
   *     multiple times.  An optional callback can be provided as a final
   *     argument.  The callback will be called with a boolean indicating whether
   *     the animation completed without being cancelled.
   * @api
   */
  animate(e) {
    this.isDef() && !this.getAnimating() && this.resolveConstraints(0);
    const t = new Array(arguments.length);
    for (let r = 0; r < t.length; ++r) {
      let n = arguments[r];
      n.center && (n = Object.assign({}, n), n.center = ai(
        n.center,
        this.getProjection()
      )), n.anchor && (n = Object.assign({}, n), n.anchor = ai(
        n.anchor,
        this.getProjection()
      )), t[r] = n;
    }
    this.animateInternal.apply(this, t);
  }
  /**
   * @param {...(AnimationOptions|function(boolean): void)} var_args Animation options.
   */
  animateInternal(e) {
    let t = arguments.length, r;
    t > 1 && typeof arguments[t - 1] == "function" && (r = arguments[t - 1], --t);
    let n = 0;
    for (; n < t && !this.isDef(); ++n) {
      const h = arguments[n];
      h.center && this.setCenterInternal(h.center), h.zoom !== void 0 ? this.setZoom(h.zoom) : h.resolution && this.setResolution(h.resolution), h.rotation !== void 0 && this.setRotation(h.rotation);
    }
    if (n === t) {
      r && Sp(r, !0);
      return;
    }
    let s = Date.now(), a = this.targetCenter_.slice(), o = this.targetResolution_, A = this.targetRotation_;
    const l = [];
    for (; n < t; ++n) {
      const h = (
        /** @type {AnimationOptions} */
        arguments[n]
      ), c = {
        start: s,
        complete: !1,
        anchor: h.anchor,
        duration: h.duration !== void 0 ? h.duration : 1e3,
        easing: h.easing || vm,
        callback: r
      };
      if (h.center && (c.sourceCenter = a, c.targetCenter = h.center.slice(), a = c.targetCenter), h.zoom !== void 0 ? (c.sourceResolution = o, c.targetResolution = this.getResolutionForZoom(h.zoom), o = c.targetResolution) : h.resolution && (c.sourceResolution = o, c.targetResolution = h.resolution, o = c.targetResolution), h.rotation !== void 0) {
        c.sourceRotation = A;
        const u = tl(h.rotation - A + Math.PI, 2 * Math.PI) - Math.PI;
        c.targetRotation = A + u, A = c.targetRotation;
      }
      r6(c) ? c.complete = !0 : s += c.duration, l.push(c);
    }
    this.animations_.push(l), this.setHint(ei.ANIMATING, 1), this.updateAnimations_();
  }
  /**
   * Determine if the view is being animated.
   * @return {boolean} The view is being animated.
   * @api
   */
  getAnimating() {
    return this.hints_[ei.ANIMATING] > 0;
  }
  /**
   * Determine if the user is interacting with the view, such as panning or zooming.
   * @return {boolean} The view is being interacted with.
   * @api
   */
  getInteracting() {
    return this.hints_[ei.INTERACTING] > 0;
  }
  /**
   * Cancel any ongoing animations.
   * @api
   */
  cancelAnimations() {
    this.setHint(ei.ANIMATING, -this.hints_[ei.ANIMATING]);
    let e;
    for (let t = 0, r = this.animations_.length; t < r; ++t) {
      const n = this.animations_[t];
      if (n[0].callback && Sp(n[0].callback, !1), !e)
        for (let s = 0, a = n.length; s < a; ++s) {
          const o = n[s];
          if (!o.complete) {
            e = o.anchor;
            break;
          }
        }
    }
    this.animations_.length = 0, this.cancelAnchor_ = e, this.nextCenter_ = null, this.nextResolution_ = NaN, this.nextRotation_ = NaN;
  }
  /**
   * Update all animations.
   */
  updateAnimations_() {
    if (this.updateAnimationKey_ !== void 0 && (cancelAnimationFrame(this.updateAnimationKey_), this.updateAnimationKey_ = void 0), !this.getAnimating())
      return;
    const e = Date.now();
    let t = !1;
    for (let r = this.animations_.length - 1; r >= 0; --r) {
      const n = this.animations_[r];
      let s = !0;
      for (let a = 0, o = n.length; a < o; ++a) {
        const A = n[a];
        if (A.complete)
          continue;
        const l = e - A.start;
        let h = A.duration > 0 ? l / A.duration : 1;
        h >= 1 ? (A.complete = !0, h = 1) : s = !1;
        const c = A.easing(h);
        if (A.sourceCenter) {
          const u = A.sourceCenter[0], f = A.sourceCenter[1], g = A.targetCenter[0], p = A.targetCenter[1];
          this.nextCenter_ = A.targetCenter;
          const y = u + c * (g - u), v = f + c * (p - f);
          this.targetCenter_ = [y, v];
        }
        if (A.sourceResolution && A.targetResolution) {
          const u = c === 1 ? A.targetResolution : A.sourceResolution + c * (A.targetResolution - A.sourceResolution);
          if (A.anchor) {
            const f = this.getViewportSize_(this.getRotation()), g = this.constraints_.resolution(
              u,
              0,
              f,
              !0
            );
            this.targetCenter_ = this.calculateCenterZoom(
              g,
              A.anchor
            );
          }
          this.nextResolution_ = A.targetResolution, this.targetResolution_ = u, this.applyTargetState_(!0);
        }
        if (A.sourceRotation !== void 0 && A.targetRotation !== void 0) {
          const u = c === 1 ? tl(A.targetRotation + Math.PI, 2 * Math.PI) - Math.PI : A.sourceRotation + c * (A.targetRotation - A.sourceRotation);
          if (A.anchor) {
            const f = this.constraints_.rotation(
              u,
              !0
            );
            this.targetCenter_ = this.calculateCenterRotate(
              f,
              A.anchor
            );
          }
          this.nextRotation_ = A.targetRotation, this.targetRotation_ = u;
        }
        if (this.applyTargetState_(!0), t = !0, !A.complete)
          break;
      }
      if (s) {
        this.animations_[r] = null, this.setHint(ei.ANIMATING, -1), this.nextCenter_ = null, this.nextResolution_ = NaN, this.nextRotation_ = NaN;
        const a = n[0].callback;
        a && Sp(a, !0);
      }
    }
    this.animations_ = this.animations_.filter(Boolean), t && this.updateAnimationKey_ === void 0 && (this.updateAnimationKey_ = requestAnimationFrame(
      this.updateAnimations_.bind(this)
    ));
  }
  /**
   * @param {number} rotation Target rotation.
   * @param {import("./coordinate.js").Coordinate} anchor Rotation anchor.
   * @return {import("./coordinate.js").Coordinate|undefined} Center for rotation and anchor.
   */
  calculateCenterRotate(e, t) {
    let r;
    const n = this.getCenterInternal();
    return n !== void 0 && (r = [n[0] - t[0], n[1] - t[1]], fE(r, e - this.getRotation()), NR(r, t)), r;
  }
  /**
   * @param {number} resolution Target resolution.
   * @param {import("./coordinate.js").Coordinate} anchor Zoom anchor.
   * @return {import("./coordinate.js").Coordinate|undefined} Center for resolution and anchor.
   */
  calculateCenterZoom(e, t) {
    let r;
    const n = this.getCenterInternal(), s = this.getResolution();
    if (n !== void 0 && s !== void 0) {
      const a = t[0] - e * (t[0] - n[0]) / s, o = t[1] - e * (t[1] - n[1]) / s;
      r = [a, o];
    }
    return r;
  }
  /**
   * Returns the current viewport size.
   * @private
   * @param {number} [rotation] Take into account the rotation of the viewport when giving the size
   * @return {import("./size.js").Size} Viewport size or `[100, 100]` when no viewport is found.
   */
  getViewportSize_(e) {
    const t = this.viewportSize_;
    if (e) {
      const r = t[0], n = t[1];
      return [
        Math.abs(r * Math.cos(e)) + Math.abs(n * Math.sin(e)),
        Math.abs(r * Math.sin(e)) + Math.abs(n * Math.cos(e))
      ];
    }
    return t;
  }
  /**
   * Stores the viewport size on the view. The viewport size is not read every time from the DOM
   * to avoid performance hit and layout reflow.
   * This should be done on map size change.
   * Note: the constraints are not resolved during an animation to avoid stopping it
   * @param {import("./size.js").Size} [size] Viewport size; if undefined, [100, 100] is assumed
   */
  setViewportSize(e) {
    this.viewportSize_ = Array.isArray(e) ? e.slice() : [100, 100], this.getAnimating() || this.resolveConstraints(0);
  }
  /**
   * Get the view center.
   * @return {import("./coordinate.js").Coordinate|undefined} The center of the view.
   * @observable
   * @api
   */
  getCenter() {
    const e = this.getCenterInternal();
    return e && fu(e, this.getProjection());
  }
  /**
   * Get the view center without transforming to user projection.
   * @return {import("./coordinate.js").Coordinate|undefined} The center of the view.
   */
  getCenterInternal() {
    return (
      /** @type {import("./coordinate.js").Coordinate|undefined} */
      this.get(Rs.CENTER)
    );
  }
  /**
   * @return {Constraints} Constraints.
   */
  getConstraints() {
    return this.constraints_;
  }
  /**
   * @return {boolean} Resolution constraint is set
   */
  getConstrainResolution() {
    return this.get("constrainResolution");
  }
  /**
   * @param {Array<number>} [hints] Destination array.
   * @return {Array<number>} Hint.
   */
  getHints(e) {
    return e !== void 0 ? (e[0] = this.hints_[0], e[1] = this.hints_[1], e) : this.hints_.slice();
  }
  /**
   * Calculate the extent for the current view state and the passed size.
   * The size is the pixel dimensions of the box into which the calculated extent
   * should fit. In most cases you want to get the extent of the entire map,
   * that is `map.getSize()`.
   * @param {import("./size.js").Size} [size] Box pixel size. If not provided, the size
   * of the map that uses this view will be used.
   * @return {import("./extent.js").Extent} Extent.
   * @api
   */
  calculateExtent(e) {
    const t = this.calculateExtentInternal(e);
    return fg(t, this.getProjection());
  }
  /**
   * @param {import("./size.js").Size} [size] Box pixel size. If not provided,
   * the map's last known viewport size will be used.
   * @return {import("./extent.js").Extent} Extent.
   */
  calculateExtentInternal(e) {
    e = e || this.getViewportSizeMinusPadding_();
    const t = (
      /** @type {!import("./coordinate.js").Coordinate} */
      this.getCenterInternal()
    );
    lt(t, 1);
    const r = (
      /** @type {!number} */
      this.getResolution()
    );
    lt(r !== void 0, 2);
    const n = (
      /** @type {!number} */
      this.getRotation()
    );
    return lt(n !== void 0, 3), th(t, r, n, e);
  }
  /**
   * Get the maximum resolution of the view.
   * @return {number} The maximum resolution of the view.
   * @api
   */
  getMaxResolution() {
    return this.maxResolution_;
  }
  /**
   * Get the minimum resolution of the view.
   * @return {number} The minimum resolution of the view.
   * @api
   */
  getMinResolution() {
    return this.minResolution_;
  }
  /**
   * Get the maximum zoom level for the view.
   * @return {number} The maximum zoom level.
   * @api
   */
  getMaxZoom() {
    return (
      /** @type {number} */
      this.getZoomForResolution(this.minResolution_)
    );
  }
  /**
   * Set a new maximum zoom level for the view.
   * @param {number} zoom The maximum zoom level.
   * @api
   */
  setMaxZoom(e) {
    this.applyOptions_(this.getUpdatedOptions_({ maxZoom: e }));
  }
  /**
   * Get the minimum zoom level for the view.
   * @return {number} The minimum zoom level.
   * @api
   */
  getMinZoom() {
    return (
      /** @type {number} */
      this.getZoomForResolution(this.maxResolution_)
    );
  }
  /**
   * Set a new minimum zoom level for the view.
   * @param {number} zoom The minimum zoom level.
   * @api
   */
  setMinZoom(e) {
    this.applyOptions_(this.getUpdatedOptions_({ minZoom: e }));
  }
  /**
   * Set whether the view should allow intermediary zoom levels.
   * @param {boolean} enabled Whether the resolution is constrained.
   * @api
   */
  setConstrainResolution(e) {
    this.applyOptions_(this.getUpdatedOptions_({ constrainResolution: e }));
  }
  /**
   * Get the view projection.
   * @return {import("./proj/Projection.js").default} The projection of the view.
   * @api
   */
  getProjection() {
    return this.projection_;
  }
  /**
   * Get the view resolution.
   * @return {number|undefined} The resolution of the view.
   * @observable
   * @api
   */
  getResolution() {
    return (
      /** @type {number|undefined} */
      this.get(Rs.RESOLUTION)
    );
  }
  /**
   * Get the resolutions for the view. This returns the array of resolutions
   * passed to the constructor of the View, or undefined if none were given.
   * @return {Array<number>|undefined} The resolutions of the view.
   * @api
   */
  getResolutions() {
    return this.resolutions_;
  }
  /**
   * Get the resolution for a provided extent (in map units) and size (in pixels).
   * @param {import("./extent.js").Extent} extent Extent.
   * @param {import("./size.js").Size} [size] Box pixel size.
   * @return {number} The resolution at which the provided extent will render at
   *     the given size.
   * @api
   */
  getResolutionForExtent(e, t) {
    return this.getResolutionForExtentInternal(
      Os(e, this.getProjection()),
      t
    );
  }
  /**
   * Get the resolution for a provided extent (in map units) and size (in pixels).
   * @param {import("./extent.js").Extent} extent Extent.
   * @param {import("./size.js").Size} [size] Box pixel size.
   * @return {number} The resolution at which the provided extent will render at
   *     the given size.
   */
  getResolutionForExtentInternal(e, t) {
    t = t || this.getViewportSizeMinusPadding_();
    const r = ir(e) / t[0], n = _i(e) / t[1];
    return Math.max(r, n);
  }
  /**
   * Return a function that returns a value between 0 and 1 for a
   * resolution. Exponential scaling is assumed.
   * @param {number} [power] Power.
   * @return {function(number): number} Resolution for value function.
   */
  getResolutionForValueFunction(e) {
    e = e || 2;
    const t = this.getConstrainedResolution(this.maxResolution_), r = this.minResolution_, n = Math.log(t / r) / Math.log(e);
    return (
      /**
       * @param {number} value Value.
       * @return {number} Resolution.
       */
      function(s) {
        return t / Math.pow(e, s * n);
      }
    );
  }
  /**
   * Get the view rotation.
   * @return {number} The rotation of the view in radians.
   * @observable
   * @api
   */
  getRotation() {
    return (
      /** @type {number} */
      this.get(Rs.ROTATION)
    );
  }
  /**
   * Return a function that returns a resolution for a value between
   * 0 and 1. Exponential scaling is assumed.
   * @param {number} [power] Power.
   * @return {function(number): number} Value for resolution function.
   */
  getValueForResolutionFunction(e) {
    const t = Math.log(e || 2), r = this.getConstrainedResolution(this.maxResolution_), n = this.minResolution_, s = Math.log(r / n) / t;
    return (
      /**
       * @param {number} resolution Resolution.
       * @return {number} Value.
       */
      function(a) {
        return Math.log(r / a) / t / s;
      }
    );
  }
  /**
   * Returns the size of the viewport minus padding.
   * @private
   * @param {number} [rotation] Take into account the rotation of the viewport when giving the size
   * @return {import("./size.js").Size} Viewport size reduced by the padding.
   */
  getViewportSizeMinusPadding_(e) {
    let t = this.getViewportSize_(e);
    const r = this.padding_;
    return r && (t = [
      t[0] - r[1] - r[3],
      t[1] - r[0] - r[2]
    ]), t;
  }
  /**
   * @return {State} View state.
   */
  getState() {
    const e = this.getProjection(), t = this.getResolution(), r = this.getRotation();
    let n = (
      /** @type {import("./coordinate.js").Coordinate} */
      this.getCenterInternal()
    );
    const s = this.padding_;
    if (s) {
      const a = this.getViewportSizeMinusPadding_();
      n = I1(
        n,
        this.getViewportSize_(),
        [a[0] / 2 + s[3], a[1] / 2 + s[0]],
        t,
        r
      );
    }
    return {
      center: n.slice(0),
      projection: e !== void 0 ? e : null,
      resolution: t,
      nextCenter: this.nextCenter_,
      nextResolution: this.nextResolution_,
      nextRotation: this.nextRotation_,
      rotation: r,
      zoom: this.getZoom()
    };
  }
  /**
   * @return {ViewStateAndExtent} Like `FrameState`, but just `viewState` and `extent`.
   */
  getViewStateAndExtent() {
    return {
      viewState: this.getState(),
      extent: this.calculateExtent()
    };
  }
  /**
   * Get the current zoom level. This method may return non-integer zoom levels
   * if the view does not constrain the resolution, or if an interaction or
   * animation is underway.
   * @return {number|undefined} Zoom.
   * @api
   */
  getZoom() {
    let e;
    const t = this.getResolution();
    return t !== void 0 && (e = this.getZoomForResolution(t)), e;
  }
  /**
   * Get the zoom level for a resolution.
   * @param {number} resolution The resolution.
   * @return {number|undefined} The zoom level for the provided resolution.
   * @api
   */
  getZoomForResolution(e) {
    let t = this.minZoom_ || 0, r, n;
    if (this.resolutions_) {
      const s = Lv(this.resolutions_, e, 1);
      t = s, r = this.resolutions_[s], s == this.resolutions_.length - 1 ? n = 2 : n = r / this.resolutions_[s + 1];
    } else
      r = this.maxResolution_, n = this.zoomFactor_;
    return t + Math.log(r / e) / Math.log(n);
  }
  /**
   * Get the resolution for a zoom level.
   * @param {number} zoom Zoom level.
   * @return {number} The view resolution for the provided zoom level.
   * @api
   */
  getResolutionForZoom(e) {
    if (this.resolutions_) {
      if (this.resolutions_.length <= 1)
        return 0;
      const t = jr(
        Math.floor(e),
        0,
        this.resolutions_.length - 2
      ), r = this.resolutions_[t] / this.resolutions_[t + 1];
      return this.resolutions_[t] / Math.pow(r, jr(e - t, 0, 1));
    }
    return this.maxResolution_ / Math.pow(this.zoomFactor_, e - this.minZoom_);
  }
  /**
   * Fit the given geometry or extent based on the given map size and border.
   * The size is pixel dimensions of the box to fit the extent into.
   * In most cases you will want to use the map size, that is `map.getSize()`.
   * Takes care of the map angle.
   * @param {import("./geom/SimpleGeometry.js").default|import("./extent.js").Extent} geometryOrExtent The geometry or
   *     extent to fit the view to.
   * @param {FitOptions} [options] Options.
   * @api
   */
  fit(e, t) {
    let r;
    if (lt(
      Array.isArray(e) || typeof /** @type {?} */
      e.getSimplifiedGeometry == "function",
      24
    ), Array.isArray(e)) {
      lt(!Tu(e), 25);
      const n = Os(e, this.getProjection());
      r = jA(n);
    } else if (e.getType() === "Circle") {
      const n = Os(
        e.getExtent(),
        this.getProjection()
      );
      r = jA(n), r.rotate(this.getRotation(), Xn(n));
    } else
      r = e;
    this.fitInternal(r, t);
  }
  /**
   * Calculate rotated extent
   * @param {import("./geom/SimpleGeometry.js").default} geometry The geometry.
   * @return {import("./extent").Extent} The rotated extent for the geometry.
   */
  rotatedExtentForGeometry(e) {
    const t = this.getRotation(), r = Math.cos(t), n = Math.sin(-t), s = e.getFlatCoordinates(), a = e.getStride();
    let o = 1 / 0, A = 1 / 0, l = -1 / 0, h = -1 / 0;
    for (let c = 0, u = s.length; c < u; c += a) {
      const f = s[c] * r - s[c + 1] * n, g = s[c] * n + s[c + 1] * r;
      o = Math.min(o, f), A = Math.min(A, g), l = Math.max(l, f), h = Math.max(h, g);
    }
    return [o, A, l, h];
  }
  /**
   * @param {import("./geom/SimpleGeometry.js").default} geometry The geometry.
   * @param {FitOptions} [options] Options.
   */
  fitInternal(e, t) {
    t = t || {};
    let r = t.size;
    r || (r = this.getViewportSizeMinusPadding_());
    const n = t.padding !== void 0 ? t.padding : [0, 0, 0, 0], s = t.nearest !== void 0 ? t.nearest : !1;
    let a;
    t.minResolution !== void 0 ? a = t.minResolution : t.maxZoom !== void 0 ? a = this.getResolutionForZoom(t.maxZoom) : a = 0;
    const o = this.rotatedExtentForGeometry(e);
    let A = this.getResolutionForExtentInternal(o, [
      r[0] - n[1] - n[3],
      r[1] - n[0] - n[2]
    ]);
    A = isNaN(A) ? a : Math.max(A, a), A = this.getConstrainedResolution(A, s ? 0 : 1);
    const l = this.getRotation(), h = Math.sin(l), c = Math.cos(l), u = Xn(o);
    u[0] += (n[1] - n[3]) / 2 * A, u[1] += (n[0] - n[2]) / 2 * A;
    const f = u[0] * c - u[1] * h, g = u[1] * c + u[0] * h, p = this.getConstrainedCenter([f, g], A), y = t.callback ? t.callback : hu;
    t.duration !== void 0 ? this.animateInternal(
      {
        resolution: A,
        center: p,
        duration: t.duration,
        easing: t.easing
      },
      y
    ) : (this.targetResolution_ = A, this.targetCenter_ = p, this.applyTargetState_(!1, !0), Sp(y, !0));
  }
  /**
   * Center on coordinate and view position.
   * @param {import("./coordinate.js").Coordinate} coordinate Coordinate.
   * @param {import("./size.js").Size} size Box pixel size.
   * @param {import("./pixel.js").Pixel} position Position on the view to center on.
   * @api
   */
  centerOn(e, t, r) {
    this.centerOnInternal(
      ai(e, this.getProjection()),
      t,
      r
    );
  }
  /**
   * @param {import("./coordinate.js").Coordinate} coordinate Coordinate.
   * @param {import("./size.js").Size} size Box pixel size.
   * @param {import("./pixel.js").Pixel} position Position on the view to center on.
   */
  centerOnInternal(e, t, r) {
    this.setCenterInternal(
      I1(
        e,
        t,
        r,
        this.getResolution(),
        this.getRotation()
      )
    );
  }
  /**
   * Calculates the shift between map and viewport center.
   * @param {import("./coordinate.js").Coordinate} center Center.
   * @param {number} resolution Resolution.
   * @param {number} rotation Rotation.
   * @param {import("./size.js").Size} size Size.
   * @return {Array<number>|undefined} Center shift.
   */
  calculateCenterShift(e, t, r, n) {
    let s;
    const a = this.padding_;
    if (a && e) {
      const o = this.getViewportSizeMinusPadding_(-r), A = I1(
        e,
        n,
        [o[0] / 2 + a[3], o[1] / 2 + a[0]],
        t,
        r
      );
      s = [
        e[0] - A[0],
        e[1] - A[1]
      ];
    }
    return s;
  }
  /**
   * @return {boolean} Is defined.
   */
  isDef() {
    return !!this.getCenterInternal() && this.getResolution() !== void 0;
  }
  /**
   * Adds relative coordinates to the center of the view. Any extent constraint will apply.
   * @param {import("./coordinate.js").Coordinate} deltaCoordinates Relative value to add.
   * @api
   */
  adjustCenter(e) {
    const t = fu(this.targetCenter_, this.getProjection());
    this.setCenter([
      t[0] + e[0],
      t[1] + e[1]
    ]);
  }
  /**
   * Adds relative coordinates to the center of the view. Any extent constraint will apply.
   * @param {import("./coordinate.js").Coordinate} deltaCoordinates Relative value to add.
   */
  adjustCenterInternal(e) {
    const t = this.targetCenter_;
    this.setCenterInternal([
      t[0] + e[0],
      t[1] + e[1]
    ]);
  }
  /**
   * Multiply the view resolution by a ratio, optionally using an anchor. Any resolution
   * constraint will apply.
   * @param {number} ratio The ratio to apply on the view resolution.
   * @param {import("./coordinate.js").Coordinate} [anchor] The origin of the transformation.
   * @api
   */
  adjustResolution(e, t) {
    t = t && ai(t, this.getProjection()), this.adjustResolutionInternal(e, t);
  }
  /**
   * Multiply the view resolution by a ratio, optionally using an anchor. Any resolution
   * constraint will apply.
   * @param {number} ratio The ratio to apply on the view resolution.
   * @param {import("./coordinate.js").Coordinate} [anchor] The origin of the transformation.
   */
  adjustResolutionInternal(e, t) {
    const r = this.getAnimating() || this.getInteracting(), n = this.getViewportSize_(this.getRotation()), s = this.constraints_.resolution(
      this.targetResolution_ * e,
      0,
      n,
      r
    );
    t && (this.targetCenter_ = this.calculateCenterZoom(s, t)), this.targetResolution_ *= e, this.applyTargetState_();
  }
  /**
   * Adds a value to the view zoom level, optionally using an anchor. Any resolution
   * constraint will apply.
   * @param {number} delta Relative value to add to the zoom level.
   * @param {import("./coordinate.js").Coordinate} [anchor] The origin of the transformation.
   * @api
   */
  adjustZoom(e, t) {
    this.adjustResolution(Math.pow(this.zoomFactor_, -e), t);
  }
  /**
   * Adds a value to the view rotation, optionally using an anchor. Any rotation
   * constraint will apply.
   * @param {number} delta Relative value to add to the zoom rotation, in radians.
   * @param {import("./coordinate.js").Coordinate} [anchor] The rotation center.
   * @api
   */
  adjustRotation(e, t) {
    t && (t = ai(t, this.getProjection())), this.adjustRotationInternal(e, t);
  }
  /**
   * @param {number} delta Relative value to add to the zoom rotation, in radians.
   * @param {import("./coordinate.js").Coordinate} [anchor] The rotation center.
   */
  adjustRotationInternal(e, t) {
    const r = this.getAnimating() || this.getInteracting(), n = this.constraints_.rotation(
      this.targetRotation_ + e,
      r
    );
    t && (this.targetCenter_ = this.calculateCenterRotate(n, t)), this.targetRotation_ += e, this.applyTargetState_();
  }
  /**
   * Set the center of the current view. Any extent constraint will apply.
   * @param {import("./coordinate.js").Coordinate|undefined} center The center of the view.
   * @observable
   * @api
   */
  setCenter(e) {
    this.setCenterInternal(
      e && ai(e, this.getProjection())
    );
  }
  /**
   * Set the center using the view projection (not the user projection).
   * @param {import("./coordinate.js").Coordinate|undefined} center The center of the view.
   */
  setCenterInternal(e) {
    this.targetCenter_ = e, this.applyTargetState_();
  }
  /**
   * @param {import("./ViewHint.js").default} hint Hint.
   * @param {number} delta Delta.
   * @return {number} New value.
   */
  setHint(e, t) {
    return this.hints_[e] += t, this.changed(), this.hints_[e];
  }
  /**
   * Set the resolution for this view. Any resolution constraint will apply.
   * @param {number|undefined} resolution The resolution of the view.
   * @observable
   * @api
   */
  setResolution(e) {
    this.targetResolution_ = e, this.applyTargetState_();
  }
  /**
   * Set the rotation for this view. Any rotation constraint will apply.
   * @param {number} rotation The rotation of the view in radians.
   * @observable
   * @api
   */
  setRotation(e) {
    this.targetRotation_ = e, this.applyTargetState_();
  }
  /**
   * Zoom to a specific zoom level. Any resolution constrain will apply.
   * @param {number} zoom Zoom level.
   * @api
   */
  setZoom(e) {
    this.setResolution(this.getResolutionForZoom(e));
  }
  /**
   * Recompute rotation/resolution/center based on target values.
   * Note: we have to compute rotation first, then resolution and center considering that
   * parameters can influence one another in case a view extent constraint is present.
   * @param {boolean} [doNotCancelAnims] Do not cancel animations.
   * @param {boolean} [forceMoving] Apply constraints as if the view is moving.
   * @private
   */
  applyTargetState_(e, t) {
    const r = this.getAnimating() || this.getInteracting() || t, n = this.constraints_.rotation(
      this.targetRotation_,
      r
    ), s = this.getViewportSize_(n), a = this.constraints_.resolution(
      this.targetResolution_,
      0,
      s,
      r
    ), o = this.constraints_.center(
      this.targetCenter_,
      a,
      s,
      r,
      this.calculateCenterShift(
        this.targetCenter_,
        a,
        n,
        s
      )
    );
    this.get(Rs.ROTATION) !== n && this.set(Rs.ROTATION, n), this.get(Rs.RESOLUTION) !== a && (this.set(Rs.RESOLUTION, a), this.set("zoom", this.getZoom(), !0)), (!o || !this.get(Rs.CENTER) || !ya(this.get(Rs.CENTER), o)) && this.set(Rs.CENTER, o), this.getAnimating() && !e && this.cancelAnimations(), this.cancelAnchor_ = void 0;
  }
  /**
   * If any constraints need to be applied, an animation will be triggered.
   * This is typically done on interaction end.
   * Note: calling this with a duration of 0 will apply the constrained values straight away,
   * without animation.
   * @param {number} [duration] The animation duration in ms.
   * @param {number} [resolutionDirection] Which direction to zoom.
   * @param {import("./coordinate.js").Coordinate} [anchor] The origin of the transformation.
   */
  resolveConstraints(e, t, r) {
    e = e !== void 0 ? e : 200;
    const n = t || 0, s = this.constraints_.rotation(this.targetRotation_), a = this.getViewportSize_(s), o = this.constraints_.resolution(
      this.targetResolution_,
      n,
      a
    ), A = this.constraints_.center(
      this.targetCenter_,
      o,
      a,
      !1,
      this.calculateCenterShift(
        this.targetCenter_,
        o,
        s,
        a
      )
    );
    if (e === 0 && !this.cancelAnchor_) {
      this.targetResolution_ = o, this.targetRotation_ = s, this.targetCenter_ = A, this.applyTargetState_();
      return;
    }
    r = r || (e === 0 ? this.cancelAnchor_ : void 0), this.cancelAnchor_ = void 0, (this.getResolution() !== o || this.getRotation() !== s || !this.getCenterInternal() || !ya(this.getCenterInternal(), A)) && (this.getAnimating() && this.cancelAnimations(), this.animateInternal({
      rotation: s,
      center: A,
      resolution: o,
      duration: e,
      easing: ea,
      anchor: r
    }));
  }
  /**
   * Notify the View that an interaction has started.
   * The view state will be resolved to a stable one if needed
   * (depending on its constraints).
   * @api
   */
  beginInteraction() {
    this.resolveConstraints(0), this.setHint(ei.INTERACTING, 1);
  }
  /**
   * Notify the View that an interaction has ended. The view state will be resolved
   * to a stable one if needed (depending on its constraints).
   * @param {number} [duration] Animation duration in ms.
   * @param {number} [resolutionDirection] Which direction to zoom.
   * @param {import("./coordinate.js").Coordinate} [anchor] The origin of the transformation.
   * @api
   */
  endInteraction(e, t, r) {
    r = r && ai(r, this.getProjection()), this.endInteractionInternal(e, t, r);
  }
  /**
   * Notify the View that an interaction has ended. The view state will be resolved
   * to a stable one if needed (depending on its constraints).
   * @param {number} [duration] Animation duration in ms.
   * @param {number} [resolutionDirection] Which direction to zoom.
   * @param {import("./coordinate.js").Coordinate} [anchor] The origin of the transformation.
   */
  endInteractionInternal(e, t, r) {
    this.getInteracting() && (this.setHint(ei.INTERACTING, -1), this.resolveConstraints(e, t, r));
  }
  /**
   * Get a valid position for the view center according to the current constraints.
   * @param {import("./coordinate.js").Coordinate|undefined} targetCenter Target center position.
   * @param {number} [targetResolution] Target resolution. If not supplied, the current one will be used.
   * This is useful to guess a valid center position at a different zoom level.
   * @return {import("./coordinate.js").Coordinate|undefined} Valid center position.
   */
  getConstrainedCenter(e, t) {
    const r = this.getViewportSize_(this.getRotation());
    return this.constraints_.center(
      e,
      t || this.getResolution(),
      r
    );
  }
  /**
   * Get a valid zoom level according to the current view constraints.
   * @param {number|undefined} targetZoom Target zoom.
   * @param {number} [direction=0] Indicate which resolution should be used
   * by a renderer if the view resolution does not match any resolution of the tile source.
   * If 0, the nearest resolution will be used. If 1, the nearest lower resolution
   * will be used. If -1, the nearest higher resolution will be used.
   * @return {number|undefined} Valid zoom level.
   */
  getConstrainedZoom(e, t) {
    const r = this.getResolutionForZoom(e);
    return this.getZoomForResolution(
      this.getConstrainedResolution(r, t)
    );
  }
  /**
   * Get a valid resolution according to the current view constraints.
   * @param {number|undefined} targetResolution Target resolution.
   * @param {number} [direction=0] Indicate which resolution should be used
   * by a renderer if the view resolution does not match any resolution of the tile source.
   * If 0, the nearest resolution will be used. If 1, the nearest lower resolution
   * will be used. If -1, the nearest higher resolution will be used.
   * @return {number|undefined} Valid resolution.
   */
  getConstrainedResolution(e, t) {
    t = t || 0;
    const r = this.getViewportSize_(this.getRotation());
    return this.constraints_.resolution(e, t, r);
  }
};
function Sp(i, e) {
  setTimeout(function() {
    i(e);
  }, 0);
}
function JD(i) {
  if (i.extent !== void 0) {
    const t = i.smoothExtentConstraint !== void 0 ? i.smoothExtentConstraint : !0;
    return IS(i.extent, i.constrainOnlyCenter, t);
  }
  const e = gE(i.projection, "EPSG:3857");
  if (i.multiWorld !== !0 && e.isGlobal()) {
    const t = e.getExtent().slice();
    return t[0] = -1 / 0, t[2] = 1 / 0, IS(t, !1, !1);
  }
  return xD;
}
function e6(i) {
  let e, t, r, a = i.minZoom !== void 0 ? i.minZoom : L1, o = i.maxZoom !== void 0 ? i.maxZoom : 28;
  const A = i.zoomFactor !== void 0 ? i.zoomFactor : 2, l = i.multiWorld !== void 0 ? i.multiWorld : !1, h = i.smoothResolutionConstraint !== void 0 ? i.smoothResolutionConstraint : !0, c = i.showFullExtent !== void 0 ? i.showFullExtent : !1, u = gE(i.projection, "EPSG:3857"), f = u.getExtent();
  let g = i.constrainOnlyCenter, p = i.extent;
  if (!l && !p && u.isGlobal() && (g = !1, p = f), i.resolutions !== void 0) {
    const y = i.resolutions;
    t = y[a], r = y[o] !== void 0 ? y[o] : y[y.length - 1], i.constrainResolution ? e = CD(
      y,
      h,
      !g && p,
      c
    ) : e = RS(
      t,
      r,
      h,
      !g && p,
      c
    );
  } else {
    const v = (f ? Math.max(ir(f), _i(f)) : (
      // use an extent that can fit the whole world if need be
      360 * cu.degrees / u.getMetersPerUnit()
    )) / cE / Math.pow(2, L1), w = v / Math.pow(2, 28 - L1);
    t = i.maxResolution, t !== void 0 ? a = 0 : t = v / Math.pow(A, a), r = i.minResolution, r === void 0 && (i.maxZoom !== void 0 ? i.maxResolution !== void 0 ? r = t / Math.pow(A, o) : r = v / Math.pow(A, o) : r = w), o = a + Math.floor(
      Math.log(t / r) / Math.log(A)
    ), r = t / Math.pow(A, o - a), i.constrainResolution ? e = ED(
      A,
      t,
      r,
      h,
      !g && p,
      c
    ) : e = RS(
      t,
      r,
      h,
      !g && p,
      c
    );
  }
  return {
    constraint: e,
    maxResolution: t,
    minResolution: r,
    minZoom: a,
    zoomFactor: A
  };
}
function t6(i) {
  if (i.enableRotation !== void 0 ? i.enableRotation : !0) {
    const t = i.constrainRotation;
    return t === void 0 || t === !0 ? bD() : t === !1 ? MS : typeof t == "number" ? BD(t) : MS;
  }
  return vE;
}
function r6(i) {
  return !(i.sourceCenter && i.targetCenter && !ya(i.sourceCenter, i.targetCenter) || i.sourceResolution !== i.targetResolution || i.sourceRotation !== i.targetRotation);
}
function I1(i, e, t, r, n) {
  const s = Math.cos(-n);
  let a = Math.sin(-n), o = i[0] * s - i[1] * a, A = i[1] * s + i[0] * a;
  o += (e[0] / 2 - t[0]) * r, A += (t[1] - e[1] / 2) * r, a = -a;
  const l = o * s - A * a, h = A * s + o * a;
  return [l, h];
}
const Ys = ZD;
class i6 extends hE {
  /**
   * @param {Options<SourceType>} options Layer options.
   */
  constructor(e) {
    const t = Object.assign({}, e);
    delete t.source, super(t), this.on, this.once, this.un, this.mapPrecomposeKey_ = null, this.mapRenderKey_ = null, this.sourceChangeKey_ = null, this.renderer_ = null, this.sourceReady_ = !1, this.rendered = !1, e.render && (this.render = e.render), e.map && this.setMap(e.map), this.addChangeListener(
      Fr.SOURCE,
      this.handleSourcePropertyChange_
    );
    const r = e.source ? (
      /** @type {SourceType} */
      e.source
    ) : null;
    this.setSource(r);
  }
  /**
   * @param {Array<import("./Layer.js").default>} [array] Array of layers (to be modified in place).
   * @return {Array<import("./Layer.js").default>} Array of layers.
   */
  getLayersArray(e) {
    return e = e || [], e.push(this), e;
  }
  /**
   * @param {Array<import("./Layer.js").State>} [states] Optional list of layer states (to be modified in place).
   * @return {Array<import("./Layer.js").State>} List of layer states.
   */
  getLayerStatesArray(e) {
    return e = e || [], e.push(this.getLayerState()), e;
  }
  /**
   * Get the layer source.
   * @return {SourceType|null} The layer source (or `null` if not yet set).
   * @observable
   * @api
   */
  getSource() {
    return (
      /** @type {SourceType} */
      this.get(Fr.SOURCE) || null
    );
  }
  /**
   * @return {SourceType|null} The source being rendered.
   */
  getRenderSource() {
    return this.getSource();
  }
  /**
   * @return {import("../source/Source.js").State} Source state.
   */
  getSourceState() {
    const e = this.getSource();
    return e ? e.getState() : "undefined";
  }
  /**
   * @private
   */
  handleSourceChange_() {
    this.changed(), !(this.sourceReady_ || this.getSource().getState() !== "ready") && (this.sourceReady_ = !0, this.dispatchEvent("sourceready"));
  }
  /**
   * @private
   */
  handleSourcePropertyChange_() {
    this.sourceChangeKey_ && (pr(this.sourceChangeKey_), this.sourceChangeKey_ = null), this.sourceReady_ = !1;
    const e = this.getSource();
    e && (this.sourceChangeKey_ = St(
      e,
      ut.CHANGE,
      this.handleSourceChange_,
      this
    ), e.getState() === "ready" && (this.sourceReady_ = !0, setTimeout(() => {
      this.dispatchEvent("sourceready");
    }, 0))), this.changed();
  }
  /**
   * @param {import("../pixel").Pixel} pixel Pixel.
   * @return {Promise<Array<import("../Feature").FeatureLike>>} Promise that resolves with
   * an array of features.
   */
  getFeatures(e) {
    return this.renderer_ ? this.renderer_.getFeatures(e) : Promise.resolve([]);
  }
  /**
   * @param {import("../pixel").Pixel} pixel Pixel.
   * @return {Uint8ClampedArray|Uint8Array|Float32Array|DataView|null} Pixel data.
   */
  getData(e) {
    return !this.renderer_ || !this.rendered ? null : this.renderer_.getData(e);
  }
  /**
   * The layer is visible in the given view, i.e. within its min/max resolution or zoom and
   * extent, and `getVisible()` is `true`.
   * @param {View|import("../View.js").ViewStateAndExtent} view View or {@link import("../Map.js").FrameState}.
   * @return {boolean} The layer is visible in the current view.
   * @api
   */
  isVisible(e) {
    let t;
    e instanceof Ys ? t = {
      viewState: e.getState(),
      extent: e.calculateExtent()
    } : t = e;
    const r = this.getExtent();
    return this.getVisible() && LE(this.getLayerState(), t.viewState) && (!r || ci(r, t.extent));
  }
  /**
   * Get the attributions of the source of this layer for the given view.
   * @param {View|import("../View.js").ViewStateAndExtent} view View or  {@link import("../Map.js").FrameState}.
   * @return {Array<string>} Attributions for this layer at the given view.
   * @api
   */
  getAttributions(e) {
    if (!this.isVisible(e))
      return [];
    let t;
    const r = this.getSource();
    if (r && (t = r.getAttributions()), !t)
      return [];
    const n = e instanceof Ys ? e.getViewStateAndExtent() : e;
    let s = t(n);
    return Array.isArray(s) || (s = [s]), s;
  }
  /**
   * In charge to manage the rendering of the layer. One layer type is
   * bounded with one layer renderer.
   * @param {?import("../Map.js").FrameState} frameState Frame state.
   * @param {HTMLElement} target Target which the renderer may (but need not) use
   * for rendering its content.
   * @return {HTMLElement} The rendered element.
   */
  render(e, t) {
    const r = this.getRenderer();
    if (r.prepareFrame(e))
      return this.rendered = !0, r.renderFrame(e, t);
  }
  /**
   * Called when a layer is not visible during a map render.
   */
  unrender() {
    this.rendered = !1;
  }
  /**
   * For use inside the library only.
   * @param {import("../Map.js").default|null} map Map.
   */
  setMapInternal(e) {
    e || this.unrender(), this.set(Fr.MAP, e);
  }
  /**
   * For use inside the library only.
   * @return {import("../Map.js").default|null} Map.
   */
  getMapInternal() {
    return this.get(Fr.MAP);
  }
  /**
   * Sets the layer to be rendered on top of other layers on a map. The map will
   * not manage this layer in its layers collection. This
   * is useful for temporary layers. To remove an unmanaged layer from the map,
   * use `#setMap(null)`.
   *
   * To add the layer to a map and have it managed by the map, use
   * {@link module:ol/Map~Map#addLayer} instead.
   * @param {import("../Map.js").default|null} map Map.
   * @api
   */
  setMap(e) {
    this.mapPrecomposeKey_ && (pr(this.mapPrecomposeKey_), this.mapPrecomposeKey_ = null), e || this.changed(), this.mapRenderKey_ && (pr(this.mapRenderKey_), this.mapRenderKey_ = null), e && (this.mapPrecomposeKey_ = St(
      e,
      ds.PRECOMPOSE,
      function(t) {
        const n = /** @type {import("../render/Event.js").default} */ t.frameState.layerStatesArray, s = this.getLayerState(!1);
        lt(
          !n.some(function(a) {
            return a.layer === s.layer;
          }),
          67
        ), n.push(s);
      },
      this
    ), this.mapRenderKey_ = St(this, ut.CHANGE, e.render, e), this.changed());
  }
  /**
   * Set the layer source.
   * @param {SourceType|null} source The layer source.
   * @observable
   * @api
   */
  setSource(e) {
    this.set(Fr.SOURCE, e);
  }
  /**
   * Get the renderer for this layer.
   * @return {RendererType|null} The layer renderer.
   */
  getRenderer() {
    return this.renderer_ || (this.renderer_ = this.createRenderer()), this.renderer_;
  }
  /**
   * @return {boolean} The layer has a renderer.
   */
  hasRenderer() {
    return !!this.renderer_;
  }
  /**
   * Create a renderer for this layer.
   * @return {RendererType} A layer renderer.
   * @protected
   */
  createRenderer() {
    return null;
  }
  /**
   * Clean up.
   */
  disposeInternal() {
    this.renderer_ && (this.renderer_.dispose(), delete this.renderer_), this.setSource(null), super.disposeInternal();
  }
}
function LE(i, e) {
  if (!i.visible)
    return !1;
  const t = e.resolution;
  if (t < i.minResolution || t >= i.maxResolution)
    return !1;
  const r = e.zoom;
  return r > i.minZoom && r <= i.maxZoom;
}
const bh = i6;
class n6 extends Fv {
  /**
   * @param {import("../Map.js").default} map Map.
   */
  constructor(e) {
    super(), this.map_ = e;
  }
  /**
   * @abstract
   * @param {import("../render/EventType.js").default} type Event type.
   * @param {import("../Map.js").FrameState} frameState Frame state.
   */
  dispatchRenderEvent(e, t) {
    pt();
  }
  /**
   * @param {import("../Map.js").FrameState} frameState FrameState.
   * @protected
   */
  calculateMatrices2D(e) {
    const t = e.viewState, r = e.coordinateToPixelTransform, n = e.pixelToCoordinateTransform;
    Qs(
      r,
      e.size[0] / 2,
      e.size[1] / 2,
      1 / t.resolution,
      -1 / t.resolution,
      -t.rotation,
      -t.center[0],
      -t.center[1]
    ), Ag(n, r);
  }
  /**
   * @param {import("../coordinate.js").Coordinate} coordinate Coordinate.
   * @param {import("../Map.js").FrameState} frameState FrameState.
   * @param {number} hitTolerance Hit tolerance in pixels.
   * @param {boolean} checkWrapped Check for wrapped geometries.
   * @param {import("./vector.js").FeatureCallback<T>} callback Feature callback.
   * @param {S} thisArg Value to use as `this` when executing `callback`.
   * @param {function(this: U, import("../layer/Layer.js").default): boolean} layerFilter Layer filter
   *     function, only layers which are visible and for which this function
   *     returns `true` will be tested for features.  By default, all visible
   *     layers will be tested.
   * @param {U} thisArg2 Value to use as `this` when executing `layerFilter`.
   * @return {T|undefined} Callback result.
   * @template S,T,U
   */
  forEachFeatureAtCoordinate(e, t, r, n, s, a, o, A) {
    let l;
    const h = t.viewState;
    function c(E, S, M, T) {
      return s.call(a, S, E ? M : null, T);
    }
    const u = h.projection, f = Nv(e.slice(), u), g = [[0, 0]];
    if (u.canWrapX() && n) {
      const E = u.getExtent(), S = ir(E);
      g.push([-S, 0], [S, 0]);
    }
    const p = t.layerStatesArray, y = p.length, v = (
      /** @type {Array<HitMatch<T>>} */
      []
    ), w = [];
    for (let E = 0; E < g.length; E++)
      for (let S = y - 1; S >= 0; --S) {
        const M = p[S], T = M.layer;
        if (T.hasRenderer() && LE(M, h) && o.call(A, T)) {
          const F = T.getRenderer(), k = T.getSource();
          if (F && k) {
            const $ = k.getWrapX() ? f : e, I = c.bind(
              null,
              M.managed
            );
            w[0] = $[0] + g[E][0], w[1] = $[1] + g[E][1], l = F.forEachFeatureAtCoordinate(
              w,
              t,
              r,
              I,
              v
            );
          }
          if (l)
            return l;
        }
      }
    if (v.length === 0)
      return;
    const C = 1 / v.length;
    return v.forEach((E, S) => E.distanceSq += S * C), v.sort((E, S) => E.distanceSq - S.distanceSq), v.some((E) => l = E.callback(E.feature, E.layer, E.geometry)), l;
  }
  /**
   * @param {import("../coordinate.js").Coordinate} coordinate Coordinate.
   * @param {import("../Map.js").FrameState} frameState FrameState.
   * @param {number} hitTolerance Hit tolerance in pixels.
   * @param {boolean} checkWrapped Check for wrapped geometries.
   * @param {function(this: U, import("../layer/Layer.js").default): boolean} layerFilter Layer filter
   *     function, only layers which are visible and for which this function
   *     returns `true` will be tested for features.  By default, all visible
   *     layers will be tested.
   * @param {U} thisArg Value to use as `this` when executing `layerFilter`.
   * @return {boolean} Is there a feature at the given coordinate?
   * @template U
   */
  hasFeatureAtCoordinate(e, t, r, n, s, a) {
    return this.forEachFeatureAtCoordinate(
      e,
      t,
      r,
      n,
      Xo,
      this,
      s,
      a
    ) !== void 0;
  }
  /**
   * @return {import("../Map.js").default} Map.
   */
  getMap() {
    return this.map_;
  }
  /**
   * Render.
   * @abstract
   * @param {?import("../Map.js").FrameState} frameState Frame state.
   */
  renderFrame(e) {
    pt();
  }
  /**
   * @param {import("../Map.js").FrameState} frameState Frame state.
   * @protected
   */
  scheduleExpireIconCache(e) {
    fm.canExpireCache() && e.postRenderFunctions.push(s6);
  }
}
function s6(i, e) {
  fm.expire();
}
const a6 = n6;
class o6 extends _s {
  /**
   * @param {import("./EventType.js").default} type Type.
   * @param {import("../transform.js").Transform} [inversePixelTransform] Transform for
   *     CSS pixels to rendered pixels.
   * @param {import("../Map.js").FrameState} [frameState] Frame state.
   * @param {?(CanvasRenderingContext2D|WebGLRenderingContext)} [context] Context.
   */
  constructor(e, t, r, n) {
    super(e), this.inversePixelTransform = t, this.frameState = r, this.context = n;
  }
}
const ld = o6, Tp = "ol-hidden", A6 = "ol-selectable", Wa = "ol-unselectable", US = "ol-unsupported", Sh = "ol-control", _m = "ol-collapsed", l6 = new RegExp(
  [
    "^\\s*(?=(?:(?:[-a-z]+\\s*){0,2}(italic|oblique))?)",
    "(?=(?:(?:[-a-z]+\\s*){0,2}(small-caps))?)",
    "(?=(?:(?:[-a-z]+\\s*){0,2}(bold(?:er)?|lighter|[1-9]00 ))?)",
    "(?:(?:normal|\\1|\\2|\\3)\\s*){0,3}((?:xx?-)?",
    "(?:small|large)|medium|smaller|larger|[\\.\\d]+(?:\\%|in|[cem]m|ex|p[ctx]))",
    "(?:\\s*\\/\\s*(normal|[\\.\\d]+(?:\\%|in|[cem]m|ex|p[ctx])?))",
    `?\\s*([-,\\"\\'\\sa-z]+?)\\s*$`
  ].join(""),
  "i"
), QS = [
  "style",
  "variant",
  "weight",
  "size",
  "lineHeight",
  "family"
], ZR = function(i) {
  const e = i.match(l6);
  if (!e)
    return null;
  const t = (
    /** @type {FontParameters} */
    {
      lineHeight: "normal",
      size: "1.2em",
      style: "normal",
      weight: "normal",
      variant: "normal"
    }
  );
  for (let r = 0, n = QS.length; r < n; ++r) {
    const s = e[r + 1];
    s !== void 0 && (t[QS[r]] = s);
  }
  return t.families = t.family.split(/,\s?/), t;
};
function Ii(i, e, t, r) {
  let n;
  return t && t.length ? n = t.shift() : rE ? n = new OffscreenCanvas(i || 300, e || 300) : n = document.createElement("canvas"), i && (n.width = i), e && (n.height = e), /** @type {CanvasRenderingContext2D} */
  n.getContext("2d", r);
}
function gu(i) {
  const e = i.canvas;
  e.width = 1, e.height = 1, i.clearRect(0, 0, 1, 1);
}
function h6(i) {
  let e = i.offsetWidth;
  const t = getComputedStyle(i);
  return e += parseInt(t.marginLeft, 10) + parseInt(t.marginRight, 10), e;
}
function c6(i) {
  let e = i.offsetHeight;
  const t = getComputedStyle(i);
  return e += parseInt(t.marginTop, 10) + parseInt(t.marginBottom, 10), e;
}
function pu(i, e) {
  const t = e.parentNode;
  t && t.replaceChild(i, e);
}
function wm(i) {
  return i && i.parentNode ? i.parentNode.removeChild(i) : null;
}
function JR(i) {
  for (; i.lastChild; )
    i.removeChild(i.lastChild);
}
function u6(i, e) {
  const t = i.childNodes;
  for (let r = 0; ; ++r) {
    const n = t[r], s = e[r];
    if (!n && !s)
      break;
    if (n !== s) {
      if (!n) {
        i.appendChild(s);
        continue;
      }
      if (!s) {
        i.removeChild(n), --r;
        continue;
      }
      i.insertBefore(s, n);
    }
  }
}
const eM = "10px sans-serif", Go = "#000", xm = "round", Id = [], Rd = 0, mu = "round", Md = 10, Nd = "#000", Pd = "center", Cm = "middle", zl = [0, 0, 0, 0], Od = 1, Ro = new ws();
let Cc = null, Hw;
const Gw = {}, f6 = function() {
  const e = "32px ", t = ["monospace", "serif"], r = t.length, n = "wmytzilWMYTZIL@#/&?$%10";
  let s, a;
  function o(l, h, c) {
    let u = !0;
    for (let f = 0; f < r; ++f) {
      const g = t[f];
      if (a = Em(
        l + " " + h + " " + e + g,
        n
      ), c != g) {
        const p = Em(
          l + " " + h + " " + e + c + "," + g,
          n
        );
        u = u && p != a;
      }
    }
    return !!u;
  }
  function A() {
    let l = !0;
    const h = Ro.getKeys();
    for (let c = 0, u = h.length; c < u; ++c) {
      const f = h[c];
      Ro.get(f) < 100 && (o.apply(this, f.split(`
`)) ? (Bh(Gw), Cc = null, Hw = void 0, Ro.set(f, 100)) : (Ro.set(f, Ro.get(f) + 1, !0), l = !1));
    }
    l && (clearInterval(s), s = void 0);
  }
  return function(l) {
    const h = ZR(l);
    if (!h)
      return;
    const c = h.families;
    for (let u = 0, f = c.length; u < f; ++u) {
      const g = c[u], p = h.style + `
` + h.weight + `
` + g;
      Ro.get(p) === void 0 && (Ro.set(p, 100, !0), o(h.style, h.weight, g) || (Ro.set(p, 0, !0), s === void 0 && (s = setInterval(A, 32))));
    }
  };
}(), d6 = function() {
  let i;
  return function(e) {
    let t = Gw[e];
    if (t == null) {
      if (rE) {
        const r = ZR(e), n = tM(e, "g");
        t = (isNaN(Number(r.lineHeight)) ? 1.2 : Number(r.lineHeight)) * (n.actualBoundingBoxAscent + n.actualBoundingBoxDescent);
      } else
        i || (i = document.createElement("div"), i.innerHTML = "M", i.style.minHeight = "0", i.style.maxHeight = "none", i.style.height = "auto", i.style.padding = "0", i.style.border = "none", i.style.position = "absolute", i.style.display = "block", i.style.left = "-99999px"), i.style.font = e, document.body.appendChild(i), t = i.offsetHeight, document.body.removeChild(i);
      Gw[e] = t;
    }
    return t;
  };
}();
function tM(i, e) {
  return Cc || (Cc = Ii(1, 1)), i != Hw && (Cc.font = i, Hw = Cc.font), Cc.measureText(e);
}
function Em(i, e) {
  return tM(i, e).width;
}
function DS(i, e, t) {
  if (e in t)
    return t[e];
  const r = e.split(`
`).reduce((n, s) => Math.max(n, Em(i, s)), 0);
  return t[e] = r, r;
}
function g6(i, e) {
  const t = [], r = [], n = [];
  let s = 0, a = 0, o = 0, A = 0;
  for (let l = 0, h = e.length; l <= h; l += 2) {
    const c = e[l];
    if (c === `
` || l === h) {
      s = Math.max(s, a), n.push(a), a = 0, o += A;
      continue;
    }
    const u = e[l + 1] || i.font, f = Em(u, c);
    t.push(f), a += f;
    const g = d6(u);
    r.push(g), A = Math.max(A, g);
  }
  return { width: s, height: o, widths: t, heights: r, lineWidths: n };
}
function p6(i, e, t, r, n, s, a, o, A, l, h) {
  i.save(), t !== 1 && (i.globalAlpha *= t), e && i.setTransform.apply(i, e), /** @type {*} */
  r.contextInstructions ? (i.translate(A, l), i.scale(h[0], h[1]), m6(
    /** @type {Label} */
    r,
    i
  )) : h[0] < 0 || h[1] < 0 ? (i.translate(A, l), i.scale(h[0], h[1]), i.drawImage(
    /** @type {HTMLCanvasElement|HTMLImageElement|HTMLVideoElement} */
    r,
    n,
    s,
    a,
    o,
    0,
    0,
    a,
    o
  )) : i.drawImage(
    /** @type {HTMLCanvasElement|HTMLImageElement|HTMLVideoElement} */
    r,
    n,
    s,
    a,
    o,
    A,
    l,
    a * h[0],
    o * h[1]
  ), i.restore();
}
function m6(i, e) {
  const t = i.contextInstructions;
  for (let r = 0, n = t.length; r < n; r += 2)
    Array.isArray(t[r + 1]) ? e[t[r]].apply(
      e,
      t[r + 1]
    ) : e[t[r]] = t[r + 1];
}
class v6 extends a6 {
  /**
   * @param {import("../Map.js").default} map Map.
   */
  constructor(e) {
    super(e), this.fontChangeListenerKey_ = St(
      Ro,
      fh.PROPERTYCHANGE,
      e.redrawText.bind(e)
    ), this.element_ = document.createElement("div");
    const t = this.element_.style;
    t.position = "absolute", t.width = "100%", t.height = "100%", t.zIndex = "0", this.element_.className = Wa + " ol-layers";
    const r = e.getViewport();
    r.insertBefore(this.element_, r.firstChild || null), this.children_ = [], this.renderedVisible_ = !0;
  }
  /**
   * @param {import("../render/EventType.js").default} type Event type.
   * @param {import("../Map.js").FrameState} frameState Frame state.
   */
  dispatchRenderEvent(e, t) {
    const r = this.getMap();
    if (r.hasListener(e)) {
      const n = new ld(e, void 0, t);
      r.dispatchEvent(n);
    }
  }
  disposeInternal() {
    pr(this.fontChangeListenerKey_), this.element_.parentNode.removeChild(this.element_), super.disposeInternal();
  }
  /**
   * Render.
   * @param {?import("../Map.js").FrameState} frameState Frame state.
   */
  renderFrame(e) {
    if (!e) {
      this.renderedVisible_ && (this.element_.style.display = "none", this.renderedVisible_ = !1);
      return;
    }
    this.calculateMatrices2D(e), this.dispatchRenderEvent(ds.PRECOMPOSE, e);
    const t = e.layerStatesArray.sort(function(a, o) {
      return a.zIndex - o.zIndex;
    }), r = e.viewState;
    this.children_.length = 0;
    const n = [];
    let s = null;
    for (let a = 0, o = t.length; a < o; ++a) {
      const A = t[a];
      e.layerIndex = a;
      const l = A.layer, h = l.getSourceState();
      if (!LE(A, r) || h != "ready" && h != "undefined") {
        l.unrender();
        continue;
      }
      const c = l.render(e, s);
      c && (c !== s && (this.children_.push(c), s = c), "getDeclutter" in l && n.push(
        /** @type {import("../layer/BaseVector.js").default} */
        l
      ));
    }
    for (let a = n.length - 1; a >= 0; --a)
      n[a].renderDeclutter(e);
    u6(this.element_, this.children_), this.dispatchRenderEvent(ds.POSTCOMPOSE, e), this.renderedVisible_ || (this.element_.style.display = "", this.renderedVisible_ = !0), this.scheduleExpireIconCache(e);
  }
}
const y6 = v6;
class HA extends _s {
  /**
   * @param {EventType} type The event type.
   * @param {BaseLayer} layer The layer.
   */
  constructor(e, t) {
    super(e), this.layer = t;
  }
}
const R1 = {
  LAYERS: "layers"
};
class IE extends hE {
  /**
   * @param {Options} [options] Layer options.
   */
  constructor(e) {
    e = e || {};
    const t = (
      /** @type {Options} */
      Object.assign({}, e)
    );
    delete t.layers;
    let r = e.layers;
    super(t), this.on, this.once, this.un, this.layersListenerKeys_ = [], this.listenerKeys_ = {}, this.addChangeListener(R1.LAYERS, this.handleLayersChanged_), r ? Array.isArray(r) ? r = new Yi(r.slice(), { unique: !0 }) : lt(typeof /** @type {?} */
    r.getArray == "function", 43) : r = new Yi(void 0, { unique: !0 }), this.setLayers(r);
  }
  /**
   * @private
   */
  handleLayerChange_() {
    this.changed();
  }
  /**
   * @private
   */
  handleLayersChanged_() {
    this.layersListenerKeys_.forEach(pr), this.layersListenerKeys_.length = 0;
    const e = this.getLayers();
    this.layersListenerKeys_.push(
      St(e, Si.ADD, this.handleLayersAdd_, this),
      St(e, Si.REMOVE, this.handleLayersRemove_, this)
    );
    for (const r in this.listenerKeys_)
      this.listenerKeys_[r].forEach(pr);
    Bh(this.listenerKeys_);
    const t = e.getArray();
    for (let r = 0, n = t.length; r < n; r++) {
      const s = t[r];
      this.registerLayerListeners_(s), this.dispatchEvent(new HA("addlayer", s));
    }
    this.changed();
  }
  /**
   * @param {BaseLayer} layer The layer.
   */
  registerLayerListeners_(e) {
    const t = [
      St(
        e,
        fh.PROPERTYCHANGE,
        this.handleLayerChange_,
        this
      ),
      St(e, ut.CHANGE, this.handleLayerChange_, this)
    ];
    e instanceof IE && t.push(
      St(e, "addlayer", this.handleLayerGroupAdd_, this),
      St(e, "removelayer", this.handleLayerGroupRemove_, this)
    ), this.listenerKeys_[st(e)] = t;
  }
  /**
   * @param {GroupEvent} event The layer group event.
   */
  handleLayerGroupAdd_(e) {
    this.dispatchEvent(new HA("addlayer", e.layer));
  }
  /**
   * @param {GroupEvent} event The layer group event.
   */
  handleLayerGroupRemove_(e) {
    this.dispatchEvent(new HA("removelayer", e.layer));
  }
  /**
   * @param {import("../Collection.js").CollectionEvent<import("./Base.js").default>} collectionEvent CollectionEvent.
   * @private
   */
  handleLayersAdd_(e) {
    const t = e.element;
    this.registerLayerListeners_(t), this.dispatchEvent(new HA("addlayer", t)), this.changed();
  }
  /**
   * @param {import("../Collection.js").CollectionEvent<import("./Base.js").default>} collectionEvent CollectionEvent.
   * @private
   */
  handleLayersRemove_(e) {
    const t = e.element, r = st(t);
    this.listenerKeys_[r].forEach(pr), delete this.listenerKeys_[r], this.dispatchEvent(new HA("removelayer", t)), this.changed();
  }
  /**
   * Returns the {@link module:ol/Collection~Collection collection} of {@link module:ol/layer/Layer~Layer layers}
   * in this group.
   * @return {!Collection<import("./Base.js").default>} Collection of
   *   {@link module:ol/layer/Base~BaseLayer layers} that are part of this group.
   * @observable
   * @api
   */
  getLayers() {
    return (
      /** @type {!Collection<import("./Base.js").default>} */
      this.get(R1.LAYERS)
    );
  }
  /**
   * Set the {@link module:ol/Collection~Collection collection} of {@link module:ol/layer/Layer~Layer layers}
   * in this group.
   * @param {!Collection<import("./Base.js").default>} layers Collection of
   *   {@link module:ol/layer/Base~BaseLayer layers} that are part of this group.
   * @observable
   * @api
   */
  setLayers(e) {
    const t = this.getLayers();
    if (t) {
      const r = t.getArray();
      for (let n = 0, s = r.length; n < s; ++n)
        this.dispatchEvent(new HA("removelayer", r[n]));
    }
    this.set(R1.LAYERS, e);
  }
  /**
   * @param {Array<import("./Layer.js").default>} [array] Array of layers (to be modified in place).
   * @return {Array<import("./Layer.js").default>} Array of layers.
   */
  getLayersArray(e) {
    return e = e !== void 0 ? e : [], this.getLayers().forEach(function(t) {
      t.getLayersArray(e);
    }), e;
  }
  /**
   * Get the layer states list and use this groups z-index as the default
   * for all layers in this and nested groups, if it is unset at this point.
   * If dest is not provided and this group's z-index is undefined
   * 0 is used a the default z-index.
   * @param {Array<import("./Layer.js").State>} [dest] Optional list
   * of layer states (to be modified in place).
   * @return {Array<import("./Layer.js").State>} List of layer states.
   */
  getLayerStatesArray(e) {
    const t = e !== void 0 ? e : [], r = t.length;
    this.getLayers().forEach(function(a) {
      a.getLayerStatesArray(t);
    });
    const n = this.getLayerState();
    let s = n.zIndex;
    !e && n.zIndex === void 0 && (s = 0);
    for (let a = r, o = t.length; a < o; a++) {
      const A = t[a];
      A.opacity *= n.opacity, A.visible = A.visible && n.visible, A.maxResolution = Math.min(
        A.maxResolution,
        n.maxResolution
      ), A.minResolution = Math.max(
        A.minResolution,
        n.minResolution
      ), A.minZoom = Math.max(A.minZoom, n.minZoom), A.maxZoom = Math.min(A.maxZoom, n.maxZoom), n.extent !== void 0 && (A.extent !== void 0 ? A.extent = jn(
        A.extent,
        n.extent
      ) : A.extent = n.extent), A.zIndex === void 0 && (A.zIndex = s);
    }
    return t;
  }
  /**
   * @return {import("../source/Source.js").State} Source state.
   */
  getSourceState() {
    return "ready";
  }
}
const pg = IE;
class _6 extends _s {
  /**
   * @param {string} type Event type.
   * @param {import("./Map.js").default} map Map.
   * @param {?import("./Map.js").FrameState} [frameState] Frame state.
   */
  constructor(e, t, r) {
    super(e), this.map = t, this.frameState = r !== void 0 ? r : null;
  }
}
const Ec = _6;
class w6 extends Ec {
  /**
   * @param {string} type Event type.
   * @param {import("./Map.js").default} map Map.
   * @param {EVENT} originalEvent Original event.
   * @param {boolean} [dragging] Is the map currently being dragged?
   * @param {import("./Map.js").FrameState} [frameState] Frame state.
   * @param {Array<PointerEvent>} [activePointers] Active pointers.
   */
  constructor(e, t, r, n, s, a) {
    super(e, t, s), this.originalEvent = r, this.pixel_ = null, this.coordinate_ = null, this.dragging = n !== void 0 ? n : !1, this.activePointers = a;
  }
  /**
   * The map pixel relative to the viewport corresponding to the original event.
   * @type {import("./pixel.js").Pixel}
   * @api
   */
  get pixel() {
    return this.pixel_ || (this.pixel_ = this.map.getEventPixel(this.originalEvent)), this.pixel_;
  }
  set pixel(e) {
    this.pixel_ = e;
  }
  /**
   * The coordinate corresponding to the original browser event.  This will be in the user
   * projection if one is set.  Otherwise it will be in the view projection.
   * @type {import("./coordinate.js").Coordinate}
   * @api
   */
  get coordinate() {
    return this.coordinate_ || (this.coordinate_ = this.map.getCoordinateFromPixel(this.pixel)), this.coordinate_;
  }
  set coordinate(e) {
    this.coordinate_ = e;
  }
  /**
   * Prevents the default browser action.
   * See https://developer.mozilla.org/en-US/docs/Web/API/event.preventDefault.
   * @api
   */
  preventDefault() {
    super.preventDefault(), "preventDefault" in this.originalEvent && this.originalEvent.preventDefault();
  }
  /**
   * Prevents further propagation of the current event.
   * See https://developer.mozilla.org/en-US/docs/Web/API/event.stopPropagation.
   * @api
   */
  stopPropagation() {
    super.stopPropagation(), "stopPropagation" in this.originalEvent && this.originalEvent.stopPropagation();
  }
}
const No = w6, or = {
  /**
   * A true single click with no dragging and no double click. Note that this
   * event is delayed by 250 ms to ensure that it is not a double click.
   * @event module:ol/MapBrowserEvent~MapBrowserEvent#singleclick
   * @api
   */
  SINGLECLICK: "singleclick",
  /**
   * A click with no dragging. A double click will fire two of this.
   * @event module:ol/MapBrowserEvent~MapBrowserEvent#click
   * @api
   */
  CLICK: ut.CLICK,
  /**
   * A true double click, with no dragging.
   * @event module:ol/MapBrowserEvent~MapBrowserEvent#dblclick
   * @api
   */
  DBLCLICK: ut.DBLCLICK,
  /**
   * Triggered when a pointer is dragged.
   * @event module:ol/MapBrowserEvent~MapBrowserEvent#pointerdrag
   * @api
   */
  POINTERDRAG: "pointerdrag",
  /**
   * Triggered when a pointer is moved. Note that on touch devices this is
   * triggered when the map is panned, so is not the same as mousemove.
   * @event module:ol/MapBrowserEvent~MapBrowserEvent#pointermove
   * @api
   */
  POINTERMOVE: "pointermove",
  POINTERDOWN: "pointerdown",
  POINTERUP: "pointerup",
  POINTEROVER: "pointerover",
  POINTEROUT: "pointerout",
  POINTERENTER: "pointerenter",
  POINTERLEAVE: "pointerleave",
  POINTERCANCEL: "pointercancel"
}, ka = {
  POINTERMOVE: "pointermove",
  POINTERDOWN: "pointerdown",
  POINTERUP: "pointerup",
  POINTEROVER: "pointerover",
  POINTEROUT: "pointerout",
  POINTERENTER: "pointerenter",
  POINTERLEAVE: "pointerleave",
  POINTERCANCEL: "pointercancel"
};
class x6 extends bu {
  /**
   * @param {import("./Map.js").default} map The map with the viewport to listen to events on.
   * @param {number} [moveTolerance] The minimal distance the pointer must travel to trigger a move.
   */
  constructor(e, t) {
    super(e), this.map_ = e, this.clickTimeoutId_, this.emulateClicks_ = !1, this.dragging_ = !1, this.dragListenerKeys_ = [], this.moveTolerance_ = t === void 0 ? 1 : t, this.down_ = null;
    const r = this.map_.getViewport();
    this.activePointers_ = [], this.trackedTouches_ = {}, this.element_ = r, this.pointerdownListenerKey_ = St(
      r,
      ka.POINTERDOWN,
      this.handlePointerDown_,
      this
    ), this.originalPointerMoveEvent_, this.relayedListenerKey_ = St(
      r,
      ka.POINTERMOVE,
      this.relayMoveEvent_,
      this
    ), this.boundHandleTouchMove_ = this.handleTouchMove_.bind(this), this.element_.addEventListener(
      ut.TOUCHMOVE,
      this.boundHandleTouchMove_,
      vR ? { passive: !1 } : !1
    );
  }
  /**
   * @param {PointerEvent} pointerEvent Pointer
   * event.
   * @private
   */
  emulateClick_(e) {
    let t = new No(
      or.CLICK,
      this.map_,
      e
    );
    this.dispatchEvent(t), this.clickTimeoutId_ !== void 0 ? (clearTimeout(this.clickTimeoutId_), this.clickTimeoutId_ = void 0, t = new No(
      or.DBLCLICK,
      this.map_,
      e
    ), this.dispatchEvent(t)) : this.clickTimeoutId_ = setTimeout(() => {
      this.clickTimeoutId_ = void 0;
      const r = new No(
        or.SINGLECLICK,
        this.map_,
        e
      );
      this.dispatchEvent(r);
    }, 250);
  }
  /**
   * Keeps track on how many pointers are currently active.
   *
   * @param {PointerEvent} pointerEvent Pointer
   * event.
   * @private
   */
  updateActivePointers_(e) {
    const t = e, r = t.pointerId;
    if (t.type == or.POINTERUP || t.type == or.POINTERCANCEL) {
      delete this.trackedTouches_[r];
      for (const n in this.trackedTouches_)
        if (this.trackedTouches_[n].target !== t.target) {
          delete this.trackedTouches_[n];
          break;
        }
    } else
      (t.type == or.POINTERDOWN || t.type == or.POINTERMOVE) && (this.trackedTouches_[r] = t);
    this.activePointers_ = Object.values(this.trackedTouches_);
  }
  /**
   * @param {PointerEvent} pointerEvent Pointer
   * event.
   * @private
   */
  handlePointerUp_(e) {
    this.updateActivePointers_(e);
    const t = new No(
      or.POINTERUP,
      this.map_,
      e,
      void 0,
      void 0,
      this.activePointers_
    );
    this.dispatchEvent(t), this.emulateClicks_ && !t.defaultPrevented && !this.dragging_ && this.isMouseActionButton_(e) && this.emulateClick_(this.down_), this.activePointers_.length === 0 && (this.dragListenerKeys_.forEach(pr), this.dragListenerKeys_.length = 0, this.dragging_ = !1, this.down_ = null);
  }
  /**
   * @param {PointerEvent} pointerEvent Pointer
   * event.
   * @return {boolean} If the left mouse button was pressed.
   * @private
   */
  isMouseActionButton_(e) {
    return e.button === 0;
  }
  /**
   * @param {PointerEvent} pointerEvent Pointer
   * event.
   * @private
   */
  handlePointerDown_(e) {
    this.emulateClicks_ = this.activePointers_.length === 0, this.updateActivePointers_(e);
    const t = new No(
      or.POINTERDOWN,
      this.map_,
      e,
      void 0,
      void 0,
      this.activePointers_
    );
    if (this.dispatchEvent(t), this.down_ = new PointerEvent(e.type, e), Object.defineProperty(this.down_, "target", {
      writable: !1,
      value: e.target
    }), this.dragListenerKeys_.length === 0) {
      const r = this.map_.getOwnerDocument();
      this.dragListenerKeys_.push(
        St(
          r,
          or.POINTERMOVE,
          this.handlePointerMove_,
          this
        ),
        St(r, or.POINTERUP, this.handlePointerUp_, this),
        /* Note that the listener for `pointercancel is set up on
         * `pointerEventHandler_` and not `documentPointerEventHandler_` like
         * the `pointerup` and `pointermove` listeners.
         *
         * The reason for this is the following: `TouchSource.vacuumTouches_()`
         * issues `pointercancel` events, when there was no `touchend` for a
         * `touchstart`. Now, let's say a first `touchstart` is registered on
         * `pointerEventHandler_`. The `documentPointerEventHandler_` is set up.
         * But `documentPointerEventHandler_` doesn't know about the first
         * `touchstart`. If there is no `touchend` for the `touchstart`, we can
         * only receive a `touchcancel` from `pointerEventHandler_`, because it is
         * only registered there.
         */
        St(
          this.element_,
          or.POINTERCANCEL,
          this.handlePointerUp_,
          this
        )
      ), this.element_.getRootNode && this.element_.getRootNode() !== r && this.dragListenerKeys_.push(
        St(
          this.element_.getRootNode(),
          or.POINTERUP,
          this.handlePointerUp_,
          this
        )
      );
    }
  }
  /**
   * @param {PointerEvent} pointerEvent Pointer
   * event.
   * @private
   */
  handlePointerMove_(e) {
    if (this.isMoving_(e)) {
      this.updateActivePointers_(e), this.dragging_ = !0;
      const t = new No(
        or.POINTERDRAG,
        this.map_,
        e,
        this.dragging_,
        void 0,
        this.activePointers_
      );
      this.dispatchEvent(t);
    }
  }
  /**
   * Wrap and relay a pointermove event.
   * @param {PointerEvent} pointerEvent Pointer
   * event.
   * @private
   */
  relayMoveEvent_(e) {
    this.originalPointerMoveEvent_ = e;
    const t = !!(this.down_ && this.isMoving_(e));
    this.dispatchEvent(
      new No(
        or.POINTERMOVE,
        this.map_,
        e,
        t
      )
    );
  }
  /**
   * Flexible handling of a `touch-action: none` css equivalent: because calling
   * `preventDefault()` on a `pointermove` event does not stop native page scrolling
   * and zooming, we also listen for `touchmove` and call `preventDefault()` on it
   * when an interaction (currently `DragPan` handles the event.
   * @param {TouchEvent} event Event.
   * @private
   */
  handleTouchMove_(e) {
    const t = this.originalPointerMoveEvent_;
    (!t || t.defaultPrevented) && (typeof e.cancelable != "boolean" || e.cancelable === !0) && e.preventDefault();
  }
  /**
   * @param {PointerEvent} pointerEvent Pointer
   * event.
   * @return {boolean} Is moving.
   * @private
   */
  isMoving_(e) {
    return this.dragging_ || Math.abs(e.clientX - this.down_.clientX) > this.moveTolerance_ || Math.abs(e.clientY - this.down_.clientY) > this.moveTolerance_;
  }
  /**
   * Clean up.
   */
  disposeInternal() {
    this.relayedListenerKey_ && (pr(this.relayedListenerKey_), this.relayedListenerKey_ = null), this.element_.removeEventListener(
      ut.TOUCHMOVE,
      this.boundHandleTouchMove_
    ), this.pointerdownListenerKey_ && (pr(this.pointerdownListenerKey_), this.pointerdownListenerKey_ = null), this.dragListenerKeys_.forEach(pr), this.dragListenerKeys_.length = 0, this.element_ = null, super.disposeInternal();
  }
}
const C6 = x6, Qa = {
  /**
   * Triggered after a map frame is rendered.
   * @event module:ol/MapEvent~MapEvent#postrender
   * @api
   */
  POSTRENDER: "postrender",
  /**
   * Triggered when the map starts moving.
   * @event module:ol/MapEvent~MapEvent#movestart
   * @api
   */
  MOVESTART: "movestart",
  /**
   * Triggered after the map is moved.
   * @event module:ol/MapEvent~MapEvent#moveend
   * @api
   */
  MOVEEND: "moveend",
  /**
   * Triggered when loading of additional map data (tiles, images, features) starts.
   * @event module:ol/MapEvent~MapEvent#loadstart
   * @api
   */
  LOADSTART: "loadstart",
  /**
   * Triggered when loading of additional map data has completed.
   * @event module:ol/MapEvent~MapEvent#loadend
   * @api
   */
  LOADEND: "loadend"
}, Pi = {
  LAYERGROUP: "layergroup",
  SIZE: "size",
  TARGET: "target",
  VIEW: "view"
}, Bm = 1 / 0;
class E6 {
  /**
   * @param {function(T): number} priorityFunction Priority function.
   * @param {function(T): string} keyFunction Key function.
   */
  constructor(e, t) {
    this.priorityFunction_ = e, this.keyFunction_ = t, this.elements_ = [], this.priorities_ = [], this.queuedElements_ = {};
  }
  /**
   * FIXME empty description for jsdoc
   */
  clear() {
    this.elements_.length = 0, this.priorities_.length = 0, Bh(this.queuedElements_);
  }
  /**
   * Remove and return the highest-priority element. O(log N).
   * @return {T} Element.
   */
  dequeue() {
    const e = this.elements_, t = this.priorities_, r = e[0];
    e.length == 1 ? (e.length = 0, t.length = 0) : (e[0] = e.pop(), t[0] = t.pop(), this.siftUp_(0));
    const n = this.keyFunction_(r);
    return delete this.queuedElements_[n], r;
  }
  /**
   * Enqueue an element. O(log N).
   * @param {T} element Element.
   * @return {boolean} The element was added to the queue.
   */
  enqueue(e) {
    lt(!(this.keyFunction_(e) in this.queuedElements_), 31);
    const t = this.priorityFunction_(e);
    return t != Bm ? (this.elements_.push(e), this.priorities_.push(t), this.queuedElements_[this.keyFunction_(e)] = !0, this.siftDown_(0, this.elements_.length - 1), !0) : !1;
  }
  /**
   * @return {number} Count.
   */
  getCount() {
    return this.elements_.length;
  }
  /**
   * Gets the index of the left child of the node at the given index.
   * @param {number} index The index of the node to get the left child for.
   * @return {number} The index of the left child.
   * @private
   */
  getLeftChildIndex_(e) {
    return e * 2 + 1;
  }
  /**
   * Gets the index of the right child of the node at the given index.
   * @param {number} index The index of the node to get the right child for.
   * @return {number} The index of the right child.
   * @private
   */
  getRightChildIndex_(e) {
    return e * 2 + 2;
  }
  /**
   * Gets the index of the parent of the node at the given index.
   * @param {number} index The index of the node to get the parent for.
   * @return {number} The index of the parent.
   * @private
   */
  getParentIndex_(e) {
    return e - 1 >> 1;
  }
  /**
   * Make this a heap. O(N).
   * @private
   */
  heapify_() {
    let e;
    for (e = (this.elements_.length >> 1) - 1; e >= 0; e--)
      this.siftUp_(e);
  }
  /**
   * @return {boolean} Is empty.
   */
  isEmpty() {
    return this.elements_.length === 0;
  }
  /**
   * @param {string} key Key.
   * @return {boolean} Is key queued.
   */
  isKeyQueued(e) {
    return e in this.queuedElements_;
  }
  /**
   * @param {T} element Element.
   * @return {boolean} Is queued.
   */
  isQueued(e) {
    return this.isKeyQueued(this.keyFunction_(e));
  }
  /**
   * @param {number} index The index of the node to move down.
   * @private
   */
  siftUp_(e) {
    const t = this.elements_, r = this.priorities_, n = t.length, s = t[e], a = r[e], o = e;
    for (; e < n >> 1; ) {
      const A = this.getLeftChildIndex_(e), l = this.getRightChildIndex_(e), h = l < n && r[l] < r[A] ? l : A;
      t[e] = t[h], r[e] = r[h], e = h;
    }
    t[e] = s, r[e] = a, this.siftDown_(o, e);
  }
  /**
   * @param {number} startIndex The index of the root.
   * @param {number} index The index of the node to move up.
   * @private
   */
  siftDown_(e, t) {
    const r = this.elements_, n = this.priorities_, s = r[t], a = n[t];
    for (; t > e; ) {
      const o = this.getParentIndex_(t);
      if (n[o] > a)
        r[t] = r[o], n[t] = n[o], t = o;
      else
        break;
    }
    r[t] = s, n[t] = a;
  }
  /**
   * FIXME empty description for jsdoc
   */
  reprioritize() {
    const e = this.priorityFunction_, t = this.elements_, r = this.priorities_;
    let n = 0;
    const s = t.length;
    let a, o, A;
    for (o = 0; o < s; ++o)
      a = t[o], A = e(a), A == Bm ? delete this.queuedElements_[this.keyFunction_(a)] : (r[n] = A, t[n++] = a);
    t.length = n, r.length = n, this.heapify_();
  }
}
const B6 = E6, He = {
  IDLE: 0,
  LOADING: 1,
  LOADED: 2,
  /**
   * Indicates that tile loading failed
   * @type {number}
   */
  ERROR: 3,
  EMPTY: 4
};
class b6 extends B6 {
  /**
   * @param {PriorityFunction} tilePriorityFunction Tile priority function.
   * @param {function(): ?} tileChangeCallback Function called on each tile change event.
   */
  constructor(e, t) {
    super(
      /**
       * @param {Array} element Element.
       * @return {number} Priority.
       */
      function(r) {
        return e.apply(null, r);
      },
      /**
       * @param {Array} element Element.
       * @return {string} Key.
       */
      function(r) {
        return (
          /** @type {import("./Tile.js").default} */
          r[0].getKey()
        );
      }
    ), this.boundHandleTileChange_ = this.handleTileChange.bind(this), this.tileChangeCallback_ = t, this.tilesLoading_ = 0, this.tilesLoadingKeys_ = {};
  }
  /**
   * @param {Array} element Element.
   * @return {boolean} The element was added to the queue.
   */
  enqueue(e) {
    const t = super.enqueue(e);
    return t && e[0].addEventListener(ut.CHANGE, this.boundHandleTileChange_), t;
  }
  /**
   * @return {number} Number of tiles loading.
   */
  getTilesLoading() {
    return this.tilesLoading_;
  }
  /**
   * @param {import("./events/Event.js").default} event Event.
   * @protected
   */
  handleTileChange(e) {
    const t = (
      /** @type {import("./Tile.js").default} */
      e.target
    ), r = t.getState();
    if (r === He.LOADED || r === He.ERROR || r === He.EMPTY) {
      r !== He.ERROR && t.removeEventListener(ut.CHANGE, this.boundHandleTileChange_);
      const n = t.getKey();
      n in this.tilesLoadingKeys_ && (delete this.tilesLoadingKeys_[n], --this.tilesLoading_), this.tileChangeCallback_();
    }
  }
  /**
   * @param {number} maxTotalLoading Maximum number tiles to load simultaneously.
   * @param {number} maxNewLoads Maximum number of new tiles to load.
   */
  loadMoreTiles(e, t) {
    let r = 0, n, s, a;
    for (; this.tilesLoading_ < e && r < t && this.getCount() > 0; )
      s = /** @type {import("./Tile.js").default} */
      this.dequeue()[0], a = s.getKey(), n = s.getState(), n === He.IDLE && !(a in this.tilesLoadingKeys_) && (this.tilesLoadingKeys_[a] = !0, ++this.tilesLoading_, ++r, s.load());
  }
}
const S6 = b6;
function T6(i, e, t, r, n) {
  if (!i || !(t in i.wantedTiles) || !i.wantedTiles[t][e.getKey()])
    return Bm;
  const s = i.viewState.center, a = r[0] - s[0], o = r[1] - s[1];
  return 65536 * Math.log(n) + Math.sqrt(a * a + o * o) / n;
}
let F6 = class extends ws {
  /**
   * @param {Options} options Control options.
   */
  constructor(e) {
    super();
    const t = e.element;
    t && !e.target && !t.style.pointerEvents && (t.style.pointerEvents = "auto"), this.element = t || null, this.target_ = null, this.map_ = null, this.listenerKeys = [], e.render && (this.render = e.render), e.target && this.setTarget(e.target);
  }
  /**
   * Clean up.
   */
  disposeInternal() {
    wm(this.element), super.disposeInternal();
  }
  /**
   * Get the map associated with this control.
   * @return {import("../Map.js").default|null} Map.
   * @api
   */
  getMap() {
    return this.map_;
  }
  /**
   * Remove the control from its current map and attach it to the new map.
   * Pass `null` to just remove the control from the current map.
   * Subclasses may set up event handlers to get notified about changes to
   * the map here.
   * @param {import("../Map.js").default|null} map Map.
   * @api
   */
  setMap(e) {
    this.map_ && wm(this.element);
    for (let t = 0, r = this.listenerKeys.length; t < r; ++t)
      pr(this.listenerKeys[t]);
    this.listenerKeys.length = 0, this.map_ = e, e && ((this.target_ ? this.target_ : e.getOverlayContainerStopEvent()).appendChild(this.element), this.render !== hu && this.listenerKeys.push(
      St(e, Qa.POSTRENDER, this.render, this)
    ), e.render());
  }
  /**
   * Renders the control.
   * @param {import("../MapEvent.js").default} mapEvent Map event.
   * @api
   */
  render(e) {
  }
  /**
   * This function is used to set a target element for the control. It has no
   * effect if it is called after the control has been added to the map (i.e.
   * after `setMap` is called on the control). If no `target` is set in the
   * options passed to the control constructor and if `setTarget` is not called
   * then the control is added to the map's overlay container.
   * @param {HTMLElement|string} target Target.
   * @api
   */
  setTarget(e) {
    this.target_ = typeof e == "string" ? document.getElementById(e) : e;
  }
};
const hn = F6;
class L6 extends hn {
  /**
   * @param {Options} [options] Attribution options.
   */
  constructor(e) {
    e = e || {}, super({
      element: document.createElement("div"),
      render: e.render,
      target: e.target
    }), this.ulElement_ = document.createElement("ul"), this.collapsed_ = e.collapsed !== void 0 ? e.collapsed : !0, this.userCollapsed_ = this.collapsed_, this.overrideCollapsible_ = e.collapsible !== void 0, this.collapsible_ = e.collapsible !== void 0 ? e.collapsible : !0, this.collapsible_ || (this.collapsed_ = !1);
    const t = e.className !== void 0 ? e.className : "ol-attribution", r = e.tipLabel !== void 0 ? e.tipLabel : "Attributions", n = e.expandClassName !== void 0 ? e.expandClassName : t + "-expand", s = e.collapseLabel !== void 0 ? e.collapseLabel : "", a = e.collapseClassName !== void 0 ? e.collapseClassName : t + "-collapse";
    typeof s == "string" ? (this.collapseLabel_ = document.createElement("span"), this.collapseLabel_.textContent = s, this.collapseLabel_.className = a) : this.collapseLabel_ = s;
    const o = e.label !== void 0 ? e.label : "i";
    typeof o == "string" ? (this.label_ = document.createElement("span"), this.label_.textContent = o, this.label_.className = n) : this.label_ = o;
    const A = this.collapsible_ && !this.collapsed_ ? this.collapseLabel_ : this.label_;
    this.toggleButton_ = document.createElement("button"), this.toggleButton_.setAttribute("type", "button"), this.toggleButton_.setAttribute("aria-expanded", String(!this.collapsed_)), this.toggleButton_.title = r, this.toggleButton_.appendChild(A), this.toggleButton_.addEventListener(
      ut.CLICK,
      this.handleClick_.bind(this),
      !1
    );
    const l = t + " " + Wa + " " + Sh + (this.collapsed_ && this.collapsible_ ? " " + _m : "") + (this.collapsible_ ? "" : " ol-uncollapsible"), h = this.element;
    h.className = l, h.appendChild(this.toggleButton_), h.appendChild(this.ulElement_), this.renderedAttributions_ = [], this.renderedVisible_ = !0;
  }
  /**
   * Collect a list of visible attributions and set the collapsible state.
   * @param {import("../Map.js").FrameState} frameState Frame state.
   * @return {Array<string>} Attributions.
   * @private
   */
  collectSourceAttributions_(e) {
    const t = Array.from(
      new Set(
        this.getMap().getAllLayers().flatMap((n) => n.getAttributions(e))
      )
    ), r = !this.getMap().getAllLayers().some(
      (n) => n.getSource() && n.getSource().getAttributionsCollapsible() === !1
    );
    return this.overrideCollapsible_ || this.setCollapsible(r), t;
  }
  /**
   * @private
   * @param {?import("../Map.js").FrameState} frameState Frame state.
   */
  updateElement_(e) {
    if (!e) {
      this.renderedVisible_ && (this.element.style.display = "none", this.renderedVisible_ = !1);
      return;
    }
    const t = this.collectSourceAttributions_(e), r = t.length > 0;
    if (this.renderedVisible_ != r && (this.element.style.display = r ? "" : "none", this.renderedVisible_ = r), !Za(t, this.renderedAttributions_)) {
      JR(this.ulElement_);
      for (let n = 0, s = t.length; n < s; ++n) {
        const a = document.createElement("li");
        a.innerHTML = t[n], this.ulElement_.appendChild(a);
      }
      this.renderedAttributions_ = t;
    }
  }
  /**
   * @param {MouseEvent} event The event to handle
   * @private
   */
  handleClick_(e) {
    e.preventDefault(), this.handleToggle_(), this.userCollapsed_ = this.collapsed_;
  }
  /**
   * @private
   */
  handleToggle_() {
    this.element.classList.toggle(_m), this.collapsed_ ? pu(this.collapseLabel_, this.label_) : pu(this.label_, this.collapseLabel_), this.collapsed_ = !this.collapsed_, this.toggleButton_.setAttribute("aria-expanded", String(!this.collapsed_));
  }
  /**
   * Return `true` if the attribution is collapsible, `false` otherwise.
   * @return {boolean} True if the widget is collapsible.
   * @api
   */
  getCollapsible() {
    return this.collapsible_;
  }
  /**
   * Set whether the attribution should be collapsible.
   * @param {boolean} collapsible True if the widget is collapsible.
   * @api
   */
  setCollapsible(e) {
    this.collapsible_ !== e && (this.collapsible_ = e, this.element.classList.toggle("ol-uncollapsible"), this.userCollapsed_ && this.handleToggle_());
  }
  /**
   * Collapse or expand the attribution according to the passed parameter. Will
   * not do anything if the attribution isn't collapsible or if the current
   * collapsed state is already the one requested.
   * @param {boolean} collapsed True if the widget is collapsed.
   * @api
   */
  setCollapsed(e) {
    this.userCollapsed_ = e, !(!this.collapsible_ || this.collapsed_ === e) && this.handleToggle_();
  }
  /**
   * Return `true` when the attribution is currently collapsed or `false`
   * otherwise.
   * @return {boolean} True if the widget is collapsed.
   * @api
   */
  getCollapsed() {
    return this.collapsed_;
  }
  /**
   * Update the attribution element.
   * @param {import("../MapEvent.js").default} mapEvent Map event.
   * @override
   */
  render(e) {
    this.updateElement_(e.frameState);
  }
}
const rM = L6;
let I6 = class extends hn {
  /**
   * @param {Options} [options] Rotate options.
   */
  constructor(e) {
    e = e || {}, super({
      element: document.createElement("div"),
      render: e.render,
      target: e.target
    });
    const t = e.className !== void 0 ? e.className : "ol-rotate", r = e.label !== void 0 ? e.label : "", n = e.compassClassName !== void 0 ? e.compassClassName : "ol-compass";
    this.label_ = null, typeof r == "string" ? (this.label_ = document.createElement("span"), this.label_.className = n, this.label_.textContent = r) : (this.label_ = r, this.label_.classList.add(n));
    const s = e.tipLabel ? e.tipLabel : "Reset rotation", a = document.createElement("button");
    a.className = t + "-reset", a.setAttribute("type", "button"), a.title = s, a.appendChild(this.label_), a.addEventListener(
      ut.CLICK,
      this.handleClick_.bind(this),
      !1
    );
    const o = t + " " + Wa + " " + Sh, A = this.element;
    A.className = o, A.appendChild(a), this.callResetNorth_ = e.resetNorth ? e.resetNorth : void 0, this.duration_ = e.duration !== void 0 ? e.duration : 250, this.autoHide_ = e.autoHide !== void 0 ? e.autoHide : !0, this.rotation_ = void 0, this.autoHide_ && this.element.classList.add(Tp);
  }
  /**
   * @param {MouseEvent} event The event to handle
   * @private
   */
  handleClick_(e) {
    e.preventDefault(), this.callResetNorth_ !== void 0 ? this.callResetNorth_() : this.resetNorth_();
  }
  /**
   * @private
   */
  resetNorth_() {
    const t = this.getMap().getView();
    if (!t)
      return;
    const r = t.getRotation();
    r !== void 0 && (this.duration_ > 0 && r % (2 * Math.PI) !== 0 ? t.animate({
      rotation: 0,
      duration: this.duration_,
      easing: ea
    }) : t.setRotation(0));
  }
  /**
   * Update the rotate control element.
   * @param {import("../MapEvent.js").default} mapEvent Map event.
   * @override
   */
  render(e) {
    const t = e.frameState;
    if (!t)
      return;
    const r = t.viewState.rotation;
    if (r != this.rotation_) {
      const n = "rotate(" + r + "rad)";
      if (this.autoHide_) {
        const s = this.element.classList.contains(Tp);
        !s && r === 0 ? this.element.classList.add(Tp) : s && r !== 0 && this.element.classList.remove(Tp);
      }
      this.label_.style.transform = n;
    }
    this.rotation_ = r;
  }
};
const iM = I6;
class R6 extends hn {
  /**
   * @param {Options} [options] Zoom options.
   */
  constructor(e) {
    e = e || {}, super({
      element: document.createElement("div"),
      target: e.target
    });
    const t = e.className !== void 0 ? e.className : "ol-zoom", r = e.delta !== void 0 ? e.delta : 1, n = e.zoomInClassName !== void 0 ? e.zoomInClassName : t + "-in", s = e.zoomOutClassName !== void 0 ? e.zoomOutClassName : t + "-out", a = e.zoomInLabel !== void 0 ? e.zoomInLabel : "+", o = e.zoomOutLabel !== void 0 ? e.zoomOutLabel : "", A = e.zoomInTipLabel !== void 0 ? e.zoomInTipLabel : "Zoom in", l = e.zoomOutTipLabel !== void 0 ? e.zoomOutTipLabel : "Zoom out", h = document.createElement("button");
    h.className = n, h.setAttribute("type", "button"), h.title = A, h.appendChild(
      typeof a == "string" ? document.createTextNode(a) : a
    ), h.addEventListener(
      ut.CLICK,
      this.handleClick_.bind(this, r),
      !1
    );
    const c = document.createElement("button");
    c.className = s, c.setAttribute("type", "button"), c.title = l, c.appendChild(
      typeof o == "string" ? document.createTextNode(o) : o
    ), c.addEventListener(
      ut.CLICK,
      this.handleClick_.bind(this, -r),
      !1
    );
    const u = t + " " + Wa + " " + Sh, f = this.element;
    f.className = u, f.appendChild(h), f.appendChild(c), this.duration_ = e.duration !== void 0 ? e.duration : 250;
  }
  /**
   * @param {number} delta Zoom delta.
   * @param {MouseEvent} event The event to handle
   * @private
   */
  handleClick_(e, t) {
    t.preventDefault(), this.zoomByDelta_(e);
  }
  /**
   * @param {number} delta Zoom delta.
   * @private
   */
  zoomByDelta_(e) {
    const r = this.getMap().getView();
    if (!r)
      return;
    const n = r.getZoom();
    if (n !== void 0) {
      const s = r.getConstrainedZoom(n + e);
      this.duration_ > 0 ? (r.getAnimating() && r.cancelAnimations(), r.animate({
        zoom: s,
        duration: this.duration_,
        easing: ea
      })) : r.setZoom(s);
    }
  }
}
const nM = R6;
function M6(i) {
  i = i || {};
  const e = new Yi();
  return (i.zoom !== void 0 ? i.zoom : !0) && e.push(new nM(i.zoomOptions)), (i.rotate !== void 0 ? i.rotate : !0) && e.push(new iM(i.rotateOptions)), (i.attribution !== void 0 ? i.attribution : !0) && e.push(new rM(i.attributionOptions)), e;
}
const $w = {
  ACTIVE: "active"
};
class N6 extends ws {
  /**
   * @param {InteractionOptions} [options] Options.
   */
  constructor(e) {
    super(), this.on, this.once, this.un, e && e.handleEvent && (this.handleEvent = e.handleEvent), this.map_ = null, this.setActive(!0);
  }
  /**
   * Return whether the interaction is currently active.
   * @return {boolean} `true` if the interaction is active, `false` otherwise.
   * @observable
   * @api
   */
  getActive() {
    return (
      /** @type {boolean} */
      this.get($w.ACTIVE)
    );
  }
  /**
   * Get the map associated with this interaction.
   * @return {import("../Map.js").default|null} Map.
   * @api
   */
  getMap() {
    return this.map_;
  }
  /**
   * Handles the {@link module:ol/MapBrowserEvent~MapBrowserEvent map browser event}.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Map browser event.
   * @return {boolean} `false` to stop event propagation.
   * @api
   */
  handleEvent(e) {
    return !0;
  }
  /**
   * Activate or deactivate the interaction.
   * @param {boolean} active Active.
   * @observable
   * @api
   */
  setActive(e) {
    this.set($w.ACTIVE, e);
  }
  /**
   * Remove the interaction from its current map and attach it to the new map.
   * Subclasses may set up event handlers to get notified about changes to
   * the map here.
   * @param {import("../Map.js").default|null} map Map.
   */
  setMap(e) {
    this.map_ = e;
  }
}
function P6(i, e, t) {
  const r = i.getCenterInternal();
  if (r) {
    const n = [r[0] + e[0], r[1] + e[1]];
    i.animateInternal({
      duration: t !== void 0 ? t : 250,
      easing: _E,
      center: i.getConstrainedCenter(n)
    });
  }
}
function RE(i, e, t, r) {
  const n = i.getZoom();
  if (n === void 0)
    return;
  const s = i.getConstrainedZoom(n + e), a = i.getResolutionForZoom(s);
  i.getAnimating() && i.cancelAnimations(), i.animate({
    resolution: a,
    anchor: t,
    duration: r !== void 0 ? r : 250,
    easing: ea
  });
}
const Lu = N6;
class O6 extends Lu {
  /**
   * @param {Options} [options] Options.
   */
  constructor(e) {
    super(), e = e || {}, this.delta_ = e.delta ? e.delta : 1, this.duration_ = e.duration !== void 0 ? e.duration : 250;
  }
  /**
   * Handles the {@link module:ol/MapBrowserEvent~MapBrowserEvent map browser event} (if it was a
   * doubleclick) and eventually zooms the map.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Map browser event.
   * @return {boolean} `false` to stop event propagation.
   */
  handleEvent(e) {
    let t = !1;
    if (e.type == or.DBLCLICK) {
      const r = (
        /** @type {MouseEvent} */
        e.originalEvent
      ), n = e.map, s = e.coordinate, a = r.shiftKey ? -this.delta_ : this.delta_, o = n.getView();
      RE(o, a, s, this.duration_), r.preventDefault(), t = !0;
    }
    return !t;
  }
}
const U6 = O6;
class Q6 extends Lu {
  /**
   * @param {Options} [options] Options.
   */
  constructor(e) {
    e = e || {}, super(
      /** @type {import("./Interaction.js").InteractionOptions} */
      e
    ), e.handleDownEvent && (this.handleDownEvent = e.handleDownEvent), e.handleDragEvent && (this.handleDragEvent = e.handleDragEvent), e.handleMoveEvent && (this.handleMoveEvent = e.handleMoveEvent), e.handleUpEvent && (this.handleUpEvent = e.handleUpEvent), e.stopDown && (this.stopDown = e.stopDown), this.handlingDownUpSequence = !1, this.targetPointers = [];
  }
  /**
   * Returns the current number of pointers involved in the interaction,
   * e.g. `2` when two fingers are used.
   * @return {number} The number of pointers.
   * @api
   */
  getPointerCount() {
    return this.targetPointers.length;
  }
  /**
   * Handle pointer down events.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
   * @return {boolean} If the event was consumed.
   * @protected
   */
  handleDownEvent(e) {
    return !1;
  }
  /**
   * Handle pointer drag events.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
   * @protected
   */
  handleDragEvent(e) {
  }
  /**
   * Handles the {@link module:ol/MapBrowserEvent~MapBrowserEvent map browser event} and may call into
   * other functions, if event sequences like e.g. 'drag' or 'down-up' etc. are
   * detected.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Map browser event.
   * @return {boolean} `false` to stop event propagation.
   * @api
   */
  handleEvent(e) {
    if (!e.originalEvent)
      return !0;
    let t = !1;
    if (this.updateTrackedPointers_(e), this.handlingDownUpSequence) {
      if (e.type == or.POINTERDRAG)
        this.handleDragEvent(e), e.originalEvent.preventDefault();
      else if (e.type == or.POINTERUP) {
        const r = this.handleUpEvent(e);
        this.handlingDownUpSequence = r && this.targetPointers.length > 0;
      }
    } else if (e.type == or.POINTERDOWN) {
      const r = this.handleDownEvent(e);
      this.handlingDownUpSequence = r, t = this.stopDown(r);
    } else
      e.type == or.POINTERMOVE && this.handleMoveEvent(e);
    return !t;
  }
  /**
   * Handle pointer move events.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
   * @protected
   */
  handleMoveEvent(e) {
  }
  /**
   * Handle pointer up events.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
   * @return {boolean} If the event was consumed.
   * @protected
   */
  handleUpEvent(e) {
    return !1;
  }
  /**
   * This function is used to determine if "down" events should be propagated
   * to other interactions or should be stopped.
   * @param {boolean} handled Was the event handled by the interaction?
   * @return {boolean} Should the `down` event be stopped?
   */
  stopDown(e) {
    return e;
  }
  /**
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
   * @private
   */
  updateTrackedPointers_(e) {
    e.activePointers && (this.targetPointers = e.activePointers);
  }
}
function ME(i) {
  const e = i.length;
  let t = 0, r = 0;
  for (let n = 0; n < e; n++)
    t += i[n].clientX, r += i[n].clientY;
  return { clientX: t / e, clientY: r / e };
}
const eo = Q6;
function bm(i) {
  const e = arguments;
  return function(t) {
    let r = !0;
    for (let n = 0, s = e.length; n < s && (r = r && e[n](t), !!r); ++n)
      ;
    return r;
  };
}
const sM = function(i) {
  const e = (
    /** @type {KeyboardEvent|MouseEvent|TouchEvent} */
    i.originalEvent
  );
  return e.altKey && !(e.metaKey || e.ctrlKey) && !e.shiftKey;
}, aM = function(i) {
  const e = (
    /** @type {KeyboardEvent|MouseEvent|TouchEvent} */
    i.originalEvent
  );
  return e.altKey && !(e.metaKey || e.ctrlKey) && e.shiftKey;
}, oM = function(i) {
  const e = i.map.getTargetElement(), t = i.map.getOwnerDocument().activeElement;
  return e.contains(t);
}, NE = function(i) {
  return i.map.getTargetElement().hasAttribute("tabindex") ? oM(i) : !0;
}, Ud = Xo, D6 = function(i) {
  return i.type == or.CLICK;
}, PE = function(i) {
  const e = (
    /** @type {MouseEvent} */
    i.originalEvent
  );
  return e.button == 0 && !(OQ && pR && e.ctrlKey);
}, Sm = Eh, k6 = function(i) {
  return i.type == "pointermove";
}, Dv = function(i) {
  return i.type == or.SINGLECLICK;
}, H6 = function(i) {
  return i.type == or.DBLCLICK;
}, kv = function(i) {
  const e = (
    /** @type {KeyboardEvent|MouseEvent|TouchEvent} */
    i.originalEvent
  );
  return !e.altKey && !(e.metaKey || e.ctrlKey) && !e.shiftKey;
}, G6 = function(i) {
  const e = (
    /** @type {KeyboardEvent|MouseEvent|TouchEvent} */
    i.originalEvent
  );
  return !e.altKey && (pR ? e.metaKey : e.ctrlKey) && !e.shiftKey;
}, mg = function(i) {
  const e = (
    /** @type {KeyboardEvent|MouseEvent|TouchEvent} */
    i.originalEvent
  );
  return !e.altKey && !(e.metaKey || e.ctrlKey) && e.shiftKey;
}, OE = function(i) {
  const e = (
    /** @type {KeyboardEvent|MouseEvent|TouchEvent} */
    i.originalEvent
  ), t = (
    /** @type {Element} */
    e.target.tagName
  );
  return t !== "INPUT" && t !== "SELECT" && t !== "TEXTAREA" && // `isContentEditable` is only available on `HTMLElement`, but it may also be a
  // different type like `SVGElement`.
  // @ts-ignore
  !e.target.isContentEditable;
}, rh = function(i) {
  const e = (
    /** @type {import("../MapBrowserEvent").default} */
    i.originalEvent
  );
  return lt(e !== void 0, 56), e.pointerType == "mouse";
}, $6 = function(i) {
  const e = (
    /** @type {import("../MapBrowserEvent").default} */
    i.originalEvent
  );
  return lt(e !== void 0, 56), e.pointerType === "touch";
}, V6 = function(i) {
  const e = (
    /** @type {import("../MapBrowserEvent").default} */
    i.originalEvent
  );
  return lt(e !== void 0, 56), e.pointerType === "pen";
}, UE = function(i) {
  const e = (
    /** @type {import("../MapBrowserEvent").default} */
    i.originalEvent
  );
  return lt(e !== void 0, 56), e.isPrimary && e.button === 0;
}, K6 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  all: bm,
  altKeyOnly: sM,
  altShiftKeysOnly: aM,
  always: Ud,
  click: D6,
  doubleClick: H6,
  focus: oM,
  focusWithTabindex: NE,
  mouseActionButton: PE,
  mouseOnly: rh,
  never: Sm,
  noModifierKeys: kv,
  penOnly: V6,
  platformModifierKeyOnly: G6,
  pointerMove: k6,
  primaryAction: UE,
  shiftKeyOnly: mg,
  singleClick: Dv,
  targetNotEditable: OE,
  touchOnly: $6
}, Symbol.toStringTag, { value: "Module" }));
class j6 extends eo {
  /**
   * @param {Options} [options] Options.
   */
  constructor(e) {
    super({
      stopDown: Eh
    }), e = e || {}, this.kinetic_ = e.kinetic, this.lastCentroid = null, this.lastPointersCount_, this.panning_ = !1;
    const t = e.condition ? e.condition : bm(kv, UE);
    this.condition_ = e.onFocusOnly ? bm(NE, t) : t, this.noKinetic_ = !1;
  }
  /**
   * Handle pointer drag events.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
   */
  handleDragEvent(e) {
    const t = e.map;
    this.panning_ || (this.panning_ = !0, t.getView().beginInteraction());
    const r = this.targetPointers, n = t.getEventPixel(ME(r));
    if (r.length == this.lastPointersCount_) {
      if (this.kinetic_ && this.kinetic_.update(n[0], n[1]), this.lastCentroid) {
        const s = [
          this.lastCentroid[0] - n[0],
          n[1] - this.lastCentroid[1]
        ], o = e.map.getView();
        PR(s, o.getResolution()), fE(s, o.getRotation()), o.adjustCenterInternal(s);
      }
    } else
      this.kinetic_ && this.kinetic_.begin();
    this.lastCentroid = n, this.lastPointersCount_ = r.length, e.originalEvent.preventDefault();
  }
  /**
   * Handle pointer up events.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
   * @return {boolean} If the event was consumed.
   */
  handleUpEvent(e) {
    const t = e.map, r = t.getView();
    if (this.targetPointers.length === 0) {
      if (!this.noKinetic_ && this.kinetic_ && this.kinetic_.end()) {
        const n = this.kinetic_.getDistance(), s = this.kinetic_.getAngle(), a = r.getCenterInternal(), o = t.getPixelFromCoordinateInternal(a), A = t.getCoordinateFromPixelInternal([
          o[0] - n * Math.cos(s),
          o[1] - n * Math.sin(s)
        ]);
        r.animateInternal({
          center: r.getConstrainedCenter(A),
          duration: 500,
          easing: ea
        });
      }
      return this.panning_ && (this.panning_ = !1, r.endInteraction()), !1;
    }
    return this.kinetic_ && this.kinetic_.begin(), this.lastCentroid = null, !0;
  }
  /**
   * Handle pointer down events.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
   * @return {boolean} If the event was consumed.
   */
  handleDownEvent(e) {
    if (this.targetPointers.length > 0 && this.condition_(e)) {
      const r = e.map.getView();
      return this.lastCentroid = null, r.getAnimating() && r.cancelAnimations(), this.kinetic_ && this.kinetic_.begin(), this.noKinetic_ = this.targetPointers.length > 1, !0;
    }
    return !1;
  }
}
const z6 = j6;
class X6 extends eo {
  /**
   * @param {Options} [options] Options.
   */
  constructor(e) {
    e = e || {}, super({
      stopDown: Eh
    }), this.condition_ = e.condition ? e.condition : aM, this.lastAngle_ = void 0, this.duration_ = e.duration !== void 0 ? e.duration : 250;
  }
  /**
   * Handle pointer drag events.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
   */
  handleDragEvent(e) {
    if (!rh(e))
      return;
    const t = e.map, r = t.getView();
    if (r.getConstraints().rotation === vE)
      return;
    const n = t.getSize(), s = e.pixel, a = Math.atan2(n[1] / 2 - s[1], s[0] - n[0] / 2);
    if (this.lastAngle_ !== void 0) {
      const o = a - this.lastAngle_;
      r.adjustRotationInternal(-o);
    }
    this.lastAngle_ = a;
  }
  /**
   * Handle pointer up events.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
   * @return {boolean} If the event was consumed.
   */
  handleUpEvent(e) {
    return rh(e) ? (e.map.getView().endInteraction(this.duration_), !1) : !0;
  }
  /**
   * Handle pointer down events.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
   * @return {boolean} If the event was consumed.
   */
  handleDownEvent(e) {
    return rh(e) && PE(e) && this.condition_(e) ? (e.map.getView().beginInteraction(), this.lastAngle_ = void 0, !0) : !1;
  }
}
const W6 = X6;
class Y6 extends Fv {
  /**
   * @param {string} className CSS class name.
   */
  constructor(e) {
    super(), this.geometry_ = null, this.element_ = document.createElement("div"), this.element_.style.position = "absolute", this.element_.style.pointerEvents = "auto", this.element_.className = "ol-box " + e, this.map_ = null, this.startPixel_ = null, this.endPixel_ = null;
  }
  /**
   * Clean up.
   */
  disposeInternal() {
    this.setMap(null);
  }
  /**
   * @private
   */
  render_() {
    const e = this.startPixel_, t = this.endPixel_, r = "px", n = this.element_.style;
    n.left = Math.min(e[0], t[0]) + r, n.top = Math.min(e[1], t[1]) + r, n.width = Math.abs(t[0] - e[0]) + r, n.height = Math.abs(t[1] - e[1]) + r;
  }
  /**
   * @param {import("../Map.js").default|null} map Map.
   */
  setMap(e) {
    if (this.map_) {
      this.map_.getOverlayContainer().removeChild(this.element_);
      const t = this.element_.style;
      t.left = "inherit", t.top = "inherit", t.width = "inherit", t.height = "inherit";
    }
    this.map_ = e, this.map_ && this.map_.getOverlayContainer().appendChild(this.element_);
  }
  /**
   * @param {import("../pixel.js").Pixel} startPixel Start pixel.
   * @param {import("../pixel.js").Pixel} endPixel End pixel.
   */
  setPixels(e, t) {
    this.startPixel_ = e, this.endPixel_ = t, this.createOrUpdateGeometry(), this.render_();
  }
  /**
   * Creates or updates the cached geometry.
   */
  createOrUpdateGeometry() {
    const e = this.startPixel_, t = this.endPixel_, n = [
      e,
      [e[0], t[1]],
      t,
      [t[0], e[1]]
    ].map(
      this.map_.getCoordinateFromPixelInternal,
      this.map_
    );
    n[4] = n[0].slice(), this.geometry_ ? this.geometry_.setCoordinates([n]) : this.geometry_ = new Li([n]);
  }
  /**
   * @return {import("../geom/Polygon.js").default} Geometry.
   */
  getGeometry() {
    return this.geometry_;
  }
}
const q6 = Y6, Fp = {
  /**
   * Triggered upon drag box start.
   * @event DragBoxEvent#boxstart
   * @api
   */
  BOXSTART: "boxstart",
  /**
   * Triggered on drag when box is active.
   * @event DragBoxEvent#boxdrag
   * @api
   */
  BOXDRAG: "boxdrag",
  /**
   * Triggered upon drag box end.
   * @event DragBoxEvent#boxend
   * @api
   */
  BOXEND: "boxend",
  /**
   * Triggered upon drag box canceled.
   * @event DragBoxEvent#boxcancel
   * @api
   */
  BOXCANCEL: "boxcancel"
};
class M1 extends _s {
  /**
   * @param {string} type The event type.
   * @param {import("../coordinate.js").Coordinate} coordinate The event coordinate.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Originating event.
   */
  constructor(e, t, r) {
    super(e), this.coordinate = t, this.mapBrowserEvent = r;
  }
}
class Z6 extends eo {
  /**
   * @param {Options} [options] Options.
   */
  constructor(e) {
    super(), this.on, this.once, this.un, e = e || {}, this.box_ = new q6(e.className || "ol-dragbox"), this.minArea_ = e.minArea !== void 0 ? e.minArea : 64, e.onBoxEnd && (this.onBoxEnd = e.onBoxEnd), this.startPixel_ = null, this.condition_ = e.condition ? e.condition : PE, this.boxEndCondition_ = e.boxEndCondition ? e.boxEndCondition : this.defaultBoxEndCondition;
  }
  /**
   * The default condition for determining whether the boxend event
   * should fire.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent The originating MapBrowserEvent
   *     leading to the box end.
   * @param {import("../pixel.js").Pixel} startPixel The starting pixel of the box.
   * @param {import("../pixel.js").Pixel} endPixel The end pixel of the box.
   * @return {boolean} Whether or not the boxend condition should be fired.
   */
  defaultBoxEndCondition(e, t, r) {
    const n = r[0] - t[0], s = r[1] - t[1];
    return n * n + s * s >= this.minArea_;
  }
  /**
   * Returns geometry of last drawn box.
   * @return {import("../geom/Polygon.js").default} Geometry.
   * @api
   */
  getGeometry() {
    return this.box_.getGeometry();
  }
  /**
   * Handle pointer drag events.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
   */
  handleDragEvent(e) {
    this.box_.setPixels(this.startPixel_, e.pixel), this.dispatchEvent(
      new M1(
        Fp.BOXDRAG,
        e.coordinate,
        e
      )
    );
  }
  /**
   * Handle pointer up events.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
   * @return {boolean} If the event was consumed.
   */
  handleUpEvent(e) {
    this.box_.setMap(null);
    const t = this.boxEndCondition_(
      e,
      this.startPixel_,
      e.pixel
    );
    return t && this.onBoxEnd(e), this.dispatchEvent(
      new M1(
        t ? Fp.BOXEND : Fp.BOXCANCEL,
        e.coordinate,
        e
      )
    ), !1;
  }
  /**
   * Handle pointer down events.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
   * @return {boolean} If the event was consumed.
   */
  handleDownEvent(e) {
    return this.condition_(e) ? (this.startPixel_ = e.pixel, this.box_.setMap(e.map), this.box_.setPixels(this.startPixel_, this.startPixel_), this.dispatchEvent(
      new M1(
        Fp.BOXSTART,
        e.coordinate,
        e
      )
    ), !0) : !1;
  }
  /**
   * Function to execute just before `onboxend` is fired
   * @param {import("../MapBrowserEvent.js").default} event Event.
   */
  onBoxEnd(e) {
  }
}
const J6 = Z6;
class e8 extends J6 {
  /**
   * @param {Options} [options] Options.
   */
  constructor(e) {
    e = e || {};
    const t = e.condition ? e.condition : mg;
    super({
      condition: t,
      className: e.className || "ol-dragzoom",
      minArea: e.minArea
    }), this.duration_ = e.duration !== void 0 ? e.duration : 200, this.out_ = e.out !== void 0 ? e.out : !1;
  }
  /**
   * Function to execute just before `onboxend` is fired
   * @param {import("../MapBrowserEvent.js").default} event Event.
   */
  onBoxEnd(e) {
    const r = (
      /** @type {!import("../View.js").default} */
      this.getMap().getView()
    );
    let n = this.getGeometry();
    if (this.out_) {
      const s = r.rotatedExtentForGeometry(n), a = r.getResolutionForExtentInternal(s), o = r.getResolution() / a;
      n = n.clone(), n.scale(o * o);
    }
    r.fitInternal(n, {
      duration: this.duration_,
      easing: ea
    });
  }
}
const t8 = e8, Rl = {
  LEFT: 37,
  UP: 38,
  RIGHT: 39,
  DOWN: 40
};
class r8 extends Lu {
  /**
   * @param {Options} [options] Options.
   */
  constructor(e) {
    super(), e = e || {}, this.defaultCondition_ = function(t) {
      return kv(t) && OE(t);
    }, this.condition_ = e.condition !== void 0 ? e.condition : this.defaultCondition_, this.duration_ = e.duration !== void 0 ? e.duration : 100, this.pixelDelta_ = e.pixelDelta !== void 0 ? e.pixelDelta : 128;
  }
  /**
   * Handles the {@link module:ol/MapBrowserEvent~MapBrowserEvent map browser event} if it was a
   * `KeyEvent`, and decides the direction to pan to (if an arrow key was
   * pressed).
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Map browser event.
   * @return {boolean} `false` to stop event propagation.
   */
  handleEvent(e) {
    let t = !1;
    if (e.type == ut.KEYDOWN) {
      const r = (
        /** @type {KeyboardEvent} */
        e.originalEvent
      ), n = r.keyCode;
      if (this.condition_(e) && (n == Rl.DOWN || n == Rl.LEFT || n == Rl.RIGHT || n == Rl.UP)) {
        const a = e.map.getView(), o = a.getResolution() * this.pixelDelta_;
        let A = 0, l = 0;
        n == Rl.DOWN ? l = -o : n == Rl.LEFT ? A = -o : n == Rl.RIGHT ? A = o : l = o;
        const h = [A, l];
        fE(h, a.getRotation()), P6(a, h, this.duration_), r.preventDefault(), t = !0;
      }
    }
    return !t;
  }
}
const i8 = r8;
class n8 extends Lu {
  /**
   * @param {Options} [options] Options.
   */
  constructor(e) {
    super(), e = e || {}, this.condition_ = e.condition ? e.condition : OE, this.delta_ = e.delta ? e.delta : 1, this.duration_ = e.duration !== void 0 ? e.duration : 100;
  }
  /**
   * Handles the {@link module:ol/MapBrowserEvent~MapBrowserEvent map browser event} if it was a
   * `KeyEvent`, and decides whether to zoom in or out (depending on whether the
   * key pressed was '+' or '-').
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Map browser event.
   * @return {boolean} `false` to stop event propagation.
   */
  handleEvent(e) {
    let t = !1;
    if (e.type == ut.KEYDOWN || e.type == ut.KEYPRESS) {
      const r = (
        /** @type {KeyboardEvent} */
        e.originalEvent
      ), n = r.key;
      if (this.condition_(e) && (n === "+" || n === "-")) {
        const s = e.map, a = n === "+" ? this.delta_ : -this.delta_, o = s.getView();
        RE(o, a, void 0, this.duration_), r.preventDefault(), t = !0;
      }
    }
    return !t;
  }
}
const s8 = n8;
class a8 {
  /**
   * @param {number} decay Rate of decay (must be negative).
   * @param {number} minVelocity Minimum velocity (pixels/millisecond).
   * @param {number} delay Delay to consider to calculate the kinetic
   *     initial values (milliseconds).
   */
  constructor(e, t, r) {
    this.decay_ = e, this.minVelocity_ = t, this.delay_ = r, this.points_ = [], this.angle_ = 0, this.initialVelocity_ = 0;
  }
  /**
   * FIXME empty description for jsdoc
   */
  begin() {
    this.points_.length = 0, this.angle_ = 0, this.initialVelocity_ = 0;
  }
  /**
   * @param {number} x X.
   * @param {number} y Y.
   */
  update(e, t) {
    this.points_.push(e, t, Date.now());
  }
  /**
   * @return {boolean} Whether we should do kinetic animation.
   */
  end() {
    if (this.points_.length < 6)
      return !1;
    const e = Date.now() - this.delay_, t = this.points_.length - 3;
    if (this.points_[t + 2] < e)
      return !1;
    let r = t - 3;
    for (; r > 0 && this.points_[r + 2] > e; )
      r -= 3;
    const n = this.points_[t + 2] - this.points_[r + 2];
    if (n < 1e3 / 60)
      return !1;
    const s = this.points_[t] - this.points_[r], a = this.points_[t + 1] - this.points_[r + 1];
    return this.angle_ = Math.atan2(a, s), this.initialVelocity_ = Math.sqrt(s * s + a * a) / n, this.initialVelocity_ > this.minVelocity_;
  }
  /**
   * @return {number} Total distance travelled (pixels).
   */
  getDistance() {
    return (this.minVelocity_ - this.initialVelocity_) / this.decay_;
  }
  /**
   * @return {number} Angle of the kinetic panning animation (radians).
   */
  getAngle() {
    return this.angle_;
  }
}
const o8 = a8;
class A8 extends Lu {
  /**
   * @param {Options} [options] Options.
   */
  constructor(e) {
    e = e || {}, super(
      /** @type {import("./Interaction.js").InteractionOptions} */
      e
    ), this.totalDelta_ = 0, this.lastDelta_ = 0, this.maxDelta_ = e.maxDelta !== void 0 ? e.maxDelta : 1, this.duration_ = e.duration !== void 0 ? e.duration : 250, this.timeout_ = e.timeout !== void 0 ? e.timeout : 80, this.useAnchor_ = e.useAnchor !== void 0 ? e.useAnchor : !0, this.constrainResolution_ = e.constrainResolution !== void 0 ? e.constrainResolution : !1;
    const t = e.condition ? e.condition : Ud;
    this.condition_ = e.onFocusOnly ? bm(NE, t) : t, this.lastAnchor_ = null, this.startTime_ = void 0, this.timeoutId_, this.mode_ = void 0, this.trackpadEventGap_ = 400, this.trackpadTimeoutId_, this.deltaPerZoom_ = 300;
  }
  /**
   * @private
   */
  endInteraction_() {
    this.trackpadTimeoutId_ = void 0;
    const e = this.getMap();
    if (!e)
      return;
    e.getView().endInteraction(
      void 0,
      this.lastDelta_ ? this.lastDelta_ > 0 ? 1 : -1 : 0,
      this.lastAnchor_
    );
  }
  /**
   * Handles the {@link module:ol/MapBrowserEvent~MapBrowserEvent map browser event} (if it was a mousewheel-event) and eventually
   * zooms the map.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Map browser event.
   * @return {boolean} `false` to stop event propagation.
   */
  handleEvent(e) {
    if (!this.condition_(e) || e.type !== ut.WHEEL)
      return !0;
    const r = e.map, n = (
      /** @type {WheelEvent} */
      e.originalEvent
    );
    n.preventDefault(), this.useAnchor_ && (this.lastAnchor_ = e.coordinate);
    let s;
    if (e.type == ut.WHEEL && (s = n.deltaY, MQ && n.deltaMode === WheelEvent.DOM_DELTA_PIXEL && (s /= mR), n.deltaMode === WheelEvent.DOM_DELTA_LINE && (s *= 40)), s === 0)
      return !1;
    this.lastDelta_ = s;
    const a = Date.now();
    this.startTime_ === void 0 && (this.startTime_ = a), (!this.mode_ || a - this.startTime_ > this.trackpadEventGap_) && (this.mode_ = Math.abs(s) < 4 ? "trackpad" : "wheel");
    const o = r.getView();
    if (this.mode_ === "trackpad" && !(o.getConstrainResolution() || this.constrainResolution_))
      return this.trackpadTimeoutId_ ? clearTimeout(this.trackpadTimeoutId_) : (o.getAnimating() && o.cancelAnimations(), o.beginInteraction()), this.trackpadTimeoutId_ = setTimeout(
        this.endInteraction_.bind(this),
        this.timeout_
      ), o.adjustZoom(-s / this.deltaPerZoom_, this.lastAnchor_), this.startTime_ = a, !1;
    this.totalDelta_ += s;
    const A = Math.max(this.timeout_ - (a - this.startTime_), 0);
    return clearTimeout(this.timeoutId_), this.timeoutId_ = setTimeout(
      this.handleWheelZoom_.bind(this, r),
      A
    ), !1;
  }
  /**
   * @private
   * @param {import("../Map.js").default} map Map.
   */
  handleWheelZoom_(e) {
    const t = e.getView();
    t.getAnimating() && t.cancelAnimations();
    let r = -jr(
      this.totalDelta_,
      -this.maxDelta_ * this.deltaPerZoom_,
      this.maxDelta_ * this.deltaPerZoom_
    ) / this.deltaPerZoom_;
    (t.getConstrainResolution() || this.constrainResolution_) && (r = r ? r > 0 ? 1 : -1 : 0), RE(t, r, this.lastAnchor_, this.duration_), this.mode_ = void 0, this.totalDelta_ = 0, this.lastAnchor_ = null, this.startTime_ = void 0, this.timeoutId_ = void 0;
  }
  /**
   * Enable or disable using the mouse's location as an anchor when zooming
   * @param {boolean} useAnchor true to zoom to the mouse's location, false
   * to zoom to the center of the map
   * @api
   */
  setMouseAnchor(e) {
    this.useAnchor_ = e, e || (this.lastAnchor_ = null);
  }
}
const l8 = A8;
class h8 extends eo {
  /**
   * @param {Options} [options] Options.
   */
  constructor(e) {
    e = e || {};
    const t = (
      /** @type {import("./Pointer.js").Options} */
      e
    );
    t.stopDown || (t.stopDown = Eh), super(t), this.anchor_ = null, this.lastAngle_ = void 0, this.rotating_ = !1, this.rotationDelta_ = 0, this.threshold_ = e.threshold !== void 0 ? e.threshold : 0.3, this.duration_ = e.duration !== void 0 ? e.duration : 250;
  }
  /**
   * Handle pointer drag events.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
   */
  handleDragEvent(e) {
    let t = 0;
    const r = this.targetPointers[0], n = this.targetPointers[1], s = Math.atan2(
      n.clientY - r.clientY,
      n.clientX - r.clientX
    );
    if (this.lastAngle_ !== void 0) {
      const A = s - this.lastAngle_;
      this.rotationDelta_ += A, !this.rotating_ && Math.abs(this.rotationDelta_) > this.threshold_ && (this.rotating_ = !0), t = A;
    }
    this.lastAngle_ = s;
    const a = e.map, o = a.getView();
    o.getConstraints().rotation !== vE && (this.anchor_ = a.getCoordinateFromPixelInternal(
      a.getEventPixel(ME(this.targetPointers))
    ), this.rotating_ && (a.render(), o.adjustRotationInternal(t, this.anchor_)));
  }
  /**
   * Handle pointer up events.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
   * @return {boolean} If the event was consumed.
   */
  handleUpEvent(e) {
    return this.targetPointers.length < 2 ? (e.map.getView().endInteraction(this.duration_), !1) : !0;
  }
  /**
   * Handle pointer down events.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
   * @return {boolean} If the event was consumed.
   */
  handleDownEvent(e) {
    if (this.targetPointers.length >= 2) {
      const t = e.map;
      return this.anchor_ = null, this.lastAngle_ = void 0, this.rotating_ = !1, this.rotationDelta_ = 0, this.handlingDownUpSequence || t.getView().beginInteraction(), !0;
    }
    return !1;
  }
}
const c8 = h8;
class u8 extends eo {
  /**
   * @param {Options} [options] Options.
   */
  constructor(e) {
    e = e || {};
    const t = (
      /** @type {import("./Pointer.js").Options} */
      e
    );
    t.stopDown || (t.stopDown = Eh), super(t), this.anchor_ = null, this.duration_ = e.duration !== void 0 ? e.duration : 400, this.lastDistance_ = void 0, this.lastScaleDelta_ = 1;
  }
  /**
   * Handle pointer drag events.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
   */
  handleDragEvent(e) {
    let t = 1;
    const r = this.targetPointers[0], n = this.targetPointers[1], s = r.clientX - n.clientX, a = r.clientY - n.clientY, o = Math.sqrt(s * s + a * a);
    this.lastDistance_ !== void 0 && (t = this.lastDistance_ / o), this.lastDistance_ = o;
    const A = e.map, l = A.getView();
    t != 1 && (this.lastScaleDelta_ = t), this.anchor_ = A.getCoordinateFromPixelInternal(
      A.getEventPixel(ME(this.targetPointers))
    ), A.render(), l.adjustResolutionInternal(t, this.anchor_);
  }
  /**
   * Handle pointer up events.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
   * @return {boolean} If the event was consumed.
   */
  handleUpEvent(e) {
    if (this.targetPointers.length < 2) {
      const r = e.map.getView(), n = this.lastScaleDelta_ > 1 ? 1 : -1;
      return r.endInteraction(this.duration_, n), !1;
    }
    return !0;
  }
  /**
   * Handle pointer down events.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
   * @return {boolean} If the event was consumed.
   */
  handleDownEvent(e) {
    if (this.targetPointers.length >= 2) {
      const t = e.map;
      return this.anchor_ = null, this.lastDistance_ = void 0, this.lastScaleDelta_ = 1, this.handlingDownUpSequence || t.getView().beginInteraction(), !0;
    }
    return !1;
  }
}
const f8 = u8;
function Vw(i) {
  i = i || {};
  const e = new Yi(), t = new o8(-5e-3, 0.05, 100);
  return (i.altShiftDragRotate !== void 0 ? i.altShiftDragRotate : !0) && e.push(new W6()), (i.doubleClickZoom !== void 0 ? i.doubleClickZoom : !0) && e.push(
    new U6({
      delta: i.zoomDelta,
      duration: i.zoomDuration
    })
  ), (i.dragPan !== void 0 ? i.dragPan : !0) && e.push(
    new z6({
      onFocusOnly: i.onFocusOnly,
      kinetic: t
    })
  ), (i.pinchRotate !== void 0 ? i.pinchRotate : !0) && e.push(new c8()), (i.pinchZoom !== void 0 ? i.pinchZoom : !0) && e.push(
    new f8({
      duration: i.zoomDuration
    })
  ), (i.keyboard !== void 0 ? i.keyboard : !0) && (e.push(new i8()), e.push(
    new s8({
      delta: i.zoomDelta,
      duration: i.zoomDuration
    })
  )), (i.mouseWheelZoom !== void 0 ? i.mouseWheelZoom : !0) && e.push(
    new l8({
      onFocusOnly: i.onFocusOnly,
      duration: i.zoomDuration
    })
  ), (i.shiftDragZoom !== void 0 ? i.shiftDragZoom : !0) && e.push(
    new t8({
      duration: i.zoomDuration
    })
  ), e;
}
function kS(i, e, t) {
  return t === void 0 && (t = [0, 0]), t[0] = i[0] + 2 * e, t[1] = i[1] + 2 * e, t;
}
function HS(i) {
  return i[0] > 0 && i[1] > 0;
}
function AM(i, e, t) {
  return t === void 0 && (t = [0, 0]), t[0] = i[0] * e + 0.5 | 0, t[1] = i[1] * e + 0.5 | 0, t;
}
function An(i, e) {
  return Array.isArray(i) ? i : (e === void 0 ? e = [i, i] : (e[0] = i, e[1] = i), e);
}
function lM(i) {
  if (i instanceof bh) {
    i.setMapInternal(null);
    return;
  }
  i instanceof pg && i.getLayers().forEach(lM);
}
function hM(i, e) {
  if (i instanceof bh) {
    i.setMapInternal(e);
    return;
  }
  if (i instanceof pg) {
    const t = i.getLayers().getArray();
    for (let r = 0, n = t.length; r < n; ++r)
      hM(t[r], e);
  }
}
let d8 = class extends ws {
  /**
   * @param {MapOptions} [options] Map options.
   */
  constructor(e) {
    super(), e = e || {}, this.on, this.once, this.un;
    const t = g8(e);
    this.renderComplete_, this.loaded_ = !0, this.boundHandleBrowserEvent_ = this.handleBrowserEvent.bind(this), this.maxTilesLoading_ = e.maxTilesLoading !== void 0 ? e.maxTilesLoading : 16, this.pixelRatio_ = e.pixelRatio !== void 0 ? e.pixelRatio : mR, this.postRenderTimeoutHandle_, this.animationDelayKey_, this.animationDelay_ = this.animationDelay_.bind(this), this.coordinateToPixelTransform_ = qi(), this.pixelToCoordinateTransform_ = qi(), this.frameIndex_ = 0, this.frameState_ = null, this.previousExtent_ = null, this.viewPropertyListenerKey_ = null, this.viewChangeListenerKey_ = null, this.layerGroupPropertyListenerKeys_ = null, this.viewport_ = document.createElement("div"), this.viewport_.className = "ol-viewport" + ("ontouchstart" in window ? " ol-touch" : ""), this.viewport_.style.position = "relative", this.viewport_.style.overflow = "hidden", this.viewport_.style.width = "100%", this.viewport_.style.height = "100%", this.overlayContainer_ = document.createElement("div"), this.overlayContainer_.style.position = "absolute", this.overlayContainer_.style.zIndex = "0", this.overlayContainer_.style.width = "100%", this.overlayContainer_.style.height = "100%", this.overlayContainer_.style.pointerEvents = "none", this.overlayContainer_.className = "ol-overlaycontainer", this.viewport_.appendChild(this.overlayContainer_), this.overlayContainerStopEvent_ = document.createElement("div"), this.overlayContainerStopEvent_.style.position = "absolute", this.overlayContainerStopEvent_.style.zIndex = "0", this.overlayContainerStopEvent_.style.width = "100%", this.overlayContainerStopEvent_.style.height = "100%", this.overlayContainerStopEvent_.style.pointerEvents = "none", this.overlayContainerStopEvent_.className = "ol-overlaycontainer-stopevent", this.viewport_.appendChild(this.overlayContainerStopEvent_), this.mapBrowserEventHandler_ = null, this.moveTolerance_ = e.moveTolerance, this.keyboardEventTarget_ = t.keyboardEventTarget, this.targetChangeHandlerKeys_ = null, this.targetElement_ = null, this.resizeObserver_ = new ResizeObserver(() => this.updateSize()), this.controls = t.controls || M6(), this.interactions = t.interactions || Vw({
      onFocusOnly: !0
    }), this.overlays_ = t.overlays, this.overlayIdIndex_ = {}, this.renderer_ = null, this.postRenderFunctions_ = [], this.tileQueue_ = new S6(
      this.getTilePriority.bind(this),
      this.handleTileChange_.bind(this)
    ), this.addChangeListener(
      Pi.LAYERGROUP,
      this.handleLayerGroupChanged_
    ), this.addChangeListener(Pi.VIEW, this.handleViewChanged_), this.addChangeListener(Pi.SIZE, this.handleSizeChanged_), this.addChangeListener(Pi.TARGET, this.handleTargetChanged_), this.setProperties(t.values);
    const r = this;
    e.view && !(e.view instanceof Ys) && e.view.then(function(n) {
      r.setView(new Ys(n));
    }), this.controls.addEventListener(
      Si.ADD,
      /**
       * @param {import("./Collection.js").CollectionEvent<import("./control/Control.js").default>} event CollectionEvent
       */
      (n) => {
        n.element.setMap(this);
      }
    ), this.controls.addEventListener(
      Si.REMOVE,
      /**
       * @param {import("./Collection.js").CollectionEvent<import("./control/Control.js").default>} event CollectionEvent.
       */
      (n) => {
        n.element.setMap(null);
      }
    ), this.interactions.addEventListener(
      Si.ADD,
      /**
       * @param {import("./Collection.js").CollectionEvent<import("./interaction/Interaction.js").default>} event CollectionEvent.
       */
      (n) => {
        n.element.setMap(this);
      }
    ), this.interactions.addEventListener(
      Si.REMOVE,
      /**
       * @param {import("./Collection.js").CollectionEvent<import("./interaction/Interaction.js").default>} event CollectionEvent.
       */
      (n) => {
        n.element.setMap(null);
      }
    ), this.overlays_.addEventListener(
      Si.ADD,
      /**
       * @param {import("./Collection.js").CollectionEvent<import("./Overlay.js").default>} event CollectionEvent.
       */
      (n) => {
        this.addOverlayInternal_(n.element);
      }
    ), this.overlays_.addEventListener(
      Si.REMOVE,
      /**
       * @param {import("./Collection.js").CollectionEvent<import("./Overlay.js").default>} event CollectionEvent.
       */
      (n) => {
        const s = n.element.getId();
        s !== void 0 && delete this.overlayIdIndex_[s.toString()], n.element.setMap(null);
      }
    ), this.controls.forEach(
      /**
       * @param {import("./control/Control.js").default} control Control.
       */
      (n) => {
        n.setMap(this);
      }
    ), this.interactions.forEach(
      /**
       * @param {import("./interaction/Interaction.js").default} interaction Interaction.
       */
      (n) => {
        n.setMap(this);
      }
    ), this.overlays_.forEach(this.addOverlayInternal_.bind(this));
  }
  /**
   * Add the given control to the map.
   * @param {import("./control/Control.js").default} control Control.
   * @api
   */
  addControl(e) {
    this.getControls().push(e);
  }
  /**
   * Add the given interaction to the map. If you want to add an interaction
   * at another point of the collection use `getInteractions()` and the methods
   * available on {@link module:ol/Collection~Collection}. This can be used to
   * stop the event propagation from the handleEvent function. The interactions
   * get to handle the events in the reverse order of this collection.
   * @param {import("./interaction/Interaction.js").default} interaction Interaction to add.
   * @api
   */
  addInteraction(e) {
    this.getInteractions().push(e);
  }
  /**
   * Adds the given layer to the top of this map. If you want to add a layer
   * elsewhere in the stack, use `getLayers()` and the methods available on
   * {@link module:ol/Collection~Collection}.
   * @param {import("./layer/Base.js").default} layer Layer.
   * @api
   */
  addLayer(e) {
    this.getLayerGroup().getLayers().push(e);
  }
  /**
   * @param {import("./layer/Group.js").GroupEvent} event The layer add event.
   * @private
   */
  handleLayerAdd_(e) {
    hM(e.layer, this);
  }
  /**
   * Add the given overlay to the map.
   * @param {import("./Overlay.js").default} overlay Overlay.
   * @api
   */
  addOverlay(e) {
    this.getOverlays().push(e);
  }
  /**
   * This deals with map's overlay collection changes.
   * @param {import("./Overlay.js").default} overlay Overlay.
   * @private
   */
  addOverlayInternal_(e) {
    const t = e.getId();
    t !== void 0 && (this.overlayIdIndex_[t.toString()] = e), e.setMap(this);
  }
  /**
   *
   * Clean up.
   */
  disposeInternal() {
    this.controls.clear(), this.interactions.clear(), this.overlays_.clear(), this.resizeObserver_.disconnect(), this.setTarget(null), super.disposeInternal();
  }
  /**
   * Detect features that intersect a pixel on the viewport, and execute a
   * callback with each intersecting feature. Layers included in the detection can
   * be configured through the `layerFilter` option in `options`.
   * @param {import("./pixel.js").Pixel} pixel Pixel.
   * @param {function(import("./Feature.js").FeatureLike, import("./layer/Layer.js").default<import("./source/Source").default>, import("./geom/SimpleGeometry.js").default): T} callback Feature callback. The callback will be
   *     called with two arguments. The first argument is one
   *     {@link module:ol/Feature~Feature feature} or
   *     {@link module:ol/render/Feature~RenderFeature render feature} at the pixel, the second is
   *     the {@link module:ol/layer/Layer~Layer layer} of the feature and will be null for
   *     unmanaged layers. To stop detection, callback functions can return a
   *     truthy value.
   * @param {AtPixelOptions} [options] Optional options.
   * @return {T|undefined} Callback result, i.e. the return value of last
   * callback execution, or the first truthy callback return value.
   * @template T
   * @api
   */
  forEachFeatureAtPixel(e, t, r) {
    if (!this.frameState_ || !this.renderer_)
      return;
    const n = this.getCoordinateFromPixelInternal(e);
    r = r !== void 0 ? r : {};
    const s = r.hitTolerance !== void 0 ? r.hitTolerance : 0, a = r.layerFilter !== void 0 ? r.layerFilter : Xo, o = r.checkWrapped !== !1;
    return this.renderer_.forEachFeatureAtCoordinate(
      n,
      this.frameState_,
      s,
      o,
      t,
      null,
      a,
      null
    );
  }
  /**
   * Get all features that intersect a pixel on the viewport.
   * @param {import("./pixel.js").Pixel} pixel Pixel.
   * @param {AtPixelOptions} [options] Optional options.
   * @return {Array<import("./Feature.js").FeatureLike>} The detected features or
   * an empty array if none were found.
   * @api
   */
  getFeaturesAtPixel(e, t) {
    const r = [];
    return this.forEachFeatureAtPixel(
      e,
      function(n) {
        r.push(n);
      },
      t
    ), r;
  }
  /**
   * Get all layers from all layer groups.
   * @return {Array<import("./layer/Layer.js").default>} Layers.
   * @api
   */
  getAllLayers() {
    const e = [];
    function t(r) {
      r.forEach(function(n) {
        n instanceof pg ? t(n.getLayers()) : e.push(n);
      });
    }
    return t(this.getLayers()), e;
  }
  /**
   * Detect if features intersect a pixel on the viewport. Layers included in the
   * detection can be configured through the `layerFilter` option.
   * @param {import("./pixel.js").Pixel} pixel Pixel.
   * @param {AtPixelOptions} [options] Optional options.
   * @return {boolean} Is there a feature at the given pixel?
   * @api
   */
  hasFeatureAtPixel(e, t) {
    if (!this.frameState_ || !this.renderer_)
      return !1;
    const r = this.getCoordinateFromPixelInternal(e);
    t = t !== void 0 ? t : {};
    const n = t.layerFilter !== void 0 ? t.layerFilter : Xo, s = t.hitTolerance !== void 0 ? t.hitTolerance : 0, a = t.checkWrapped !== !1;
    return this.renderer_.hasFeatureAtCoordinate(
      r,
      this.frameState_,
      s,
      a,
      n,
      null
    );
  }
  /**
   * Returns the coordinate in user projection for a browser event.
   * @param {MouseEvent} event Event.
   * @return {import("./coordinate.js").Coordinate} Coordinate.
   * @api
   */
  getEventCoordinate(e) {
    return this.getCoordinateFromPixel(this.getEventPixel(e));
  }
  /**
   * Returns the coordinate in view projection for a browser event.
   * @param {MouseEvent} event Event.
   * @return {import("./coordinate.js").Coordinate} Coordinate.
   */
  getEventCoordinateInternal(e) {
    return this.getCoordinateFromPixelInternal(this.getEventPixel(e));
  }
  /**
   * Returns the map pixel position for a browser event relative to the viewport.
   * @param {UIEvent|{clientX: number, clientY: number}} event Event.
   * @return {import("./pixel.js").Pixel} Pixel.
   * @api
   */
  getEventPixel(e) {
    const r = this.viewport_.getBoundingClientRect(), n = this.getSize(), s = r.width / n[0], a = r.height / n[1], o = (
      //FIXME Are we really calling this with a TouchEvent anywhere?
      "changedTouches" in e ? (
        /** @type {TouchEvent} */
        e.changedTouches[0]
      ) : (
        /** @type {MouseEvent} */
        e
      )
    );
    return [
      (o.clientX - r.left) / s,
      (o.clientY - r.top) / a
    ];
  }
  /**
   * Get the target in which this map is rendered.
   * Note that this returns what is entered as an option or in setTarget:
   * if that was an element, it returns an element; if a string, it returns that.
   * @return {HTMLElement|string|undefined} The Element or id of the Element that the
   *     map is rendered in.
   * @observable
   * @api
   */
  getTarget() {
    return (
      /** @type {HTMLElement|string|undefined} */
      this.get(Pi.TARGET)
    );
  }
  /**
   * Get the DOM element into which this map is rendered. In contrast to
   * `getTarget` this method always return an `Element`, or `null` if the
   * map has no target.
   * @return {HTMLElement} The element that the map is rendered in.
   * @api
   */
  getTargetElement() {
    return this.targetElement_;
  }
  /**
   * Get the coordinate for a given pixel.  This returns a coordinate in the
   * user projection.
   * @param {import("./pixel.js").Pixel} pixel Pixel position in the map viewport.
   * @return {import("./coordinate.js").Coordinate} The coordinate for the pixel position.
   * @api
   */
  getCoordinateFromPixel(e) {
    return fu(
      this.getCoordinateFromPixelInternal(e),
      this.getView().getProjection()
    );
  }
  /**
   * Get the coordinate for a given pixel.  This returns a coordinate in the
   * map view projection.
   * @param {import("./pixel.js").Pixel} pixel Pixel position in the map viewport.
   * @return {import("./coordinate.js").Coordinate} The coordinate for the pixel position.
   */
  getCoordinateFromPixelInternal(e) {
    const t = this.frameState_;
    return t ? vi(t.pixelToCoordinateTransform, e.slice()) : null;
  }
  /**
   * Get the map controls. Modifying this collection changes the controls
   * associated with the map.
   * @return {Collection<import("./control/Control.js").default>} Controls.
   * @api
   */
  getControls() {
    return this.controls;
  }
  /**
   * Get the map overlays. Modifying this collection changes the overlays
   * associated with the map.
   * @return {Collection<import("./Overlay.js").default>} Overlays.
   * @api
   */
  getOverlays() {
    return this.overlays_;
  }
  /**
   * Get an overlay by its identifier (the value returned by overlay.getId()).
   * Note that the index treats string and numeric identifiers as the same. So
   * `map.getOverlayById(2)` will return an overlay with id `'2'` or `2`.
   * @param {string|number} id Overlay identifier.
   * @return {import("./Overlay.js").default} Overlay.
   * @api
   */
  getOverlayById(e) {
    const t = this.overlayIdIndex_[e.toString()];
    return t !== void 0 ? t : null;
  }
  /**
   * Get the map interactions. Modifying this collection changes the interactions
   * associated with the map.
   *
   * Interactions are used for e.g. pan, zoom and rotate.
   * @return {Collection<import("./interaction/Interaction.js").default>} Interactions.
   * @api
   */
  getInteractions() {
    return this.interactions;
  }
  /**
   * Get the layergroup associated with this map.
   * @return {LayerGroup} A layer group containing the layers in this map.
   * @observable
   * @api
   */
  getLayerGroup() {
    return (
      /** @type {LayerGroup} */
      this.get(Pi.LAYERGROUP)
    );
  }
  /**
   * Clear any existing layers and add layers to the map.
   * @param {Array<import("./layer/Base.js").default>|Collection<import("./layer/Base.js").default>} layers The layers to be added to the map.
   * @api
   */
  setLayers(e) {
    const t = this.getLayerGroup();
    if (e instanceof Yi) {
      t.setLayers(e);
      return;
    }
    const r = t.getLayers();
    r.clear(), r.extend(e);
  }
  /**
   * Get the collection of layers associated with this map.
   * @return {!Collection<import("./layer/Base.js").default>} Layers.
   * @api
   */
  getLayers() {
    return this.getLayerGroup().getLayers();
  }
  /**
   * @return {boolean} Layers have sources that are still loading.
   */
  getLoadingOrNotReady() {
    const e = this.getLayerGroup().getLayerStatesArray();
    for (let t = 0, r = e.length; t < r; ++t) {
      const n = e[t];
      if (!n.visible)
        continue;
      const s = n.layer.getRenderer();
      if (s && !s.ready)
        return !0;
      const a = n.layer.getSource();
      if (a && a.loading)
        return !0;
    }
    return !1;
  }
  /**
   * Get the pixel for a coordinate.  This takes a coordinate in the user
   * projection and returns the corresponding pixel.
   * @param {import("./coordinate.js").Coordinate} coordinate A map coordinate.
   * @return {import("./pixel.js").Pixel} A pixel position in the map viewport.
   * @api
   */
  getPixelFromCoordinate(e) {
    const t = ai(
      e,
      this.getView().getProjection()
    );
    return this.getPixelFromCoordinateInternal(t);
  }
  /**
   * Get the pixel for a coordinate.  This takes a coordinate in the map view
   * projection and returns the corresponding pixel.
   * @param {import("./coordinate.js").Coordinate} coordinate A map coordinate.
   * @return {import("./pixel.js").Pixel} A pixel position in the map viewport.
   */
  getPixelFromCoordinateInternal(e) {
    const t = this.frameState_;
    return t ? vi(
      t.coordinateToPixelTransform,
      e.slice(0, 2)
    ) : null;
  }
  /**
   * Get the map renderer.
   * @return {import("./renderer/Map.js").default|null} Renderer
   */
  getRenderer() {
    return this.renderer_;
  }
  /**
   * Get the size of this map.
   * @return {import("./size.js").Size|undefined} The size in pixels of the map in the DOM.
   * @observable
   * @api
   */
  getSize() {
    return (
      /** @type {import("./size.js").Size|undefined} */
      this.get(Pi.SIZE)
    );
  }
  /**
   * Get the view associated with this map. A view manages properties such as
   * center and resolution.
   * @return {View} The view that controls this map.
   * @observable
   * @api
   */
  getView() {
    return (
      /** @type {View} */
      this.get(Pi.VIEW)
    );
  }
  /**
   * Get the element that serves as the map viewport.
   * @return {HTMLElement} Viewport.
   * @api
   */
  getViewport() {
    return this.viewport_;
  }
  /**
   * Get the element that serves as the container for overlays.  Elements added to
   * this container will let mousedown and touchstart events through to the map,
   * so clicks and gestures on an overlay will trigger {@link module:ol/MapBrowserEvent~MapBrowserEvent}
   * events.
   * @return {!HTMLElement} The map's overlay container.
   */
  getOverlayContainer() {
    return this.overlayContainer_;
  }
  /**
   * Get the element that serves as a container for overlays that don't allow
   * event propagation. Elements added to this container won't let mousedown and
   * touchstart events through to the map, so clicks and gestures on an overlay
   * don't trigger any {@link module:ol/MapBrowserEvent~MapBrowserEvent}.
   * @return {!HTMLElement} The map's overlay container that stops events.
   */
  getOverlayContainerStopEvent() {
    return this.overlayContainerStopEvent_;
  }
  /**
   * @return {!Document} The document where the map is displayed.
   */
  getOwnerDocument() {
    const e = this.getTargetElement();
    return e ? e.ownerDocument : document;
  }
  /**
   * @param {import("./Tile.js").default} tile Tile.
   * @param {string} tileSourceKey Tile source key.
   * @param {import("./coordinate.js").Coordinate} tileCenter Tile center.
   * @param {number} tileResolution Tile resolution.
   * @return {number} Tile priority.
   */
  getTilePriority(e, t, r, n) {
    return T6(
      this.frameState_,
      e,
      t,
      r,
      n
    );
  }
  /**
   * @param {UIEvent} browserEvent Browser event.
   * @param {string} [type] Type.
   */
  handleBrowserEvent(e, t) {
    t = t || e.type;
    const r = new No(t, this, e);
    this.handleMapBrowserEvent(r);
  }
  /**
   * @param {MapBrowserEvent} mapBrowserEvent The event to handle.
   */
  handleMapBrowserEvent(e) {
    if (!this.frameState_)
      return;
    const t = (
      /** @type {PointerEvent} */
      e.originalEvent
    ), r = t.type;
    if (r === ka.POINTERDOWN || r === ut.WHEEL || r === ut.KEYDOWN) {
      const n = this.getOwnerDocument(), s = this.viewport_.getRootNode ? this.viewport_.getRootNode() : n, a = (
        /** @type {Node} */
        t.target
      );
      if (
        // Abort if the target is a child of the container for elements whose events are not meant
        // to be handled by map interactions.
        this.overlayContainerStopEvent_.contains(a) || // Abort if the event target is a child of the container that is no longer in the page.
        // It's possible for the target to no longer be in the page if it has been removed in an
        // event listener, this might happen in a Control that recreates it's content based on
        // user interaction either manually or via a render in something like https://reactjs.org/
        !(s === n ? n.documentElement : s).contains(a)
      )
        return;
    }
    if (e.frameState = this.frameState_, this.dispatchEvent(e) !== !1) {
      const n = this.getInteractions().getArray().slice();
      for (let s = n.length - 1; s >= 0; s--) {
        const a = n[s];
        if (a.getMap() !== this || !a.getActive() || !this.getTargetElement())
          continue;
        if (!a.handleEvent(e) || e.propagationStopped)
          break;
      }
    }
  }
  /**
   * @protected
   */
  handlePostRender() {
    const e = this.frameState_, t = this.tileQueue_;
    if (!t.isEmpty()) {
      let n = this.maxTilesLoading_, s = n;
      if (e) {
        const a = e.viewHints;
        if (a[ei.ANIMATING] || a[ei.INTERACTING]) {
          const o = Date.now() - e.time > 8;
          n = o ? 0 : 8, s = o ? 0 : 2;
        }
      }
      t.getTilesLoading() < n && (t.reprioritize(), t.loadMoreTiles(n, s));
    }
    e && this.renderer_ && !e.animate && (this.renderComplete_ === !0 ? (this.hasListener(ds.RENDERCOMPLETE) && this.renderer_.dispatchRenderEvent(
      ds.RENDERCOMPLETE,
      e
    ), this.loaded_ === !1 && (this.loaded_ = !0, this.dispatchEvent(
      new Ec(Qa.LOADEND, this, e)
    ))) : this.loaded_ === !0 && (this.loaded_ = !1, this.dispatchEvent(
      new Ec(Qa.LOADSTART, this, e)
    )));
    const r = this.postRenderFunctions_;
    for (let n = 0, s = r.length; n < s; ++n)
      r[n](this, e);
    r.length = 0;
  }
  /**
   * @private
   */
  handleSizeChanged_() {
    this.getView() && !this.getView().getAnimating() && this.getView().resolveConstraints(0), this.render();
  }
  /**
   * @private
   */
  handleTargetChanged_() {
    if (this.mapBrowserEventHandler_) {
      for (let r = 0, n = this.targetChangeHandlerKeys_.length; r < n; ++r)
        pr(this.targetChangeHandlerKeys_[r]);
      this.targetChangeHandlerKeys_ = null, this.viewport_.removeEventListener(
        ut.CONTEXTMENU,
        this.boundHandleBrowserEvent_
      ), this.viewport_.removeEventListener(
        ut.WHEEL,
        this.boundHandleBrowserEvent_
      ), this.mapBrowserEventHandler_.dispose(), this.mapBrowserEventHandler_ = null, wm(this.viewport_);
    }
    if (this.targetElement_) {
      this.resizeObserver_.unobserve(this.targetElement_);
      const r = this.targetElement_.getRootNode();
      r instanceof ShadowRoot && this.resizeObserver_.unobserve(r.host);
    }
    const e = this.getTarget(), t = typeof e == "string" ? document.getElementById(e) : e;
    if (this.targetElement_ = t, !t)
      this.renderer_ && (clearTimeout(this.postRenderTimeoutHandle_), this.postRenderTimeoutHandle_ = void 0, this.postRenderFunctions_.length = 0, this.renderer_.dispose(), this.renderer_ = null), this.animationDelayKey_ && (cancelAnimationFrame(this.animationDelayKey_), this.animationDelayKey_ = void 0);
    else {
      t.appendChild(this.viewport_), this.renderer_ || (this.renderer_ = new y6(this)), this.mapBrowserEventHandler_ = new C6(
        this,
        this.moveTolerance_
      );
      for (const s in or)
        this.mapBrowserEventHandler_.addEventListener(
          or[s],
          this.handleMapBrowserEvent.bind(this)
        );
      this.viewport_.addEventListener(
        ut.CONTEXTMENU,
        this.boundHandleBrowserEvent_,
        !1
      ), this.viewport_.addEventListener(
        ut.WHEEL,
        this.boundHandleBrowserEvent_,
        vR ? { passive: !1 } : !1
      );
      const r = this.keyboardEventTarget_ ? this.keyboardEventTarget_ : t;
      this.targetChangeHandlerKeys_ = [
        St(
          r,
          ut.KEYDOWN,
          this.handleBrowserEvent,
          this
        ),
        St(
          r,
          ut.KEYPRESS,
          this.handleBrowserEvent,
          this
        )
      ];
      const n = t.getRootNode();
      n instanceof ShadowRoot && this.resizeObserver_.observe(n.host), this.resizeObserver_.observe(t);
    }
    this.updateSize();
  }
  /**
   * @private
   */
  handleTileChange_() {
    this.render();
  }
  /**
   * @private
   */
  handleViewPropertyChanged_() {
    this.render();
  }
  /**
   * @private
   */
  handleViewChanged_() {
    this.viewPropertyListenerKey_ && (pr(this.viewPropertyListenerKey_), this.viewPropertyListenerKey_ = null), this.viewChangeListenerKey_ && (pr(this.viewChangeListenerKey_), this.viewChangeListenerKey_ = null);
    const e = this.getView();
    e && (this.updateViewportSize_(), this.viewPropertyListenerKey_ = St(
      e,
      fh.PROPERTYCHANGE,
      this.handleViewPropertyChanged_,
      this
    ), this.viewChangeListenerKey_ = St(
      e,
      ut.CHANGE,
      this.handleViewPropertyChanged_,
      this
    ), e.resolveConstraints(0)), this.render();
  }
  /**
   * @private
   */
  handleLayerGroupChanged_() {
    this.layerGroupPropertyListenerKeys_ && (this.layerGroupPropertyListenerKeys_.forEach(pr), this.layerGroupPropertyListenerKeys_ = null);
    const e = this.getLayerGroup();
    e && (this.handleLayerAdd_(new HA("addlayer", e)), this.layerGroupPropertyListenerKeys_ = [
      St(e, fh.PROPERTYCHANGE, this.render, this),
      St(e, ut.CHANGE, this.render, this),
      St(e, "addlayer", this.handleLayerAdd_, this),
      St(e, "removelayer", this.handleLayerRemove_, this)
    ]), this.render();
  }
  /**
   * @return {boolean} Is rendered.
   */
  isRendered() {
    return !!this.frameState_;
  }
  /**
   * @private
   */
  animationDelay_() {
    this.animationDelayKey_ = void 0, this.renderFrame_(Date.now());
  }
  /**
   * Requests an immediate render in a synchronous manner.
   * @api
   */
  renderSync() {
    this.animationDelayKey_ && cancelAnimationFrame(this.animationDelayKey_), this.animationDelay_();
  }
  /**
   * Redraws all text after new fonts have loaded
   */
  redrawText() {
    const e = this.getLayerGroup().getLayerStatesArray();
    for (let t = 0, r = e.length; t < r; ++t) {
      const n = e[t].layer;
      n.hasRenderer() && n.getRenderer().handleFontsChanged();
    }
  }
  /**
   * Request a map rendering (at the next animation frame).
   * @api
   */
  render() {
    this.renderer_ && this.animationDelayKey_ === void 0 && (this.animationDelayKey_ = requestAnimationFrame(this.animationDelay_));
  }
  /**
   * Remove the given control from the map.
   * @param {import("./control/Control.js").default} control Control.
   * @return {import("./control/Control.js").default|undefined} The removed control (or undefined
   *     if the control was not found).
   * @api
   */
  removeControl(e) {
    return this.getControls().remove(e);
  }
  /**
   * Remove the given interaction from the map.
   * @param {import("./interaction/Interaction.js").default} interaction Interaction to remove.
   * @return {import("./interaction/Interaction.js").default|undefined} The removed interaction (or
   *     undefined if the interaction was not found).
   * @api
   */
  removeInteraction(e) {
    return this.getInteractions().remove(e);
  }
  /**
   * Removes the given layer from the map.
   * @param {import("./layer/Base.js").default} layer Layer.
   * @return {import("./layer/Base.js").default|undefined} The removed layer (or undefined if the
   *     layer was not found).
   * @api
   */
  removeLayer(e) {
    return this.getLayerGroup().getLayers().remove(e);
  }
  /**
   * @param {import("./layer/Group.js").GroupEvent} event The layer remove event.
   * @private
   */
  handleLayerRemove_(e) {
    lM(e.layer);
  }
  /**
   * Remove the given overlay from the map.
   * @param {import("./Overlay.js").default} overlay Overlay.
   * @return {import("./Overlay.js").default|undefined} The removed overlay (or undefined
   *     if the overlay was not found).
   * @api
   */
  removeOverlay(e) {
    return this.getOverlays().remove(e);
  }
  /**
   * @param {number} time Time.
   * @private
   */
  renderFrame_(e) {
    const t = this.getSize(), r = this.getView(), n = this.frameState_;
    let s = null;
    if (t !== void 0 && HS(t) && r && r.isDef()) {
      const a = r.getHints(
        this.frameState_ ? this.frameState_.viewHints : void 0
      ), o = r.getState();
      if (s = {
        animate: !1,
        coordinateToPixelTransform: this.coordinateToPixelTransform_,
        declutterTree: null,
        extent: th(
          o.center,
          o.resolution,
          o.rotation,
          t
        ),
        index: this.frameIndex_++,
        layerIndex: 0,
        layerStatesArray: this.getLayerGroup().getLayerStatesArray(),
        pixelRatio: this.pixelRatio_,
        pixelToCoordinateTransform: this.pixelToCoordinateTransform_,
        postRenderFunctions: [],
        size: t,
        tileQueue: this.tileQueue_,
        time: e,
        usedTiles: {},
        viewState: o,
        viewHints: a,
        wantedTiles: {},
        mapId: st(this),
        renderTargets: {}
      }, o.nextCenter && o.nextResolution) {
        const A = isNaN(o.nextRotation) ? o.rotation : o.nextRotation;
        s.nextExtent = th(
          o.nextCenter,
          o.nextResolution,
          A,
          t
        );
      }
    }
    this.frameState_ = s, this.renderer_.renderFrame(s), s && (s.animate && this.render(), Array.prototype.push.apply(
      this.postRenderFunctions_,
      s.postRenderFunctions
    ), n && (!this.previousExtent_ || !Tu(this.previousExtent_) && !Xa(s.extent, this.previousExtent_)) && (this.dispatchEvent(
      new Ec(Qa.MOVESTART, this, n)
    ), this.previousExtent_ = _l(this.previousExtent_)), this.previousExtent_ && !s.viewHints[ei.ANIMATING] && !s.viewHints[ei.INTERACTING] && !Xa(s.extent, this.previousExtent_) && (this.dispatchEvent(
      new Ec(Qa.MOVEEND, this, s)
    ), sE(s.extent, this.previousExtent_))), this.dispatchEvent(new Ec(Qa.POSTRENDER, this, s)), this.renderComplete_ = this.hasListener(Qa.LOADSTART) || this.hasListener(Qa.LOADEND) || this.hasListener(ds.RENDERCOMPLETE) ? !this.tileQueue_.getTilesLoading() && !this.tileQueue_.getCount() && !this.getLoadingOrNotReady() : void 0, this.postRenderTimeoutHandle_ || (this.postRenderTimeoutHandle_ = setTimeout(() => {
      this.postRenderTimeoutHandle_ = void 0, this.handlePostRender();
    }, 0));
  }
  /**
   * Sets the layergroup of this map.
   * @param {LayerGroup} layerGroup A layer group containing the layers in this map.
   * @observable
   * @api
   */
  setLayerGroup(e) {
    const t = this.getLayerGroup();
    t && this.handleLayerRemove_(new HA("removelayer", t)), this.set(Pi.LAYERGROUP, e);
  }
  /**
   * Set the size of this map.
   * @param {import("./size.js").Size|undefined} size The size in pixels of the map in the DOM.
   * @observable
   * @api
   */
  setSize(e) {
    this.set(Pi.SIZE, e);
  }
  /**
   * Set the target element to render this map into.
   * @param {HTMLElement|string} [target] The Element or id of the Element
   *     that the map is rendered in.
   * @observable
   * @api
   */
  setTarget(e) {
    this.set(Pi.TARGET, e);
  }
  /**
   * Set the view for this map.
   * @param {View|Promise<import("./View.js").ViewOptions>} view The view that controls this map.
   * It is also possible to pass a promise that resolves to options for constructing a view.  This
   * alternative allows view properties to be resolved by sources or other components that load
   * view-related metadata.
   * @observable
   * @api
   */
  setView(e) {
    if (!e || e instanceof Ys) {
      this.set(Pi.VIEW, e);
      return;
    }
    this.set(Pi.VIEW, new Ys());
    const t = this;
    e.then(function(r) {
      t.setView(new Ys(r));
    });
  }
  /**
   * Force a recalculation of the map viewport size.  This should be called when
   * third-party code changes the size of the map viewport.
   * @api
   */
  updateSize() {
    const e = this.getTargetElement();
    let t;
    if (e) {
      const n = getComputedStyle(e), s = e.offsetWidth - parseFloat(n.borderLeftWidth) - parseFloat(n.paddingLeft) - parseFloat(n.paddingRight) - parseFloat(n.borderRightWidth), a = e.offsetHeight - parseFloat(n.borderTopWidth) - parseFloat(n.paddingTop) - parseFloat(n.paddingBottom) - parseFloat(n.borderBottomWidth);
      !isNaN(s) && !isNaN(a) && (t = [s, a], !HS(t) && (e.offsetWidth || e.offsetHeight || e.getClientRects().length) && DR(
        "No map visible because the map container's width or height are 0."
      ));
    }
    const r = this.getSize();
    t && (!r || !Za(t, r)) && (this.setSize(t), this.updateViewportSize_());
  }
  /**
   * Recomputes the viewport size and save it on the view object (if any)
   * @private
   */
  updateViewportSize_() {
    const e = this.getView();
    if (e) {
      let t;
      const r = getComputedStyle(this.viewport_);
      r.width && r.height && (t = [
        parseInt(r.width, 10),
        parseInt(r.height, 10)
      ]), e.setViewportSize(t);
    }
  }
};
function g8(i) {
  let e = null;
  i.keyboardEventTarget !== void 0 && (e = typeof i.keyboardEventTarget == "string" ? document.getElementById(i.keyboardEventTarget) : i.keyboardEventTarget);
  const t = {}, r = i.layers && typeof /** @type {?} */
  i.layers.getLayers == "function" ? (
    /** @type {LayerGroup} */
    i.layers
  ) : new pg({
    layers: (
      /** @type {Collection<import("./layer/Base.js").default>|Array<import("./layer/Base.js").default>} */
      i.layers
    )
  });
  t[Pi.LAYERGROUP] = r, t[Pi.TARGET] = i.target, t[Pi.VIEW] = i.view instanceof Ys ? i.view : new Ys();
  let n;
  i.controls !== void 0 && (Array.isArray(i.controls) ? n = new Yi(i.controls.slice()) : (lt(
    typeof /** @type {?} */
    i.controls.getArray == "function",
    47
  ), n = i.controls));
  let s;
  i.interactions !== void 0 && (Array.isArray(i.interactions) ? s = new Yi(i.interactions.slice()) : (lt(
    typeof /** @type {?} */
    i.interactions.getArray == "function",
    48
  ), s = i.interactions));
  let a;
  return i.overlays !== void 0 ? Array.isArray(i.overlays) ? a = new Yi(i.overlays.slice()) : (lt(
    typeof /** @type {?} */
    i.overlays.getArray == "function",
    49
  ), a = i.overlays) : a = new Yi(), {
    controls: n,
    interactions: s,
    keyboardEventTarget: e,
    overlays: a,
    values: t
  };
}
const vg = d8;
function sr(i, e = []) {
  let t = uh(i);
  Object.keys(t).forEach((n) => {
    t[n] = t[n].value;
  });
  const r = mQ({
    ...t
  });
  return at(i, () => {
    t = uh(i), Object.keys(t).forEach((n) => {
      r[n] != t[n].value && !e.includes(n) && (r[n] = t[n].value);
    });
  }), {
    properties: r
  };
}
const qe = (i, e) => {
  const t = i.__vccOpts || i;
  for (const [r, n] of e)
    t[r] = n;
  return t;
}, p8 = {
  name: "ol-map",
  setup(i, { emit: e }) {
    const { properties: t } = sr(i), r = Mo(null);
    let n = new vg({
      ...t,
      interactions: Vw({
        ...t
      })
    });
    at(t, () => {
      n.setProperties({
        ...t,
        interactions: Vw({
          ...t
        })
      });
    }), tr(() => {
      n.setTarget(r.value);
    }), nr(() => {
      n.setTarget(null), n = null;
    }), Ur("map", n);
    const s = () => n.focus(), a = (u, f, g = {}) => n.forEachFeatureAtPixel(u, f, g), o = (u, f, g) => n.forEachLayerAtPixel(u, f, g), A = (u) => n.getCoordinateFromPixel(u), l = () => n.refresh(), h = () => n.render(), c = () => n.updateSize();
    return n.on("click", (u) => e("click", u)), n.on("dblclick", (u) => e("dblclick", u)), n.on("singleclick", (u) => e("singleclick", u)), n.on("pointerdrag", (u) => e("pointerdrag", u)), n.on("pointermove", (u) => e("pointermove", u)), n.on("movestart", (u) => e("movestart", u)), n.on("moveend", (u) => e("moveend", u)), n.on("postrender", (u) => e("postrender", u)), n.on("precompose", (u) => e("precompose", u)), n.on("postcompose", (u) => e("postcompose", u)), {
      map: n,
      mapRef: r,
      focus: s,
      forEachFeatureAtPixel: a,
      forEachLayerAtPixel: o,
      getCoordinateFromPixel: A,
      refresh: l,
      render: h,
      updateSize: c
    };
  },
  props: {
    loadTilesWhileAnimating: {
      type: Boolean,
      default: !1
    },
    loadTilesWhileInteracting: {
      type: Boolean,
      default: !1
    },
    moveTolerance: {
      type: Number,
      default: 1
    },
    pixelRatio: {
      type: Number,
      default: 1
    },
    controls: {
      type: Array,
      default: () => []
    },
    altShiftDragRotate: {
      type: Boolean,
      default: !0
    },
    onFocusOnly: {
      type: Boolean,
      default: !0
    },
    doubleClickZoom: {
      type: Boolean,
      default: !0
    },
    keyboard: {
      type: Boolean,
      default: !0
    },
    mouseWheelZoom: {
      type: Boolean,
      default: !0
    },
    shiftDragZoom: {
      type: Boolean,
      default: !0
    },
    dragPan: {
      type: Boolean,
      default: !0
    },
    pinchRotate: {
      type: Boolean,
      default: !0
    },
    pinchZoom: {
      type: Boolean,
      default: !0
    }
  }
};
function m8(i, e, t, r, n, s) {
  return xn(), Cn("div", {
    ref: (a) => r.mapRef = a
  }, [
    mr(i.$slots, "default")
  ], 512);
}
const Kw = /* @__PURE__ */ qe(p8, [["render", m8]]);
function v8(i, e) {
  const t = _t("map"), { properties: r } = sr(i), n = () => ({
    ...r,
    projection: typeof r.projection == "string" ? r.projection : new Ja({
      ...r.projection
    })
  }), s = new Ys(n());
  tr(() => {
    t.setView(s);
  }), s.on("change:center", () => {
    e("centerChanged", S()), e("zoomChanged", ne());
  }), s.on(
    "change:resolution",
    () => e("resolutionChanged", Q())
  ), s.on("change:rotation", () => e("rotationChanged", oe())), at(r, () => {
    const ee = n();
    s.setProperties(ee), s.applyOptions_(ee);
  });
  const a = (ee) => s.adjustCenter(ee), o = (ee, xe) => s.adjustResolution(ee, xe), A = (ee, xe) => s.adjustRotation(ee, xe), l = (ee, xe) => s.adjustZoom(ee, xe), h = (ee) => s.animate(ee), c = () => s.beginInteraction(), u = (ee) => s.calculateExtent(ee), f = () => s.cancelAnimations(), g = (ee, xe, Ee) => s.centerOn(ee, xe, Ee), p = () => s.changed(), y = (ee) => s.dispatchEvent(ee), v = (ee, xe, Ee) => s.endInteraction(ee, xe, Ee), w = (ee, xe) => s.fit(ee, xe), C = (ee) => s.get(ee), E = () => s.getAnimating(), S = () => s.getCenter(), M = () => s.getInteracting(), T = () => s.getKeys(), F = () => s.getMaxResolution(), k = () => s.getMaxZoom(), $ = () => s.getMinResolution(), I = () => s.getMinZoom(), L = () => s.getProjection(), P = () => s.getProperties(), Q = () => s.getResolution(), X = (ee, xe) => s.getResolutionForExtent(ee, xe), W = (ee) => s.getResolutionForZoom(ee), q = () => s.getResolutions(), Z = () => s.getRevision(), oe = () => s.getRotation(), ne = () => s.getZoom();
  return {
    view: s,
    adjustCenter: a,
    adjustResolution: o,
    adjustRotation: A,
    adjustZoom: l,
    animate: h,
    beginInteraction: c,
    calculateExtent: u,
    cancelAnimations: f,
    centerOn: g,
    changed: p,
    dispatchEvent: y,
    endInteraction: v,
    fit: w,
    get: C,
    getAnimating: E,
    getCenter: S,
    getInteracting: M,
    getKeys: T,
    getMaxResolution: F,
    getMaxZoom: k,
    getMinResolution: $,
    getMinZoom: I,
    getProjection: L,
    getProperties: P,
    getResolution: Q,
    getResolutionForExtent: X,
    getResolutionForZoom: W,
    getResolutions: q,
    getRevision: Z,
    getRotation: oe,
    getZoom: ne,
    getZoomForResolution: (ee) => s.getZoomForResolution(ee),
    setCenter: (ee) => s.setCenter(ee),
    setConstrainResolution: (ee) => s.setConstrainResolution(ee),
    setMaxZoom: (ee) => s.setMaxZoom(ee),
    setMinZoom: (ee) => s.setMinZoom(ee),
    setResolution: (ee) => s.setResolution(ee),
    setRotation: (ee) => s.setRotation(ee),
    setZoom: (ee) => s.setZoom(ee)
  };
}
const y8 = {
  name: "ol-view",
  setup(i, { emit: e }) {
    return {
      ...v8(i, e)
    };
  },
  props: {
    center: {
      type: Array,
      default: () => [0, 0]
    },
    constrainRotation: {
      type: Boolean,
      default: !0
    },
    enableRotation: {
      type: Boolean,
      default: !0
    },
    extent: {
      type: Array
    },
    constrainOnlyCenter: {
      type: Boolean,
      default: !1
    },
    smoothExtentConstraint: {
      type: Boolean,
      default: !0
    },
    maxResolution: {
      type: Number
    },
    minResolution: {
      type: Number
    },
    maxZoom: {
      type: Number,
      default: 28
    },
    minZoom: {
      type: Number,
      default: 0
    },
    multiWorld: {
      type: Boolean,
      default: !1
    },
    constrainResolution: {
      type: Boolean,
      default: !1
    },
    smoothResolutionConstraint: {
      type: Boolean,
      default: !0
    },
    showFullExtent: {
      type: Boolean,
      default: !1
    },
    projection: {
      type: [String, Object],
      default: "EPSG:3857"
    },
    resolution: {
      type: Number
    },
    resolutions: {
      type: Array
    },
    rotation: {
      type: Number
    },
    zoom: {
      type: Number,
      default: 0
    },
    zoomFactor: {
      type: Number,
      default: 2
    },
    padding: {
      type: Array,
      default: () => [0, 0, 0, 0]
    }
  }
};
function _8(i, e, t, r, n, s) {
  return ur("", !0);
}
const jw = /* @__PURE__ */ qe(y8, [["render", _8]]);
let w8 = class cM extends ws {
  /**
   * @param {Geometry|ObjectWithGeometry<Geometry>} [geometryOrProperties]
   *     You may pass a Geometry object directly, or an object literal containing
   *     properties. If you pass an object literal, you may include a Geometry
   *     associated with a `geometry` key.
   */
  constructor(e) {
    if (super(), this.on, this.once, this.un, this.id_ = void 0, this.geometryName_ = "geometry", this.style_ = null, this.styleFunction_ = void 0, this.geometryChangeKey_ = null, this.addChangeListener(this.geometryName_, this.handleGeometryChanged_), e)
      if (typeof /** @type {?} */
      e.getSimplifiedGeometry == "function") {
        const t = (
          /** @type {Geometry} */
          e
        );
        this.setGeometry(t);
      } else {
        const t = e;
        this.setProperties(t);
      }
  }
  /**
   * Clone this feature. If the original feature has a geometry it
   * is also cloned. The feature id is not set in the clone.
   * @return {Feature<Geometry>} The clone.
   * @api
   */
  clone() {
    const e = (
      /** @type {Feature<Geometry>} */
      new cM(this.hasProperties() ? this.getProperties() : null)
    );
    e.setGeometryName(this.getGeometryName());
    const t = this.getGeometry();
    t && e.setGeometry(
      /** @type {Geometry} */
      t.clone()
    );
    const r = this.getStyle();
    return r && e.setStyle(r), e;
  }
  /**
   * Get the feature's default geometry.  A feature may have any number of named
   * geometries.  The "default" geometry (the one that is rendered by default) is
   * set when calling {@link module:ol/Feature~Feature#setGeometry}.
   * @return {Geometry|undefined} The default geometry for the feature.
   * @api
   * @observable
   */
  getGeometry() {
    return (
      /** @type {Geometry|undefined} */
      this.get(this.geometryName_)
    );
  }
  /**
   * Get the feature identifier.  This is a stable identifier for the feature and
   * is either set when reading data from a remote source or set explicitly by
   * calling {@link module:ol/Feature~Feature#setId}.
   * @return {number|string|undefined} Id.
   * @api
   */
  getId() {
    return this.id_;
  }
  /**
   * Get the name of the feature's default geometry.  By default, the default
   * geometry is named `geometry`.
   * @return {string} Get the property name associated with the default geometry
   *     for this feature.
   * @api
   */
  getGeometryName() {
    return this.geometryName_;
  }
  /**
   * Get the feature's style. Will return what was provided to the
   * {@link module:ol/Feature~Feature#setStyle} method.
   * @return {import("./style/Style.js").StyleLike|undefined} The feature style.
   * @api
   */
  getStyle() {
    return this.style_;
  }
  /**
   * Get the feature's style function.
   * @return {import("./style/Style.js").StyleFunction|undefined} Return a function
   * representing the current style of this feature.
   * @api
   */
  getStyleFunction() {
    return this.styleFunction_;
  }
  /**
   * @private
   */
  handleGeometryChange_() {
    this.changed();
  }
  /**
   * @private
   */
  handleGeometryChanged_() {
    this.geometryChangeKey_ && (pr(this.geometryChangeKey_), this.geometryChangeKey_ = null);
    const e = this.getGeometry();
    e && (this.geometryChangeKey_ = St(
      e,
      ut.CHANGE,
      this.handleGeometryChange_,
      this
    )), this.changed();
  }
  /**
   * Set the default geometry for the feature.  This will update the property
   * with the name returned by {@link module:ol/Feature~Feature#getGeometryName}.
   * @param {Geometry|undefined} geometry The new geometry.
   * @api
   * @observable
   */
  setGeometry(e) {
    this.set(this.geometryName_, e);
  }
  /**
   * Set the style for the feature to override the layer style.  This can be a
   * single style object, an array of styles, or a function that takes a
   * resolution and returns an array of styles. To unset the feature style, call
   * `setStyle()` without arguments or a falsey value.
   * @param {import("./style/Style.js").StyleLike} [style] Style for this feature.
   * @api
   * @fires module:ol/events/Event~BaseEvent#event:change
   */
  setStyle(e) {
    this.style_ = e, this.styleFunction_ = e ? x8(e) : void 0, this.changed();
  }
  /**
   * Set the feature id.  The feature id is considered stable and may be used when
   * requesting features or comparing identifiers returned from a remote source.
   * The feature id can be used with the
   * {@link module:ol/source/Vector~VectorSource#getFeatureById} method.
   * @param {number|string|undefined} id The feature id.
   * @api
   * @fires module:ol/events/Event~BaseEvent#event:change
   */
  setId(e) {
    this.id_ = e, this.changed();
  }
  /**
   * Set the property name to be used when getting the feature's default geometry.
   * When calling {@link module:ol/Feature~Feature#getGeometry}, the value of the property with
   * this name will be returned.
   * @param {string} name The property name of the default geometry.
   * @api
   */
  setGeometryName(e) {
    this.removeChangeListener(this.geometryName_, this.handleGeometryChanged_), this.geometryName_ = e, this.addChangeListener(this.geometryName_, this.handleGeometryChanged_), this.handleGeometryChanged_();
  }
};
function x8(i) {
  if (typeof i == "function")
    return i;
  let e;
  return Array.isArray(i) ? e = i : (lt(typeof /** @type {?} */
  i.getZIndex == "function", 41), e = [
    /** @type {import("./style/Style.js").default} */
    i
  ]), function() {
    return e;
  };
}
const qt = w8, C8 = {
  name: "ol-feature",
  setup(i) {
    const e = _t("vectorSource"), t = _t("vectorLayer"), r = _t("animation", null), { properties: n } = sr(i), s = cr(() => new qt({ ...n.properties }));
    return at(s, (a, o) => {
      e.value.removeFeature(o), e.value.addFeature(a), e.value.changed();
    }), at(e, (a, o) => {
      o.removeFeature(s.value), a.addFeature(s.value), a.changed();
    }), tr(() => {
      e.value.addFeature(s.value), r != null && t.value.animateFeature(s.value, r.value);
    }), nr(() => {
      e.value.removeFeature(s.value);
    }), Ur("feature", s), Ur("stylable", s), {
      feature: s
    };
  },
  props: {
    properties: {
      type: [dg, Object, Array]
    }
  }
};
function E8(i, e, t, r, n, s) {
  return mr(i.$slots, "default");
}
const zw = /* @__PURE__ */ qe(C8, [["render", E8]]), Un = {
  ELEMENT: "element",
  MAP: "map",
  OFFSET: "offset",
  POSITION: "position",
  POSITIONING: "positioning"
};
let B8 = class extends ws {
  /**
   * @param {Options} options Overlay options.
   */
  constructor(e) {
    super(), this.on, this.once, this.un, this.options = e, this.id = e.id, this.insertFirst = e.insertFirst !== void 0 ? e.insertFirst : !0, this.stopEvent = e.stopEvent !== void 0 ? e.stopEvent : !0, this.element = document.createElement("div"), this.element.className = e.className !== void 0 ? e.className : "ol-overlay-container " + A6, this.element.style.position = "absolute", this.element.style.pointerEvents = "auto", this.autoPan = e.autoPan === !0 ? {} : e.autoPan || void 0, this.rendered = {
      transform_: "",
      visible: !0
    }, this.mapPostrenderListenerKey = null, this.addChangeListener(Un.ELEMENT, this.handleElementChanged), this.addChangeListener(Un.MAP, this.handleMapChanged), this.addChangeListener(Un.OFFSET, this.handleOffsetChanged), this.addChangeListener(Un.POSITION, this.handlePositionChanged), this.addChangeListener(Un.POSITIONING, this.handlePositioningChanged), e.element !== void 0 && this.setElement(e.element), this.setOffset(e.offset !== void 0 ? e.offset : [0, 0]), this.setPositioning(e.positioning || "top-left"), e.position !== void 0 && this.setPosition(e.position);
  }
  /**
   * Get the DOM element of this overlay.
   * @return {HTMLElement|undefined} The Element containing the overlay.
   * @observable
   * @api
   */
  getElement() {
    return (
      /** @type {HTMLElement|undefined} */
      this.get(Un.ELEMENT)
    );
  }
  /**
   * Get the overlay identifier which is set on constructor.
   * @return {number|string|undefined} Id.
   * @api
   */
  getId() {
    return this.id;
  }
  /**
   * Get the map associated with this overlay.
   * @return {import("./Map.js").default|null} The map that the
   * overlay is part of.
   * @observable
   * @api
   */
  getMap() {
    return (
      /** @type {import("./Map.js").default|null} */
      this.get(Un.MAP) || null
    );
  }
  /**
   * Get the offset of this overlay.
   * @return {Array<number>} The offset.
   * @observable
   * @api
   */
  getOffset() {
    return (
      /** @type {Array<number>} */
      this.get(Un.OFFSET)
    );
  }
  /**
   * Get the current position of this overlay.
   * @return {import("./coordinate.js").Coordinate|undefined} The spatial point that the overlay is
   *     anchored at.
   * @observable
   * @api
   */
  getPosition() {
    return (
      /** @type {import("./coordinate.js").Coordinate|undefined} */
      this.get(Un.POSITION)
    );
  }
  /**
   * Get the current positioning of this overlay.
   * @return {Positioning} How the overlay is positioned
   *     relative to its point on the map.
   * @observable
   * @api
   */
  getPositioning() {
    return (
      /** @type {Positioning} */
      this.get(Un.POSITIONING)
    );
  }
  /**
   * @protected
   */
  handleElementChanged() {
    JR(this.element);
    const e = this.getElement();
    e && this.element.appendChild(e);
  }
  /**
   * @protected
   */
  handleMapChanged() {
    this.mapPostrenderListenerKey && (wm(this.element), pr(this.mapPostrenderListenerKey), this.mapPostrenderListenerKey = null);
    const e = this.getMap();
    if (e) {
      this.mapPostrenderListenerKey = St(
        e,
        Qa.POSTRENDER,
        this.render,
        this
      ), this.updatePixelPosition();
      const t = this.stopEvent ? e.getOverlayContainerStopEvent() : e.getOverlayContainer();
      this.insertFirst ? t.insertBefore(this.element, t.childNodes[0] || null) : t.appendChild(this.element), this.performAutoPan();
    }
  }
  /**
   * @protected
   */
  render() {
    this.updatePixelPosition();
  }
  /**
   * @protected
   */
  handleOffsetChanged() {
    this.updatePixelPosition();
  }
  /**
   * @protected
   */
  handlePositionChanged() {
    this.updatePixelPosition(), this.performAutoPan();
  }
  /**
   * @protected
   */
  handlePositioningChanged() {
    this.updatePixelPosition();
  }
  /**
   * Set the DOM element to be associated with this overlay.
   * @param {HTMLElement|undefined} element The Element containing the overlay.
   * @observable
   * @api
   */
  setElement(e) {
    this.set(Un.ELEMENT, e);
  }
  /**
   * Set the map to be associated with this overlay.
   * @param {import("./Map.js").default|null} map The map that the
   * overlay is part of. Pass `null` to just remove the overlay from the current map.
   * @observable
   * @api
   */
  setMap(e) {
    this.set(Un.MAP, e);
  }
  /**
   * Set the offset for this overlay.
   * @param {Array<number>} offset Offset.
   * @observable
   * @api
   */
  setOffset(e) {
    this.set(Un.OFFSET, e);
  }
  /**
   * Set the position for this overlay. If the position is `undefined` the
   * overlay is hidden.
   * @param {import("./coordinate.js").Coordinate|undefined} position The spatial point that the overlay
   *     is anchored at.
   * @observable
   * @api
   */
  setPosition(e) {
    this.set(Un.POSITION, e);
  }
  /**
   * Pan the map so that the overlay is entirely visible in the current viewport
   * (if necessary) using the configured autoPan parameters
   * @protected
   */
  performAutoPan() {
    this.autoPan && this.panIntoView(this.autoPan);
  }
  /**
   * Pan the map so that the overlay is entirely visible in the current viewport
   * (if necessary).
   * @param {PanIntoViewOptions} [panIntoViewOptions] Options for the pan action
   * @api
   */
  panIntoView(e) {
    const t = this.getMap();
    if (!t || !t.getTargetElement() || !this.get(Un.POSITION))
      return;
    const r = this.getRect(t.getTargetElement(), t.getSize()), n = this.getElement(), s = this.getRect(n, [
      h6(n),
      c6(n)
    ]);
    e = e || {};
    const a = e.margin === void 0 ? 20 : e.margin;
    if (!Ps(r, s)) {
      const o = s[0] - r[0], A = r[2] - s[2], l = s[1] - r[1], h = r[3] - s[3], c = [0, 0];
      if (o < 0 ? c[0] = o - a : A < 0 && (c[0] = Math.abs(A) + a), l < 0 ? c[1] = l - a : h < 0 && (c[1] = Math.abs(h) + a), c[0] !== 0 || c[1] !== 0) {
        const u = (
          /** @type {import("./coordinate.js").Coordinate} */
          t.getView().getCenterInternal()
        ), f = t.getPixelFromCoordinateInternal(u);
        if (!f)
          return;
        const g = [f[0] + c[0], f[1] + c[1]], p = e.animation || {};
        t.getView().animateInternal({
          center: t.getCoordinateFromPixelInternal(g),
          duration: p.duration,
          easing: p.easing
        });
      }
    }
  }
  /**
   * Get the extent of an element relative to the document
   * @param {HTMLElement} element The element.
   * @param {import("./size.js").Size} size The size of the element.
   * @return {import("./extent.js").Extent} The extent.
   * @protected
   */
  getRect(e, t) {
    const r = e.getBoundingClientRect(), n = r.left + window.pageXOffset, s = r.top + window.pageYOffset;
    return [n, s, n + t[0], s + t[1]];
  }
  /**
   * Set the positioning for this overlay.
   * @param {Positioning} positioning how the overlay is
   *     positioned relative to its point on the map.
   * @observable
   * @api
   */
  setPositioning(e) {
    this.set(Un.POSITIONING, e);
  }
  /**
   * Modify the visibility of the element.
   * @param {boolean} visible Element visibility.
   * @protected
   */
  setVisible(e) {
    this.rendered.visible !== e && (this.element.style.display = e ? "" : "none", this.rendered.visible = e);
  }
  /**
   * Update pixel position.
   * @protected
   */
  updatePixelPosition() {
    const e = this.getMap(), t = this.getPosition();
    if (!e || !e.isRendered() || !t) {
      this.setVisible(!1);
      return;
    }
    const r = e.getPixelFromCoordinate(t), n = e.getSize();
    this.updateRenderedPosition(r, n);
  }
  /**
   * @param {import("./pixel.js").Pixel} pixel The pixel location.
   * @param {import("./size.js").Size|undefined} mapSize The map size.
   * @protected
   */
  updateRenderedPosition(e, t) {
    const r = this.element.style, n = this.getOffset(), s = this.getPositioning();
    this.setVisible(!0);
    const a = Math.round(e[0] + n[0]) + "px", o = Math.round(e[1] + n[1]) + "px";
    let A = "0%", l = "0%";
    s == "bottom-right" || s == "center-right" || s == "top-right" ? A = "-100%" : (s == "bottom-center" || s == "center-center" || s == "top-center") && (A = "-50%"), s == "bottom-left" || s == "bottom-center" || s == "bottom-right" ? l = "-100%" : (s == "center-left" || s == "center-center" || s == "center-right") && (l = "-50%");
    const h = `translate(${A}, ${l}) translate(${a}, ${o})`;
    this.rendered.transform_ != h && (this.rendered.transform_ = h, r.transform = h);
  }
  /**
   * returns the options this Overlay has been created with
   * @return {Options} overlay options
   */
  getOptions() {
    return this.options;
  }
};
const uM = B8;
function b8(i, e) {
  const t = _t("map"), r = Mo(null), { properties: n } = sr(i), s = cr(() => new uM(n));
  tr(() => {
    t.addOverlay(s.value);
  }), nr(() => {
    t.removeOverlay(s.value);
  }), at(s, (p, y) => {
    t.removeOverlay(y), t.addOverlay(p);
  }), vQ(
    () => {
      c(r.value);
    },
    {
      flush: "post"
    }
  ), s.value.on(
    "change:element",
    () => e("elementChanged", a())
  ), s.value.on("change:offset", () => e("offsetChanged", o())), s.value.on(
    "change:position",
    () => e("positionChanged", A())
  ), s.value.on(
    "change:positioning",
    () => e("positioningChanged", l())
  );
  const a = () => s.value.getElement(), o = () => s.value.getOffset(), A = () => s.value.getPosition(), l = () => s.value.getPositioning(), h = (p) => s.value.panIntoView(p), c = (p) => s.value.setElement(p);
  return {
    overlay: s,
    htmlContent: r,
    getOffset: o,
    getPosition: A,
    getPositioning: l,
    panIntoView: h,
    setElement: c,
    setOffset: (p) => s.value.setOffset(p),
    setPosition: (p) => s.value.setPosition(p),
    setPositioning: (p) => s.value.setPositioning(p)
  };
}
const S8 = {
  name: "ol-overlay",
  setup(i, { emit: e }) {
    return {
      ...new b8(i, e)
    };
  },
  props: {
    position: {
      type: Array
    },
    offset: {
      type: Array
    },
    positioning: {
      type: String
    },
    stopEvent: {
      type: Boolean,
      default: !0
    },
    insertFirst: {
      type: Boolean,
      default: !0
    },
    autoPan: {
      type: Boolean,
      default: !1
    },
    autoPanMargin: {
      type: Number,
      default: 20
    },
    autoPanAnimation: {
      type: Object,
      default: void 0
    }
  }
}, T8 = { ref: "htmlContent" };
function F8(i, e, t, r, n, s) {
  return xn(), Cn("div", T8, [
    mr(i.$slots, "default", { position: t.position })
  ], 512);
}
const Xw = /* @__PURE__ */ qe(S8, [["render", F8]]), pi = {
  ACCURACY: "accuracy",
  ACCURACY_GEOMETRY: "accuracyGeometry",
  ALTITUDE: "altitude",
  ALTITUDE_ACCURACY: "altitudeAccuracy",
  HEADING: "heading",
  POSITION: "position",
  PROJECTION: "projection",
  SPEED: "speed",
  TRACKING: "tracking",
  TRACKING_OPTIONS: "trackingOptions"
}, L8 = {
  /**
   * Triggered when a `GeolocationPositionError` occurs.
   * @event module:ol/Geolocation.GeolocationError#error
   * @api
   */
  ERROR: "error"
};
class I8 extends _s {
  /**
   * @param {GeolocationPositionError} error error object.
   */
  constructor(e) {
    super(L8.ERROR), this.code = e.code, this.message = e.message;
  }
}
class R8 extends ws {
  /**
   * @param {Options} [options] Options.
   */
  constructor(e) {
    super(), this.on, this.once, this.un, e = e || {}, this.position_ = null, this.transform_ = Pv, this.watchId_ = void 0, this.addChangeListener(pi.PROJECTION, this.handleProjectionChanged_), this.addChangeListener(pi.TRACKING, this.handleTrackingChanged_), e.projection !== void 0 && this.setProjection(e.projection), e.trackingOptions !== void 0 && this.setTrackingOptions(e.trackingOptions), this.setTracking(e.tracking !== void 0 ? e.tracking : !1);
  }
  /**
   * Clean up.
   */
  disposeInternal() {
    this.setTracking(!1), super.disposeInternal();
  }
  /**
   * @private
   */
  handleProjectionChanged_() {
    const e = this.getProjection();
    e && (this.transform_ = Fu(
      Ct("EPSG:4326"),
      e
    ), this.position_ && this.set(pi.POSITION, this.transform_(this.position_)));
  }
  /**
   * @private
   */
  handleTrackingChanged_() {
    if ("geolocation" in navigator) {
      const e = this.getTracking();
      e && this.watchId_ === void 0 ? this.watchId_ = navigator.geolocation.watchPosition(
        this.positionChange_.bind(this),
        this.positionError_.bind(this),
        this.getTrackingOptions()
      ) : !e && this.watchId_ !== void 0 && (navigator.geolocation.clearWatch(this.watchId_), this.watchId_ = void 0);
    }
  }
  /**
   * @private
   * @param {GeolocationPosition} position position event.
   */
  positionChange_(e) {
    const t = e.coords;
    this.set(pi.ACCURACY, t.accuracy), this.set(
      pi.ALTITUDE,
      t.altitude === null ? void 0 : t.altitude
    ), this.set(
      pi.ALTITUDE_ACCURACY,
      t.altitudeAccuracy === null ? void 0 : t.altitudeAccuracy
    ), this.set(
      pi.HEADING,
      t.heading === null ? void 0 : el(t.heading)
    ), this.position_ ? (this.position_[0] = t.longitude, this.position_[1] = t.latitude) : this.position_ = [t.longitude, t.latitude];
    const r = this.transform_(this.position_);
    this.set(pi.POSITION, r.slice()), this.set(pi.SPEED, t.speed === null ? void 0 : t.speed);
    const n = WD(this.position_, t.accuracy);
    n.applyTransform(this.transform_), this.set(pi.ACCURACY_GEOMETRY, n), this.changed();
  }
  /**
   * @private
   * @param {GeolocationPositionError} error error object.
   */
  positionError_(e) {
    this.dispatchEvent(new I8(e));
  }
  /**
   * Get the accuracy of the position in meters.
   * @return {number|undefined} The accuracy of the position measurement in
   *     meters.
   * @observable
   * @api
   */
  getAccuracy() {
    return (
      /** @type {number|undefined} */
      this.get(pi.ACCURACY)
    );
  }
  /**
   * Get a geometry of the position accuracy.
   * @return {?import("./geom/Polygon.js").default} A geometry of the position accuracy.
   * @observable
   * @api
   */
  getAccuracyGeometry() {
    return (
      /** @type {?import("./geom/Polygon.js").default} */
      this.get(pi.ACCURACY_GEOMETRY) || null
    );
  }
  /**
   * Get the altitude associated with the position.
   * @return {number|undefined} The altitude of the position in meters above mean
   *     sea level.
   * @observable
   * @api
   */
  getAltitude() {
    return (
      /** @type {number|undefined} */
      this.get(pi.ALTITUDE)
    );
  }
  /**
   * Get the altitude accuracy of the position.
   * @return {number|undefined} The accuracy of the altitude measurement in
   *     meters.
   * @observable
   * @api
   */
  getAltitudeAccuracy() {
    return (
      /** @type {number|undefined} */
      this.get(pi.ALTITUDE_ACCURACY)
    );
  }
  /**
   * Get the heading as radians clockwise from North.
   * Note: depending on the browser, the heading is only defined if the `enableHighAccuracy`
   * is set to `true` in the tracking options.
   * @return {number|undefined} The heading of the device in radians from north.
   * @observable
   * @api
   */
  getHeading() {
    return (
      /** @type {number|undefined} */
      this.get(pi.HEADING)
    );
  }
  /**
   * Get the position of the device.
   * @return {import("./coordinate.js").Coordinate|undefined} The current position of the device reported
   *     in the current projection.
   * @observable
   * @api
   */
  getPosition() {
    return (
      /** @type {import("./coordinate.js").Coordinate|undefined} */
      this.get(pi.POSITION)
    );
  }
  /**
   * Get the projection associated with the position.
   * @return {import("./proj/Projection.js").default|undefined} The projection the position is
   *     reported in.
   * @observable
   * @api
   */
  getProjection() {
    return (
      /** @type {import("./proj/Projection.js").default|undefined} */
      this.get(pi.PROJECTION)
    );
  }
  /**
   * Get the speed in meters per second.
   * @return {number|undefined} The instantaneous speed of the device in meters
   *     per second.
   * @observable
   * @api
   */
  getSpeed() {
    return (
      /** @type {number|undefined} */
      this.get(pi.SPEED)
    );
  }
  /**
   * Determine if the device location is being tracked.
   * @return {boolean} The device location is being tracked.
   * @observable
   * @api
   */
  getTracking() {
    return (
      /** @type {boolean} */
      this.get(pi.TRACKING)
    );
  }
  /**
   * Get the tracking options.
   * See https://www.w3.org/TR/geolocation-API/#position-options.
   * @return {PositionOptions|undefined} PositionOptions as defined by
   *     the [HTML5 Geolocation spec
   *     ](https://www.w3.org/TR/geolocation-API/#position_options_interface).
   * @observable
   * @api
   */
  getTrackingOptions() {
    return (
      /** @type {PositionOptions|undefined} */
      this.get(pi.TRACKING_OPTIONS)
    );
  }
  /**
   * Set the projection to use for transforming the coordinates.
   * @param {import("./proj.js").ProjectionLike} projection The projection the position is
   *     reported in.
   * @observable
   * @api
   */
  setProjection(e) {
    this.set(pi.PROJECTION, Ct(e));
  }
  /**
   * Enable or disable tracking.
   * @param {boolean} tracking Enable tracking.
   * @observable
   * @api
   */
  setTracking(e) {
    this.set(pi.TRACKING, e);
  }
  /**
   * Set the tracking options.
   * See http://www.w3.org/TR/geolocation-API/#position-options.
   * @param {PositionOptions} options PositionOptions as defined by the
   *     [HTML5 Geolocation spec
   *     ](http://www.w3.org/TR/geolocation-API/#position_options_interface).
   * @observable
   * @api
   */
  setTrackingOptions(e) {
    this.set(pi.TRACKING_OPTIONS, e);
  }
}
const M8 = R8, N8 = {
  name: "ol-geolocation",
  emits: [
    "positionChanged",
    "speedChanged",
    "headingChanged",
    "altitudeChanged",
    "altitudeAccuracyChanged",
    "accuracyGeometryChanged"
  ],
  setup(i, { emit: e }) {
    const { properties: t } = sr(i), r = cr(() => {
      const u = new M8(t);
      return u.on("change", c), u;
    }), n = Mo([]), s = Mo(0), a = Mo(0), o = Mo(0), A = Mo(0), l = Mo(0), h = Mo({});
    at(n, () => {
      e("positionChanged", n.value);
    }), at(A, () => {
      e("speedChanged", A.value);
    }), at(l, () => {
      e("headingChanged", l.value);
    }), at(a, () => {
      e("altitudeChanged", a.value);
    }), at(o, () => {
      e("altitudeAccuracyChanged", o.value);
    }), at(h, () => {
      e("accuracyGeometryChanged", h.value);
    });
    const c = () => {
      n.value = r.value.getPosition(), A.value = r.value.getSpeed(), l.value = r.value.getHeading(), s.value = r.value.getAccuracy(), a.value = r.value.getAltitude(), o.value = r.value.getAltitudeAccuracy(), h.value = r.value.getAccuracyGeometry();
    };
    return at(r, (u, f) => {
      f.un("change", c), u.on("change", c);
    }), {
      geoLoc: r,
      position: n,
      accuracy: s,
      altitude: a,
      altitudeAccuracy: o,
      speed: A,
      heading: l,
      accuracyGeometry: h
    };
  },
  props: {
    projection: {
      type: [String, Object],
      default: "EPSG:3857"
    },
    tracking: {
      type: Boolean,
      default: !0
    },
    trackingOptions: {
      type: Object,
      default: () => ({
        enableHighAccuracy: !0
      })
    }
  }
};
function P8(i, e, t, r, n, s) {
  return mr(i.$slots, "default", {
    position: r.position,
    speed: r.speed,
    heading: r.heading,
    accuracy: r.accuracy,
    altitude: r.altitude,
    altitudeAccuracy: r.altitudeAccuracy,
    accuracyGeometry: r.accuracyGeometry
  });
}
const Ww = /* @__PURE__ */ qe(N8, [["render", P8]]);
function O8(i) {
  i("EPSG:4326", "+title=WGS 84 (long/lat) +proj=longlat +ellps=WGS84 +datum=WGS84 +units=degrees"), i("EPSG:4269", "+title=NAD83 (long/lat) +proj=longlat +a=6378137.0 +b=6356752.31414036 +ellps=GRS80 +datum=NAD83 +units=degrees"), i("EPSG:3857", "+title=WGS 84 / Pseudo-Mercator +proj=merc +a=6378137 +b=6378137 +lat_ts=0.0 +lon_0=0.0 +x_0=0.0 +y_0=0 +k=1.0 +units=m +nadgrids=@null +no_defs"), i.WGS84 = i["EPSG:4326"], i["EPSG:3785"] = i["EPSG:3857"], i.GOOGLE = i["EPSG:3857"], i["EPSG:900913"] = i["EPSG:3857"], i["EPSG:102113"] = i["EPSG:3857"];
}
var mh = 1, vh = 2, Zc = 3, U8 = 4, Yw = 5, GS = 6378137, Q8 = 6356752314e-3, $S = 0.0066943799901413165, hd = 484813681109536e-20, Qe = Math.PI / 2, D8 = 0.16666666666666666, k8 = 0.04722222222222222, H8 = 0.022156084656084655, Xe = 1e-10, Sn = 0.017453292519943295, Ha = 57.29577951308232, Nr = Math.PI / 4, Qd = Math.PI * 2, Ui = 3.14159265359, xs = {};
xs.greenwich = 0;
xs.lisbon = -9.131906111111;
xs.paris = 2.337229166667;
xs.bogota = -74.080916666667;
xs.madrid = -3.687938888889;
xs.rome = 12.452333333333;
xs.bern = 7.439583333333;
xs.jakarta = 106.807719444444;
xs.ferro = -17.666666666667;
xs.brussels = 4.367975;
xs.stockholm = 18.058277777778;
xs.athens = 23.7163375;
xs.oslo = 10.722916666667;
const G8 = {
  ft: { to_meter: 0.3048 },
  "us-ft": { to_meter: 1200 / 3937 }
};
var VS = /[\s_\-\/\(\)]/g;
function ul(i, e) {
  if (i[e])
    return i[e];
  for (var t = Object.keys(i), r = e.toLowerCase().replace(VS, ""), n = -1, s, a; ++n < t.length; )
    if (s = t[n], a = s.toLowerCase().replace(VS, ""), a === r)
      return i[s];
}
function qw(i) {
  var e = {}, t = i.split("+").map(function(o) {
    return o.trim();
  }).filter(function(o) {
    return o;
  }).reduce(function(o, A) {
    var l = A.split("=");
    return l.push(!0), o[l[0].toLowerCase()] = l[1], o;
  }, {}), r, n, s, a = {
    proj: "projName",
    datum: "datumCode",
    rf: function(o) {
      e.rf = parseFloat(o);
    },
    lat_0: function(o) {
      e.lat0 = o * Sn;
    },
    lat_1: function(o) {
      e.lat1 = o * Sn;
    },
    lat_2: function(o) {
      e.lat2 = o * Sn;
    },
    lat_ts: function(o) {
      e.lat_ts = o * Sn;
    },
    lon_0: function(o) {
      e.long0 = o * Sn;
    },
    lon_1: function(o) {
      e.long1 = o * Sn;
    },
    lon_2: function(o) {
      e.long2 = o * Sn;
    },
    alpha: function(o) {
      e.alpha = parseFloat(o) * Sn;
    },
    gamma: function(o) {
      e.rectified_grid_angle = parseFloat(o);
    },
    lonc: function(o) {
      e.longc = o * Sn;
    },
    x_0: function(o) {
      e.x0 = parseFloat(o);
    },
    y_0: function(o) {
      e.y0 = parseFloat(o);
    },
    k_0: function(o) {
      e.k0 = parseFloat(o);
    },
    k: function(o) {
      e.k0 = parseFloat(o);
    },
    a: function(o) {
      e.a = parseFloat(o);
    },
    b: function(o) {
      e.b = parseFloat(o);
    },
    r_a: function() {
      e.R_A = !0;
    },
    zone: function(o) {
      e.zone = parseInt(o, 10);
    },
    south: function() {
      e.utmSouth = !0;
    },
    towgs84: function(o) {
      e.datum_params = o.split(",").map(function(A) {
        return parseFloat(A);
      });
    },
    to_meter: function(o) {
      e.to_meter = parseFloat(o);
    },
    units: function(o) {
      e.units = o;
      var A = ul(G8, o);
      A && (e.to_meter = A.to_meter);
    },
    from_greenwich: function(o) {
      e.from_greenwich = o * Sn;
    },
    pm: function(o) {
      var A = ul(xs, o);
      e.from_greenwich = (A || parseFloat(o)) * Sn;
    },
    nadgrids: function(o) {
      o === "@null" ? e.datumCode = "none" : e.nadgrids = o;
    },
    axis: function(o) {
      var A = "ewnsud";
      o.length === 3 && A.indexOf(o.substr(0, 1)) !== -1 && A.indexOf(o.substr(1, 1)) !== -1 && A.indexOf(o.substr(2, 1)) !== -1 && (e.axis = o);
    },
    approx: function() {
      e.approx = !0;
    }
  };
  for (r in t)
    n = t[r], r in a ? (s = a[r], typeof s == "function" ? s(n) : e[s] = n) : e[r] = n;
  return typeof e.datumCode == "string" && e.datumCode !== "WGS84" && (e.datumCode = e.datumCode.toLowerCase()), e;
}
var Dd = 1, fM = 2, dM = 3, Tm = 4, gM = 5, QE = -1, $8 = /\s/, V8 = /[A-Za-z]/, K8 = /[A-Za-z84_]/, Hv = /[,\]]/, pM = /[\d\.E\-\+]/;
function iA(i) {
  if (typeof i != "string")
    throw new Error("not a string");
  this.text = i.trim(), this.level = 0, this.place = 0, this.root = null, this.stack = [], this.currentObject = null, this.state = Dd;
}
iA.prototype.readCharicter = function() {
  var i = this.text[this.place++];
  if (this.state !== Tm)
    for (; $8.test(i); ) {
      if (this.place >= this.text.length)
        return;
      i = this.text[this.place++];
    }
  switch (this.state) {
    case Dd:
      return this.neutral(i);
    case fM:
      return this.keyword(i);
    case Tm:
      return this.quoted(i);
    case gM:
      return this.afterquote(i);
    case dM:
      return this.number(i);
    case QE:
      return;
  }
};
iA.prototype.afterquote = function(i) {
  if (i === '"') {
    this.word += '"', this.state = Tm;
    return;
  }
  if (Hv.test(i)) {
    this.word = this.word.trim(), this.afterItem(i);
    return;
  }
  throw new Error(`havn't handled "` + i + '" in afterquote yet, index ' + this.place);
};
iA.prototype.afterItem = function(i) {
  if (i === ",") {
    this.word !== null && this.currentObject.push(this.word), this.word = null, this.state = Dd;
    return;
  }
  if (i === "]") {
    this.level--, this.word !== null && (this.currentObject.push(this.word), this.word = null), this.state = Dd, this.currentObject = this.stack.pop(), this.currentObject || (this.state = QE);
    return;
  }
};
iA.prototype.number = function(i) {
  if (pM.test(i)) {
    this.word += i;
    return;
  }
  if (Hv.test(i)) {
    this.word = parseFloat(this.word), this.afterItem(i);
    return;
  }
  throw new Error(`havn't handled "` + i + '" in number yet, index ' + this.place);
};
iA.prototype.quoted = function(i) {
  if (i === '"') {
    this.state = gM;
    return;
  }
  this.word += i;
};
iA.prototype.keyword = function(i) {
  if (K8.test(i)) {
    this.word += i;
    return;
  }
  if (i === "[") {
    var e = [];
    e.push(this.word), this.level++, this.root === null ? this.root = e : this.currentObject.push(e), this.stack.push(this.currentObject), this.currentObject = e, this.state = Dd;
    return;
  }
  if (Hv.test(i)) {
    this.afterItem(i);
    return;
  }
  throw new Error(`havn't handled "` + i + '" in keyword yet, index ' + this.place);
};
iA.prototype.neutral = function(i) {
  if (V8.test(i)) {
    this.word = i, this.state = fM;
    return;
  }
  if (i === '"') {
    this.word = "", this.state = Tm;
    return;
  }
  if (pM.test(i)) {
    this.word = i, this.state = dM;
    return;
  }
  if (Hv.test(i)) {
    this.afterItem(i);
    return;
  }
  throw new Error(`havn't handled "` + i + '" in neutral yet, index ' + this.place);
};
iA.prototype.output = function() {
  for (; this.place < this.text.length; )
    this.readCharicter();
  if (this.state === QE)
    return this.root;
  throw new Error('unable to parse string "' + this.text + '". State is ' + this.state);
};
function j8(i) {
  var e = new iA(i);
  return e.output();
}
function KS(i, e, t) {
  Array.isArray(e) && (t.unshift(e), e = null);
  var r = e ? {} : i, n = t.reduce(function(s, a) {
    return Oc(a, s), s;
  }, r);
  e && (i[e] = n);
}
function Oc(i, e) {
  if (!Array.isArray(i)) {
    e[i] = !0;
    return;
  }
  var t = i.shift();
  if (t === "PARAMETER" && (t = i.shift()), i.length === 1) {
    if (Array.isArray(i[0])) {
      e[t] = {}, Oc(i[0], e[t]);
      return;
    }
    e[t] = i[0];
    return;
  }
  if (!i.length) {
    e[t] = !0;
    return;
  }
  if (t === "TOWGS84") {
    e[t] = i;
    return;
  }
  if (t === "AXIS") {
    t in e || (e[t] = []), e[t].push(i);
    return;
  }
  Array.isArray(t) || (e[t] = {});
  var r;
  switch (t) {
    case "UNIT":
    case "PRIMEM":
    case "VERT_DATUM":
      e[t] = {
        name: i[0].toLowerCase(),
        convert: i[1]
      }, i.length === 3 && Oc(i[2], e[t]);
      return;
    case "SPHEROID":
    case "ELLIPSOID":
      e[t] = {
        name: i[0],
        a: i[1],
        rf: i[2]
      }, i.length === 4 && Oc(i[3], e[t]);
      return;
    case "PROJECTEDCRS":
    case "PROJCRS":
    case "GEOGCS":
    case "GEOCCS":
    case "PROJCS":
    case "LOCAL_CS":
    case "GEODCRS":
    case "GEODETICCRS":
    case "GEODETICDATUM":
    case "EDATUM":
    case "ENGINEERINGDATUM":
    case "VERT_CS":
    case "VERTCRS":
    case "VERTICALCRS":
    case "COMPD_CS":
    case "COMPOUNDCRS":
    case "ENGINEERINGCRS":
    case "ENGCRS":
    case "FITTED_CS":
    case "LOCAL_DATUM":
    case "DATUM":
      i[0] = ["name", i[0]], KS(e, t, i);
      return;
    default:
      for (r = -1; ++r < i.length; )
        if (!Array.isArray(i[r]))
          return Oc(i, e[t]);
      return KS(e, t, i);
  }
}
var z8 = 0.017453292519943295;
function X8(i, e) {
  var t = e[0], r = e[1];
  !(t in i) && r in i && (i[t] = i[r], e.length === 3 && (i[t] = e[2](i[t])));
}
function Co(i) {
  return i * z8;
}
function W8(i) {
  if (i.type === "GEOGCS" ? i.projName = "longlat" : i.type === "LOCAL_CS" ? (i.projName = "identity", i.local = !0) : typeof i.PROJECTION == "object" ? i.projName = Object.keys(i.PROJECTION)[0] : i.projName = i.PROJECTION, i.AXIS) {
    for (var e = "", t = 0, r = i.AXIS.length; t < r; ++t) {
      var n = [i.AXIS[t][0].toLowerCase(), i.AXIS[t][1].toLowerCase()];
      n[0].indexOf("north") !== -1 || (n[0] === "y" || n[0] === "lat") && n[1] === "north" ? e += "n" : n[0].indexOf("south") !== -1 || (n[0] === "y" || n[0] === "lat") && n[1] === "south" ? e += "s" : n[0].indexOf("east") !== -1 || (n[0] === "x" || n[0] === "lon") && n[1] === "east" ? e += "e" : (n[0].indexOf("west") !== -1 || (n[0] === "x" || n[0] === "lon") && n[1] === "west") && (e += "w");
    }
    e.length === 2 && (e += "u"), e.length === 3 && (i.axis = e);
  }
  i.UNIT && (i.units = i.UNIT.name.toLowerCase(), i.units === "metre" && (i.units = "meter"), i.UNIT.convert && (i.type === "GEOGCS" ? i.DATUM && i.DATUM.SPHEROID && (i.to_meter = i.UNIT.convert * i.DATUM.SPHEROID.a) : i.to_meter = i.UNIT.convert));
  var s = i.GEOGCS;
  i.type === "GEOGCS" && (s = i), s && (s.DATUM ? i.datumCode = s.DATUM.name.toLowerCase() : i.datumCode = s.name.toLowerCase(), i.datumCode.slice(0, 2) === "d_" && (i.datumCode = i.datumCode.slice(2)), (i.datumCode === "new_zealand_geodetic_datum_1949" || i.datumCode === "new_zealand_1949") && (i.datumCode = "nzgd49"), (i.datumCode === "wgs_1984" || i.datumCode === "world_geodetic_system_1984") && (i.PROJECTION === "Mercator_Auxiliary_Sphere" && (i.sphere = !0), i.datumCode = "wgs84"), i.datumCode.slice(-6) === "_ferro" && (i.datumCode = i.datumCode.slice(0, -6)), i.datumCode.slice(-8) === "_jakarta" && (i.datumCode = i.datumCode.slice(0, -8)), ~i.datumCode.indexOf("belge") && (i.datumCode = "rnb72"), s.DATUM && s.DATUM.SPHEROID && (i.ellps = s.DATUM.SPHEROID.name.replace("_19", "").replace(/[Cc]larke\_18/, "clrk"), i.ellps.toLowerCase().slice(0, 13) === "international" && (i.ellps = "intl"), i.a = s.DATUM.SPHEROID.a, i.rf = parseFloat(s.DATUM.SPHEROID.rf, 10)), s.DATUM && s.DATUM.TOWGS84 && (i.datum_params = s.DATUM.TOWGS84), ~i.datumCode.indexOf("osgb_1936") && (i.datumCode = "osgb36"), ~i.datumCode.indexOf("osni_1952") && (i.datumCode = "osni52"), (~i.datumCode.indexOf("tm65") || ~i.datumCode.indexOf("geodetic_datum_of_1965")) && (i.datumCode = "ire65"), i.datumCode === "ch1903+" && (i.datumCode = "ch1903"), ~i.datumCode.indexOf("israel") && (i.datumCode = "isr93")), i.b && !isFinite(i.b) && (i.b = i.a);
  function a(l) {
    var h = i.to_meter || 1;
    return l * h;
  }
  var o = function(l) {
    return X8(i, l);
  }, A = [
    ["standard_parallel_1", "Standard_Parallel_1"],
    ["standard_parallel_1", "Latitude of 1st standard parallel"],
    ["standard_parallel_2", "Standard_Parallel_2"],
    ["standard_parallel_2", "Latitude of 2nd standard parallel"],
    ["false_easting", "False_Easting"],
    ["false_easting", "False easting"],
    ["false-easting", "Easting at false origin"],
    ["false_northing", "False_Northing"],
    ["false_northing", "False northing"],
    ["false_northing", "Northing at false origin"],
    ["central_meridian", "Central_Meridian"],
    ["central_meridian", "Longitude of natural origin"],
    ["central_meridian", "Longitude of false origin"],
    ["latitude_of_origin", "Latitude_Of_Origin"],
    ["latitude_of_origin", "Central_Parallel"],
    ["latitude_of_origin", "Latitude of natural origin"],
    ["latitude_of_origin", "Latitude of false origin"],
    ["scale_factor", "Scale_Factor"],
    ["k0", "scale_factor"],
    ["latitude_of_center", "Latitude_Of_Center"],
    ["latitude_of_center", "Latitude_of_center"],
    ["lat0", "latitude_of_center", Co],
    ["longitude_of_center", "Longitude_Of_Center"],
    ["longitude_of_center", "Longitude_of_center"],
    ["longc", "longitude_of_center", Co],
    ["x0", "false_easting", a],
    ["y0", "false_northing", a],
    ["long0", "central_meridian", Co],
    ["lat0", "latitude_of_origin", Co],
    ["lat0", "standard_parallel_1", Co],
    ["lat1", "standard_parallel_1", Co],
    ["lat2", "standard_parallel_2", Co],
    ["azimuth", "Azimuth"],
    ["alpha", "azimuth", Co],
    ["srsCode", "name"]
  ];
  A.forEach(o), !i.long0 && i.longc && (i.projName === "Albers_Conic_Equal_Area" || i.projName === "Lambert_Azimuthal_Equal_Area") && (i.long0 = i.longc), !i.lat_ts && i.lat1 && (i.projName === "Stereographic_South_Pole" || i.projName === "Polar Stereographic (variant B)") && (i.lat0 = Co(i.lat1 > 0 ? 90 : -90), i.lat_ts = i.lat1);
}
function mM(i) {
  var e = j8(i), t = e.shift(), r = e.shift();
  e.unshift(["name", r]), e.unshift(["type", t]);
  var n = {};
  return Oc(e, n), W8(n), n;
}
function Jn(i) {
  var e = this;
  if (arguments.length === 2) {
    var t = arguments[1];
    typeof t == "string" ? t.charAt(0) === "+" ? Jn[i] = qw(arguments[1]) : Jn[i] = mM(arguments[1]) : Jn[i] = t;
  } else if (arguments.length === 1) {
    if (Array.isArray(i))
      return i.map(function(r) {
        Array.isArray(r) ? Jn.apply(e, r) : Jn(r);
      });
    if (typeof i == "string") {
      if (i in Jn)
        return Jn[i];
    } else
      "EPSG" in i ? Jn["EPSG:" + i.EPSG] = i : "ESRI" in i ? Jn["ESRI:" + i.ESRI] = i : "IAU2000" in i ? Jn["IAU2000:" + i.IAU2000] = i : console.log(i);
    return;
  }
}
O8(Jn);
function Y8(i) {
  return typeof i == "string";
}
function q8(i) {
  return i in Jn;
}
var Z8 = ["PROJECTEDCRS", "PROJCRS", "GEOGCS", "GEOCCS", "PROJCS", "LOCAL_CS", "GEODCRS", "GEODETICCRS", "GEODETICDATUM", "ENGCRS", "ENGINEERINGCRS"];
function J8(i) {
  return Z8.some(function(e) {
    return i.indexOf(e) > -1;
  });
}
var ek = ["3857", "900913", "3785", "102113"];
function tk(i) {
  var e = ul(i, "authority");
  if (e) {
    var t = ul(e, "epsg");
    return t && ek.indexOf(t) > -1;
  }
}
function rk(i) {
  var e = ul(i, "extension");
  if (e)
    return ul(e, "proj4");
}
function ik(i) {
  return i[0] === "+";
}
function nk(i) {
  if (Y8(i)) {
    if (q8(i))
      return Jn[i];
    if (J8(i)) {
      var e = mM(i);
      if (tk(e))
        return Jn["EPSG:3857"];
      var t = rk(e);
      return t ? qw(t) : e;
    }
    if (ik(i))
      return qw(i);
  } else
    return i;
}
function jS(i, e) {
  i = i || {};
  var t, r;
  if (!e)
    return i;
  for (r in e)
    t = e[r], t !== void 0 && (i[r] = t);
  return i;
}
function Ya(i, e, t) {
  var r = i * e;
  return t / Math.sqrt(1 - r * r);
}
function yg(i) {
  return i < 0 ? -1 : 1;
}
function it(i) {
  return Math.abs(i) <= Ui ? i : i - yg(i) * Qd;
}
function Ca(i, e, t) {
  var r = i * t, n = 0.5 * i;
  return r = Math.pow((1 - r) / (1 + r), n), Math.tan(0.5 * (Qe - e)) / r;
}
function kd(i, e) {
  for (var t = 0.5 * i, r, n, s = Qe - 2 * Math.atan(e), a = 0; a <= 15; a++)
    if (r = i * Math.sin(s), n = Qe - 2 * Math.atan(e * Math.pow((1 - r) / (1 + r), t)) - s, s += n, Math.abs(n) <= 1e-10)
      return s;
  return -9999;
}
function sk() {
  var i = this.b / this.a;
  this.es = 1 - i * i, "x0" in this || (this.x0 = 0), "y0" in this || (this.y0 = 0), this.e = Math.sqrt(this.es), this.lat_ts ? this.sphere ? this.k0 = Math.cos(this.lat_ts) : this.k0 = Ya(this.e, Math.sin(this.lat_ts), Math.cos(this.lat_ts)) : this.k0 || (this.k ? this.k0 = this.k : this.k0 = 1);
}
function ak(i) {
  var e = i.x, t = i.y;
  if (t * Ha > 90 && t * Ha < -90 && e * Ha > 180 && e * Ha < -180)
    return null;
  var r, n;
  if (Math.abs(Math.abs(t) - Qe) <= Xe)
    return null;
  if (this.sphere)
    r = this.x0 + this.a * this.k0 * it(e - this.long0), n = this.y0 + this.a * this.k0 * Math.log(Math.tan(Nr + 0.5 * t));
  else {
    var s = Math.sin(t), a = Ca(this.e, t, s);
    r = this.x0 + this.a * this.k0 * it(e - this.long0), n = this.y0 - this.a * this.k0 * Math.log(a);
  }
  return i.x = r, i.y = n, i;
}
function ok(i) {
  var e = i.x - this.x0, t = i.y - this.y0, r, n;
  if (this.sphere)
    n = Qe - 2 * Math.atan(Math.exp(-t / (this.a * this.k0)));
  else {
    var s = Math.exp(-t / (this.a * this.k0));
    if (n = kd(this.e, s), n === -9999)
      return null;
  }
  return r = it(this.long0 + e / (this.a * this.k0)), i.x = r, i.y = n, i;
}
var Ak = ["Mercator", "Popular Visualisation Pseudo Mercator", "Mercator_1SP", "Mercator_Auxiliary_Sphere", "merc"];
const lk = {
  init: sk,
  forward: ak,
  inverse: ok,
  names: Ak
};
function hk() {
}
function zS(i) {
  return i;
}
var ck = ["longlat", "identity"];
const uk = {
  init: hk,
  forward: zS,
  inverse: zS,
  names: ck
};
var fk = [lk, uk], k0 = {}, Fm = [];
function vM(i, e) {
  var t = Fm.length;
  return i.names ? (Fm[t] = i, i.names.forEach(function(r) {
    k0[r.toLowerCase()] = t;
  }), this) : (console.log(e), !0);
}
function dk(i) {
  if (!i)
    return !1;
  var e = i.toLowerCase();
  if (typeof k0[e] < "u" && Fm[k0[e]])
    return Fm[k0[e]];
}
function gk() {
  fk.forEach(vM);
}
const pk = {
  start: gk,
  add: vM,
  get: dk
};
var Dt = {};
Dt.MERIT = {
  a: 6378137,
  rf: 298.257,
  ellipseName: "MERIT 1983"
};
Dt.SGS85 = {
  a: 6378136,
  rf: 298.257,
  ellipseName: "Soviet Geodetic System 85"
};
Dt.GRS80 = {
  a: 6378137,
  rf: 298.257222101,
  ellipseName: "GRS 1980(IUGG, 1980)"
};
Dt.IAU76 = {
  a: 6378140,
  rf: 298.257,
  ellipseName: "IAU 1976"
};
Dt.airy = {
  a: 6377563396e-3,
  b: 635625691e-2,
  ellipseName: "Airy 1830"
};
Dt.APL4 = {
  a: 6378137,
  rf: 298.25,
  ellipseName: "Appl. Physics. 1965"
};
Dt.NWL9D = {
  a: 6378145,
  rf: 298.25,
  ellipseName: "Naval Weapons Lab., 1965"
};
Dt.mod_airy = {
  a: 6377340189e-3,
  b: 6356034446e-3,
  ellipseName: "Modified Airy"
};
Dt.andrae = {
  a: 637710443e-2,
  rf: 300,
  ellipseName: "Andrae 1876 (Den., Iclnd.)"
};
Dt.aust_SA = {
  a: 6378160,
  rf: 298.25,
  ellipseName: "Australian Natl & S. Amer. 1969"
};
Dt.GRS67 = {
  a: 6378160,
  rf: 298.247167427,
  ellipseName: "GRS 67(IUGG 1967)"
};
Dt.bessel = {
  a: 6377397155e-3,
  rf: 299.1528128,
  ellipseName: "Bessel 1841"
};
Dt.bess_nam = {
  a: 6377483865e-3,
  rf: 299.1528128,
  ellipseName: "Bessel 1841 (Namibia)"
};
Dt.clrk66 = {
  a: 63782064e-1,
  b: 63565838e-1,
  ellipseName: "Clarke 1866"
};
Dt.clrk80 = {
  a: 6378249145e-3,
  rf: 293.4663,
  ellipseName: "Clarke 1880 mod."
};
Dt.clrk80ign = {
  a: 63782492e-1,
  b: 6356515,
  rf: 293.4660213,
  ellipseName: "Clarke 1880 (IGN)"
};
Dt.clrk58 = {
  a: 6378293645208759e-9,
  rf: 294.2606763692654,
  ellipseName: "Clarke 1858"
};
Dt.CPM = {
  a: 63757387e-1,
  rf: 334.29,
  ellipseName: "Comm. des Poids et Mesures 1799"
};
Dt.delmbr = {
  a: 6376428,
  rf: 311.5,
  ellipseName: "Delambre 1810 (Belgium)"
};
Dt.engelis = {
  a: 637813605e-2,
  rf: 298.2566,
  ellipseName: "Engelis 1985"
};
Dt.evrst30 = {
  a: 6377276345e-3,
  rf: 300.8017,
  ellipseName: "Everest 1830"
};
Dt.evrst48 = {
  a: 6377304063e-3,
  rf: 300.8017,
  ellipseName: "Everest 1948"
};
Dt.evrst56 = {
  a: 6377301243e-3,
  rf: 300.8017,
  ellipseName: "Everest 1956"
};
Dt.evrst69 = {
  a: 6377295664e-3,
  rf: 300.8017,
  ellipseName: "Everest 1969"
};
Dt.evrstSS = {
  a: 6377298556e-3,
  rf: 300.8017,
  ellipseName: "Everest (Sabah & Sarawak)"
};
Dt.fschr60 = {
  a: 6378166,
  rf: 298.3,
  ellipseName: "Fischer (Mercury Datum) 1960"
};
Dt.fschr60m = {
  a: 6378155,
  rf: 298.3,
  ellipseName: "Fischer 1960"
};
Dt.fschr68 = {
  a: 6378150,
  rf: 298.3,
  ellipseName: "Fischer 1968"
};
Dt.helmert = {
  a: 6378200,
  rf: 298.3,
  ellipseName: "Helmert 1906"
};
Dt.hough = {
  a: 6378270,
  rf: 297,
  ellipseName: "Hough"
};
Dt.intl = {
  a: 6378388,
  rf: 297,
  ellipseName: "International 1909 (Hayford)"
};
Dt.kaula = {
  a: 6378163,
  rf: 298.24,
  ellipseName: "Kaula 1961"
};
Dt.lerch = {
  a: 6378139,
  rf: 298.257,
  ellipseName: "Lerch 1979"
};
Dt.mprts = {
  a: 6397300,
  rf: 191,
  ellipseName: "Maupertius 1738"
};
Dt.new_intl = {
  a: 63781575e-1,
  b: 63567722e-1,
  ellipseName: "New International 1967"
};
Dt.plessis = {
  a: 6376523,
  rf: 6355863,
  ellipseName: "Plessis 1817 (France)"
};
Dt.krass = {
  a: 6378245,
  rf: 298.3,
  ellipseName: "Krassovsky, 1942"
};
Dt.SEasia = {
  a: 6378155,
  b: 63567733205e-4,
  ellipseName: "Southeast Asia"
};
Dt.walbeck = {
  a: 6376896,
  b: 63558348467e-4,
  ellipseName: "Walbeck"
};
Dt.WGS60 = {
  a: 6378165,
  rf: 298.3,
  ellipseName: "WGS 60"
};
Dt.WGS66 = {
  a: 6378145,
  rf: 298.25,
  ellipseName: "WGS 66"
};
Dt.WGS7 = {
  a: 6378135,
  rf: 298.26,
  ellipseName: "WGS 72"
};
var mk = Dt.WGS84 = {
  a: 6378137,
  rf: 298.257223563,
  ellipseName: "WGS 84"
};
Dt.sphere = {
  a: 6370997,
  b: 6370997,
  ellipseName: "Normal Sphere (r=6370997)"
};
function vk(i, e, t, r) {
  var n = i * i, s = e * e, a = (n - s) / n, o = 0;
  r ? (i *= 1 - a * (D8 + a * (k8 + a * H8)), n = i * i, a = 0) : o = Math.sqrt(a);
  var A = (n - s) / s;
  return {
    es: a,
    e: o,
    ep2: A
  };
}
function yk(i, e, t, r, n) {
  if (!i) {
    var s = ul(Dt, r);
    s || (s = mk), i = s.a, e = s.b, t = s.rf;
  }
  return t && !e && (e = (1 - 1 / t) * i), (t === 0 || Math.abs(i - e) < Xe) && (n = !0, e = i), {
    a: i,
    b: e,
    rf: t,
    sphere: n
  };
}
var En = {};
En.wgs84 = {
  towgs84: "0,0,0",
  ellipse: "WGS84",
  datumName: "WGS84"
};
En.ch1903 = {
  towgs84: "674.374,15.056,405.346",
  ellipse: "bessel",
  datumName: "swiss"
};
En.ggrs87 = {
  towgs84: "-199.87,74.79,246.62",
  ellipse: "GRS80",
  datumName: "Greek_Geodetic_Reference_System_1987"
};
En.nad83 = {
  towgs84: "0,0,0",
  ellipse: "GRS80",
  datumName: "North_American_Datum_1983"
};
En.nad27 = {
  nadgrids: "@conus,@alaska,@ntv2_0.gsb,@ntv1_can.dat",
  ellipse: "clrk66",
  datumName: "North_American_Datum_1927"
};
En.potsdam = {
  towgs84: "598.1,73.7,418.2,0.202,0.045,-2.455,6.7",
  ellipse: "bessel",
  datumName: "Potsdam Rauenberg 1950 DHDN"
};
En.carthage = {
  towgs84: "-263.0,6.0,431.0",
  ellipse: "clark80",
  datumName: "Carthage 1934 Tunisia"
};
En.hermannskogel = {
  towgs84: "577.326,90.129,463.919,5.137,1.474,5.297,2.4232",
  ellipse: "bessel",
  datumName: "Hermannskogel"
};
En.osni52 = {
  towgs84: "482.530,-130.596,564.557,-1.042,-0.214,-0.631,8.15",
  ellipse: "airy",
  datumName: "Irish National"
};
En.ire65 = {
  towgs84: "482.530,-130.596,564.557,-1.042,-0.214,-0.631,8.15",
  ellipse: "mod_airy",
  datumName: "Ireland 1965"
};
En.rassadiran = {
  towgs84: "-133.63,-157.5,-158.62",
  ellipse: "intl",
  datumName: "Rassadiran"
};
En.nzgd49 = {
  towgs84: "59.47,-5.04,187.44,0.47,-0.1,1.024,-4.5993",
  ellipse: "intl",
  datumName: "New Zealand Geodetic Datum 1949"
};
En.osgb36 = {
  towgs84: "446.448,-125.157,542.060,0.1502,0.2470,0.8421,-20.4894",
  ellipse: "airy",
  datumName: "Airy 1830"
};
En.s_jtsk = {
  towgs84: "589,76,480",
  ellipse: "bessel",
  datumName: "S-JTSK (Ferro)"
};
En.beduaram = {
  towgs84: "-106,-87,188",
  ellipse: "clrk80",
  datumName: "Beduaram"
};
En.gunung_segara = {
  towgs84: "-403,684,41",
  ellipse: "bessel",
  datumName: "Gunung Segara Jakarta"
};
En.rnb72 = {
  towgs84: "106.869,-52.2978,103.724,-0.33657,0.456955,-1.84218,1",
  ellipse: "intl",
  datumName: "Reseau National Belge 1972"
};
function _k(i, e, t, r, n, s, a) {
  var o = {};
  return i === void 0 || i === "none" ? o.datum_type = Yw : o.datum_type = U8, e && (o.datum_params = e.map(parseFloat), (o.datum_params[0] !== 0 || o.datum_params[1] !== 0 || o.datum_params[2] !== 0) && (o.datum_type = mh), o.datum_params.length > 3 && (o.datum_params[3] !== 0 || o.datum_params[4] !== 0 || o.datum_params[5] !== 0 || o.datum_params[6] !== 0) && (o.datum_type = vh, o.datum_params[3] *= hd, o.datum_params[4] *= hd, o.datum_params[5] *= hd, o.datum_params[6] = o.datum_params[6] / 1e6 + 1)), a && (o.datum_type = Zc, o.grids = a), o.a = t, o.b = r, o.es = n, o.ep2 = s, o;
}
var yM = {};
function wk(i, e) {
  var t = new DataView(e), r = Ek(t), n = Bk(t, r);
  n.nSubgrids > 1 && console.log("Only single NTv2 subgrids are currently supported, subsequent sub grids are ignored");
  var s = bk(t, n, r), a = { header: n, subgrids: s };
  return yM[i] = a, a;
}
function xk(i) {
  if (i === void 0)
    return null;
  var e = i.split(",");
  return e.map(Ck);
}
function Ck(i) {
  if (i.length === 0)
    return null;
  var e = i[0] === "@";
  return e && (i = i.slice(1)), i === "null" ? { name: "null", mandatory: !e, grid: null, isNull: !0 } : {
    name: i,
    mandatory: !e,
    grid: yM[i] || null,
    isNull: !1
  };
}
function Uc(i) {
  return i / 3600 * Math.PI / 180;
}
function Ek(i) {
  var e = i.getInt32(8, !1);
  return e === 11 ? !1 : (e = i.getInt32(8, !0), e !== 11 && console.warn("Failed to detect nadgrid endian-ness, defaulting to little-endian"), !0);
}
function Bk(i, e) {
  return {
    nFields: i.getInt32(8, e),
    nSubgridFields: i.getInt32(24, e),
    nSubgrids: i.getInt32(40, e),
    shiftType: Zw(i, 56, 56 + 8).trim(),
    fromSemiMajorAxis: i.getFloat64(120, e),
    fromSemiMinorAxis: i.getFloat64(136, e),
    toSemiMajorAxis: i.getFloat64(152, e),
    toSemiMinorAxis: i.getFloat64(168, e)
  };
}
function Zw(i, e, t) {
  return String.fromCharCode.apply(null, new Uint8Array(i.buffer.slice(e, t)));
}
function bk(i, e, t) {
  for (var r = 176, n = [], s = 0; s < e.nSubgrids; s++) {
    var a = Tk(i, r, t), o = Fk(i, r, a, t), A = Math.round(
      1 + (a.upperLongitude - a.lowerLongitude) / a.longitudeInterval
    ), l = Math.round(
      1 + (a.upperLatitude - a.lowerLatitude) / a.latitudeInterval
    );
    n.push({
      ll: [Uc(a.lowerLongitude), Uc(a.lowerLatitude)],
      del: [Uc(a.longitudeInterval), Uc(a.latitudeInterval)],
      lim: [A, l],
      count: a.gridNodeCount,
      cvs: Sk(o)
    });
  }
  return n;
}
function Sk(i) {
  return i.map(function(e) {
    return [Uc(e.longitudeShift), Uc(e.latitudeShift)];
  });
}
function Tk(i, e, t) {
  return {
    name: Zw(i, e + 8, e + 16).trim(),
    parent: Zw(i, e + 24, e + 24 + 8).trim(),
    lowerLatitude: i.getFloat64(e + 72, t),
    upperLatitude: i.getFloat64(e + 88, t),
    lowerLongitude: i.getFloat64(e + 104, t),
    upperLongitude: i.getFloat64(e + 120, t),
    latitudeInterval: i.getFloat64(e + 136, t),
    longitudeInterval: i.getFloat64(e + 152, t),
    gridNodeCount: i.getInt32(e + 168, t)
  };
}
function Fk(i, e, t, r) {
  for (var n = e + 176, s = 16, a = [], o = 0; o < t.gridNodeCount; o++) {
    var A = {
      latitudeShift: i.getFloat32(n + o * s, r),
      longitudeShift: i.getFloat32(n + o * s + 4, r),
      latitudeAccuracy: i.getFloat32(n + o * s + 8, r),
      longitudeAccuracy: i.getFloat32(n + o * s + 12, r)
    };
    a.push(A);
  }
  return a;
}
function ja(i, e) {
  if (!(this instanceof ja))
    return new ja(i);
  e = e || function(l) {
    if (l)
      throw l;
  };
  var t = nk(i);
  if (typeof t != "object") {
    e(i);
    return;
  }
  var r = ja.projections.get(t.projName);
  if (!r) {
    e(i);
    return;
  }
  if (t.datumCode && t.datumCode !== "none") {
    var n = ul(En, t.datumCode);
    n && (t.datum_params = t.datum_params || (n.towgs84 ? n.towgs84.split(",") : null), t.ellps = n.ellipse, t.datumName = n.datumName ? n.datumName : t.datumCode);
  }
  t.k0 = t.k0 || 1, t.axis = t.axis || "enu", t.ellps = t.ellps || "wgs84", t.lat1 = t.lat1 || t.lat0;
  var s = yk(t.a, t.b, t.rf, t.ellps, t.sphere), a = vk(s.a, s.b, s.rf, t.R_A), o = xk(t.nadgrids), A = t.datum || _k(
    t.datumCode,
    t.datum_params,
    s.a,
    s.b,
    a.es,
    a.ep2,
    o
  );
  jS(this, t), jS(this, r), this.a = s.a, this.b = s.b, this.rf = s.rf, this.sphere = s.sphere, this.es = a.es, this.e = a.e, this.ep2 = a.ep2, this.datum = A, this.init(), e(null, this);
}
ja.projections = pk;
ja.projections.start();
function Lk(i, e) {
  return i.datum_type !== e.datum_type || i.a !== e.a || Math.abs(i.es - e.es) > 5e-11 ? !1 : i.datum_type === mh ? i.datum_params[0] === e.datum_params[0] && i.datum_params[1] === e.datum_params[1] && i.datum_params[2] === e.datum_params[2] : i.datum_type === vh ? i.datum_params[0] === e.datum_params[0] && i.datum_params[1] === e.datum_params[1] && i.datum_params[2] === e.datum_params[2] && i.datum_params[3] === e.datum_params[3] && i.datum_params[4] === e.datum_params[4] && i.datum_params[5] === e.datum_params[5] && i.datum_params[6] === e.datum_params[6] : !0;
}
function _M(i, e, t) {
  var r = i.x, n = i.y, s = i.z ? i.z : 0, a, o, A, l;
  if (n < -Qe && n > -1.001 * Qe)
    n = -Qe;
  else if (n > Qe && n < 1.001 * Qe)
    n = Qe;
  else {
    if (n < -Qe)
      return { x: -1 / 0, y: -1 / 0, z: i.z };
    if (n > Qe)
      return { x: 1 / 0, y: 1 / 0, z: i.z };
  }
  return r > Math.PI && (r -= 2 * Math.PI), o = Math.sin(n), l = Math.cos(n), A = o * o, a = t / Math.sqrt(1 - e * A), {
    x: (a + s) * l * Math.cos(r),
    y: (a + s) * l * Math.sin(r),
    z: (a * (1 - e) + s) * o
  };
}
function wM(i, e, t, r) {
  var n = 1e-12, s = n * n, a = 30, o, A, l, h, c, u, f, g, p, y, v, w, C, E = i.x, S = i.y, M = i.z ? i.z : 0, T, F, k;
  if (o = Math.sqrt(E * E + S * S), A = Math.sqrt(E * E + S * S + M * M), o / t < n) {
    if (T = 0, A / t < n)
      return F = Qe, k = -r, {
        x: i.x,
        y: i.y,
        z: i.z
      };
  } else
    T = Math.atan2(S, E);
  l = M / A, h = o / A, c = 1 / Math.sqrt(1 - e * (2 - e) * h * h), g = h * (1 - e) * c, p = l * c, C = 0;
  do
    C++, f = t / Math.sqrt(1 - e * p * p), k = o * g + M * p - f * (1 - e * p * p), u = e * f / (f + k), c = 1 / Math.sqrt(1 - u * (2 - u) * h * h), y = h * (1 - u) * c, v = l * c, w = v * g - y * p, g = y, p = v;
  while (w * w > s && C < a);
  return F = Math.atan(v / Math.abs(y)), {
    x: T,
    y: F,
    z: k
  };
}
function Ik(i, e, t) {
  if (e === mh)
    return {
      x: i.x + t[0],
      y: i.y + t[1],
      z: i.z + t[2]
    };
  if (e === vh) {
    var r = t[0], n = t[1], s = t[2], a = t[3], o = t[4], A = t[5], l = t[6];
    return {
      x: l * (i.x - A * i.y + o * i.z) + r,
      y: l * (A * i.x + i.y - a * i.z) + n,
      z: l * (-o * i.x + a * i.y + i.z) + s
    };
  }
}
function Rk(i, e, t) {
  if (e === mh)
    return {
      x: i.x - t[0],
      y: i.y - t[1],
      z: i.z - t[2]
    };
  if (e === vh) {
    var r = t[0], n = t[1], s = t[2], a = t[3], o = t[4], A = t[5], l = t[6], h = (i.x - r) / l, c = (i.y - n) / l, u = (i.z - s) / l;
    return {
      x: h + A * c - o * u,
      y: -A * h + c + a * u,
      z: o * h - a * c + u
    };
  }
}
function Lp(i) {
  return i === mh || i === vh;
}
function Mk(i, e, t) {
  if (Lk(i, e) || i.datum_type === Yw || e.datum_type === Yw)
    return t;
  var r = i.a, n = i.es;
  if (i.datum_type === Zc) {
    var s = XS(i, !1, t);
    if (s !== 0)
      return;
    r = GS, n = $S;
  }
  var a = e.a, o = e.b, A = e.es;
  if (e.datum_type === Zc && (a = GS, o = Q8, A = $S), n === A && r === a && !Lp(i.datum_type) && !Lp(e.datum_type))
    return t;
  if (t = _M(t, n, r), Lp(i.datum_type) && (t = Ik(t, i.datum_type, i.datum_params)), Lp(e.datum_type) && (t = Rk(t, e.datum_type, e.datum_params)), t = wM(t, A, a, o), e.datum_type === Zc) {
    var l = XS(e, !0, t);
    if (l !== 0)
      return;
  }
  return t;
}
function XS(i, e, t) {
  if (i.grids === null || i.grids.length === 0)
    return console.log("Grid shift grids not found"), -1;
  for (var r = { x: -t.x, y: t.y }, n = { x: Number.NaN, y: Number.NaN }, s = [], a = 0; a < i.grids.length; a++) {
    var o = i.grids[a];
    if (s.push(o.name), o.isNull) {
      n = r;
      break;
    }
    if (o.mandatory, o.grid === null) {
      if (o.mandatory)
        return console.log("Unable to find mandatory grid '" + o.name + "'"), -1;
      continue;
    }
    var A = o.grid.subgrids[0], l = (Math.abs(A.del[1]) + Math.abs(A.del[0])) / 1e4, h = A.ll[0] - l, c = A.ll[1] - l, u = A.ll[0] + (A.lim[0] - 1) * A.del[0] + l, f = A.ll[1] + (A.lim[1] - 1) * A.del[1] + l;
    if (!(c > r.y || h > r.x || f < r.y || u < r.x) && (n = Nk(r, e, A), !isNaN(n.x)))
      break;
  }
  return isNaN(n.x) ? (console.log("Failed to find a grid shift table for location '" + -r.x * Ha + " " + r.y * Ha + " tried: '" + s + "'"), -1) : (t.x = -n.x, t.y = n.y, 0);
}
function Nk(i, e, t) {
  var r = { x: Number.NaN, y: Number.NaN };
  if (isNaN(i.x))
    return r;
  var n = { x: i.x, y: i.y };
  n.x -= t.ll[0], n.y -= t.ll[1], n.x = it(n.x - Math.PI) + Math.PI;
  var s = WS(n, t);
  if (e) {
    if (isNaN(s.x))
      return r;
    s.x = n.x - s.x, s.y = n.y - s.y;
    var a = 9, o = 1e-12, A, l;
    do {
      if (l = WS(s, t), isNaN(l.x)) {
        console.log("Inverse grid shift iteration failed, presumably at grid edge.  Using first approximation.");
        break;
      }
      A = { x: n.x - (l.x + s.x), y: n.y - (l.y + s.y) }, s.x += A.x, s.y += A.y;
    } while (a-- && Math.abs(A.x) > o && Math.abs(A.y) > o);
    if (a < 0)
      return console.log("Inverse grid shift iterator failed to converge."), r;
    r.x = it(s.x + t.ll[0]), r.y = s.y + t.ll[1];
  } else
    isNaN(s.x) || (r.x = i.x + s.x, r.y = i.y + s.y);
  return r;
}
function WS(i, e) {
  var t = { x: i.x / e.del[0], y: i.y / e.del[1] }, r = { x: Math.floor(t.x), y: Math.floor(t.y) }, n = { x: t.x - 1 * r.x, y: t.y - 1 * r.y }, s = { x: Number.NaN, y: Number.NaN }, a;
  if (r.x < 0 || r.x >= e.lim[0] || r.y < 0 || r.y >= e.lim[1])
    return s;
  a = r.y * e.lim[0] + r.x;
  var o = { x: e.cvs[a][0], y: e.cvs[a][1] };
  a++;
  var A = { x: e.cvs[a][0], y: e.cvs[a][1] };
  a += e.lim[0];
  var l = { x: e.cvs[a][0], y: e.cvs[a][1] };
  a--;
  var h = { x: e.cvs[a][0], y: e.cvs[a][1] }, c = n.x * n.y, u = n.x * (1 - n.y), f = (1 - n.x) * (1 - n.y), g = (1 - n.x) * n.y;
  return s.x = f * o.x + u * A.x + g * h.x + c * l.x, s.y = f * o.y + u * A.y + g * h.y + c * l.y, s;
}
function YS(i, e, t) {
  var r = t.x, n = t.y, s = t.z || 0, a, o, A, l = {};
  for (A = 0; A < 3; A++)
    if (!(e && A === 2 && t.z === void 0))
      switch (A === 0 ? (a = r, "ew".indexOf(i.axis[A]) !== -1 ? o = "x" : o = "y") : A === 1 ? (a = n, "ns".indexOf(i.axis[A]) !== -1 ? o = "y" : o = "x") : (a = s, o = "z"), i.axis[A]) {
        case "e":
          l[o] = a;
          break;
        case "w":
          l[o] = -a;
          break;
        case "n":
          l[o] = a;
          break;
        case "s":
          l[o] = -a;
          break;
        case "u":
          t[o] !== void 0 && (l.z = a);
          break;
        case "d":
          t[o] !== void 0 && (l.z = -a);
          break;
        default:
          return null;
      }
  return l;
}
function xM(i) {
  var e = {
    x: i[0],
    y: i[1]
  };
  return i.length > 2 && (e.z = i[2]), i.length > 3 && (e.m = i[3]), e;
}
function Pk(i) {
  qS(i.x), qS(i.y);
}
function qS(i) {
  if (typeof Number.isFinite == "function") {
    if (Number.isFinite(i))
      return;
    throw new TypeError("coordinates must be finite numbers");
  }
  if (typeof i != "number" || i !== i || !isFinite(i))
    throw new TypeError("coordinates must be finite numbers");
}
function Ok(i, e) {
  return (i.datum.datum_type === mh || i.datum.datum_type === vh || i.datum.datum_type === Zc) && e.datumCode !== "WGS84" || (e.datum.datum_type === mh || e.datum.datum_type === vh || e.datum.datum_type === Zc) && i.datumCode !== "WGS84";
}
function Lm(i, e, t, r) {
  var n;
  Array.isArray(t) ? t = xM(t) : t = {
    x: t.x,
    y: t.y,
    z: t.z,
    m: t.m
  };
  var s = t.z !== void 0;
  if (Pk(t), i.datum && e.datum && Ok(i, e) && (n = new ja("WGS84"), t = Lm(i, n, t, r), i = n), r && i.axis !== "enu" && (t = YS(i, !1, t)), i.projName === "longlat")
    t = {
      x: t.x * Sn,
      y: t.y * Sn,
      z: t.z || 0
    };
  else if (i.to_meter && (t = {
    x: t.x * i.to_meter,
    y: t.y * i.to_meter,
    z: t.z || 0
  }), t = i.inverse(t), !t)
    return;
  if (i.from_greenwich && (t.x += i.from_greenwich), t = Mk(i.datum, e.datum, t), !!t)
    return e.from_greenwich && (t = {
      x: t.x - e.from_greenwich,
      y: t.y,
      z: t.z || 0
    }), e.projName === "longlat" ? t = {
      x: t.x * Ha,
      y: t.y * Ha,
      z: t.z || 0
    } : (t = e.forward(t), e.to_meter && (t = {
      x: t.x / e.to_meter,
      y: t.y / e.to_meter,
      z: t.z || 0
    })), r && e.axis !== "enu" ? YS(e, !0, t) : (s || delete t.z, t);
}
var ZS = ja("WGS84");
function N1(i, e, t, r) {
  var n, s, a;
  return Array.isArray(t) ? (n = Lm(i, e, t, r) || { x: NaN, y: NaN }, t.length > 2 ? typeof i.name < "u" && i.name === "geocent" || typeof e.name < "u" && e.name === "geocent" ? typeof n.z == "number" ? [n.x, n.y, n.z].concat(t.splice(3)) : [n.x, n.y, t[2]].concat(t.splice(3)) : [n.x, n.y].concat(t.splice(2)) : [n.x, n.y]) : (s = Lm(i, e, t, r), a = Object.keys(t), a.length === 2 || a.forEach(function(o) {
    if (typeof i.name < "u" && i.name === "geocent" || typeof e.name < "u" && e.name === "geocent") {
      if (o === "x" || o === "y" || o === "z")
        return;
    } else if (o === "x" || o === "y")
      return;
    s[o] = t[o];
  }), s);
}
function JS(i) {
  return i instanceof ja ? i : i.oProj ? i.oProj : ja(i);
}
function vs(i, e, t) {
  i = JS(i);
  var r = !1, n;
  return typeof e > "u" ? (e = i, i = ZS, r = !0) : (typeof e.x < "u" || Array.isArray(e)) && (t = e, e = i, i = ZS, r = !0), e = JS(e), t ? N1(i, e, t) : (n = {
    forward: function(s, a) {
      return N1(i, e, s, a);
    },
    inverse: function(s, a) {
      return N1(e, i, s, a);
    }
  }, r && (n.oProj = e), n);
}
var e5 = 6, CM = "AJSAJS", EM = "AFAFAF", Qc = 65, cs = 73, js = 79, Wf = 86, Yf = 90;
const Uk = {
  forward: BM,
  inverse: Qk,
  toPoint: bM
};
function BM(i, e) {
  return e = e || 5, Hk(Dk({
    lat: i[1],
    lon: i[0]
  }), e);
}
function Qk(i) {
  var e = DE(TM(i.toUpperCase()));
  return e.lat && e.lon ? [e.lon, e.lat, e.lon, e.lat] : [e.left, e.bottom, e.right, e.top];
}
function bM(i) {
  var e = DE(TM(i.toUpperCase()));
  return e.lat && e.lon ? [e.lon, e.lat] : [(e.left + e.right) / 2, (e.top + e.bottom) / 2];
}
function P1(i) {
  return i * (Math.PI / 180);
}
function t5(i) {
  return 180 * (i / Math.PI);
}
function Dk(i) {
  var e = i.lat, t = i.lon, r = 6378137, n = 669438e-8, s = 0.9996, a, o, A, l, h, c, u, f = P1(e), g = P1(t), p, y;
  y = Math.floor((t + 180) / 6) + 1, t === 180 && (y = 60), e >= 56 && e < 64 && t >= 3 && t < 12 && (y = 32), e >= 72 && e < 84 && (t >= 0 && t < 9 ? y = 31 : t >= 9 && t < 21 ? y = 33 : t >= 21 && t < 33 ? y = 35 : t >= 33 && t < 42 && (y = 37)), a = (y - 1) * 6 - 180 + 3, p = P1(a), o = n / (1 - n), A = r / Math.sqrt(1 - n * Math.sin(f) * Math.sin(f)), l = Math.tan(f) * Math.tan(f), h = o * Math.cos(f) * Math.cos(f), c = Math.cos(f) * (g - p), u = r * ((1 - n / 4 - 3 * n * n / 64 - 5 * n * n * n / 256) * f - (3 * n / 8 + 3 * n * n / 32 + 45 * n * n * n / 1024) * Math.sin(2 * f) + (15 * n * n / 256 + 45 * n * n * n / 1024) * Math.sin(4 * f) - 35 * n * n * n / 3072 * Math.sin(6 * f));
  var v = s * A * (c + (1 - l + h) * c * c * c / 6 + (5 - 18 * l + l * l + 72 * h - 58 * o) * c * c * c * c * c / 120) + 5e5, w = s * (u + A * Math.tan(f) * (c * c / 2 + (5 - l + 9 * h + 4 * h * h) * c * c * c * c / 24 + (61 - 58 * l + l * l + 600 * h - 330 * o) * c * c * c * c * c * c / 720));
  return e < 0 && (w += 1e7), {
    northing: Math.round(w),
    easting: Math.round(v),
    zoneNumber: y,
    zoneLetter: kk(e)
  };
}
function DE(i) {
  var e = i.northing, t = i.easting, r = i.zoneLetter, n = i.zoneNumber;
  if (n < 0 || n > 60)
    return null;
  var s = 0.9996, a = 6378137, o = 669438e-8, A, l = (1 - Math.sqrt(1 - o)) / (1 + Math.sqrt(1 - o)), h, c, u, f, g, p, y, v, w, C = t - 5e5, E = e;
  r < "N" && (E -= 1e7), y = (n - 1) * 6 - 180 + 3, A = o / (1 - o), p = E / s, v = p / (a * (1 - o / 4 - 3 * o * o / 64 - 5 * o * o * o / 256)), w = v + (3 * l / 2 - 27 * l * l * l / 32) * Math.sin(2 * v) + (21 * l * l / 16 - 55 * l * l * l * l / 32) * Math.sin(4 * v) + 151 * l * l * l / 96 * Math.sin(6 * v), h = a / Math.sqrt(1 - o * Math.sin(w) * Math.sin(w)), c = Math.tan(w) * Math.tan(w), u = A * Math.cos(w) * Math.cos(w), f = a * (1 - o) / Math.pow(1 - o * Math.sin(w) * Math.sin(w), 1.5), g = C / (h * s);
  var S = w - h * Math.tan(w) / f * (g * g / 2 - (5 + 3 * c + 10 * u - 4 * u * u - 9 * A) * g * g * g * g / 24 + (61 + 90 * c + 298 * u + 45 * c * c - 252 * A - 3 * u * u) * g * g * g * g * g * g / 720);
  S = t5(S);
  var M = (g - (1 + 2 * c + u) * g * g * g / 6 + (5 - 2 * u + 28 * c - 3 * u * u + 8 * A + 24 * c * c) * g * g * g * g * g / 120) / Math.cos(w);
  M = y + t5(M);
  var T;
  if (i.accuracy) {
    var F = DE({
      northing: i.northing + i.accuracy,
      easting: i.easting + i.accuracy,
      zoneLetter: i.zoneLetter,
      zoneNumber: i.zoneNumber
    });
    T = {
      top: F.lat,
      right: F.lon,
      bottom: S,
      left: M
    };
  } else
    T = {
      lat: S,
      lon: M
    };
  return T;
}
function kk(i) {
  var e = "Z";
  return 84 >= i && i >= 72 ? e = "X" : 72 > i && i >= 64 ? e = "W" : 64 > i && i >= 56 ? e = "V" : 56 > i && i >= 48 ? e = "U" : 48 > i && i >= 40 ? e = "T" : 40 > i && i >= 32 ? e = "S" : 32 > i && i >= 24 ? e = "R" : 24 > i && i >= 16 ? e = "Q" : 16 > i && i >= 8 ? e = "P" : 8 > i && i >= 0 ? e = "N" : 0 > i && i >= -8 ? e = "M" : -8 > i && i >= -16 ? e = "L" : -16 > i && i >= -24 ? e = "K" : -24 > i && i >= -32 ? e = "J" : -32 > i && i >= -40 ? e = "H" : -40 > i && i >= -48 ? e = "G" : -48 > i && i >= -56 ? e = "F" : -56 > i && i >= -64 ? e = "E" : -64 > i && i >= -72 ? e = "D" : -72 > i && i >= -80 && (e = "C"), e;
}
function Hk(i, e) {
  var t = "00000" + i.easting, r = "00000" + i.northing;
  return i.zoneNumber + i.zoneLetter + Gk(i.easting, i.northing, i.zoneNumber) + t.substr(t.length - 5, e) + r.substr(r.length - 5, e);
}
function Gk(i, e, t) {
  var r = SM(t), n = Math.floor(i / 1e5), s = Math.floor(e / 1e5) % 20;
  return $k(n, s, r);
}
function SM(i) {
  var e = i % e5;
  return e === 0 && (e = e5), e;
}
function $k(i, e, t) {
  var r = t - 1, n = CM.charCodeAt(r), s = EM.charCodeAt(r), a = n + i - 1, o = s + e, A = !1;
  a > Yf && (a = a - Yf + Qc - 1, A = !0), (a === cs || n < cs && a > cs || (a > cs || n < cs) && A) && a++, (a === js || n < js && a > js || (a > js || n < js) && A) && (a++, a === cs && a++), a > Yf && (a = a - Yf + Qc - 1), o > Wf ? (o = o - Wf + Qc - 1, A = !0) : A = !1, (o === cs || s < cs && o > cs || (o > cs || s < cs) && A) && o++, (o === js || s < js && o > js || (o > js || s < js) && A) && (o++, o === cs && o++), o > Wf && (o = o - Wf + Qc - 1);
  var l = String.fromCharCode(a) + String.fromCharCode(o);
  return l;
}
function TM(i) {
  if (i && i.length === 0)
    throw "MGRSPoint coverting from nothing";
  for (var e = i.length, t = null, r = "", n, s = 0; !/[A-Z]/.test(n = i.charAt(s)); ) {
    if (s >= 2)
      throw "MGRSPoint bad conversion from: " + i;
    r += n, s++;
  }
  var a = parseInt(r, 10);
  if (s === 0 || s + 3 > e)
    throw "MGRSPoint bad conversion from: " + i;
  var o = i.charAt(s++);
  if (o <= "A" || o === "B" || o === "Y" || o >= "Z" || o === "I" || o === "O")
    throw "MGRSPoint zone letter " + o + " not handled: " + i;
  t = i.substring(s, s += 2);
  for (var A = SM(a), l = Vk(t.charAt(0), A), h = Kk(t.charAt(1), A); h < jk(o); )
    h += 2e6;
  var c = e - s;
  if (c % 2 !== 0)
    throw `MGRSPoint has to have an even number 
of digits after the zone letter and two 100km letters - front 
half for easting meters, second half for 
northing meters` + i;
  var u = c / 2, f = 0, g = 0, p, y, v, w, C;
  return u > 0 && (p = 1e5 / Math.pow(10, u), y = i.substring(s, s + u), f = parseFloat(y) * p, v = i.substring(s + u), g = parseFloat(v) * p), w = f + l, C = g + h, {
    easting: w,
    northing: C,
    zoneLetter: o,
    zoneNumber: a,
    accuracy: p
  };
}
function Vk(i, e) {
  for (var t = CM.charCodeAt(e - 1), r = 1e5, n = !1; t !== i.charCodeAt(0); ) {
    if (t++, t === cs && t++, t === js && t++, t > Yf) {
      if (n)
        throw "Bad character: " + i;
      t = Qc, n = !0;
    }
    r += 1e5;
  }
  return r;
}
function Kk(i, e) {
  if (i > "V")
    throw "MGRSPoint given invalid Northing " + i;
  for (var t = EM.charCodeAt(e - 1), r = 0, n = !1; t !== i.charCodeAt(0); ) {
    if (t++, t === cs && t++, t === js && t++, t > Wf) {
      if (n)
        throw "Bad character: " + i;
      t = Qc, n = !0;
    }
    r += 1e5;
  }
  return r;
}
function jk(i) {
  var e;
  switch (i) {
    case "C":
      e = 11e5;
      break;
    case "D":
      e = 2e6;
      break;
    case "E":
      e = 28e5;
      break;
    case "F":
      e = 37e5;
      break;
    case "G":
      e = 46e5;
      break;
    case "H":
      e = 55e5;
      break;
    case "J":
      e = 64e5;
      break;
    case "K":
      e = 73e5;
      break;
    case "L":
      e = 82e5;
      break;
    case "M":
      e = 91e5;
      break;
    case "N":
      e = 0;
      break;
    case "P":
      e = 8e5;
      break;
    case "Q":
      e = 17e5;
      break;
    case "R":
      e = 26e5;
      break;
    case "S":
      e = 35e5;
      break;
    case "T":
      e = 44e5;
      break;
    case "U":
      e = 53e5;
      break;
    case "V":
      e = 62e5;
      break;
    case "W":
      e = 7e6;
      break;
    case "X":
      e = 79e5;
      break;
    default:
      e = -1;
  }
  if (e >= 0)
    return e;
  throw "Invalid zone letter: " + i;
}
function vu(i, e, t) {
  if (!(this instanceof vu))
    return new vu(i, e, t);
  if (Array.isArray(i))
    this.x = i[0], this.y = i[1], this.z = i[2] || 0;
  else if (typeof i == "object")
    this.x = i.x, this.y = i.y, this.z = i.z || 0;
  else if (typeof i == "string" && typeof e > "u") {
    var r = i.split(",");
    this.x = parseFloat(r[0], 10), this.y = parseFloat(r[1], 10), this.z = parseFloat(r[2], 10) || 0;
  } else
    this.x = i, this.y = e, this.z = t || 0;
  console.warn("proj4.Point will be removed in version 3, use proj4.toPoint");
}
vu.fromMGRS = function(i) {
  return new vu(bM(i));
};
vu.prototype.toMGRS = function(i) {
  return BM([this.x, this.y], i);
};
var zk = 1, Xk = 0.25, r5 = 0.046875, i5 = 0.01953125, n5 = 0.01068115234375, Wk = 0.75, Yk = 0.46875, qk = 0.013020833333333334, Zk = 0.007120768229166667, Jk = 0.3645833333333333, eH = 0.005696614583333333, tH = 0.3076171875;
function FM(i) {
  var e = [];
  e[0] = zk - i * (Xk + i * (r5 + i * (i5 + i * n5))), e[1] = i * (Wk - i * (r5 + i * (i5 + i * n5)));
  var t = i * i;
  return e[2] = t * (Yk - i * (qk + i * Zk)), t *= i, e[3] = t * (Jk - i * eH), e[4] = t * i * tH, e;
}
function Gv(i, e, t, r) {
  return t *= e, e *= e, r[0] * i - t * (r[1] + e * (r[2] + e * (r[3] + e * r[4])));
}
var rH = 20;
function LM(i, e, t) {
  for (var r = 1 / (1 - e), n = i, s = rH; s; --s) {
    var a = Math.sin(n), o = 1 - e * a * a;
    if (o = (Gv(n, a, Math.cos(n), t) - i) * (o * Math.sqrt(o)) * r, n -= o, Math.abs(o) < Xe)
      return n;
  }
  return n;
}
function iH() {
  this.x0 = this.x0 !== void 0 ? this.x0 : 0, this.y0 = this.y0 !== void 0 ? this.y0 : 0, this.long0 = this.long0 !== void 0 ? this.long0 : 0, this.lat0 = this.lat0 !== void 0 ? this.lat0 : 0, this.es && (this.en = FM(this.es), this.ml0 = Gv(this.lat0, Math.sin(this.lat0), Math.cos(this.lat0), this.en));
}
function nH(i) {
  var e = i.x, t = i.y, r = it(e - this.long0), n, s, a, o = Math.sin(t), A = Math.cos(t);
  if (this.es) {
    var h = A * r, c = Math.pow(h, 2), u = this.ep2 * Math.pow(A, 2), f = Math.pow(u, 2), g = Math.abs(A) > Xe ? Math.tan(t) : 0, p = Math.pow(g, 2), y = Math.pow(p, 2);
    n = 1 - this.es * Math.pow(o, 2), h = h / Math.sqrt(n);
    var v = Gv(t, o, A, this.en);
    s = this.a * (this.k0 * h * (1 + c / 6 * (1 - p + u + c / 20 * (5 - 18 * p + y + 14 * u - 58 * p * u + c / 42 * (61 + 179 * y - y * p - 479 * p))))) + this.x0, a = this.a * (this.k0 * (v - this.ml0 + o * r * h / 2 * (1 + c / 12 * (5 - p + 9 * u + 4 * f + c / 30 * (61 + y - 58 * p + 270 * u - 330 * p * u + c / 56 * (1385 + 543 * y - y * p - 3111 * p)))))) + this.y0;
  } else {
    var l = A * Math.sin(r);
    if (Math.abs(Math.abs(l) - 1) < Xe)
      return 93;
    if (s = 0.5 * this.a * this.k0 * Math.log((1 + l) / (1 - l)) + this.x0, a = A * Math.cos(r) / Math.sqrt(1 - Math.pow(l, 2)), l = Math.abs(a), l >= 1) {
      if (l - 1 > Xe)
        return 93;
      a = 0;
    } else
      a = Math.acos(a);
    t < 0 && (a = -a), a = this.a * this.k0 * (a - this.lat0) + this.y0;
  }
  return i.x = s, i.y = a, i;
}
function sH(i) {
  var e, t, r, n, s = (i.x - this.x0) * (1 / this.a), a = (i.y - this.y0) * (1 / this.a);
  if (this.es)
    if (e = this.ml0 + a / this.k0, t = LM(e, this.es, this.en), Math.abs(t) < Qe) {
      var c = Math.sin(t), u = Math.cos(t), f = Math.abs(u) > Xe ? Math.tan(t) : 0, g = this.ep2 * Math.pow(u, 2), p = Math.pow(g, 2), y = Math.pow(f, 2), v = Math.pow(y, 2);
      e = 1 - this.es * Math.pow(c, 2);
      var w = s * Math.sqrt(e) / this.k0, C = Math.pow(w, 2);
      e = e * f, r = t - e * C / (1 - this.es) * 0.5 * (1 - C / 12 * (5 + 3 * y - 9 * g * y + g - 4 * p - C / 30 * (61 + 90 * y - 252 * g * y + 45 * v + 46 * g - C / 56 * (1385 + 3633 * y + 4095 * v + 1574 * v * y)))), n = it(this.long0 + w * (1 - C / 6 * (1 + 2 * y + g - C / 20 * (5 + 28 * y + 24 * v + 8 * g * y + 6 * g - C / 42 * (61 + 662 * y + 1320 * v + 720 * v * y)))) / u);
    } else
      r = Qe * yg(a), n = 0;
  else {
    var o = Math.exp(s / this.k0), A = 0.5 * (o - 1 / o), l = this.lat0 + a / this.k0, h = Math.cos(l);
    e = Math.sqrt((1 - Math.pow(h, 2)) / (1 + Math.pow(A, 2))), r = Math.asin(e), a < 0 && (r = -r), A === 0 && h === 0 ? n = 0 : n = it(Math.atan2(A, h) + this.long0);
  }
  return i.x = n, i.y = r, i;
}
var aH = ["Fast_Transverse_Mercator", "Fast Transverse Mercator"];
const H0 = {
  init: iH,
  forward: nH,
  inverse: sH,
  names: aH
};
function IM(i) {
  var e = Math.exp(i);
  return e = (e - 1 / e) / 2, e;
}
function wa(i, e) {
  i = Math.abs(i), e = Math.abs(e);
  var t = Math.max(i, e), r = Math.min(i, e) / (t || 1);
  return t * Math.sqrt(1 + Math.pow(r, 2));
}
function oH(i) {
  var e = 1 + i, t = e - 1;
  return t === 0 ? i : i * Math.log(e) / t;
}
function AH(i) {
  var e = Math.abs(i);
  return e = oH(e * (1 + e / (wa(1, e) + 1))), i < 0 ? -e : e;
}
function kE(i, e) {
  for (var t = 2 * Math.cos(2 * e), r = i.length - 1, n = i[r], s = 0, a; --r >= 0; )
    a = -s + t * n + i[r], s = n, n = a;
  return e + a * Math.sin(2 * e);
}
function lH(i, e) {
  for (var t = 2 * Math.cos(e), r = i.length - 1, n = i[r], s = 0, a; --r >= 0; )
    a = -s + t * n + i[r], s = n, n = a;
  return Math.sin(e) * a;
}
function hH(i) {
  var e = Math.exp(i);
  return e = (e + 1 / e) / 2, e;
}
function RM(i, e, t) {
  for (var r = Math.sin(e), n = Math.cos(e), s = IM(t), a = hH(t), o = 2 * n * a, A = -2 * r * s, l = i.length - 1, h = i[l], c = 0, u = 0, f = 0, g, p; --l >= 0; )
    g = u, p = c, u = h, c = f, h = -g + o * u - A * c + i[l], f = -p + A * u + o * c;
  return o = r * a, A = n * s, [o * h - A * f, o * f + A * h];
}
function cH() {
  if (!this.approx && (isNaN(this.es) || this.es <= 0))
    throw new Error('Incorrect elliptical usage. Try using the +approx option in the proj string, or PROJECTION["Fast_Transverse_Mercator"] in the WKT.');
  this.approx && (H0.init.apply(this), this.forward = H0.forward, this.inverse = H0.inverse), this.x0 = this.x0 !== void 0 ? this.x0 : 0, this.y0 = this.y0 !== void 0 ? this.y0 : 0, this.long0 = this.long0 !== void 0 ? this.long0 : 0, this.lat0 = this.lat0 !== void 0 ? this.lat0 : 0, this.cgb = [], this.cbg = [], this.utg = [], this.gtu = [];
  var i = this.es / (1 + Math.sqrt(1 - this.es)), e = i / (2 - i), t = e;
  this.cgb[0] = e * (2 + e * (-2 / 3 + e * (-2 + e * (116 / 45 + e * (26 / 45 + e * (-2854 / 675)))))), this.cbg[0] = e * (-2 + e * (2 / 3 + e * (4 / 3 + e * (-82 / 45 + e * (32 / 45 + e * (4642 / 4725)))))), t = t * e, this.cgb[1] = t * (7 / 3 + e * (-8 / 5 + e * (-227 / 45 + e * (2704 / 315 + e * (2323 / 945))))), this.cbg[1] = t * (5 / 3 + e * (-16 / 15 + e * (-13 / 9 + e * (904 / 315 + e * (-1522 / 945))))), t = t * e, this.cgb[2] = t * (56 / 15 + e * (-136 / 35 + e * (-1262 / 105 + e * (73814 / 2835)))), this.cbg[2] = t * (-26 / 15 + e * (34 / 21 + e * (8 / 5 + e * (-12686 / 2835)))), t = t * e, this.cgb[3] = t * (4279 / 630 + e * (-332 / 35 + e * (-399572 / 14175))), this.cbg[3] = t * (1237 / 630 + e * (-12 / 5 + e * (-24832 / 14175))), t = t * e, this.cgb[4] = t * (4174 / 315 + e * (-144838 / 6237)), this.cbg[4] = t * (-734 / 315 + e * (109598 / 31185)), t = t * e, this.cgb[5] = t * (601676 / 22275), this.cbg[5] = t * (444337 / 155925), t = Math.pow(e, 2), this.Qn = this.k0 / (1 + e) * (1 + t * (1 / 4 + t * (1 / 64 + t / 256))), this.utg[0] = e * (-0.5 + e * (2 / 3 + e * (-37 / 96 + e * (1 / 360 + e * (81 / 512 + e * (-96199 / 604800)))))), this.gtu[0] = e * (0.5 + e * (-2 / 3 + e * (5 / 16 + e * (41 / 180 + e * (-127 / 288 + e * (7891 / 37800)))))), this.utg[1] = t * (-1 / 48 + e * (-1 / 15 + e * (437 / 1440 + e * (-46 / 105 + e * (1118711 / 3870720))))), this.gtu[1] = t * (13 / 48 + e * (-3 / 5 + e * (557 / 1440 + e * (281 / 630 + e * (-1983433 / 1935360))))), t = t * e, this.utg[2] = t * (-17 / 480 + e * (37 / 840 + e * (209 / 4480 + e * (-5569 / 90720)))), this.gtu[2] = t * (61 / 240 + e * (-103 / 140 + e * (15061 / 26880 + e * (167603 / 181440)))), t = t * e, this.utg[3] = t * (-4397 / 161280 + e * (11 / 504 + e * (830251 / 7257600))), this.gtu[3] = t * (49561 / 161280 + e * (-179 / 168 + e * (6601661 / 7257600))), t = t * e, this.utg[4] = t * (-4583 / 161280 + e * (108847 / 3991680)), this.gtu[4] = t * (34729 / 80640 + e * (-3418889 / 1995840)), t = t * e, this.utg[5] = t * (-20648693 / 638668800), this.gtu[5] = t * (212378941 / 319334400);
  var r = kE(this.cbg, this.lat0);
  this.Zb = -this.Qn * (r + lH(this.gtu, 2 * r));
}
function uH(i) {
  var e = it(i.x - this.long0), t = i.y;
  t = kE(this.cbg, t);
  var r = Math.sin(t), n = Math.cos(t), s = Math.sin(e), a = Math.cos(e);
  t = Math.atan2(r, a * n), e = Math.atan2(s * n, wa(r, n * a)), e = AH(Math.tan(e));
  var o = RM(this.gtu, 2 * t, 2 * e);
  t = t + o[0], e = e + o[1];
  var A, l;
  return Math.abs(e) <= 2.623395162778 ? (A = this.a * (this.Qn * e) + this.x0, l = this.a * (this.Qn * t + this.Zb) + this.y0) : (A = 1 / 0, l = 1 / 0), i.x = A, i.y = l, i;
}
function fH(i) {
  var e = (i.x - this.x0) * (1 / this.a), t = (i.y - this.y0) * (1 / this.a);
  t = (t - this.Zb) / this.Qn, e = e / this.Qn;
  var r, n;
  if (Math.abs(e) <= 2.623395162778) {
    var s = RM(this.utg, 2 * t, 2 * e);
    t = t + s[0], e = e + s[1], e = Math.atan(IM(e));
    var a = Math.sin(t), o = Math.cos(t), A = Math.sin(e), l = Math.cos(e);
    t = Math.atan2(a * l, wa(A, l * o)), e = Math.atan2(A, l * o), r = it(e + this.long0), n = kE(this.cgb, t);
  } else
    r = 1 / 0, n = 1 / 0;
  return i.x = r, i.y = n, i;
}
var dH = ["Extended_Transverse_Mercator", "Extended Transverse Mercator", "etmerc", "Transverse_Mercator", "Transverse Mercator", "tmerc"];
const G0 = {
  init: cH,
  forward: uH,
  inverse: fH,
  names: dH
};
function gH(i, e) {
  if (i === void 0) {
    if (i = Math.floor((it(e) + Math.PI) * 30 / Math.PI) + 1, i < 0)
      return 0;
    if (i > 60)
      return 60;
  }
  return i;
}
var pH = "etmerc";
function mH() {
  var i = gH(this.zone, this.long0);
  if (i === void 0)
    throw new Error("unknown utm zone");
  this.lat0 = 0, this.long0 = (6 * Math.abs(i) - 183) * Sn, this.x0 = 5e5, this.y0 = this.utmSouth ? 1e7 : 0, this.k0 = 0.9996, G0.init.apply(this), this.forward = G0.forward, this.inverse = G0.inverse;
}
var vH = ["Universal Transverse Mercator System", "utm"];
const yH = {
  init: mH,
  names: vH,
  dependsOn: pH
};
function HE(i, e) {
  return Math.pow((1 - i) / (1 + i), e);
}
var _H = 20;
function wH() {
  var i = Math.sin(this.lat0), e = Math.cos(this.lat0);
  e *= e, this.rc = Math.sqrt(1 - this.es) / (1 - this.es * i * i), this.C = Math.sqrt(1 + this.es * e * e / (1 - this.es)), this.phic0 = Math.asin(i / this.C), this.ratexp = 0.5 * this.C * this.e, this.K = Math.tan(0.5 * this.phic0 + Nr) / (Math.pow(Math.tan(0.5 * this.lat0 + Nr), this.C) * HE(this.e * i, this.ratexp));
}
function xH(i) {
  var e = i.x, t = i.y;
  return i.y = 2 * Math.atan(this.K * Math.pow(Math.tan(0.5 * t + Nr), this.C) * HE(this.e * Math.sin(t), this.ratexp)) - Qe, i.x = this.C * e, i;
}
function CH(i) {
  for (var e = 1e-14, t = i.x / this.C, r = i.y, n = Math.pow(Math.tan(0.5 * r + Nr) / this.K, 1 / this.C), s = _H; s > 0 && (r = 2 * Math.atan(n * HE(this.e * Math.sin(i.y), -0.5 * this.e)) - Qe, !(Math.abs(r - i.y) < e)); --s)
    i.y = r;
  return s ? (i.x = t, i.y = r, i) : null;
}
var EH = ["gauss"];
const GE = {
  init: wH,
  forward: xH,
  inverse: CH,
  names: EH
};
function BH() {
  GE.init.apply(this), this.rc && (this.sinc0 = Math.sin(this.phic0), this.cosc0 = Math.cos(this.phic0), this.R2 = 2 * this.rc, this.title || (this.title = "Oblique Stereographic Alternative"));
}
function bH(i) {
  var e, t, r, n;
  return i.x = it(i.x - this.long0), GE.forward.apply(this, [i]), e = Math.sin(i.y), t = Math.cos(i.y), r = Math.cos(i.x), n = this.k0 * this.R2 / (1 + this.sinc0 * e + this.cosc0 * t * r), i.x = n * t * Math.sin(i.x), i.y = n * (this.cosc0 * e - this.sinc0 * t * r), i.x = this.a * i.x + this.x0, i.y = this.a * i.y + this.y0, i;
}
function SH(i) {
  var e, t, r, n, s;
  if (i.x = (i.x - this.x0) / this.a, i.y = (i.y - this.y0) / this.a, i.x /= this.k0, i.y /= this.k0, s = Math.sqrt(i.x * i.x + i.y * i.y)) {
    var a = 2 * Math.atan2(s, this.R2);
    e = Math.sin(a), t = Math.cos(a), n = Math.asin(t * this.sinc0 + i.y * e * this.cosc0 / s), r = Math.atan2(i.x * e, s * this.cosc0 * t - i.y * this.sinc0 * e);
  } else
    n = this.phic0, r = 0;
  return i.x = r, i.y = n, GE.inverse.apply(this, [i]), i.x = it(i.x + this.long0), i;
}
var TH = ["Stereographic_North_Pole", "Oblique_Stereographic", "Polar_Stereographic", "sterea", "Oblique Stereographic Alternative", "Double_Stereographic"];
const FH = {
  init: BH,
  forward: bH,
  inverse: SH,
  names: TH
};
function LH(i, e, t) {
  return e *= t, Math.tan(0.5 * (Qe + i)) * Math.pow((1 - e) / (1 + e), 0.5 * t);
}
function IH() {
  this.coslat0 = Math.cos(this.lat0), this.sinlat0 = Math.sin(this.lat0), this.sphere ? this.k0 === 1 && !isNaN(this.lat_ts) && Math.abs(this.coslat0) <= Xe && (this.k0 = 0.5 * (1 + yg(this.lat0) * Math.sin(this.lat_ts))) : (Math.abs(this.coslat0) <= Xe && (this.lat0 > 0 ? this.con = 1 : this.con = -1), this.cons = Math.sqrt(Math.pow(1 + this.e, 1 + this.e) * Math.pow(1 - this.e, 1 - this.e)), this.k0 === 1 && !isNaN(this.lat_ts) && Math.abs(this.coslat0) <= Xe && (this.k0 = 0.5 * this.cons * Ya(this.e, Math.sin(this.lat_ts), Math.cos(this.lat_ts)) / Ca(this.e, this.con * this.lat_ts, this.con * Math.sin(this.lat_ts))), this.ms1 = Ya(this.e, this.sinlat0, this.coslat0), this.X0 = 2 * Math.atan(this.ssfn_(this.lat0, this.sinlat0, this.e)) - Qe, this.cosX0 = Math.cos(this.X0), this.sinX0 = Math.sin(this.X0));
}
function RH(i) {
  var e = i.x, t = i.y, r = Math.sin(t), n = Math.cos(t), s, a, o, A, l, h, c = it(e - this.long0);
  return Math.abs(Math.abs(e - this.long0) - Math.PI) <= Xe && Math.abs(t + this.lat0) <= Xe ? (i.x = NaN, i.y = NaN, i) : this.sphere ? (s = 2 * this.k0 / (1 + this.sinlat0 * r + this.coslat0 * n * Math.cos(c)), i.x = this.a * s * n * Math.sin(c) + this.x0, i.y = this.a * s * (this.coslat0 * r - this.sinlat0 * n * Math.cos(c)) + this.y0, i) : (a = 2 * Math.atan(this.ssfn_(t, r, this.e)) - Qe, A = Math.cos(a), o = Math.sin(a), Math.abs(this.coslat0) <= Xe ? (l = Ca(this.e, t * this.con, this.con * r), h = 2 * this.a * this.k0 * l / this.cons, i.x = this.x0 + h * Math.sin(e - this.long0), i.y = this.y0 - this.con * h * Math.cos(e - this.long0), i) : (Math.abs(this.sinlat0) < Xe ? (s = 2 * this.a * this.k0 / (1 + A * Math.cos(c)), i.y = s * o) : (s = 2 * this.a * this.k0 * this.ms1 / (this.cosX0 * (1 + this.sinX0 * o + this.cosX0 * A * Math.cos(c))), i.y = s * (this.cosX0 * o - this.sinX0 * A * Math.cos(c)) + this.y0), i.x = s * A * Math.sin(c) + this.x0, i));
}
function MH(i) {
  i.x -= this.x0, i.y -= this.y0;
  var e, t, r, n, s, a = Math.sqrt(i.x * i.x + i.y * i.y);
  if (this.sphere) {
    var o = 2 * Math.atan(a / (2 * this.a * this.k0));
    return e = this.long0, t = this.lat0, a <= Xe ? (i.x = e, i.y = t, i) : (t = Math.asin(Math.cos(o) * this.sinlat0 + i.y * Math.sin(o) * this.coslat0 / a), Math.abs(this.coslat0) < Xe ? this.lat0 > 0 ? e = it(this.long0 + Math.atan2(i.x, -1 * i.y)) : e = it(this.long0 + Math.atan2(i.x, i.y)) : e = it(this.long0 + Math.atan2(i.x * Math.sin(o), a * this.coslat0 * Math.cos(o) - i.y * this.sinlat0 * Math.sin(o))), i.x = e, i.y = t, i);
  } else if (Math.abs(this.coslat0) <= Xe) {
    if (a <= Xe)
      return t = this.lat0, e = this.long0, i.x = e, i.y = t, i;
    i.x *= this.con, i.y *= this.con, r = a * this.cons / (2 * this.a * this.k0), t = this.con * kd(this.e, r), e = this.con * it(this.con * this.long0 + Math.atan2(i.x, -1 * i.y));
  } else
    n = 2 * Math.atan(a * this.cosX0 / (2 * this.a * this.k0 * this.ms1)), e = this.long0, a <= Xe ? s = this.X0 : (s = Math.asin(Math.cos(n) * this.sinX0 + i.y * Math.sin(n) * this.cosX0 / a), e = it(this.long0 + Math.atan2(i.x * Math.sin(n), a * this.cosX0 * Math.cos(n) - i.y * this.sinX0 * Math.sin(n)))), t = -1 * kd(this.e, Math.tan(0.5 * (Qe + s)));
  return i.x = e, i.y = t, i;
}
var NH = ["stere", "Stereographic_South_Pole", "Polar Stereographic (variant B)"];
const PH = {
  init: IH,
  forward: RH,
  inverse: MH,
  names: NH,
  ssfn_: LH
};
function OH() {
  var i = this.lat0;
  this.lambda0 = this.long0;
  var e = Math.sin(i), t = this.a, r = this.rf, n = 1 / r, s = 2 * n - Math.pow(n, 2), a = this.e = Math.sqrt(s);
  this.R = this.k0 * t * Math.sqrt(1 - s) / (1 - s * Math.pow(e, 2)), this.alpha = Math.sqrt(1 + s / (1 - s) * Math.pow(Math.cos(i), 4)), this.b0 = Math.asin(e / this.alpha);
  var o = Math.log(Math.tan(Math.PI / 4 + this.b0 / 2)), A = Math.log(Math.tan(Math.PI / 4 + i / 2)), l = Math.log((1 + a * e) / (1 - a * e));
  this.K = o - this.alpha * A + this.alpha * a / 2 * l;
}
function UH(i) {
  var e = Math.log(Math.tan(Math.PI / 4 - i.y / 2)), t = this.e / 2 * Math.log((1 + this.e * Math.sin(i.y)) / (1 - this.e * Math.sin(i.y))), r = -this.alpha * (e + t) + this.K, n = 2 * (Math.atan(Math.exp(r)) - Math.PI / 4), s = this.alpha * (i.x - this.lambda0), a = Math.atan(Math.sin(s) / (Math.sin(this.b0) * Math.tan(n) + Math.cos(this.b0) * Math.cos(s))), o = Math.asin(Math.cos(this.b0) * Math.sin(n) - Math.sin(this.b0) * Math.cos(n) * Math.cos(s));
  return i.y = this.R / 2 * Math.log((1 + Math.sin(o)) / (1 - Math.sin(o))) + this.y0, i.x = this.R * a + this.x0, i;
}
function QH(i) {
  for (var e = i.x - this.x0, t = i.y - this.y0, r = e / this.R, n = 2 * (Math.atan(Math.exp(t / this.R)) - Math.PI / 4), s = Math.asin(Math.cos(this.b0) * Math.sin(n) + Math.sin(this.b0) * Math.cos(n) * Math.cos(r)), a = Math.atan(Math.sin(r) / (Math.cos(this.b0) * Math.cos(r) - Math.sin(this.b0) * Math.tan(n))), o = this.lambda0 + a / this.alpha, A = 0, l = s, h = -1e3, c = 0; Math.abs(l - h) > 1e-7; ) {
    if (++c > 20)
      return;
    A = 1 / this.alpha * (Math.log(Math.tan(Math.PI / 4 + s / 2)) - this.K) + this.e * Math.log(Math.tan(Math.PI / 4 + Math.asin(this.e * Math.sin(l)) / 2)), h = l, l = 2 * Math.atan(Math.exp(A)) - Math.PI / 2;
  }
  return i.x = o, i.y = l, i;
}
var DH = ["somerc"];
const kH = {
  init: OH,
  forward: UH,
  inverse: QH,
  names: DH
};
var Bc = 1e-7;
function HH(i) {
  var e = ["Hotine_Oblique_Mercator", "Hotine_Oblique_Mercator_Azimuth_Natural_Origin"], t = typeof i.PROJECTION == "object" ? Object.keys(i.PROJECTION)[0] : i.PROJECTION;
  return "no_uoff" in i || "no_off" in i || e.indexOf(t) !== -1;
}
function GH() {
  var i, e, t, r, n, s, a, o, A, l, h = 0, c, u = 0, f = 0, g = 0, p = 0, y = 0, v = 0;
  this.no_off = HH(this), this.no_rot = "no_rot" in this;
  var w = !1;
  "alpha" in this && (w = !0);
  var C = !1;
  if ("rectified_grid_angle" in this && (C = !0), w && (v = this.alpha), C && (h = this.rectified_grid_angle * Sn), w || C)
    u = this.longc;
  else if (f = this.long1, p = this.lat1, g = this.long2, y = this.lat2, Math.abs(p - y) <= Bc || (i = Math.abs(p)) <= Bc || Math.abs(i - Qe) <= Bc || Math.abs(Math.abs(this.lat0) - Qe) <= Bc || Math.abs(Math.abs(y) - Qe) <= Bc)
    throw new Error();
  var E = 1 - this.es;
  e = Math.sqrt(E), Math.abs(this.lat0) > Xe ? (o = Math.sin(this.lat0), t = Math.cos(this.lat0), i = 1 - this.es * o * o, this.B = t * t, this.B = Math.sqrt(1 + this.es * this.B * this.B / E), this.A = this.B * this.k0 * e / i, r = this.B * e / (t * Math.sqrt(i)), n = r * r - 1, n <= 0 ? n = 0 : (n = Math.sqrt(n), this.lat0 < 0 && (n = -n)), this.E = n += r, this.E *= Math.pow(Ca(this.e, this.lat0, o), this.B)) : (this.B = 1 / e, this.A = this.k0, this.E = r = n = 1), w || C ? (w ? (c = Math.asin(Math.sin(v) / r), C || (h = v)) : (c = h, v = Math.asin(r * Math.sin(c))), this.lam0 = u - Math.asin(0.5 * (n - 1 / n) * Math.tan(c)) / this.B) : (s = Math.pow(Ca(this.e, p, Math.sin(p)), this.B), a = Math.pow(Ca(this.e, y, Math.sin(y)), this.B), n = this.E / s, A = (a - s) / (a + s), l = this.E * this.E, l = (l - a * s) / (l + a * s), i = f - g, i < -Math.pi ? g -= Qd : i > Math.pi && (g += Qd), this.lam0 = it(0.5 * (f + g) - Math.atan(l * Math.tan(0.5 * this.B * (f - g)) / A) / this.B), c = Math.atan(2 * Math.sin(this.B * it(f - this.lam0)) / (n - 1 / n)), h = v = Math.asin(r * Math.sin(c))), this.singam = Math.sin(c), this.cosgam = Math.cos(c), this.sinrot = Math.sin(h), this.cosrot = Math.cos(h), this.rB = 1 / this.B, this.ArB = this.A * this.rB, this.BrA = 1 / this.ArB, this.A * this.B, this.no_off ? this.u_0 = 0 : (this.u_0 = Math.abs(this.ArB * Math.atan(Math.sqrt(r * r - 1) / Math.cos(v))), this.lat0 < 0 && (this.u_0 = -this.u_0)), n = 0.5 * c, this.v_pole_n = this.ArB * Math.log(Math.tan(Nr - n)), this.v_pole_s = this.ArB * Math.log(Math.tan(Nr + n));
}
function $H(i) {
  var e = {}, t, r, n, s, a, o, A, l;
  if (i.x = i.x - this.lam0, Math.abs(Math.abs(i.y) - Qe) > Xe) {
    if (a = this.E / Math.pow(Ca(this.e, i.y, Math.sin(i.y)), this.B), o = 1 / a, t = 0.5 * (a - o), r = 0.5 * (a + o), s = Math.sin(this.B * i.x), n = (t * this.singam - s * this.cosgam) / r, Math.abs(Math.abs(n) - 1) < Xe)
      throw new Error();
    l = 0.5 * this.ArB * Math.log((1 - n) / (1 + n)), o = Math.cos(this.B * i.x), Math.abs(o) < Bc ? A = this.A * i.x : A = this.ArB * Math.atan2(t * this.cosgam + s * this.singam, o);
  } else
    l = i.y > 0 ? this.v_pole_n : this.v_pole_s, A = this.ArB * i.y;
  return this.no_rot ? (e.x = A, e.y = l) : (A -= this.u_0, e.x = l * this.cosrot + A * this.sinrot, e.y = A * this.cosrot - l * this.sinrot), e.x = this.a * e.x + this.x0, e.y = this.a * e.y + this.y0, e;
}
function VH(i) {
  var e, t, r, n, s, a, o, A = {};
  if (i.x = (i.x - this.x0) * (1 / this.a), i.y = (i.y - this.y0) * (1 / this.a), this.no_rot ? (t = i.y, e = i.x) : (t = i.x * this.cosrot - i.y * this.sinrot, e = i.y * this.cosrot + i.x * this.sinrot + this.u_0), r = Math.exp(-this.BrA * t), n = 0.5 * (r - 1 / r), s = 0.5 * (r + 1 / r), a = Math.sin(this.BrA * e), o = (a * this.cosgam + n * this.singam) / s, Math.abs(Math.abs(o) - 1) < Xe)
    A.x = 0, A.y = o < 0 ? -Qe : Qe;
  else {
    if (A.y = this.E / Math.sqrt((1 + o) / (1 - o)), A.y = kd(this.e, Math.pow(A.y, 1 / this.B)), A.y === 1 / 0)
      throw new Error();
    A.x = -this.rB * Math.atan2(n * this.cosgam - a * this.singam, Math.cos(this.BrA * e));
  }
  return A.x += this.lam0, A;
}
var KH = ["Hotine_Oblique_Mercator", "Hotine Oblique Mercator", "Hotine_Oblique_Mercator_Azimuth_Natural_Origin", "Hotine_Oblique_Mercator_Two_Point_Natural_Origin", "Hotine_Oblique_Mercator_Azimuth_Center", "Oblique_Mercator", "omerc"];
const jH = {
  init: GH,
  forward: $H,
  inverse: VH,
  names: KH
};
function zH() {
  if (this.lat2 || (this.lat2 = this.lat1), this.k0 || (this.k0 = 1), this.x0 = this.x0 || 0, this.y0 = this.y0 || 0, !(Math.abs(this.lat1 + this.lat2) < Xe)) {
    var i = this.b / this.a;
    this.e = Math.sqrt(1 - i * i);
    var e = Math.sin(this.lat1), t = Math.cos(this.lat1), r = Ya(this.e, e, t), n = Ca(this.e, this.lat1, e), s = Math.sin(this.lat2), a = Math.cos(this.lat2), o = Ya(this.e, s, a), A = Ca(this.e, this.lat2, s), l = Ca(this.e, this.lat0, Math.sin(this.lat0));
    Math.abs(this.lat1 - this.lat2) > Xe ? this.ns = Math.log(r / o) / Math.log(n / A) : this.ns = e, isNaN(this.ns) && (this.ns = e), this.f0 = r / (this.ns * Math.pow(n, this.ns)), this.rh = this.a * this.f0 * Math.pow(l, this.ns), this.title || (this.title = "Lambert Conformal Conic");
  }
}
function XH(i) {
  var e = i.x, t = i.y;
  Math.abs(2 * Math.abs(t) - Math.PI) <= Xe && (t = yg(t) * (Qe - 2 * Xe));
  var r = Math.abs(Math.abs(t) - Qe), n, s;
  if (r > Xe)
    n = Ca(this.e, t, Math.sin(t)), s = this.a * this.f0 * Math.pow(n, this.ns);
  else {
    if (r = t * this.ns, r <= 0)
      return null;
    s = 0;
  }
  var a = this.ns * it(e - this.long0);
  return i.x = this.k0 * (s * Math.sin(a)) + this.x0, i.y = this.k0 * (this.rh - s * Math.cos(a)) + this.y0, i;
}
function WH(i) {
  var e, t, r, n, s, a = (i.x - this.x0) / this.k0, o = this.rh - (i.y - this.y0) / this.k0;
  this.ns > 0 ? (e = Math.sqrt(a * a + o * o), t = 1) : (e = -Math.sqrt(a * a + o * o), t = -1);
  var A = 0;
  if (e !== 0 && (A = Math.atan2(t * a, t * o)), e !== 0 || this.ns > 0) {
    if (t = 1 / this.ns, r = Math.pow(e / (this.a * this.f0), t), n = kd(this.e, r), n === -9999)
      return null;
  } else
    n = -Qe;
  return s = it(A / this.ns + this.long0), i.x = s, i.y = n, i;
}
var YH = [
  "Lambert Tangential Conformal Conic Projection",
  "Lambert_Conformal_Conic",
  "Lambert_Conformal_Conic_1SP",
  "Lambert_Conformal_Conic_2SP",
  "lcc",
  "Lambert Conic Conformal (1SP)",
  "Lambert Conic Conformal (2SP)"
];
const qH = {
  init: zH,
  forward: XH,
  inverse: WH,
  names: YH
};
function ZH() {
  this.a = 6377397155e-3, this.es = 0.006674372230614, this.e = Math.sqrt(this.es), this.lat0 || (this.lat0 = 0.863937979737193), this.long0 || (this.long0 = 0.7417649320975901 - 0.308341501185665), this.k0 || (this.k0 = 0.9999), this.s45 = 0.785398163397448, this.s90 = 2 * this.s45, this.fi0 = this.lat0, this.e2 = this.es, this.e = Math.sqrt(this.e2), this.alfa = Math.sqrt(1 + this.e2 * Math.pow(Math.cos(this.fi0), 4) / (1 - this.e2)), this.uq = 1.04216856380474, this.u0 = Math.asin(Math.sin(this.fi0) / this.alfa), this.g = Math.pow((1 + this.e * Math.sin(this.fi0)) / (1 - this.e * Math.sin(this.fi0)), this.alfa * this.e / 2), this.k = Math.tan(this.u0 / 2 + this.s45) / Math.pow(Math.tan(this.fi0 / 2 + this.s45), this.alfa) * this.g, this.k1 = this.k0, this.n0 = this.a * Math.sqrt(1 - this.e2) / (1 - this.e2 * Math.pow(Math.sin(this.fi0), 2)), this.s0 = 1.37008346281555, this.n = Math.sin(this.s0), this.ro0 = this.k1 * this.n0 / Math.tan(this.s0), this.ad = this.s90 - this.uq;
}
function JH(i) {
  var e, t, r, n, s, a, o, A = i.x, l = i.y, h = it(A - this.long0);
  return e = Math.pow((1 + this.e * Math.sin(l)) / (1 - this.e * Math.sin(l)), this.alfa * this.e / 2), t = 2 * (Math.atan(this.k * Math.pow(Math.tan(l / 2 + this.s45), this.alfa) / e) - this.s45), r = -h * this.alfa, n = Math.asin(Math.cos(this.ad) * Math.sin(t) + Math.sin(this.ad) * Math.cos(t) * Math.cos(r)), s = Math.asin(Math.cos(t) * Math.sin(r) / Math.cos(n)), a = this.n * s, o = this.ro0 * Math.pow(Math.tan(this.s0 / 2 + this.s45), this.n) / Math.pow(Math.tan(n / 2 + this.s45), this.n), i.y = o * Math.cos(a) / 1, i.x = o * Math.sin(a) / 1, this.czech || (i.y *= -1, i.x *= -1), i;
}
function eG(i) {
  var e, t, r, n, s, a, o, A, l = i.x;
  i.x = i.y, i.y = l, this.czech || (i.y *= -1, i.x *= -1), a = Math.sqrt(i.x * i.x + i.y * i.y), s = Math.atan2(i.y, i.x), n = s / Math.sin(this.s0), r = 2 * (Math.atan(Math.pow(this.ro0 / a, 1 / this.n) * Math.tan(this.s0 / 2 + this.s45)) - this.s45), e = Math.asin(Math.cos(this.ad) * Math.sin(r) - Math.sin(this.ad) * Math.cos(r) * Math.cos(n)), t = Math.asin(Math.cos(r) * Math.sin(n) / Math.cos(e)), i.x = this.long0 - t / this.alfa, o = e, A = 0;
  var h = 0;
  do
    i.y = 2 * (Math.atan(Math.pow(this.k, -1 / this.alfa) * Math.pow(Math.tan(e / 2 + this.s45), 1 / this.alfa) * Math.pow((1 + this.e * Math.sin(o)) / (1 - this.e * Math.sin(o)), this.e / 2)) - this.s45), Math.abs(o - i.y) < 1e-10 && (A = 1), o = i.y, h += 1;
  while (A === 0 && h < 15);
  return h >= 15 ? null : i;
}
var tG = ["Krovak", "krovak"];
const rG = {
  init: ZH,
  forward: JH,
  inverse: eG,
  names: tG
};
function ts(i, e, t, r, n) {
  return i * n - e * Math.sin(2 * n) + t * Math.sin(4 * n) - r * Math.sin(6 * n);
}
function _g(i) {
  return 1 - 0.25 * i * (1 + i / 16 * (3 + 1.25 * i));
}
function wg(i) {
  return 0.375 * i * (1 + 0.25 * i * (1 + 0.46875 * i));
}
function xg(i) {
  return 0.05859375 * i * i * (1 + 0.75 * i);
}
function Cg(i) {
  return i * i * i * (35 / 3072);
}
function yu(i, e, t) {
  var r = e * t;
  return i / Math.sqrt(1 - r * r);
}
function Iu(i) {
  return Math.abs(i) < Qe ? i : i - yg(i) * Math.PI;
}
function Im(i, e, t, r, n) {
  var s, a;
  s = i / e;
  for (var o = 0; o < 15; o++)
    if (a = (i - (e * s - t * Math.sin(2 * s) + r * Math.sin(4 * s) - n * Math.sin(6 * s))) / (e - 2 * t * Math.cos(2 * s) + 4 * r * Math.cos(4 * s) - 6 * n * Math.cos(6 * s)), s += a, Math.abs(a) <= 1e-10)
      return s;
  return NaN;
}
function iG() {
  this.sphere || (this.e0 = _g(this.es), this.e1 = wg(this.es), this.e2 = xg(this.es), this.e3 = Cg(this.es), this.ml0 = this.a * ts(this.e0, this.e1, this.e2, this.e3, this.lat0));
}
function nG(i) {
  var e, t, r = i.x, n = i.y;
  if (r = it(r - this.long0), this.sphere)
    e = this.a * Math.asin(Math.cos(n) * Math.sin(r)), t = this.a * (Math.atan2(Math.tan(n), Math.cos(r)) - this.lat0);
  else {
    var s = Math.sin(n), a = Math.cos(n), o = yu(this.a, this.e, s), A = Math.tan(n) * Math.tan(n), l = r * Math.cos(n), h = l * l, c = this.es * a * a / (1 - this.es), u = this.a * ts(this.e0, this.e1, this.e2, this.e3, n);
    e = o * l * (1 - h * A * (1 / 6 - (8 - A + 8 * c) * h / 120)), t = u - this.ml0 + o * s / a * h * (0.5 + (5 - A + 6 * c) * h / 24);
  }
  return i.x = e + this.x0, i.y = t + this.y0, i;
}
function sG(i) {
  i.x -= this.x0, i.y -= this.y0;
  var e = i.x / this.a, t = i.y / this.a, r, n;
  if (this.sphere) {
    var s = t + this.lat0;
    r = Math.asin(Math.sin(s) * Math.cos(e)), n = Math.atan2(Math.tan(e), Math.cos(s));
  } else {
    var a = this.ml0 / this.a + t, o = Im(a, this.e0, this.e1, this.e2, this.e3);
    if (Math.abs(Math.abs(o) - Qe) <= Xe)
      return i.x = this.long0, i.y = Qe, t < 0 && (i.y *= -1), i;
    var A = yu(this.a, this.e, Math.sin(o)), l = A * A * A / this.a / this.a * (1 - this.es), h = Math.pow(Math.tan(o), 2), c = e * this.a / A, u = c * c;
    r = o - A * Math.tan(o) / l * c * c * (0.5 - (1 + 3 * h) * c * c / 24), n = c * (1 - u * (h / 3 + (1 + 3 * h) * h * u / 15)) / Math.cos(o);
  }
  return i.x = it(n + this.long0), i.y = Iu(r), i;
}
var aG = ["Cassini", "Cassini_Soldner", "cass"];
const oG = {
  init: iG,
  forward: nG,
  inverse: sG,
  names: aG
};
function nl(i, e) {
  var t;
  return i > 1e-7 ? (t = i * e, (1 - i * i) * (e / (1 - t * t) - 0.5 / i * Math.log((1 - t) / (1 + t)))) : 2 * e;
}
var AG = 1, lG = 2, hG = 3, cG = 4;
function uG() {
  var i = Math.abs(this.lat0);
  if (Math.abs(i - Qe) < Xe ? this.mode = this.lat0 < 0 ? this.S_POLE : this.N_POLE : Math.abs(i) < Xe ? this.mode = this.EQUIT : this.mode = this.OBLIQ, this.es > 0) {
    var e;
    switch (this.qp = nl(this.e, 1), this.mmf = 0.5 / (1 - this.es), this.apa = wG(this.es), this.mode) {
      case this.N_POLE:
        this.dd = 1;
        break;
      case this.S_POLE:
        this.dd = 1;
        break;
      case this.EQUIT:
        this.rq = Math.sqrt(0.5 * this.qp), this.dd = 1 / this.rq, this.xmf = 1, this.ymf = 0.5 * this.qp;
        break;
      case this.OBLIQ:
        this.rq = Math.sqrt(0.5 * this.qp), e = Math.sin(this.lat0), this.sinb1 = nl(this.e, e) / this.qp, this.cosb1 = Math.sqrt(1 - this.sinb1 * this.sinb1), this.dd = Math.cos(this.lat0) / (Math.sqrt(1 - this.es * e * e) * this.rq * this.cosb1), this.ymf = (this.xmf = this.rq) / this.dd, this.xmf *= this.dd;
        break;
    }
  } else
    this.mode === this.OBLIQ && (this.sinph0 = Math.sin(this.lat0), this.cosph0 = Math.cos(this.lat0));
}
function fG(i) {
  var e, t, r, n, s, a, o, A, l, h, c = i.x, u = i.y;
  if (c = it(c - this.long0), this.sphere) {
    if (s = Math.sin(u), h = Math.cos(u), r = Math.cos(c), this.mode === this.OBLIQ || this.mode === this.EQUIT) {
      if (t = this.mode === this.EQUIT ? 1 + h * r : 1 + this.sinph0 * s + this.cosph0 * h * r, t <= Xe)
        return null;
      t = Math.sqrt(2 / t), e = t * h * Math.sin(c), t *= this.mode === this.EQUIT ? s : this.cosph0 * s - this.sinph0 * h * r;
    } else if (this.mode === this.N_POLE || this.mode === this.S_POLE) {
      if (this.mode === this.N_POLE && (r = -r), Math.abs(u + this.lat0) < Xe)
        return null;
      t = Nr - u * 0.5, t = 2 * (this.mode === this.S_POLE ? Math.cos(t) : Math.sin(t)), e = t * Math.sin(c), t *= r;
    }
  } else {
    switch (o = 0, A = 0, l = 0, r = Math.cos(c), n = Math.sin(c), s = Math.sin(u), a = nl(this.e, s), (this.mode === this.OBLIQ || this.mode === this.EQUIT) && (o = a / this.qp, A = Math.sqrt(1 - o * o)), this.mode) {
      case this.OBLIQ:
        l = 1 + this.sinb1 * o + this.cosb1 * A * r;
        break;
      case this.EQUIT:
        l = 1 + A * r;
        break;
      case this.N_POLE:
        l = Qe + u, a = this.qp - a;
        break;
      case this.S_POLE:
        l = u - Qe, a = this.qp + a;
        break;
    }
    if (Math.abs(l) < Xe)
      return null;
    switch (this.mode) {
      case this.OBLIQ:
      case this.EQUIT:
        l = Math.sqrt(2 / l), this.mode === this.OBLIQ ? t = this.ymf * l * (this.cosb1 * o - this.sinb1 * A * r) : t = (l = Math.sqrt(2 / (1 + A * r))) * o * this.ymf, e = this.xmf * l * A * n;
        break;
      case this.N_POLE:
      case this.S_POLE:
        a >= 0 ? (e = (l = Math.sqrt(a)) * n, t = r * (this.mode === this.S_POLE ? l : -l)) : e = t = 0;
        break;
    }
  }
  return i.x = this.a * e + this.x0, i.y = this.a * t + this.y0, i;
}
function dG(i) {
  i.x -= this.x0, i.y -= this.y0;
  var e = i.x / this.a, t = i.y / this.a, r, n, s, a, o, A, l;
  if (this.sphere) {
    var h = 0, c, u = 0;
    if (c = Math.sqrt(e * e + t * t), n = c * 0.5, n > 1)
      return null;
    switch (n = 2 * Math.asin(n), (this.mode === this.OBLIQ || this.mode === this.EQUIT) && (u = Math.sin(n), h = Math.cos(n)), this.mode) {
      case this.EQUIT:
        n = Math.abs(c) <= Xe ? 0 : Math.asin(t * u / c), e *= u, t = h * c;
        break;
      case this.OBLIQ:
        n = Math.abs(c) <= Xe ? this.lat0 : Math.asin(h * this.sinph0 + t * u * this.cosph0 / c), e *= u * this.cosph0, t = (h - Math.sin(n) * this.sinph0) * c;
        break;
      case this.N_POLE:
        t = -t, n = Qe - n;
        break;
      case this.S_POLE:
        n -= Qe;
        break;
    }
    r = t === 0 && (this.mode === this.EQUIT || this.mode === this.OBLIQ) ? 0 : Math.atan2(e, t);
  } else {
    if (l = 0, this.mode === this.OBLIQ || this.mode === this.EQUIT) {
      if (e /= this.dd, t *= this.dd, A = Math.sqrt(e * e + t * t), A < Xe)
        return i.x = this.long0, i.y = this.lat0, i;
      a = 2 * Math.asin(0.5 * A / this.rq), s = Math.cos(a), e *= a = Math.sin(a), this.mode === this.OBLIQ ? (l = s * this.sinb1 + t * a * this.cosb1 / A, o = this.qp * l, t = A * this.cosb1 * s - t * this.sinb1 * a) : (l = t * a / A, o = this.qp * l, t = A * s);
    } else if (this.mode === this.N_POLE || this.mode === this.S_POLE) {
      if (this.mode === this.N_POLE && (t = -t), o = e * e + t * t, !o)
        return i.x = this.long0, i.y = this.lat0, i;
      l = 1 - o / this.qp, this.mode === this.S_POLE && (l = -l);
    }
    r = Math.atan2(e, t), n = xG(Math.asin(l), this.apa);
  }
  return i.x = it(this.long0 + r), i.y = n, i;
}
var gG = 0.3333333333333333, pG = 0.17222222222222222, mG = 0.10257936507936508, vG = 0.06388888888888888, yG = 0.0664021164021164, _G = 0.016415012942191543;
function wG(i) {
  var e, t = [];
  return t[0] = i * gG, e = i * i, t[0] += e * pG, t[1] = e * vG, e *= i, t[0] += e * mG, t[1] += e * yG, t[2] = e * _G, t;
}
function xG(i, e) {
  var t = i + i;
  return i + e[0] * Math.sin(t) + e[1] * Math.sin(t + t) + e[2] * Math.sin(t + t + t);
}
var CG = ["Lambert Azimuthal Equal Area", "Lambert_Azimuthal_Equal_Area", "laea"];
const EG = {
  init: uG,
  forward: fG,
  inverse: dG,
  names: CG,
  S_POLE: AG,
  N_POLE: lG,
  EQUIT: hG,
  OBLIQ: cG
};
function fl(i) {
  return Math.abs(i) > 1 && (i = i > 1 ? 1 : -1), Math.asin(i);
}
function BG() {
  Math.abs(this.lat1 + this.lat2) < Xe || (this.temp = this.b / this.a, this.es = 1 - Math.pow(this.temp, 2), this.e3 = Math.sqrt(this.es), this.sin_po = Math.sin(this.lat1), this.cos_po = Math.cos(this.lat1), this.t1 = this.sin_po, this.con = this.sin_po, this.ms1 = Ya(this.e3, this.sin_po, this.cos_po), this.qs1 = nl(this.e3, this.sin_po), this.sin_po = Math.sin(this.lat2), this.cos_po = Math.cos(this.lat2), this.t2 = this.sin_po, this.ms2 = Ya(this.e3, this.sin_po, this.cos_po), this.qs2 = nl(this.e3, this.sin_po), this.sin_po = Math.sin(this.lat0), this.cos_po = Math.cos(this.lat0), this.t3 = this.sin_po, this.qs0 = nl(this.e3, this.sin_po), Math.abs(this.lat1 - this.lat2) > Xe ? this.ns0 = (this.ms1 * this.ms1 - this.ms2 * this.ms2) / (this.qs2 - this.qs1) : this.ns0 = this.con, this.c = this.ms1 * this.ms1 + this.ns0 * this.qs1, this.rh = this.a * Math.sqrt(this.c - this.ns0 * this.qs0) / this.ns0);
}
function bG(i) {
  var e = i.x, t = i.y;
  this.sin_phi = Math.sin(t), this.cos_phi = Math.cos(t);
  var r = nl(this.e3, this.sin_phi), n = this.a * Math.sqrt(this.c - this.ns0 * r) / this.ns0, s = this.ns0 * it(e - this.long0), a = n * Math.sin(s) + this.x0, o = this.rh - n * Math.cos(s) + this.y0;
  return i.x = a, i.y = o, i;
}
function SG(i) {
  var e, t, r, n, s, a;
  return i.x -= this.x0, i.y = this.rh - i.y + this.y0, this.ns0 >= 0 ? (e = Math.sqrt(i.x * i.x + i.y * i.y), r = 1) : (e = -Math.sqrt(i.x * i.x + i.y * i.y), r = -1), n = 0, e !== 0 && (n = Math.atan2(r * i.x, r * i.y)), r = e * this.ns0 / this.a, this.sphere ? a = Math.asin((this.c - r * r) / (2 * this.ns0)) : (t = (this.c - r * r) / this.ns0, a = this.phi1z(this.e3, t)), s = it(n / this.ns0 + this.long0), i.x = s, i.y = a, i;
}
function TG(i, e) {
  var t, r, n, s, a, o = fl(0.5 * e);
  if (i < Xe)
    return o;
  for (var A = i * i, l = 1; l <= 25; l++)
    if (t = Math.sin(o), r = Math.cos(o), n = i * t, s = 1 - n * n, a = 0.5 * s * s / r * (e / (1 - A) - t / s + 0.5 / i * Math.log((1 - n) / (1 + n))), o = o + a, Math.abs(a) <= 1e-7)
      return o;
  return null;
}
var FG = ["Albers_Conic_Equal_Area", "Albers", "aea"];
const LG = {
  init: BG,
  forward: bG,
  inverse: SG,
  names: FG,
  phi1z: TG
};
function IG() {
  this.sin_p14 = Math.sin(this.lat0), this.cos_p14 = Math.cos(this.lat0), this.infinity_dist = 1e3 * this.a, this.rc = 1;
}
function RG(i) {
  var e, t, r, n, s, a, o, A, l = i.x, h = i.y;
  return r = it(l - this.long0), e = Math.sin(h), t = Math.cos(h), n = Math.cos(r), a = this.sin_p14 * e + this.cos_p14 * t * n, s = 1, a > 0 || Math.abs(a) <= Xe ? (o = this.x0 + this.a * s * t * Math.sin(r) / a, A = this.y0 + this.a * s * (this.cos_p14 * e - this.sin_p14 * t * n) / a) : (o = this.x0 + this.infinity_dist * t * Math.sin(r), A = this.y0 + this.infinity_dist * (this.cos_p14 * e - this.sin_p14 * t * n)), i.x = o, i.y = A, i;
}
function MG(i) {
  var e, t, r, n, s, a;
  return i.x = (i.x - this.x0) / this.a, i.y = (i.y - this.y0) / this.a, i.x /= this.k0, i.y /= this.k0, (e = Math.sqrt(i.x * i.x + i.y * i.y)) ? (n = Math.atan2(e, this.rc), t = Math.sin(n), r = Math.cos(n), a = fl(r * this.sin_p14 + i.y * t * this.cos_p14 / e), s = Math.atan2(i.x * t, e * this.cos_p14 * r - i.y * this.sin_p14 * t), s = it(this.long0 + s)) : (a = this.phic0, s = 0), i.x = s, i.y = a, i;
}
var NG = ["gnom"];
const PG = {
  init: IG,
  forward: RG,
  inverse: MG,
  names: NG
};
function OG(i, e) {
  var t = 1 - (1 - i * i) / (2 * i) * Math.log((1 - i) / (1 + i));
  if (Math.abs(Math.abs(e) - t) < 1e-6)
    return e < 0 ? -1 * Qe : Qe;
  for (var r = Math.asin(0.5 * e), n, s, a, o, A = 0; A < 30; A++)
    if (s = Math.sin(r), a = Math.cos(r), o = i * s, n = Math.pow(1 - o * o, 2) / (2 * a) * (e / (1 - i * i) - s / (1 - o * o) + 0.5 / i * Math.log((1 - o) / (1 + o))), r += n, Math.abs(n) <= 1e-10)
      return r;
  return NaN;
}
function UG() {
  this.sphere || (this.k0 = Ya(this.e, Math.sin(this.lat_ts), Math.cos(this.lat_ts)));
}
function QG(i) {
  var e = i.x, t = i.y, r, n, s = it(e - this.long0);
  if (this.sphere)
    r = this.x0 + this.a * s * Math.cos(this.lat_ts), n = this.y0 + this.a * Math.sin(t) / Math.cos(this.lat_ts);
  else {
    var a = nl(this.e, Math.sin(t));
    r = this.x0 + this.a * this.k0 * s, n = this.y0 + this.a * a * 0.5 / this.k0;
  }
  return i.x = r, i.y = n, i;
}
function DG(i) {
  i.x -= this.x0, i.y -= this.y0;
  var e, t;
  return this.sphere ? (e = it(this.long0 + i.x / this.a / Math.cos(this.lat_ts)), t = Math.asin(i.y / this.a * Math.cos(this.lat_ts))) : (t = OG(this.e, 2 * i.y * this.k0 / this.a), e = it(this.long0 + i.x / (this.a * this.k0))), i.x = e, i.y = t, i;
}
var kG = ["cea"];
const HG = {
  init: UG,
  forward: QG,
  inverse: DG,
  names: kG
};
function GG() {
  this.x0 = this.x0 || 0, this.y0 = this.y0 || 0, this.lat0 = this.lat0 || 0, this.long0 = this.long0 || 0, this.lat_ts = this.lat_ts || 0, this.title = this.title || "Equidistant Cylindrical (Plate Carre)", this.rc = Math.cos(this.lat_ts);
}
function $G(i) {
  var e = i.x, t = i.y, r = it(e - this.long0), n = Iu(t - this.lat0);
  return i.x = this.x0 + this.a * r * this.rc, i.y = this.y0 + this.a * n, i;
}
function VG(i) {
  var e = i.x, t = i.y;
  return i.x = it(this.long0 + (e - this.x0) / (this.a * this.rc)), i.y = Iu(this.lat0 + (t - this.y0) / this.a), i;
}
var KG = ["Equirectangular", "Equidistant_Cylindrical", "eqc"];
const jG = {
  init: GG,
  forward: $G,
  inverse: VG,
  names: KG
};
var s5 = 20;
function zG() {
  this.temp = this.b / this.a, this.es = 1 - Math.pow(this.temp, 2), this.e = Math.sqrt(this.es), this.e0 = _g(this.es), this.e1 = wg(this.es), this.e2 = xg(this.es), this.e3 = Cg(this.es), this.ml0 = this.a * ts(this.e0, this.e1, this.e2, this.e3, this.lat0);
}
function XG(i) {
  var e = i.x, t = i.y, r, n, s, a = it(e - this.long0);
  if (s = a * Math.sin(t), this.sphere)
    Math.abs(t) <= Xe ? (r = this.a * a, n = -1 * this.a * this.lat0) : (r = this.a * Math.sin(s) / Math.tan(t), n = this.a * (Iu(t - this.lat0) + (1 - Math.cos(s)) / Math.tan(t)));
  else if (Math.abs(t) <= Xe)
    r = this.a * a, n = -1 * this.ml0;
  else {
    var o = yu(this.a, this.e, Math.sin(t)) / Math.tan(t);
    r = o * Math.sin(s), n = this.a * ts(this.e0, this.e1, this.e2, this.e3, t) - this.ml0 + o * (1 - Math.cos(s));
  }
  return i.x = r + this.x0, i.y = n + this.y0, i;
}
function WG(i) {
  var e, t, r, n, s, a, o, A, l;
  if (r = i.x - this.x0, n = i.y - this.y0, this.sphere)
    if (Math.abs(n + this.a * this.lat0) <= Xe)
      e = it(r / this.a + this.long0), t = 0;
    else {
      a = this.lat0 + n / this.a, o = r * r / this.a / this.a + a * a, A = a;
      var h;
      for (s = s5; s; --s)
        if (h = Math.tan(A), l = -1 * (a * (A * h + 1) - A - 0.5 * (A * A + o) * h) / ((A - a) / h - 1), A += l, Math.abs(l) <= Xe) {
          t = A;
          break;
        }
      e = it(this.long0 + Math.asin(r * Math.tan(A) / this.a) / Math.sin(t));
    }
  else if (Math.abs(n + this.ml0) <= Xe)
    t = 0, e = it(this.long0 + r / this.a);
  else {
    a = (this.ml0 + n) / this.a, o = r * r / this.a / this.a + a * a, A = a;
    var c, u, f, g, p;
    for (s = s5; s; --s)
      if (p = this.e * Math.sin(A), c = Math.sqrt(1 - p * p) * Math.tan(A), u = this.a * ts(this.e0, this.e1, this.e2, this.e3, A), f = this.e0 - 2 * this.e1 * Math.cos(2 * A) + 4 * this.e2 * Math.cos(4 * A) - 6 * this.e3 * Math.cos(6 * A), g = u / this.a, l = (a * (c * g + 1) - g - 0.5 * c * (g * g + o)) / (this.es * Math.sin(2 * A) * (g * g + o - 2 * a * g) / (4 * c) + (a - g) * (c * f - 2 / Math.sin(2 * A)) - f), A -= l, Math.abs(l) <= Xe) {
        t = A;
        break;
      }
    c = Math.sqrt(1 - this.es * Math.pow(Math.sin(t), 2)) * Math.tan(t), e = it(this.long0 + Math.asin(r * c / this.a) / Math.sin(t));
  }
  return i.x = e, i.y = t, i;
}
var YG = ["Polyconic", "poly"];
const qG = {
  init: zG,
  forward: XG,
  inverse: WG,
  names: YG
};
function ZG() {
  this.A = [], this.A[1] = 0.6399175073, this.A[2] = -0.1358797613, this.A[3] = 0.063294409, this.A[4] = -0.02526853, this.A[5] = 0.0117879, this.A[6] = -55161e-7, this.A[7] = 26906e-7, this.A[8] = -1333e-6, this.A[9] = 67e-5, this.A[10] = -34e-5, this.B_re = [], this.B_im = [], this.B_re[1] = 0.7557853228, this.B_im[1] = 0, this.B_re[2] = 0.249204646, this.B_im[2] = 3371507e-9, this.B_re[3] = -1541739e-9, this.B_im[3] = 0.04105856, this.B_re[4] = -0.10162907, this.B_im[4] = 0.01727609, this.B_re[5] = -0.26623489, this.B_im[5] = -0.36249218, this.B_re[6] = -0.6870983, this.B_im[6] = -1.1651967, this.C_re = [], this.C_im = [], this.C_re[1] = 1.3231270439, this.C_im[1] = 0, this.C_re[2] = -0.577245789, this.C_im[2] = -7809598e-9, this.C_re[3] = 0.508307513, this.C_im[3] = -0.112208952, this.C_re[4] = -0.15094762, this.C_im[4] = 0.18200602, this.C_re[5] = 1.01418179, this.C_im[5] = 1.64497696, this.C_re[6] = 1.9660549, this.C_im[6] = 2.5127645, this.D = [], this.D[1] = 1.5627014243, this.D[2] = 0.5185406398, this.D[3] = -0.03333098, this.D[4] = -0.1052906, this.D[5] = -0.0368594, this.D[6] = 7317e-6, this.D[7] = 0.0122, this.D[8] = 394e-5, this.D[9] = -13e-4;
}
function JG(i) {
  var e, t = i.x, r = i.y, n = r - this.lat0, s = t - this.long0, a = n / hd * 1e-5, o = s, A = 1, l = 0;
  for (e = 1; e <= 10; e++)
    A = A * a, l = l + this.A[e] * A;
  var h = l, c = o, u = 1, f = 0, g, p, y = 0, v = 0;
  for (e = 1; e <= 6; e++)
    g = u * h - f * c, p = f * h + u * c, u = g, f = p, y = y + this.B_re[e] * u - this.B_im[e] * f, v = v + this.B_im[e] * u + this.B_re[e] * f;
  return i.x = v * this.a + this.x0, i.y = y * this.a + this.y0, i;
}
function e7(i) {
  var e, t = i.x, r = i.y, n = t - this.x0, s = r - this.y0, a = s / this.a, o = n / this.a, A = 1, l = 0, h, c, u = 0, f = 0;
  for (e = 1; e <= 6; e++)
    h = A * a - l * o, c = l * a + A * o, A = h, l = c, u = u + this.C_re[e] * A - this.C_im[e] * l, f = f + this.C_im[e] * A + this.C_re[e] * l;
  for (var g = 0; g < this.iterations; g++) {
    var p = u, y = f, v, w, C = a, E = o;
    for (e = 2; e <= 6; e++)
      v = p * u - y * f, w = y * u + p * f, p = v, y = w, C = C + (e - 1) * (this.B_re[e] * p - this.B_im[e] * y), E = E + (e - 1) * (this.B_im[e] * p + this.B_re[e] * y);
    p = 1, y = 0;
    var S = this.B_re[1], M = this.B_im[1];
    for (e = 2; e <= 6; e++)
      v = p * u - y * f, w = y * u + p * f, p = v, y = w, S = S + e * (this.B_re[e] * p - this.B_im[e] * y), M = M + e * (this.B_im[e] * p + this.B_re[e] * y);
    var T = S * S + M * M;
    u = (C * S + E * M) / T, f = (E * S - C * M) / T;
  }
  var F = u, k = f, $ = 1, I = 0;
  for (e = 1; e <= 9; e++)
    $ = $ * F, I = I + this.D[e] * $;
  var L = this.lat0 + I * hd * 1e5, P = this.long0 + k;
  return i.x = P, i.y = L, i;
}
var t7 = ["New_Zealand_Map_Grid", "nzmg"];
const r7 = {
  init: ZG,
  forward: JG,
  inverse: e7,
  names: t7
};
function i7() {
}
function n7(i) {
  var e = i.x, t = i.y, r = it(e - this.long0), n = this.x0 + this.a * r, s = this.y0 + this.a * Math.log(Math.tan(Math.PI / 4 + t / 2.5)) * 1.25;
  return i.x = n, i.y = s, i;
}
function s7(i) {
  i.x -= this.x0, i.y -= this.y0;
  var e = it(this.long0 + i.x / this.a), t = 2.5 * (Math.atan(Math.exp(0.8 * i.y / this.a)) - Math.PI / 4);
  return i.x = e, i.y = t, i;
}
var a7 = ["Miller_Cylindrical", "mill"];
const o7 = {
  init: i7,
  forward: n7,
  inverse: s7,
  names: a7
};
var A7 = 20;
function l7() {
  this.sphere ? (this.n = 1, this.m = 0, this.es = 0, this.C_y = Math.sqrt((this.m + 1) / this.n), this.C_x = this.C_y / (this.m + 1)) : this.en = FM(this.es);
}
function h7(i) {
  var e, t, r = i.x, n = i.y;
  if (r = it(r - this.long0), this.sphere) {
    if (!this.m)
      n = this.n !== 1 ? Math.asin(this.n * Math.sin(n)) : n;
    else
      for (var s = this.n * Math.sin(n), a = A7; a; --a) {
        var o = (this.m * n + Math.sin(n) - s) / (this.m + Math.cos(n));
        if (n -= o, Math.abs(o) < Xe)
          break;
      }
    e = this.a * this.C_x * r * (this.m + Math.cos(n)), t = this.a * this.C_y * n;
  } else {
    var A = Math.sin(n), l = Math.cos(n);
    t = this.a * Gv(n, A, l, this.en), e = this.a * r * l / Math.sqrt(1 - this.es * A * A);
  }
  return i.x = e, i.y = t, i;
}
function c7(i) {
  var e, t, r, n;
  return i.x -= this.x0, r = i.x / this.a, i.y -= this.y0, e = i.y / this.a, this.sphere ? (e /= this.C_y, r = r / (this.C_x * (this.m + Math.cos(e))), this.m ? e = fl((this.m * e + Math.sin(e)) / this.n) : this.n !== 1 && (e = fl(Math.sin(e) / this.n)), r = it(r + this.long0), e = Iu(e)) : (e = LM(i.y / this.a, this.es, this.en), n = Math.abs(e), n < Qe ? (n = Math.sin(e), t = this.long0 + i.x * Math.sqrt(1 - this.es * n * n) / (this.a * Math.cos(e)), r = it(t)) : n - Xe < Qe && (r = this.long0)), i.x = r, i.y = e, i;
}
var u7 = ["Sinusoidal", "sinu"];
const f7 = {
  init: l7,
  forward: h7,
  inverse: c7,
  names: u7
};
function d7() {
}
function g7(i) {
  for (var e = i.x, t = i.y, r = it(e - this.long0), n = t, s = Math.PI * Math.sin(t); ; ) {
    var a = -(n + Math.sin(n) - s) / (1 + Math.cos(n));
    if (n += a, Math.abs(a) < Xe)
      break;
  }
  n /= 2, Math.PI / 2 - Math.abs(t) < Xe && (r = 0);
  var o = 0.900316316158 * this.a * r * Math.cos(n) + this.x0, A = 1.4142135623731 * this.a * Math.sin(n) + this.y0;
  return i.x = o, i.y = A, i;
}
function p7(i) {
  var e, t;
  i.x -= this.x0, i.y -= this.y0, t = i.y / (1.4142135623731 * this.a), Math.abs(t) > 0.999999999999 && (t = 0.999999999999), e = Math.asin(t);
  var r = it(this.long0 + i.x / (0.900316316158 * this.a * Math.cos(e)));
  r < -Math.PI && (r = -Math.PI), r > Math.PI && (r = Math.PI), t = (2 * e + Math.sin(2 * e)) / Math.PI, Math.abs(t) > 1 && (t = 1);
  var n = Math.asin(t);
  return i.x = r, i.y = n, i;
}
var m7 = ["Mollweide", "moll"];
const v7 = {
  init: d7,
  forward: g7,
  inverse: p7,
  names: m7
};
function y7() {
  Math.abs(this.lat1 + this.lat2) < Xe || (this.lat2 = this.lat2 || this.lat1, this.temp = this.b / this.a, this.es = 1 - Math.pow(this.temp, 2), this.e = Math.sqrt(this.es), this.e0 = _g(this.es), this.e1 = wg(this.es), this.e2 = xg(this.es), this.e3 = Cg(this.es), this.sinphi = Math.sin(this.lat1), this.cosphi = Math.cos(this.lat1), this.ms1 = Ya(this.e, this.sinphi, this.cosphi), this.ml1 = ts(this.e0, this.e1, this.e2, this.e3, this.lat1), Math.abs(this.lat1 - this.lat2) < Xe ? this.ns = this.sinphi : (this.sinphi = Math.sin(this.lat2), this.cosphi = Math.cos(this.lat2), this.ms2 = Ya(this.e, this.sinphi, this.cosphi), this.ml2 = ts(this.e0, this.e1, this.e2, this.e3, this.lat2), this.ns = (this.ms1 - this.ms2) / (this.ml2 - this.ml1)), this.g = this.ml1 + this.ms1 / this.ns, this.ml0 = ts(this.e0, this.e1, this.e2, this.e3, this.lat0), this.rh = this.a * (this.g - this.ml0));
}
function _7(i) {
  var e = i.x, t = i.y, r;
  if (this.sphere)
    r = this.a * (this.g - t);
  else {
    var n = ts(this.e0, this.e1, this.e2, this.e3, t);
    r = this.a * (this.g - n);
  }
  var s = this.ns * it(e - this.long0), a = this.x0 + r * Math.sin(s), o = this.y0 + this.rh - r * Math.cos(s);
  return i.x = a, i.y = o, i;
}
function w7(i) {
  i.x -= this.x0, i.y = this.rh - i.y + this.y0;
  var e, t, r, n;
  this.ns >= 0 ? (t = Math.sqrt(i.x * i.x + i.y * i.y), e = 1) : (t = -Math.sqrt(i.x * i.x + i.y * i.y), e = -1);
  var s = 0;
  if (t !== 0 && (s = Math.atan2(e * i.x, e * i.y)), this.sphere)
    return n = it(this.long0 + s / this.ns), r = Iu(this.g - t / this.a), i.x = n, i.y = r, i;
  var a = this.g - t / this.a;
  return r = Im(a, this.e0, this.e1, this.e2, this.e3), n = it(this.long0 + s / this.ns), i.x = n, i.y = r, i;
}
var x7 = ["Equidistant_Conic", "eqdc"];
const C7 = {
  init: y7,
  forward: _7,
  inverse: w7,
  names: x7
};
function E7() {
  this.R = this.a;
}
function B7(i) {
  var e = i.x, t = i.y, r = it(e - this.long0), n, s;
  Math.abs(t) <= Xe && (n = this.x0 + this.R * r, s = this.y0);
  var a = fl(2 * Math.abs(t / Math.PI));
  (Math.abs(r) <= Xe || Math.abs(Math.abs(t) - Qe) <= Xe) && (n = this.x0, t >= 0 ? s = this.y0 + Math.PI * this.R * Math.tan(0.5 * a) : s = this.y0 + Math.PI * this.R * -Math.tan(0.5 * a));
  var o = 0.5 * Math.abs(Math.PI / r - r / Math.PI), A = o * o, l = Math.sin(a), h = Math.cos(a), c = h / (l + h - 1), u = c * c, f = c * (2 / l - 1), g = f * f, p = Math.PI * this.R * (o * (c - g) + Math.sqrt(A * (c - g) * (c - g) - (g + A) * (u - g))) / (g + A);
  r < 0 && (p = -p), n = this.x0 + p;
  var y = A + c;
  return p = Math.PI * this.R * (f * y - o * Math.sqrt((g + A) * (A + 1) - y * y)) / (g + A), t >= 0 ? s = this.y0 + p : s = this.y0 - p, i.x = n, i.y = s, i;
}
function b7(i) {
  var e, t, r, n, s, a, o, A, l, h, c, u, f;
  return i.x -= this.x0, i.y -= this.y0, c = Math.PI * this.R, r = i.x / c, n = i.y / c, s = r * r + n * n, a = -Math.abs(n) * (1 + s), o = a - 2 * n * n + r * r, A = -2 * a + 1 + 2 * n * n + s * s, f = n * n / A + (2 * o * o * o / A / A / A - 9 * a * o / A / A) / 27, l = (a - o * o / 3 / A) / A, h = 2 * Math.sqrt(-l / 3), c = 3 * f / l / h, Math.abs(c) > 1 && (c >= 0 ? c = 1 : c = -1), u = Math.acos(c) / 3, i.y >= 0 ? t = (-h * Math.cos(u + Math.PI / 3) - o / 3 / A) * Math.PI : t = -(-h * Math.cos(u + Math.PI / 3) - o / 3 / A) * Math.PI, Math.abs(r) < Xe ? e = this.long0 : e = it(this.long0 + Math.PI * (s - 1 + Math.sqrt(1 + 2 * (r * r - n * n) + s * s)) / 2 / r), i.x = e, i.y = t, i;
}
var S7 = ["Van_der_Grinten_I", "VanDerGrinten", "vandg"];
const T7 = {
  init: E7,
  forward: B7,
  inverse: b7,
  names: S7
};
function F7() {
  this.sin_p12 = Math.sin(this.lat0), this.cos_p12 = Math.cos(this.lat0);
}
function L7(i) {
  var e = i.x, t = i.y, r = Math.sin(i.y), n = Math.cos(i.y), s = it(e - this.long0), a, o, A, l, h, c, u, f, g, p, y, v, w, C, E, S, M, T, F, k, $, I, L;
  return this.sphere ? Math.abs(this.sin_p12 - 1) <= Xe ? (i.x = this.x0 + this.a * (Qe - t) * Math.sin(s), i.y = this.y0 - this.a * (Qe - t) * Math.cos(s), i) : Math.abs(this.sin_p12 + 1) <= Xe ? (i.x = this.x0 + this.a * (Qe + t) * Math.sin(s), i.y = this.y0 + this.a * (Qe + t) * Math.cos(s), i) : (T = this.sin_p12 * r + this.cos_p12 * n * Math.cos(s), S = Math.acos(T), M = S ? S / Math.sin(S) : 1, i.x = this.x0 + this.a * M * n * Math.sin(s), i.y = this.y0 + this.a * M * (this.cos_p12 * r - this.sin_p12 * n * Math.cos(s)), i) : (a = _g(this.es), o = wg(this.es), A = xg(this.es), l = Cg(this.es), Math.abs(this.sin_p12 - 1) <= Xe ? (h = this.a * ts(a, o, A, l, Qe), c = this.a * ts(a, o, A, l, t), i.x = this.x0 + (h - c) * Math.sin(s), i.y = this.y0 - (h - c) * Math.cos(s), i) : Math.abs(this.sin_p12 + 1) <= Xe ? (h = this.a * ts(a, o, A, l, Qe), c = this.a * ts(a, o, A, l, t), i.x = this.x0 + (h + c) * Math.sin(s), i.y = this.y0 + (h + c) * Math.cos(s), i) : (u = r / n, f = yu(this.a, this.e, this.sin_p12), g = yu(this.a, this.e, r), p = Math.atan((1 - this.es) * u + this.es * f * this.sin_p12 / (g * n)), y = Math.atan2(Math.sin(s), this.cos_p12 * Math.tan(p) - this.sin_p12 * Math.cos(s)), y === 0 ? F = Math.asin(this.cos_p12 * Math.sin(p) - this.sin_p12 * Math.cos(p)) : Math.abs(Math.abs(y) - Math.PI) <= Xe ? F = -Math.asin(this.cos_p12 * Math.sin(p) - this.sin_p12 * Math.cos(p)) : F = Math.asin(Math.sin(s) * Math.cos(p) / Math.sin(y)), v = this.e * this.sin_p12 / Math.sqrt(1 - this.es), w = this.e * this.cos_p12 * Math.cos(y) / Math.sqrt(1 - this.es), C = v * w, E = w * w, k = F * F, $ = k * F, I = $ * F, L = I * F, S = f * F * (1 - k * E * (1 - E) / 6 + $ / 8 * C * (1 - 2 * E) + I / 120 * (E * (4 - 7 * E) - 3 * v * v * (1 - 7 * E)) - L / 48 * C), i.x = this.x0 + S * Math.sin(y), i.y = this.y0 + S * Math.cos(y), i));
}
function I7(i) {
  i.x -= this.x0, i.y -= this.y0;
  var e, t, r, n, s, a, o, A, l, h, c, u, f, g, p, y, v, w, C, E, S, M, T, F;
  return this.sphere ? (e = Math.sqrt(i.x * i.x + i.y * i.y), e > 2 * Qe * this.a ? void 0 : (t = e / this.a, r = Math.sin(t), n = Math.cos(t), s = this.long0, Math.abs(e) <= Xe ? a = this.lat0 : (a = fl(n * this.sin_p12 + i.y * r * this.cos_p12 / e), o = Math.abs(this.lat0) - Qe, Math.abs(o) <= Xe ? this.lat0 >= 0 ? s = it(this.long0 + Math.atan2(i.x, -i.y)) : s = it(this.long0 - Math.atan2(-i.x, i.y)) : s = it(this.long0 + Math.atan2(i.x * r, e * this.cos_p12 * n - i.y * this.sin_p12 * r))), i.x = s, i.y = a, i)) : (A = _g(this.es), l = wg(this.es), h = xg(this.es), c = Cg(this.es), Math.abs(this.sin_p12 - 1) <= Xe ? (u = this.a * ts(A, l, h, c, Qe), e = Math.sqrt(i.x * i.x + i.y * i.y), f = u - e, a = Im(f / this.a, A, l, h, c), s = it(this.long0 + Math.atan2(i.x, -1 * i.y)), i.x = s, i.y = a, i) : Math.abs(this.sin_p12 + 1) <= Xe ? (u = this.a * ts(A, l, h, c, Qe), e = Math.sqrt(i.x * i.x + i.y * i.y), f = e - u, a = Im(f / this.a, A, l, h, c), s = it(this.long0 + Math.atan2(i.x, i.y)), i.x = s, i.y = a, i) : (e = Math.sqrt(i.x * i.x + i.y * i.y), y = Math.atan2(i.x, i.y), g = yu(this.a, this.e, this.sin_p12), v = Math.cos(y), w = this.e * this.cos_p12 * v, C = -w * w / (1 - this.es), E = 3 * this.es * (1 - C) * this.sin_p12 * this.cos_p12 * v / (1 - this.es), S = e / g, M = S - C * (1 + C) * Math.pow(S, 3) / 6 - E * (1 + 3 * C) * Math.pow(S, 4) / 24, T = 1 - C * M * M / 2 - S * M * M * M / 6, p = Math.asin(this.sin_p12 * Math.cos(M) + this.cos_p12 * Math.sin(M) * v), s = it(this.long0 + Math.asin(Math.sin(y) * Math.sin(M) / Math.cos(p))), F = Math.sin(p), a = Math.atan2((F - this.es * T * this.sin_p12) * Math.tan(p), F * (1 - this.es)), i.x = s, i.y = a, i));
}
var R7 = ["Azimuthal_Equidistant", "aeqd"];
const M7 = {
  init: F7,
  forward: L7,
  inverse: I7,
  names: R7
};
function N7() {
  this.sin_p14 = Math.sin(this.lat0), this.cos_p14 = Math.cos(this.lat0);
}
function P7(i) {
  var e, t, r, n, s, a, o, A, l = i.x, h = i.y;
  return r = it(l - this.long0), e = Math.sin(h), t = Math.cos(h), n = Math.cos(r), a = this.sin_p14 * e + this.cos_p14 * t * n, s = 1, (a > 0 || Math.abs(a) <= Xe) && (o = this.a * s * t * Math.sin(r), A = this.y0 + this.a * s * (this.cos_p14 * e - this.sin_p14 * t * n)), i.x = o, i.y = A, i;
}
function O7(i) {
  var e, t, r, n, s, a, o;
  return i.x -= this.x0, i.y -= this.y0, e = Math.sqrt(i.x * i.x + i.y * i.y), t = fl(e / this.a), r = Math.sin(t), n = Math.cos(t), a = this.long0, Math.abs(e) <= Xe ? (o = this.lat0, i.x = a, i.y = o, i) : (o = fl(n * this.sin_p14 + i.y * r * this.cos_p14 / e), s = Math.abs(this.lat0) - Qe, Math.abs(s) <= Xe ? (this.lat0 >= 0 ? a = it(this.long0 + Math.atan2(i.x, -i.y)) : a = it(this.long0 - Math.atan2(-i.x, i.y)), i.x = a, i.y = o, i) : (a = it(this.long0 + Math.atan2(i.x * r, e * this.cos_p14 * n - i.y * this.sin_p14 * r)), i.x = a, i.y = o, i));
}
var U7 = ["ortho"];
const Q7 = {
  init: N7,
  forward: P7,
  inverse: O7,
  names: U7
};
var mi = {
  FRONT: 1,
  RIGHT: 2,
  BACK: 3,
  LEFT: 4,
  TOP: 5,
  BOTTOM: 6
}, Pr = {
  AREA_0: 1,
  AREA_1: 2,
  AREA_2: 3,
  AREA_3: 4
};
function D7() {
  this.x0 = this.x0 || 0, this.y0 = this.y0 || 0, this.lat0 = this.lat0 || 0, this.long0 = this.long0 || 0, this.lat_ts = this.lat_ts || 0, this.title = this.title || "Quadrilateralized Spherical Cube", this.lat0 >= Qe - Nr / 2 ? this.face = mi.TOP : this.lat0 <= -(Qe - Nr / 2) ? this.face = mi.BOTTOM : Math.abs(this.long0) <= Nr ? this.face = mi.FRONT : Math.abs(this.long0) <= Qe + Nr ? this.face = this.long0 > 0 ? mi.RIGHT : mi.LEFT : this.face = mi.BACK, this.es !== 0 && (this.one_minus_f = 1 - (this.a - this.b) / this.a, this.one_minus_f_squared = this.one_minus_f * this.one_minus_f);
}
function k7(i) {
  var e = { x: 0, y: 0 }, t, r, n, s, a, o, A = { value: 0 };
  if (i.x -= this.long0, this.es !== 0 ? t = Math.atan(this.one_minus_f_squared * Math.tan(i.y)) : t = i.y, r = i.x, this.face === mi.TOP)
    s = Qe - t, r >= Nr && r <= Qe + Nr ? (A.value = Pr.AREA_0, n = r - Qe) : r > Qe + Nr || r <= -(Qe + Nr) ? (A.value = Pr.AREA_1, n = r > 0 ? r - Ui : r + Ui) : r > -(Qe + Nr) && r <= -Nr ? (A.value = Pr.AREA_2, n = r + Qe) : (A.value = Pr.AREA_3, n = r);
  else if (this.face === mi.BOTTOM)
    s = Qe + t, r >= Nr && r <= Qe + Nr ? (A.value = Pr.AREA_0, n = -r + Qe) : r < Nr && r >= -Nr ? (A.value = Pr.AREA_1, n = -r) : r < -Nr && r >= -(Qe + Nr) ? (A.value = Pr.AREA_2, n = -r - Qe) : (A.value = Pr.AREA_3, n = r > 0 ? -r + Ui : -r - Ui);
  else {
    var l, h, c, u, f, g, p;
    this.face === mi.RIGHT ? r = Jc(r, +Qe) : this.face === mi.BACK ? r = Jc(r, +Ui) : this.face === mi.LEFT && (r = Jc(r, -Qe)), u = Math.sin(t), f = Math.cos(t), g = Math.sin(r), p = Math.cos(r), l = f * p, h = f * g, c = u, this.face === mi.FRONT ? (s = Math.acos(l), n = Ip(s, c, h, A)) : this.face === mi.RIGHT ? (s = Math.acos(h), n = Ip(s, c, -l, A)) : this.face === mi.BACK ? (s = Math.acos(-l), n = Ip(s, c, -h, A)) : this.face === mi.LEFT ? (s = Math.acos(-h), n = Ip(s, c, l, A)) : (s = n = 0, A.value = Pr.AREA_0);
  }
  return o = Math.atan(12 / Ui * (n + Math.acos(Math.sin(n) * Math.cos(Nr)) - Qe)), a = Math.sqrt((1 - Math.cos(s)) / (Math.cos(o) * Math.cos(o)) / (1 - Math.cos(Math.atan(1 / Math.cos(n))))), A.value === Pr.AREA_1 ? o += Qe : A.value === Pr.AREA_2 ? o += Ui : A.value === Pr.AREA_3 && (o += 1.5 * Ui), e.x = a * Math.cos(o), e.y = a * Math.sin(o), e.x = e.x * this.a + this.x0, e.y = e.y * this.a + this.y0, i.x = e.x, i.y = e.y, i;
}
function H7(i) {
  var e = { lam: 0, phi: 0 }, t, r, n, s, a, o, A, l, h, c = { value: 0 };
  if (i.x = (i.x - this.x0) / this.a, i.y = (i.y - this.y0) / this.a, r = Math.atan(Math.sqrt(i.x * i.x + i.y * i.y)), t = Math.atan2(i.y, i.x), i.x >= 0 && i.x >= Math.abs(i.y) ? c.value = Pr.AREA_0 : i.y >= 0 && i.y >= Math.abs(i.x) ? (c.value = Pr.AREA_1, t -= Qe) : i.x < 0 && -i.x >= Math.abs(i.y) ? (c.value = Pr.AREA_2, t = t < 0 ? t + Ui : t - Ui) : (c.value = Pr.AREA_3, t += Qe), h = Ui / 12 * Math.tan(t), a = Math.sin(h) / (Math.cos(h) - 1 / Math.sqrt(2)), o = Math.atan(a), n = Math.cos(t), s = Math.tan(r), A = 1 - n * n * s * s * (1 - Math.cos(Math.atan(1 / Math.cos(o)))), A < -1 ? A = -1 : A > 1 && (A = 1), this.face === mi.TOP)
    l = Math.acos(A), e.phi = Qe - l, c.value === Pr.AREA_0 ? e.lam = o + Qe : c.value === Pr.AREA_1 ? e.lam = o < 0 ? o + Ui : o - Ui : c.value === Pr.AREA_2 ? e.lam = o - Qe : e.lam = o;
  else if (this.face === mi.BOTTOM)
    l = Math.acos(A), e.phi = l - Qe, c.value === Pr.AREA_0 ? e.lam = -o + Qe : c.value === Pr.AREA_1 ? e.lam = -o : c.value === Pr.AREA_2 ? e.lam = -o - Qe : e.lam = o < 0 ? -o - Ui : -o + Ui;
  else {
    var u, f, g;
    u = A, h = u * u, h >= 1 ? g = 0 : g = Math.sqrt(1 - h) * Math.sin(o), h += g * g, h >= 1 ? f = 0 : f = Math.sqrt(1 - h), c.value === Pr.AREA_1 ? (h = f, f = -g, g = h) : c.value === Pr.AREA_2 ? (f = -f, g = -g) : c.value === Pr.AREA_3 && (h = f, f = g, g = -h), this.face === mi.RIGHT ? (h = u, u = -f, f = h) : this.face === mi.BACK ? (u = -u, f = -f) : this.face === mi.LEFT && (h = u, u = f, f = -h), e.phi = Math.acos(-g) - Qe, e.lam = Math.atan2(f, u), this.face === mi.RIGHT ? e.lam = Jc(e.lam, -Qe) : this.face === mi.BACK ? e.lam = Jc(e.lam, -Ui) : this.face === mi.LEFT && (e.lam = Jc(e.lam, +Qe));
  }
  if (this.es !== 0) {
    var p, y, v;
    p = e.phi < 0 ? 1 : 0, y = Math.tan(e.phi), v = this.b / Math.sqrt(y * y + this.one_minus_f_squared), e.phi = Math.atan(Math.sqrt(this.a * this.a - v * v) / (this.one_minus_f * v)), p && (e.phi = -e.phi);
  }
  return e.lam += this.long0, i.x = e.lam, i.y = e.phi, i;
}
function Ip(i, e, t, r) {
  var n;
  return i < Xe ? (r.value = Pr.AREA_0, n = 0) : (n = Math.atan2(e, t), Math.abs(n) <= Nr ? r.value = Pr.AREA_0 : n > Nr && n <= Qe + Nr ? (r.value = Pr.AREA_1, n -= Qe) : n > Qe + Nr || n <= -(Qe + Nr) ? (r.value = Pr.AREA_2, n = n >= 0 ? n - Ui : n + Ui) : (r.value = Pr.AREA_3, n += Qe)), n;
}
function Jc(i, e) {
  var t = i + e;
  return t < -Ui ? t += Qd : t > +Ui && (t -= Qd), t;
}
var G7 = ["Quadrilateralized Spherical Cube", "Quadrilateralized_Spherical_Cube", "qsc"];
const $7 = {
  init: D7,
  forward: k7,
  inverse: H7,
  names: G7
};
var Jw = [
  [1, 22199e-21, -715515e-10, 31103e-10],
  [0.9986, -482243e-9, -24897e-9, -13309e-10],
  [0.9954, -83103e-8, -448605e-10, -986701e-12],
  [0.99, -135364e-8, -59661e-9, 36777e-10],
  [0.9822, -167442e-8, -449547e-11, -572411e-11],
  [0.973, -214868e-8, -903571e-10, 18736e-12],
  [0.96, -305085e-8, -900761e-10, 164917e-11],
  [0.9427, -382792e-8, -653386e-10, -26154e-10],
  [0.9216, -467746e-8, -10457e-8, 481243e-11],
  [0.8962, -536223e-8, -323831e-10, -543432e-11],
  [0.8679, -609363e-8, -113898e-9, 332484e-11],
  [0.835, -698325e-8, -640253e-10, 934959e-12],
  [0.7986, -755338e-8, -500009e-10, 935324e-12],
  [0.7597, -798324e-8, -35971e-9, -227626e-11],
  [0.7186, -851367e-8, -701149e-10, -86303e-10],
  [0.6732, -986209e-8, -199569e-9, 191974e-10],
  [0.6213, -0.010418, 883923e-10, 624051e-11],
  [0.5722, -906601e-8, 182e-6, 624051e-11],
  [0.5322, -677797e-8, 275608e-9, 624051e-11]
], qf = [
  [-520417e-23, 0.0124, 121431e-23, -845284e-16],
  [0.062, 0.0124, -126793e-14, 422642e-15],
  [0.124, 0.0124, 507171e-14, -160604e-14],
  [0.186, 0.0123999, -190189e-13, 600152e-14],
  [0.248, 0.0124002, 710039e-13, -224e-10],
  [0.31, 0.0123992, -264997e-12, 835986e-13],
  [0.372, 0.0124029, 988983e-12, -311994e-12],
  [0.434, 0.0123893, -369093e-11, -435621e-12],
  [0.4958, 0.0123198, -102252e-10, -345523e-12],
  [0.5571, 0.0121916, -154081e-10, -582288e-12],
  [0.6176, 0.0119938, -241424e-10, -525327e-12],
  [0.6769, 0.011713, -320223e-10, -516405e-12],
  [0.7346, 0.0113541, -397684e-10, -609052e-12],
  [0.7903, 0.0109107, -489042e-10, -104739e-11],
  [0.8435, 0.0103431, -64615e-9, -140374e-14],
  [0.8936, 969686e-8, -64636e-9, -8547e-9],
  [0.9394, 840947e-8, -192841e-9, -42106e-10],
  [0.9761, 616527e-8, -256e-6, -42106e-10],
  [1, 328947e-8, -319159e-9, -42106e-10]
], MM = 0.8487, NM = 1.3523, PM = Ha / 5, V7 = 1 / PM, Dc = 18, Rm = function(i, e) {
  return i[0] + e * (i[1] + e * (i[2] + e * i[3]));
}, K7 = function(i, e) {
  return i[1] + e * (2 * i[2] + e * 3 * i[3]);
};
function j7(i, e, t, r) {
  for (var n = e; r; --r) {
    var s = i(n);
    if (n -= s, Math.abs(s) < t)
      break;
  }
  return n;
}
function z7() {
  this.x0 = this.x0 || 0, this.y0 = this.y0 || 0, this.long0 = this.long0 || 0, this.es = 0, this.title = this.title || "Robinson";
}
function X7(i) {
  var e = it(i.x - this.long0), t = Math.abs(i.y), r = Math.floor(t * PM);
  r < 0 ? r = 0 : r >= Dc && (r = Dc - 1), t = Ha * (t - V7 * r);
  var n = {
    x: Rm(Jw[r], t) * e,
    y: Rm(qf[r], t)
  };
  return i.y < 0 && (n.y = -n.y), n.x = n.x * this.a * MM + this.x0, n.y = n.y * this.a * NM + this.y0, n;
}
function W7(i) {
  var e = {
    x: (i.x - this.x0) / (this.a * MM),
    y: Math.abs(i.y - this.y0) / (this.a * NM)
  };
  if (e.y >= 1)
    e.x /= Jw[Dc][0], e.y = i.y < 0 ? -Qe : Qe;
  else {
    var t = Math.floor(e.y * Dc);
    for (t < 0 ? t = 0 : t >= Dc && (t = Dc - 1); ; )
      if (qf[t][0] > e.y)
        --t;
      else if (qf[t + 1][0] <= e.y)
        ++t;
      else
        break;
    var r = qf[t], n = 5 * (e.y - r[0]) / (qf[t + 1][0] - r[0]);
    n = j7(function(s) {
      return (Rm(r, s) - e.y) / K7(r, s);
    }, n, Xe, 100), e.x /= Rm(Jw[t], n), e.y = (5 * t + n) * Sn, i.y < 0 && (e.y = -e.y);
  }
  return e.x = it(e.x + this.long0), e;
}
var Y7 = ["Robinson", "robin"];
const q7 = {
  init: z7,
  forward: X7,
  inverse: W7,
  names: Y7
};
function Z7() {
  this.name = "geocent";
}
function J7(i) {
  var e = _M(i, this.es, this.a);
  return e;
}
function e$(i) {
  var e = wM(i, this.es, this.a, this.b);
  return e;
}
var t$ = ["Geocentric", "geocentric", "geocent", "Geocent"];
const r$ = {
  init: Z7,
  forward: J7,
  inverse: e$,
  names: t$
};
var $n = {
  N_POLE: 0,
  S_POLE: 1,
  EQUIT: 2,
  OBLIQ: 3
}, Sf = {
  h: { def: 1e5, num: !0 },
  // default is Karman line, no default in PROJ.7
  azi: { def: 0, num: !0, degrees: !0 },
  // default is North
  tilt: { def: 0, num: !0, degrees: !0 },
  // default is Nadir
  long0: { def: 0, num: !0 },
  // default is Greenwich, conversion to rad is automatic
  lat0: { def: 0, num: !0 }
  // default is Equator, conversion to rad is automatic
};
function i$() {
  if (Object.keys(Sf).forEach(function(t) {
    if (typeof this[t] > "u")
      this[t] = Sf[t].def;
    else {
      if (Sf[t].num && isNaN(this[t]))
        throw new Error("Invalid parameter value, must be numeric " + t + " = " + this[t]);
      Sf[t].num && (this[t] = parseFloat(this[t]));
    }
    Sf[t].degrees && (this[t] = this[t] * Sn);
  }.bind(this)), Math.abs(Math.abs(this.lat0) - Qe) < Xe ? this.mode = this.lat0 < 0 ? $n.S_POLE : $n.N_POLE : Math.abs(this.lat0) < Xe ? this.mode = $n.EQUIT : (this.mode = $n.OBLIQ, this.sinph0 = Math.sin(this.lat0), this.cosph0 = Math.cos(this.lat0)), this.pn1 = this.h / this.a, this.pn1 <= 0 || this.pn1 > 1e10)
    throw new Error("Invalid height");
  this.p = 1 + this.pn1, this.rp = 1 / this.p, this.h1 = 1 / this.pn1, this.pfact = (this.p + 1) * this.h1, this.es = 0;
  var i = this.tilt, e = this.azi;
  this.cg = Math.cos(e), this.sg = Math.sin(e), this.cw = Math.cos(i), this.sw = Math.sin(i);
}
function n$(i) {
  i.x -= this.long0;
  var e = Math.sin(i.y), t = Math.cos(i.y), r = Math.cos(i.x), n, s;
  switch (this.mode) {
    case $n.OBLIQ:
      s = this.sinph0 * e + this.cosph0 * t * r;
      break;
    case $n.EQUIT:
      s = t * r;
      break;
    case $n.S_POLE:
      s = -e;
      break;
    case $n.N_POLE:
      s = e;
      break;
  }
  switch (s = this.pn1 / (this.p - s), n = s * t * Math.sin(i.x), this.mode) {
    case $n.OBLIQ:
      s *= this.cosph0 * e - this.sinph0 * t * r;
      break;
    case $n.EQUIT:
      s *= e;
      break;
    case $n.N_POLE:
      s *= -(t * r);
      break;
    case $n.S_POLE:
      s *= t * r;
      break;
  }
  var a, o;
  return a = s * this.cg + n * this.sg, o = 1 / (a * this.sw * this.h1 + this.cw), n = (n * this.cg - s * this.sg) * this.cw * o, s = a * o, i.x = n * this.a, i.y = s * this.a, i;
}
function s$(i) {
  i.x /= this.a, i.y /= this.a;
  var e = { x: i.x, y: i.y }, t, r, n;
  n = 1 / (this.pn1 - i.y * this.sw), t = this.pn1 * i.x * n, r = this.pn1 * i.y * this.cw * n, i.x = t * this.cg + r * this.sg, i.y = r * this.cg - t * this.sg;
  var s = wa(i.x, i.y);
  if (Math.abs(s) < Xe)
    e.x = 0, e.y = i.y;
  else {
    var a, o;
    switch (o = 1 - s * s * this.pfact, o = (this.p - Math.sqrt(o)) / (this.pn1 / s + s / this.pn1), a = Math.sqrt(1 - o * o), this.mode) {
      case $n.OBLIQ:
        e.y = Math.asin(a * this.sinph0 + i.y * o * this.cosph0 / s), i.y = (a - this.sinph0 * Math.sin(e.y)) * s, i.x *= o * this.cosph0;
        break;
      case $n.EQUIT:
        e.y = Math.asin(i.y * o / s), i.y = a * s, i.x *= o;
        break;
      case $n.N_POLE:
        e.y = Math.asin(a), i.y = -i.y;
        break;
      case $n.S_POLE:
        e.y = -Math.asin(a);
        break;
    }
    e.x = Math.atan2(i.x, i.y);
  }
  return i.x = e.x + this.long0, i.y = e.y, i;
}
var a$ = ["Tilted_Perspective", "tpers"];
const o$ = {
  init: i$,
  forward: n$,
  inverse: s$,
  names: a$
};
function A$() {
  if (this.flip_axis = this.sweep === "x" ? 1 : 0, this.h = Number(this.h), this.radius_g_1 = this.h / this.a, this.radius_g_1 <= 0 || this.radius_g_1 > 1e10)
    throw new Error();
  if (this.radius_g = 1 + this.radius_g_1, this.C = this.radius_g * this.radius_g - 1, this.es !== 0) {
    var i = 1 - this.es, e = 1 / i;
    this.radius_p = Math.sqrt(i), this.radius_p2 = i, this.radius_p_inv2 = e, this.shape = "ellipse";
  } else
    this.radius_p = 1, this.radius_p2 = 1, this.radius_p_inv2 = 1, this.shape = "sphere";
  this.title || (this.title = "Geostationary Satellite View");
}
function l$(i) {
  var e = i.x, t = i.y, r, n, s, a;
  if (e = e - this.long0, this.shape === "ellipse") {
    t = Math.atan(this.radius_p2 * Math.tan(t));
    var o = this.radius_p / wa(this.radius_p * Math.cos(t), Math.sin(t));
    if (n = o * Math.cos(e) * Math.cos(t), s = o * Math.sin(e) * Math.cos(t), a = o * Math.sin(t), (this.radius_g - n) * n - s * s - a * a * this.radius_p_inv2 < 0)
      return i.x = Number.NaN, i.y = Number.NaN, i;
    r = this.radius_g - n, this.flip_axis ? (i.x = this.radius_g_1 * Math.atan(s / wa(a, r)), i.y = this.radius_g_1 * Math.atan(a / r)) : (i.x = this.radius_g_1 * Math.atan(s / r), i.y = this.radius_g_1 * Math.atan(a / wa(s, r)));
  } else
    this.shape === "sphere" && (r = Math.cos(t), n = Math.cos(e) * r, s = Math.sin(e) * r, a = Math.sin(t), r = this.radius_g - n, this.flip_axis ? (i.x = this.radius_g_1 * Math.atan(s / wa(a, r)), i.y = this.radius_g_1 * Math.atan(a / r)) : (i.x = this.radius_g_1 * Math.atan(s / r), i.y = this.radius_g_1 * Math.atan(a / wa(s, r))));
  return i.x = i.x * this.a, i.y = i.y * this.a, i;
}
function h$(i) {
  var e = -1, t = 0, r = 0, n, s, a, o;
  if (i.x = i.x / this.a, i.y = i.y / this.a, this.shape === "ellipse") {
    this.flip_axis ? (r = Math.tan(i.y / this.radius_g_1), t = Math.tan(i.x / this.radius_g_1) * wa(1, r)) : (t = Math.tan(i.x / this.radius_g_1), r = Math.tan(i.y / this.radius_g_1) * wa(1, t));
    var A = r / this.radius_p;
    if (n = t * t + A * A + e * e, s = 2 * this.radius_g * e, a = s * s - 4 * n * this.C, a < 0)
      return i.x = Number.NaN, i.y = Number.NaN, i;
    o = (-s - Math.sqrt(a)) / (2 * n), e = this.radius_g + o * e, t *= o, r *= o, i.x = Math.atan2(t, e), i.y = Math.atan(r * Math.cos(i.x) / e), i.y = Math.atan(this.radius_p_inv2 * Math.tan(i.y));
  } else if (this.shape === "sphere") {
    if (this.flip_axis ? (r = Math.tan(i.y / this.radius_g_1), t = Math.tan(i.x / this.radius_g_1) * Math.sqrt(1 + r * r)) : (t = Math.tan(i.x / this.radius_g_1), r = Math.tan(i.y / this.radius_g_1) * Math.sqrt(1 + t * t)), n = t * t + r * r + e * e, s = 2 * this.radius_g * e, a = s * s - 4 * n * this.C, a < 0)
      return i.x = Number.NaN, i.y = Number.NaN, i;
    o = (-s - Math.sqrt(a)) / (2 * n), e = this.radius_g + o * e, t *= o, r *= o, i.x = Math.atan2(t, e), i.y = Math.atan(r * Math.cos(i.x) / e);
  }
  return i.x = i.x + this.long0, i;
}
var c$ = ["Geostationary Satellite View", "Geostationary_Satellite", "geos"];
const u$ = {
  init: A$,
  forward: l$,
  inverse: h$,
  names: c$
};
function f$(i) {
  i.Proj.projections.add(H0), i.Proj.projections.add(G0), i.Proj.projections.add(yH), i.Proj.projections.add(FH), i.Proj.projections.add(PH), i.Proj.projections.add(kH), i.Proj.projections.add(jH), i.Proj.projections.add(qH), i.Proj.projections.add(rG), i.Proj.projections.add(oG), i.Proj.projections.add(EG), i.Proj.projections.add(LG), i.Proj.projections.add(PG), i.Proj.projections.add(HG), i.Proj.projections.add(jG), i.Proj.projections.add(qG), i.Proj.projections.add(r7), i.Proj.projections.add(o7), i.Proj.projections.add(f7), i.Proj.projections.add(v7), i.Proj.projections.add(C7), i.Proj.projections.add(T7), i.Proj.projections.add(M7), i.Proj.projections.add(Q7), i.Proj.projections.add($7), i.Proj.projections.add(q7), i.Proj.projections.add(r$), i.Proj.projections.add(o$), i.Proj.projections.add(u$);
}
vs.defaultDatum = "WGS84";
vs.Proj = ja;
vs.WGS84 = new vs.Proj("WGS84");
vs.Point = vu;
vs.toPoint = xM;
vs.defs = Jn;
vs.nadgrid = wk;
vs.transform = Lm;
vs.mgrs = Uk;
vs.version = "__VERSION__";
f$(vs);
let d$ = null;
function g$(i) {
  d$ = i;
  const e = Object.keys(i.defs), t = e.length;
  let r, n;
  for (r = 0; r < t; ++r) {
    const s = e[r];
    if (!Ct(s)) {
      const a = i.defs(s);
      let o = (
        /** @type {import("./Units.js").Units} */
        a.units
      );
      !o && a.projName === "longlat" && (o = "degrees"), kR(
        new Ja({
          code: s,
          axisOrientation: a.axis,
          metersPerUnit: a.to_meter,
          units: o
        })
      );
    }
  }
  for (r = 0; r < t; ++r) {
    const s = e[r], a = Ct(s);
    for (n = 0; n < t; ++n) {
      const o = e[n], A = Ct(o);
      if (!RR(s, o))
        if (i.defs[s] === i.defs[o])
          Uw([a, A]);
        else {
          const l = i(s, o);
          yD(
            a,
            A,
            LS(a, A, l.forward),
            LS(A, a, l.inverse)
          );
        }
    }
  }
}
const p$ = {
  name: "ol-projection-register",
  setup(i) {
    const { projectionName: e, projectionDef: t, projectionExtent: r } = uh(i);
    return vs.defs(e.value, t.value), g$(vs), {
      projection: new Ja({
        code: e.value,
        extent: r.value
      })
    };
  },
  props: {
    projectionName: {
      type: String
    },
    projectionDef: {
      type: String
    },
    projectionExtent: {
      type: Array
    }
  }
};
function m$(i, e, t, r, n, s) {
  return ur("", !0);
}
const e2 = /* @__PURE__ */ qe(p$, [["render", m$]]);
function Mm(i) {
  Mm.installed || (Mm.installed = !0, i.component(Kw.name, Kw), i.component(jw.name, jw), i.component(zw.name, zw), i.component(Xw.name, Xw), i.component(Ww.name, Ww), i.component(e2.name, e2));
}
const v$ = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  Feature: zw,
  GeoLocation: Ww,
  Map: Kw,
  Overlay: Xw,
  Projection: e2,
  View: jw,
  default: Mm,
  install: Mm
}, Symbol.toStringTag, { value: "Module" })), zA = {
  PRELOAD: "preload",
  USE_INTERIM_TILES_ON_ERROR: "useInterimTilesOnError"
};
class y$ extends bh {
  /**
   * @param {Options<TileSourceType>} [options] Tile layer options.
   */
  constructor(e) {
    e = e || {};
    const t = Object.assign({}, e);
    delete t.preload, delete t.useInterimTilesOnError, super(t), this.on, this.once, this.un, this.setPreload(e.preload !== void 0 ? e.preload : 0), this.setUseInterimTilesOnError(
      e.useInterimTilesOnError !== void 0 ? e.useInterimTilesOnError : !0
    );
  }
  /**
   * Return the level as number to which we will preload tiles up to.
   * @return {number} The level to preload tiles up to.
   * @observable
   * @api
   */
  getPreload() {
    return (
      /** @type {number} */
      this.get(zA.PRELOAD)
    );
  }
  /**
   * Set the level as number to which we will preload tiles up to.
   * @param {number} preload The level to preload tiles up to.
   * @observable
   * @api
   */
  setPreload(e) {
    this.set(zA.PRELOAD, e);
  }
  /**
   * Whether we use interim tiles on error.
   * @return {boolean} Use interim tiles on error.
   * @observable
   * @api
   */
  getUseInterimTilesOnError() {
    return (
      /** @type {boolean} */
      this.get(zA.USE_INTERIM_TILES_ON_ERROR)
    );
  }
  /**
   * Set whether we use interim tiles on error.
   * @param {boolean} useInterimTilesOnError Use interim tiles on error.
   * @observable
   * @api
   */
  setUseInterimTilesOnError(e) {
    this.set(zA.USE_INTERIM_TILES_ON_ERROR, e);
  }
  /**
   * Get data for a pixel location.  The return type depends on the source data.  For image tiles,
   * a four element RGBA array will be returned.  For data tiles, the array length will match the
   * number of bands in the dataset.  For requests outside the layer extent, `null` will be returned.
   * Data for a image tiles can only be retrieved if the source's `crossOrigin` property is set.
   *
   * ```js
   * // display layer data on every pointer move
   * map.on('pointermove', (event) => {
   *   console.log(layer.getData(event.pixel));
   * });
   * ```
   * @param {import("../pixel").Pixel} pixel Pixel.
   * @return {Uint8ClampedArray|Uint8Array|Float32Array|DataView|null} Pixel data.
   * @api
   */
  getData(e) {
    return super.getData(e);
  }
}
const OM = y$, Pt = {
  IDLE: 0,
  LOADING: 1,
  LOADED: 2,
  ERROR: 3,
  EMPTY: 4
};
class _$ extends ag {
  /**
   * @param {LayerType} layer Layer.
   */
  constructor(e) {
    super(), this.ready = !0, this.boundHandleImageChange_ = this.handleImageChange_.bind(this), this.layer_ = e, this.declutterExecutorGroup = null;
  }
  /**
   * Asynchronous layer level hit detection.
   * @param {import("../pixel.js").Pixel} pixel Pixel.
   * @return {Promise<Array<import("../Feature").FeatureLike>>} Promise that resolves with
   * an array of features.
   */
  getFeatures(e) {
    return pt();
  }
  /**
   * @param {import("../pixel.js").Pixel} pixel Pixel.
   * @return {Uint8ClampedArray|Uint8Array|Float32Array|DataView|null} Pixel data.
   */
  getData(e) {
    return null;
  }
  /**
   * Determine whether render should be called.
   * @abstract
   * @param {import("../Map.js").FrameState} frameState Frame state.
   * @return {boolean} Layer is ready to be rendered.
   */
  prepareFrame(e) {
    return pt();
  }
  /**
   * Render the layer.
   * @abstract
   * @param {import("../Map.js").FrameState} frameState Frame state.
   * @param {HTMLElement} target Target that may be used to render content to.
   * @return {HTMLElement} The rendered element.
   */
  renderFrame(e, t) {
    return pt();
  }
  /**
   * @param {Object<number, Object<string, import("../Tile.js").default>>} tiles Lookup of loaded tiles by zoom level.
   * @param {number} zoom Zoom level.
   * @param {import("../Tile.js").default} tile Tile.
   * @return {boolean|void} If `false`, the tile will not be considered loaded.
   */
  loadedTileCallback(e, t, r) {
    e[t] || (e[t] = {}), e[t][r.tileCoord.toString()] = r;
  }
  /**
   * Create a function that adds loaded tiles to the tile lookup.
   * @param {import("../source/Tile.js").default} source Tile source.
   * @param {import("../proj/Projection.js").default} projection Projection of the tiles.
   * @param {Object<number, Object<string, import("../Tile.js").default>>} tiles Lookup of loaded tiles by zoom level.
   * @return {function(number, import("../TileRange.js").default):boolean} A function that can be
   *     called with a zoom level and a tile range to add loaded tiles to the lookup.
   * @protected
   */
  createLoadedTileFinder(e, t, r) {
    return (
      /**
       * @param {number} zoom Zoom level.
       * @param {import("../TileRange.js").default} tileRange Tile range.
       * @return {boolean} The tile range is fully loaded.
       */
      (n, s) => {
        const a = this.loadedTileCallback.bind(this, r, n);
        return e.forEachLoadedTile(t, n, s, a);
      }
    );
  }
  /**
   * @abstract
   * @param {import("../coordinate.js").Coordinate} coordinate Coordinate.
   * @param {import("../Map.js").FrameState} frameState Frame state.
   * @param {number} hitTolerance Hit tolerance in pixels.
   * @param {import("./vector.js").FeatureCallback<T>} callback Feature callback.
   * @param {Array<import("./Map.js").HitMatch<T>>} matches The hit detected matches with tolerance.
   * @return {T|undefined} Callback result.
   * @template T
   */
  forEachFeatureAtCoordinate(e, t, r, n, s) {
  }
  /**
   * @return {LayerType} Layer.
   */
  getLayer() {
    return this.layer_;
  }
  /**
   * Perform action necessary to get the layer rendered after new fonts have loaded
   * @abstract
   */
  handleFontsChanged() {
  }
  /**
   * Handle changes in image state.
   * @param {import("../events/Event.js").default} event Image change event.
   * @private
   */
  handleImageChange_(e) {
    /** @type {import("../Image.js").default} */
    e.target.getState() === Pt.LOADED && this.renderIfReadyAndVisible();
  }
  /**
   * Load the image if not already loaded, and register the image change
   * listener if needed.
   * @param {import("../ImageBase.js").default} image Image.
   * @return {boolean} `true` if the image is already loaded, `false` otherwise.
   * @protected
   */
  loadImage(e) {
    let t = e.getState();
    return t != Pt.LOADED && t != Pt.ERROR && e.addEventListener(ut.CHANGE, this.boundHandleImageChange_), t == Pt.IDLE && (e.load(), t = e.getState()), t == Pt.LOADED;
  }
  /**
   * @protected
   */
  renderIfReadyAndVisible() {
    const e = this.getLayer();
    e && e.getVisible() && e.getSourceState() === "ready" && e.changed();
  }
  /**
   * Clean up.
   */
  disposeInternal() {
    delete this.layer_, super.disposeInternal();
  }
}
const UM = _$, a5 = [];
let bc = null;
function w$() {
  bc = Ii(1, 1, void 0, {
    willReadFrequently: !0
  });
}
class x$ extends UM {
  /**
   * @param {LayerType} layer Layer.
   */
  constructor(e) {
    super(e), this.container = null, this.renderedResolution, this.tempTransform = qi(), this.pixelTransform = qi(), this.inversePixelTransform = qi(), this.context = null, this.containerReused = !1, this.pixelContext_ = null, this.frameState = null;
  }
  /**
   * @param {HTMLCanvasElement|HTMLImageElement|HTMLVideoElement} image Image.
   * @param {number} col The column index.
   * @param {number} row The row index.
   * @return {Uint8ClampedArray|null} The image data.
   */
  getImageData(e, t, r) {
    bc || w$(), bc.clearRect(0, 0, 1, 1);
    let n;
    try {
      bc.drawImage(e, t, r, 1, 1, 0, 0, 1, 1), n = bc.getImageData(0, 0, 1, 1).data;
    } catch {
      return bc = null, null;
    }
    return n;
  }
  /**
   * @param {import('../../Map.js').FrameState} frameState Frame state.
   * @return {string} Background color.
   */
  getBackground(e) {
    let r = this.getLayer().getBackground();
    return typeof r == "function" && (r = r(e.viewState.resolution)), r || void 0;
  }
  /**
   * Get a rendering container from an existing target, if compatible.
   * @param {HTMLElement} target Potential render target.
   * @param {string} transform CSS Transform.
   * @param {string} [backgroundColor] Background color.
   */
  useContainer(e, t, r) {
    const n = this.getLayer().getClassName();
    let s, a;
    if (e && e.className === n && (!r || e && e.style.backgroundColor && Za(
      hl(e.style.backgroundColor),
      hl(r)
    ))) {
      const o = e.firstElementChild;
      o instanceof HTMLCanvasElement && (a = o.getContext("2d"));
    }
    if (a && a.canvas.style.transform === t ? (this.container = e, this.context = a, this.containerReused = !0) : this.containerReused && (this.container = null, this.context = null, this.containerReused = !1), !this.container) {
      s = document.createElement("div"), s.className = n;
      let o = s.style;
      o.position = "absolute", o.width = "100%", o.height = "100%", a = Ii();
      const A = a.canvas;
      s.appendChild(A), o = A.style, o.position = "absolute", o.left = "0", o.transformOrigin = "top left", this.container = s, this.context = a;
    }
    !this.containerReused && r && !this.container.style.backgroundColor && (this.container.style.backgroundColor = r);
  }
  /**
   * @param {CanvasRenderingContext2D} context Context.
   * @param {import("../../Map.js").FrameState} frameState Frame state.
   * @param {import("../../extent.js").Extent} extent Clip extent.
   * @protected
   */
  clipUnrotated(e, t, r) {
    const n = Sa(r), s = hg(r), a = Su(r), o = lg(r);
    vi(t.coordinateToPixelTransform, n), vi(t.coordinateToPixelTransform, s), vi(t.coordinateToPixelTransform, a), vi(t.coordinateToPixelTransform, o);
    const A = this.inversePixelTransform;
    vi(A, n), vi(A, s), vi(A, a), vi(A, o), e.save(), e.beginPath(), e.moveTo(Math.round(n[0]), Math.round(n[1])), e.lineTo(Math.round(s[0]), Math.round(s[1])), e.lineTo(Math.round(a[0]), Math.round(a[1])), e.lineTo(Math.round(o[0]), Math.round(o[1])), e.clip();
  }
  /**
   * @param {import("../../render/EventType.js").default} type Event type.
   * @param {CanvasRenderingContext2D} context Context.
   * @param {import("../../Map.js").FrameState} frameState Frame state.
   * @private
   */
  dispatchRenderEvent_(e, t, r) {
    const n = this.getLayer();
    if (n.hasListener(e)) {
      const s = new ld(
        e,
        this.inversePixelTransform,
        r,
        t
      );
      n.dispatchEvent(s);
    }
  }
  /**
   * @param {CanvasRenderingContext2D} context Context.
   * @param {import("../../Map.js").FrameState} frameState Frame state.
   * @protected
   */
  preRender(e, t) {
    this.frameState = t, this.dispatchRenderEvent_(ds.PRERENDER, e, t);
  }
  /**
   * @param {CanvasRenderingContext2D} context Context.
   * @param {import("../../Map.js").FrameState} frameState Frame state.
   * @protected
   */
  postRender(e, t) {
    this.dispatchRenderEvent_(ds.POSTRENDER, e, t);
  }
  /**
   * Creates a transform for rendering to an element that will be rotated after rendering.
   * @param {import("../../coordinate.js").Coordinate} center Center.
   * @param {number} resolution Resolution.
   * @param {number} rotation Rotation.
   * @param {number} pixelRatio Pixel ratio.
   * @param {number} width Width of the rendered element (in pixels).
   * @param {number} height Height of the rendered element (in pixels).
   * @param {number} offsetX Offset on the x-axis in view coordinates.
   * @protected
   * @return {!import("../../transform.js").Transform} Transform.
   */
  getRenderTransform(e, t, r, n, s, a, o) {
    const A = s / 2, l = a / 2, h = n / t, c = -h, u = -e[0] + o, f = -e[1];
    return Qs(
      this.tempTransform,
      A,
      l,
      h,
      c,
      -r,
      u,
      f
    );
  }
  /**
   * Clean up.
   */
  disposeInternal() {
    delete this.frameState, super.disposeInternal();
  }
}
const $E = x$;
class C$ extends bu {
  /**
   * @param {import("./tilecoord.js").TileCoord} tileCoord Tile coordinate.
   * @param {import("./TileState.js").default} state State.
   * @param {Options} [options] Tile options.
   */
  constructor(e, t, r) {
    super(), r = r || {}, this.tileCoord = e, this.state = t, this.interimTile = null, this.key = "", this.transition_ = r.transition === void 0 ? 250 : r.transition, this.transitionStarts_ = {}, this.interpolate = !!r.interpolate;
  }
  /**
   * @protected
   */
  changed() {
    this.dispatchEvent(ut.CHANGE);
  }
  /**
   * Called by the tile cache when the tile is removed from the cache due to expiry
   */
  release() {
    this.state === He.ERROR && this.setState(He.EMPTY);
  }
  /**
   * @return {string} Key.
   */
  getKey() {
    return this.key + "/" + this.tileCoord;
  }
  /**
   * Get the interim tile most suitable for rendering using the chain of interim
   * tiles. This corresponds to the  most recent tile that has been loaded, if no
   * such tile exists, the original tile is returned.
   * @return {!Tile} Best tile for rendering.
   */
  getInterimTile() {
    if (!this.interimTile)
      return this;
    let e = this.interimTile;
    do {
      if (e.getState() == He.LOADED)
        return this.transition_ = 0, e;
      e = e.interimTile;
    } while (e);
    return this;
  }
  /**
   * Goes through the chain of interim tiles and discards sections of the chain
   * that are no longer relevant.
   */
  refreshInterimChain() {
    if (!this.interimTile)
      return;
    let e = this.interimTile, t = this;
    do {
      if (e.getState() == He.LOADED) {
        e.interimTile = null;
        break;
      } else
        e.getState() == He.LOADING ? t = e : e.getState() == He.IDLE ? t.interimTile = e.interimTile : t = e;
      e = t.interimTile;
    } while (e);
  }
  /**
   * Get the tile coordinate for this tile.
   * @return {import("./tilecoord.js").TileCoord} The tile coordinate.
   * @api
   */
  getTileCoord() {
    return this.tileCoord;
  }
  /**
   * @return {import("./TileState.js").default} State.
   */
  getState() {
    return this.state;
  }
  /**
   * Sets the state of this tile. If you write your own {@link module:ol/Tile~LoadFunction tileLoadFunction} ,
   * it is important to set the state correctly to {@link module:ol/TileState~ERROR}
   * when the tile cannot be loaded. Otherwise the tile cannot be removed from
   * the tile queue and will block other requests.
   * @param {import("./TileState.js").default} state State.
   * @api
   */
  setState(e) {
    if (this.state !== He.ERROR && this.state > e)
      throw new Error("Tile load sequence violation");
    this.state = e, this.changed();
  }
  /**
   * Load the image or retry if loading previously failed.
   * Loading is taken care of by the tile queue, and calling this method is
   * only needed for preloading or for reloading in case of an error.
   * @abstract
   * @api
   */
  load() {
    pt();
  }
  /**
   * Get the alpha value for rendering.
   * @param {string} id An id for the renderer.
   * @param {number} time The render frame time.
   * @return {number} A number between 0 and 1.
   */
  getAlpha(e, t) {
    if (!this.transition_)
      return 1;
    let r = this.transitionStarts_[e];
    if (!r)
      r = t, this.transitionStarts_[e] = r;
    else if (r === -1)
      return 1;
    const n = t - r + 1e3 / 60;
    return n >= this.transition_ ? 1 : yE(n / this.transition_);
  }
  /**
   * Determine if a tile is in an alpha transition.  A tile is considered in
   * transition if tile.getAlpha() has not yet been called or has been called
   * and returned 1.
   * @param {string} id An id for the renderer.
   * @return {boolean} The tile is in transition.
   */
  inTransition(e) {
    return this.transition_ ? this.transitionStarts_[e] !== -1 : !1;
  }
  /**
   * Mark a transition as complete.
   * @param {string} id An id for the renderer.
   */
  endTransition(e) {
    this.transition_ && (this.transitionStarts_[e] = -1);
  }
}
const VE = C$;
class E$ extends bu {
  /**
   * @param {import("./extent.js").Extent} extent Extent.
   * @param {number|undefined} resolution Resolution.
   * @param {number} pixelRatio Pixel ratio.
   * @param {import("./ImageState.js").default} state State.
   */
  constructor(e, t, r, n) {
    super(), this.extent = e, this.pixelRatio_ = r, this.resolution = t, this.state = n;
  }
  /**
   * @protected
   */
  changed() {
    this.dispatchEvent(ut.CHANGE);
  }
  /**
   * @return {import("./extent.js").Extent} Extent.
   */
  getExtent() {
    return this.extent;
  }
  /**
   * @abstract
   * @return {HTMLCanvasElement|HTMLImageElement|HTMLVideoElement} Image.
   */
  getImage() {
    return pt();
  }
  /**
   * @return {number} PixelRatio.
   */
  getPixelRatio() {
    return this.pixelRatio_;
  }
  /**
   * @return {number} Resolution.
   */
  getResolution() {
    return (
      /** @type {number} */
      this.resolution
    );
  }
  /**
   * @return {import("./ImageState.js").default} State.
   */
  getState() {
    return this.state;
  }
  /**
   * Load not yet loaded URI.
   * @abstract
   */
  load() {
    pt();
  }
}
const QM = E$;
class B$ extends QM {
  /**
   * @param {import("./extent.js").Extent} extent Extent.
   * @param {number|undefined} resolution Resolution.
   * @param {number} pixelRatio Pixel ratio.
   * @param {string} src Image source URI.
   * @param {?string} crossOrigin Cross origin.
   * @param {LoadFunction} imageLoadFunction Image load function.
   * @param {CanvasRenderingContext2D} [context] Canvas context. When provided, the image will be
   *    drawn into the context's canvas, and `getImage()` will return the canvas once the image
   *    has finished loading.
   */
  constructor(e, t, r, n, s, a, o) {
    super(e, t, r, Pt.IDLE), this.src_ = n, this.image_ = new Image(), s !== null && (this.image_.crossOrigin = s), this.context_ = o, this.unlisten_ = null, this.state = Pt.IDLE, this.imageLoadFunction_ = a;
  }
  /**
   * @return {HTMLCanvasElement|HTMLImageElement|HTMLVideoElement} Image.
   * @api
   */
  getImage() {
    if (this.state == Pt.LOADED && this.context_ && !(this.image_ instanceof HTMLCanvasElement)) {
      const e = this.context_.canvas;
      e.width = this.image_.width, e.height = this.image_.height, this.context_.drawImage(this.image_, 0, 0), this.image_ = this.context_.canvas;
    }
    return this.image_;
  }
  /**
   * Tracks loading or read errors.
   *
   * @private
   */
  handleImageError_() {
    this.state = Pt.ERROR, this.unlistenImage_(), this.changed();
  }
  /**
   * Tracks successful image load.
   *
   * @private
   */
  handleImageLoad_() {
    this.resolution === void 0 && (this.resolution = _i(this.extent) / this.image_.height), this.state = Pt.LOADED, this.unlistenImage_(), this.changed();
  }
  /**
   * Load the image or retry if loading previously failed.
   * Loading is taken care of by the tile queue, and calling this method is
   * only needed for preloading or for reloading in case of an error.
   * @api
   */
  load() {
    (this.state == Pt.IDLE || this.state == Pt.ERROR) && (this.state = Pt.LOADING, this.changed(), this.imageLoadFunction_(this, this.src_), this.unlisten_ = KE(
      this.image_,
      this.handleImageLoad_.bind(this),
      this.handleImageError_.bind(this)
    ));
  }
  /**
   * @param {HTMLCanvasElement|HTMLImageElement|HTMLVideoElement} image Image.
   */
  setImage(e) {
    this.image_ = e, this.resolution = _i(this.extent) / this.image_.height;
  }
  /**
   * Discards event handlers which listen for load completion or errors.
   *
   * @private
   */
  unlistenImage_() {
    this.unlisten_ && (this.unlisten_(), this.unlisten_ = null);
  }
}
function KE(i, e, t) {
  const r = (
    /** @type {HTMLImageElement} */
    i
  );
  let n = !0, s = !1, a = !1;
  const o = [
    Sd(r, ut.LOAD, function() {
      a = !0, s || e();
    })
  ];
  return r.src && UQ ? (s = !0, r.decode().then(function() {
    n && e();
  }).catch(function(A) {
    n && (a ? e() : t());
  })) : o.push(Sd(r, ut.ERROR, t)), function() {
    n = !1, o.forEach(pr);
  };
}
const DM = B$;
class b$ extends VE {
  /**
   * @param {import("./tilecoord.js").TileCoord} tileCoord Tile coordinate.
   * @param {import("./TileState.js").default} state State.
   * @param {string} src Image source URI.
   * @param {?string} crossOrigin Cross origin.
   * @param {import("./Tile.js").LoadFunction} tileLoadFunction Tile load function.
   * @param {import("./Tile.js").Options} [options] Tile options.
   */
  constructor(e, t, r, n, s, a) {
    super(e, t, a), this.crossOrigin_ = n, this.src_ = r, this.key = r, this.image_ = new Image(), n !== null && (this.image_.crossOrigin = n), this.unlisten_ = null, this.tileLoadFunction_ = s;
  }
  /**
   * Get the HTML image element for this tile (may be a Canvas, Image, or Video).
   * @return {HTMLCanvasElement|HTMLImageElement|HTMLVideoElement} Image.
   * @api
   */
  getImage() {
    return this.image_;
  }
  /**
   * Sets an HTML image element for this tile (may be a Canvas or preloaded Image).
   * @param {HTMLCanvasElement|HTMLImageElement} element Element.
   */
  setImage(e) {
    this.image_ = e, this.state = He.LOADED, this.unlistenImage_(), this.changed();
  }
  /**
   * Tracks loading or read errors.
   *
   * @private
   */
  handleImageError_() {
    this.state = He.ERROR, this.unlistenImage_(), this.image_ = S$(), this.changed();
  }
  /**
   * Tracks successful image load.
   *
   * @private
   */
  handleImageLoad_() {
    const e = (
      /** @type {HTMLImageElement} */
      this.image_
    );
    e.naturalWidth && e.naturalHeight ? this.state = He.LOADED : this.state = He.EMPTY, this.unlistenImage_(), this.changed();
  }
  /**
   * Load the image or retry if loading previously failed.
   * Loading is taken care of by the tile queue, and calling this method is
   * only needed for preloading or for reloading in case of an error.
   *
   * To retry loading tiles on failed requests, use a custom `tileLoadFunction`
   * that checks for error status codes and reloads only when the status code is
   * 408, 429, 500, 502, 503 and 504, and only when not too many retries have been
   * made already:
   *
   * ```js
   * const retryCodes = [408, 429, 500, 502, 503, 504];
   * const retries = {};
   * source.setTileLoadFunction((tile, src) => {
   *   const image = tile.getImage();
   *   fetch(src)
   *     .then((response) => {
   *       if (retryCodes.includes(response.status)) {
   *         retries[src] = (retries[src] || 0) + 1;
   *         if (retries[src] <= 3) {
   *           setTimeout(() => tile.load(), retries[src] * 1000);
   *         }
   *         return Promise.reject();
   *       }
   *       return response.blob();
   *     })
   *     .then((blob) => {
   *       const imageUrl = URL.createObjectURL(blob);
   *       image.src = imageUrl;
   *       setTimeout(() => URL.revokeObjectURL(imageUrl), 5000);
   *     })
   *     .catch(() => tile.setState(3)); // error
   * });
   * ```
   *
   * @api
   */
  load() {
    this.state == He.ERROR && (this.state = He.IDLE, this.image_ = new Image(), this.crossOrigin_ !== null && (this.image_.crossOrigin = this.crossOrigin_)), this.state == He.IDLE && (this.state = He.LOADING, this.changed(), this.tileLoadFunction_(this, this.src_), this.unlisten_ = KE(
      this.image_,
      this.handleImageLoad_.bind(this),
      this.handleImageError_.bind(this)
    ));
  }
  /**
   * Discards event handlers which listen for load completion or errors.
   *
   * @private
   */
  unlistenImage_() {
    this.unlisten_ && (this.unlisten_(), this.unlisten_ = null);
  }
}
function S$() {
  const i = Ii(1, 1);
  return i.fillStyle = "rgba(0,0,0,0)", i.fillRect(0, 0, 1, 1), i.canvas;
}
const Nm = b$, jE = 0.5, T$ = 10, o5 = 0.25;
class F$ {
  /**
   * @param {import("../proj/Projection.js").default} sourceProj Source projection.
   * @param {import("../proj/Projection.js").default} targetProj Target projection.
   * @param {import("../extent.js").Extent} targetExtent Target extent to triangulate.
   * @param {import("../extent.js").Extent} maxSourceExtent Maximal source extent that can be used.
   * @param {number} errorThreshold Acceptable error (in source units).
   * @param {?number} destinationResolution The (optional) resolution of the destination.
   */
  constructor(e, t, r, n, s, a) {
    this.sourceProj_ = e, this.targetProj_ = t;
    let o = {};
    const A = Td(this.targetProj_, this.sourceProj_);
    this.transformInv_ = function(w) {
      const C = w[0] + "/" + w[1];
      return o[C] || (o[C] = A(w)), o[C];
    }, this.maxSourceExtent_ = n, this.errorThresholdSquared_ = s * s, this.triangles_ = [], this.wrapsXInSource_ = !1, this.canWrapXInSource_ = this.sourceProj_.canWrapX() && !!n && !!this.sourceProj_.getExtent() && ir(n) == ir(this.sourceProj_.getExtent()), this.sourceWorldWidth_ = this.sourceProj_.getExtent() ? ir(this.sourceProj_.getExtent()) : null, this.targetWorldWidth_ = this.targetProj_.getExtent() ? ir(this.targetProj_.getExtent()) : null;
    const l = Sa(r), h = hg(r), c = Su(r), u = lg(r), f = this.transformInv_(l), g = this.transformInv_(h), p = this.transformInv_(c), y = this.transformInv_(u), v = T$ + (a ? Math.max(
      0,
      Math.ceil(
        Math.log2(
          ph(r) / (a * a * 256 * 256)
        )
      )
    ) : 0);
    if (this.addQuad_(
      l,
      h,
      c,
      u,
      f,
      g,
      p,
      y,
      v
    ), this.wrapsXInSource_) {
      let w = 1 / 0;
      this.triangles_.forEach(function(C, E, S) {
        w = Math.min(
          w,
          C.source[0][0],
          C.source[1][0],
          C.source[2][0]
        );
      }), this.triangles_.forEach((C) => {
        if (Math.max(
          C.source[0][0],
          C.source[1][0],
          C.source[2][0]
        ) - w > this.sourceWorldWidth_ / 2) {
          const E = [
            [C.source[0][0], C.source[0][1]],
            [C.source[1][0], C.source[1][1]],
            [C.source[2][0], C.source[2][1]]
          ];
          E[0][0] - w > this.sourceWorldWidth_ / 2 && (E[0][0] -= this.sourceWorldWidth_), E[1][0] - w > this.sourceWorldWidth_ / 2 && (E[1][0] -= this.sourceWorldWidth_), E[2][0] - w > this.sourceWorldWidth_ / 2 && (E[2][0] -= this.sourceWorldWidth_);
          const S = Math.min(
            E[0][0],
            E[1][0],
            E[2][0]
          );
          Math.max(
            E[0][0],
            E[1][0],
            E[2][0]
          ) - S < this.sourceWorldWidth_ / 2 && (C.source = E);
        }
      });
    }
    o = {};
  }
  /**
   * Adds triangle to the triangulation.
   * @param {import("../coordinate.js").Coordinate} a The target a coordinate.
   * @param {import("../coordinate.js").Coordinate} b The target b coordinate.
   * @param {import("../coordinate.js").Coordinate} c The target c coordinate.
   * @param {import("../coordinate.js").Coordinate} aSrc The source a coordinate.
   * @param {import("../coordinate.js").Coordinate} bSrc The source b coordinate.
   * @param {import("../coordinate.js").Coordinate} cSrc The source c coordinate.
   * @private
   */
  addTriangle_(e, t, r, n, s, a) {
    this.triangles_.push({
      source: [n, s, a],
      target: [e, t, r]
    });
  }
  /**
   * Adds quad (points in clock-wise order) to the triangulation
   * (and reprojects the vertices) if valid.
   * Performs quad subdivision if needed to increase precision.
   *
   * @param {import("../coordinate.js").Coordinate} a The target a coordinate.
   * @param {import("../coordinate.js").Coordinate} b The target b coordinate.
   * @param {import("../coordinate.js").Coordinate} c The target c coordinate.
   * @param {import("../coordinate.js").Coordinate} d The target d coordinate.
   * @param {import("../coordinate.js").Coordinate} aSrc The source a coordinate.
   * @param {import("../coordinate.js").Coordinate} bSrc The source b coordinate.
   * @param {import("../coordinate.js").Coordinate} cSrc The source c coordinate.
   * @param {import("../coordinate.js").Coordinate} dSrc The source d coordinate.
   * @param {number} maxSubdivision Maximal allowed subdivision of the quad.
   * @private
   */
  addQuad_(e, t, r, n, s, a, o, A, l) {
    const h = Xi([s, a, o, A]), c = this.sourceWorldWidth_ ? ir(h) / this.sourceWorldWidth_ : null, u = (
      /** @type {number} */
      this.sourceWorldWidth_
    ), f = this.sourceProj_.canWrapX() && c > 0.5 && c < 1;
    let g = !1;
    if (l > 0) {
      if (this.targetProj_.isGlobal() && this.targetWorldWidth_) {
        const y = Xi([e, t, r, n]);
        g = ir(y) / this.targetWorldWidth_ > o5 || g;
      }
      !f && this.sourceProj_.isGlobal() && c && (g = c > o5 || g);
    }
    if (!g && this.maxSourceExtent_ && isFinite(h[0]) && isFinite(h[1]) && isFinite(h[2]) && isFinite(h[3]) && !ci(h, this.maxSourceExtent_))
      return;
    let p = 0;
    if (!g && (!isFinite(s[0]) || !isFinite(s[1]) || !isFinite(a[0]) || !isFinite(a[1]) || !isFinite(o[0]) || !isFinite(o[1]) || !isFinite(A[0]) || !isFinite(A[1]))) {
      if (l > 0)
        g = !0;
      else if (p = (!isFinite(s[0]) || !isFinite(s[1]) ? 8 : 0) + (!isFinite(a[0]) || !isFinite(a[1]) ? 4 : 0) + (!isFinite(o[0]) || !isFinite(o[1]) ? 2 : 0) + (!isFinite(A[0]) || !isFinite(A[1]) ? 1 : 0), p != 1 && p != 2 && p != 4 && p != 8)
        return;
    }
    if (l > 0) {
      if (!g) {
        const y = [(e[0] + r[0]) / 2, (e[1] + r[1]) / 2], v = this.transformInv_(y);
        let w;
        f ? w = (tl(s[0], u) + tl(o[0], u)) / 2 - tl(v[0], u) : w = (s[0] + o[0]) / 2 - v[0];
        const C = (s[1] + o[1]) / 2 - v[1];
        g = w * w + C * C > this.errorThresholdSquared_;
      }
      if (g) {
        if (Math.abs(e[0] - r[0]) <= Math.abs(e[1] - r[1])) {
          const y = [(t[0] + r[0]) / 2, (t[1] + r[1]) / 2], v = this.transformInv_(y), w = [(n[0] + e[0]) / 2, (n[1] + e[1]) / 2], C = this.transformInv_(w);
          this.addQuad_(
            e,
            t,
            y,
            w,
            s,
            a,
            v,
            C,
            l - 1
          ), this.addQuad_(
            w,
            y,
            r,
            n,
            C,
            v,
            o,
            A,
            l - 1
          );
        } else {
          const y = [(e[0] + t[0]) / 2, (e[1] + t[1]) / 2], v = this.transformInv_(y), w = [(r[0] + n[0]) / 2, (r[1] + n[1]) / 2], C = this.transformInv_(w);
          this.addQuad_(
            e,
            y,
            w,
            n,
            s,
            v,
            C,
            A,
            l - 1
          ), this.addQuad_(
            y,
            t,
            r,
            w,
            v,
            a,
            o,
            C,
            l - 1
          );
        }
        return;
      }
    }
    if (f) {
      if (!this.canWrapXInSource_)
        return;
      this.wrapsXInSource_ = !0;
    }
    p & 11 || this.addTriangle_(e, r, n, s, o, A), p & 14 || this.addTriangle_(e, r, t, s, o, a), p && (p & 13 || this.addTriangle_(t, n, e, a, A, s), p & 7 || this.addTriangle_(t, n, r, a, A, o));
  }
  /**
   * Calculates extent of the `source` coordinates from all the triangles.
   *
   * @return {import("../extent.js").Extent} Calculated extent.
   */
  calculateSourceExtent() {
    const e = Ji();
    return this.triangles_.forEach(function(t, r, n) {
      const s = t.source;
      eh(e, s[0]), eh(e, s[1]), eh(e, s[2]);
    }), e;
  }
  /**
   * @return {Array<Triangle>} Array of the calculated triangles.
   */
  getTriangles() {
    return this.triangles_;
  }
}
const zE = F$;
let O1;
const $o = [];
function A5(i, e, t, r, n) {
  i.beginPath(), i.moveTo(0, 0), i.lineTo(e, t), i.lineTo(r, n), i.closePath(), i.save(), i.clip(), i.fillRect(0, 0, Math.max(e, r) + 1, Math.max(t, n)), i.restore();
}
function U1(i, e) {
  return Math.abs(i[e * 4] - 210) > 2 || Math.abs(i[e * 4 + 3] - 0.75 * 255) > 2;
}
function L$() {
  if (O1 === void 0) {
    const i = Ii(6, 6, $o);
    i.globalCompositeOperation = "lighter", i.fillStyle = "rgba(210, 0, 0, 0.75)", A5(i, 4, 5, 4, 0), A5(i, 4, 5, 0, 5);
    const e = i.getImageData(0, 0, 3, 3).data;
    O1 = U1(e, 0) || U1(e, 4) || U1(e, 8), gu(i), $o.push(i.canvas);
  }
  return O1;
}
function Hd(i, e, t, r) {
  const n = cl(t, e, i);
  let s = pm(
    e,
    r,
    t
  );
  const a = e.getMetersPerUnit();
  a !== void 0 && (s *= a);
  const o = i.getMetersPerUnit();
  o !== void 0 && (s /= o);
  const A = i.getExtent();
  if (!A || Wo(A, n)) {
    const l = pm(i, s, n) / s;
    isFinite(l) && l > 0 && (s /= l);
  }
  return s;
}
function kM(i, e, t, r) {
  const n = Xn(t);
  let s = Hd(
    i,
    e,
    n,
    r
  );
  return (!isFinite(s) || s <= 0) && Mv(t, function(a) {
    return s = Hd(
      i,
      e,
      a,
      r
    ), isFinite(s) && s > 0;
  }), s;
}
function XE(i, e, t, r, n, s, a, o, A, l, h, c) {
  const u = Ii(
    Math.round(t * i),
    Math.round(t * e),
    $o
  );
  if (c || (u.imageSmoothingEnabled = !1), A.length === 0)
    return u.canvas;
  u.scale(t, t);
  function f(E) {
    return Math.round(E * t) / t;
  }
  u.globalCompositeOperation = "lighter";
  const g = Ji();
  A.forEach(function(E, S, M) {
    Jl(g, E.extent);
  });
  const p = ir(g), y = _i(g), v = Ii(
    Math.round(t * p / r),
    Math.round(t * y / r),
    $o
  );
  c || (v.imageSmoothingEnabled = !1);
  const w = t / r;
  A.forEach(function(E, S, M) {
    const T = E.extent[0] - g[0], F = -(E.extent[3] - g[3]), k = ir(E.extent), $ = _i(E.extent);
    E.image.width > 0 && E.image.height > 0 && v.drawImage(
      E.image,
      l,
      l,
      E.image.width - 2 * l,
      E.image.height - 2 * l,
      T * w,
      F * w,
      k * w,
      $ * w
    );
  });
  const C = Sa(a);
  return o.getTriangles().forEach(function(E, S, M) {
    const T = E.source, F = E.target;
    let k = T[0][0], $ = T[0][1], I = T[1][0], L = T[1][1], P = T[2][0], Q = T[2][1];
    const X = f((F[0][0] - C[0]) / s), W = f(
      -(F[0][1] - C[1]) / s
    ), q = f((F[1][0] - C[0]) / s), Z = f(
      -(F[1][1] - C[1]) / s
    ), oe = f((F[2][0] - C[0]) / s), ne = f(
      -(F[2][1] - C[1]) / s
    ), me = k, b = $;
    k = 0, $ = 0, I -= me, L -= b, P -= me, Q -= b;
    const H = [
      [I, L, 0, 0, q - X],
      [P, Q, 0, 0, oe - X],
      [0, 0, I, L, Z - W],
      [0, 0, P, Q, ne - W]
    ], V = qQ(H);
    if (V) {
      if (u.save(), u.beginPath(), L$() || !c) {
        u.moveTo(q, Z);
        const j = 4, ie = X - q, ue = W - Z;
        for (let fe = 0; fe < j; fe++)
          u.lineTo(
            q + f((fe + 1) * ie / j),
            Z + f(fe * ue / (j - 1))
          ), fe != j - 1 && u.lineTo(
            q + f((fe + 1) * ie / j),
            Z + f((fe + 1) * ue / (j - 1))
          );
        u.lineTo(oe, ne);
      } else
        u.moveTo(q, Z), u.lineTo(X, W), u.lineTo(oe, ne);
      u.clip(), u.transform(
        V[0],
        V[2],
        V[1],
        V[3],
        X,
        W
      ), u.translate(
        g[0] - me,
        g[3] - b
      ), u.scale(
        r / t,
        -r / t
      ), u.drawImage(v.canvas, 0, 0), u.restore();
    }
  }), gu(v), $o.push(v.canvas), h && (u.save(), u.globalCompositeOperation = "source-over", u.strokeStyle = "black", u.lineWidth = 1, o.getTriangles().forEach(function(E, S, M) {
    const T = E.target, F = (T[0][0] - C[0]) / s, k = -(T[0][1] - C[1]) / s, $ = (T[1][0] - C[0]) / s, I = -(T[1][1] - C[1]) / s, L = (T[2][0] - C[0]) / s, P = -(T[2][1] - C[1]) / s;
    u.beginPath(), u.moveTo($, I), u.lineTo(F, k), u.lineTo(L, P), u.closePath(), u.stroke();
  }), u.restore()), u.canvas;
}
class I$ extends VE {
  /**
   * @param {import("../proj/Projection.js").default} sourceProj Source projection.
   * @param {import("../tilegrid/TileGrid.js").default} sourceTileGrid Source tile grid.
   * @param {import("../proj/Projection.js").default} targetProj Target projection.
   * @param {import("../tilegrid/TileGrid.js").default} targetTileGrid Target tile grid.
   * @param {import("../tilecoord.js").TileCoord} tileCoord Coordinate of the tile.
   * @param {import("../tilecoord.js").TileCoord} wrappedTileCoord Coordinate of the tile wrapped in X.
   * @param {number} pixelRatio Pixel ratio.
   * @param {number} gutter Gutter of the source tiles.
   * @param {FunctionType} getTileFunction
   *     Function returning source tiles (z, x, y, pixelRatio).
   * @param {number} [errorThreshold] Acceptable reprojection error (in px).
   * @param {boolean} [renderEdges] Render reprojection edges.
   * @param {boolean} [interpolate] Use linear interpolation when resampling.
   */
  constructor(e, t, r, n, s, a, o, A, l, h, c, u) {
    super(s, He.IDLE, { interpolate: !!u }), this.renderEdges_ = c !== void 0 ? c : !1, this.pixelRatio_ = o, this.gutter_ = A, this.canvas_ = null, this.sourceTileGrid_ = t, this.targetTileGrid_ = n, this.wrappedTileCoord_ = a || s, this.sourceTiles_ = [], this.sourcesListenerKeys_ = null, this.sourceZ_ = 0;
    const f = n.getTileCoordExtent(
      this.wrappedTileCoord_
    ), g = this.targetTileGrid_.getExtent();
    let p = this.sourceTileGrid_.getExtent();
    const y = g ? jn(f, g) : f;
    if (ph(y) === 0) {
      this.state = He.EMPTY;
      return;
    }
    const v = e.getExtent();
    v && (p ? p = jn(p, v) : p = v);
    const w = n.getResolution(
      this.wrappedTileCoord_[0]
    ), C = kM(
      e,
      r,
      y,
      w
    );
    if (!isFinite(C) || C <= 0) {
      this.state = He.EMPTY;
      return;
    }
    const E = h !== void 0 ? h : jE;
    if (this.triangulation_ = new zE(
      e,
      r,
      y,
      p,
      C * E,
      w
    ), this.triangulation_.getTriangles().length === 0) {
      this.state = He.EMPTY;
      return;
    }
    this.sourceZ_ = t.getZForResolution(C);
    let S = this.triangulation_.calculateSourceExtent();
    if (p && (e.canWrapX() ? (S[1] = jr(
      S[1],
      p[1],
      p[3]
    ), S[3] = jr(
      S[3],
      p[1],
      p[3]
    )) : S = jn(S, p)), !ph(S))
      this.state = He.EMPTY;
    else {
      const M = t.getTileRangeForExtentAndZ(
        S,
        this.sourceZ_
      );
      for (let T = M.minX; T <= M.maxX; T++)
        for (let F = M.minY; F <= M.maxY; F++) {
          const k = l(this.sourceZ_, T, F, o);
          k && this.sourceTiles_.push(k);
        }
      this.sourceTiles_.length === 0 && (this.state = He.EMPTY);
    }
  }
  /**
   * Get the HTML Canvas element for this tile.
   * @return {HTMLCanvasElement} Canvas.
   */
  getImage() {
    return this.canvas_;
  }
  /**
   * @private
   */
  reproject_() {
    const e = [];
    if (this.sourceTiles_.forEach((t) => {
      t && t.getState() == He.LOADED && e.push({
        extent: this.sourceTileGrid_.getTileCoordExtent(t.tileCoord),
        image: t.getImage()
      });
    }), this.sourceTiles_.length = 0, e.length === 0)
      this.state = He.ERROR;
    else {
      const t = this.wrappedTileCoord_[0], r = this.targetTileGrid_.getTileSize(t), n = typeof r == "number" ? r : r[0], s = typeof r == "number" ? r : r[1], a = this.targetTileGrid_.getResolution(t), o = this.sourceTileGrid_.getResolution(
        this.sourceZ_
      ), A = this.targetTileGrid_.getTileCoordExtent(
        this.wrappedTileCoord_
      );
      this.canvas_ = XE(
        n,
        s,
        this.pixelRatio_,
        o,
        this.sourceTileGrid_.getExtent(),
        a,
        A,
        this.triangulation_,
        e,
        this.gutter_,
        this.renderEdges_,
        this.interpolate
      ), this.state = He.LOADED;
    }
    this.changed();
  }
  /**
   * Load not yet loaded URI.
   */
  load() {
    if (this.state == He.IDLE) {
      this.state = He.LOADING, this.changed();
      let e = 0;
      this.sourcesListenerKeys_ = [], this.sourceTiles_.forEach((t) => {
        const r = t.getState();
        if (r == He.IDLE || r == He.LOADING) {
          e++;
          const n = St(
            t,
            ut.CHANGE,
            function(s) {
              const a = t.getState();
              (a == He.LOADED || a == He.ERROR || a == He.EMPTY) && (pr(n), e--, e === 0 && (this.unlistenSources_(), this.reproject_()));
            },
            this
          );
          this.sourcesListenerKeys_.push(n);
        }
      }), e === 0 ? setTimeout(this.reproject_.bind(this), 0) : this.sourceTiles_.forEach(function(t, r, n) {
        t.getState() == He.IDLE && t.load();
      });
    }
  }
  /**
   * @private
   */
  unlistenSources_() {
    this.sourcesListenerKeys_.forEach(pr), this.sourcesListenerKeys_ = null;
  }
  /**
   * Remove from the cache due to expiry
   */
  release() {
    this.canvas_ && (gu(this.canvas_.getContext("2d")), $o.push(this.canvas_), this.canvas_ = null), super.release();
  }
}
const _u = I$;
class HM {
  /**
   * @param {number} minX Minimum X.
   * @param {number} maxX Maximum X.
   * @param {number} minY Minimum Y.
   * @param {number} maxY Maximum Y.
   */
  constructor(e, t, r, n) {
    this.minX = e, this.maxX = t, this.minY = r, this.maxY = n;
  }
  /**
   * @param {import("./tilecoord.js").TileCoord} tileCoord Tile coordinate.
   * @return {boolean} Contains tile coordinate.
   */
  contains(e) {
    return this.containsXY(e[1], e[2]);
  }
  /**
   * @param {TileRange} tileRange Tile range.
   * @return {boolean} Contains.
   */
  containsTileRange(e) {
    return this.minX <= e.minX && e.maxX <= this.maxX && this.minY <= e.minY && e.maxY <= this.maxY;
  }
  /**
   * @param {number} x Tile coordinate x.
   * @param {number} y Tile coordinate y.
   * @return {boolean} Contains coordinate.
   */
  containsXY(e, t) {
    return this.minX <= e && e <= this.maxX && this.minY <= t && t <= this.maxY;
  }
  /**
   * @param {TileRange} tileRange Tile range.
   * @return {boolean} Equals.
   */
  equals(e) {
    return this.minX == e.minX && this.minY == e.minY && this.maxX == e.maxX && this.maxY == e.maxY;
  }
  /**
   * @param {TileRange} tileRange Tile range.
   */
  extend(e) {
    e.minX < this.minX && (this.minX = e.minX), e.maxX > this.maxX && (this.maxX = e.maxX), e.minY < this.minY && (this.minY = e.minY), e.maxY > this.maxY && (this.maxY = e.maxY);
  }
  /**
   * @return {number} Height.
   */
  getHeight() {
    return this.maxY - this.minY + 1;
  }
  /**
   * @return {import("./size.js").Size} Size.
   */
  getSize() {
    return [this.getWidth(), this.getHeight()];
  }
  /**
   * @return {number} Width.
   */
  getWidth() {
    return this.maxX - this.minX + 1;
  }
  /**
   * @param {TileRange} tileRange Tile range.
   * @return {boolean} Intersects.
   */
  intersects(e) {
    return this.minX <= e.maxX && this.maxX >= e.minX && this.minY <= e.maxY && this.maxY >= e.minY;
  }
}
function nc(i, e, t, r, n) {
  return n !== void 0 ? (n.minX = i, n.maxX = e, n.minY = t, n.maxY = r, n) : new HM(i, e, t, r);
}
const WE = HM;
class R$ extends $E {
  /**
   * @param {LayerType} tileLayer Tile layer.
   */
  constructor(e) {
    super(e), this.extentChanged = !0, this.renderedExtent_ = null, this.renderedPixelRatio, this.renderedProjection = null, this.renderedRevision, this.renderedTiles = [], this.newTiles_ = !1, this.tmpExtent = Ji(), this.tmpTileRange_ = new WE(0, 0, 0, 0);
  }
  /**
   * @protected
   * @param {import("../../Tile.js").default} tile Tile.
   * @return {boolean} Tile is drawable.
   */
  isDrawableTile(e) {
    const t = this.getLayer(), r = e.getState(), n = t.getUseInterimTilesOnError();
    return r == He.LOADED || r == He.EMPTY || r == He.ERROR && !n;
  }
  /**
   * @param {number} z Tile coordinate z.
   * @param {number} x Tile coordinate x.
   * @param {number} y Tile coordinate y.
   * @param {import("../../Map.js").FrameState} frameState Frame state.
   * @return {!import("../../Tile.js").default} Tile.
   */
  getTile(e, t, r, n) {
    const s = n.pixelRatio, a = n.viewState.projection, o = this.getLayer();
    let l = o.getSource().getTile(e, t, r, s, a);
    return l.getState() == He.ERROR && o.getUseInterimTilesOnError() && o.getPreload() > 0 && (this.newTiles_ = !0), this.isDrawableTile(l) || (l = l.getInterimTile()), l;
  }
  /**
   * @param {import("../../pixel.js").Pixel} pixel Pixel.
   * @return {Uint8ClampedArray} Data at the pixel location.
   */
  getData(e) {
    const t = this.frameState;
    if (!t)
      return null;
    const r = this.getLayer(), n = vi(
      t.pixelToCoordinateTransform,
      e.slice()
    ), s = r.getExtent();
    if (s && !Wo(s, n))
      return null;
    const a = t.pixelRatio, o = t.viewState.projection, A = t.viewState, l = r.getRenderSource(), h = l.getTileGridForProjection(A.projection), c = l.getTilePixelRatio(t.pixelRatio);
    for (let u = h.getZForResolution(A.resolution); u >= h.getMinZoom(); --u) {
      const f = h.getTileCoordForCoordAndZ(n, u), g = l.getTile(
        u,
        f[1],
        f[2],
        a,
        o
      );
      if (!(g instanceof Nm || g instanceof _u) || g instanceof _u && g.getState() === He.EMPTY)
        return null;
      if (g.getState() !== He.LOADED)
        continue;
      const p = h.getOrigin(u), y = An(h.getTileSize(u)), v = h.getResolution(u), w = Math.floor(
        c * ((n[0] - p[0]) / v - f[1] * y[0])
      ), C = Math.floor(
        c * ((p[1] - n[1]) / v - f[2] * y[1])
      ), E = Math.round(
        c * l.getGutterForProjection(A.projection)
      );
      return this.getImageData(g.getImage(), w + E, C + E);
    }
    return null;
  }
  /**
   * @param {Object<number, Object<string, import("../../Tile.js").default>>} tiles Lookup of loaded tiles by zoom level.
   * @param {number} zoom Zoom level.
   * @param {import("../../Tile.js").default} tile Tile.
   * @return {boolean|void} If `false`, the tile will not be considered loaded.
   */
  loadedTileCallback(e, t, r) {
    return this.isDrawableTile(r) ? super.loadedTileCallback(e, t, r) : !1;
  }
  /**
   * Determine whether render should be called.
   * @param {import("../../Map.js").FrameState} frameState Frame state.
   * @return {boolean} Layer is ready to be rendered.
   */
  prepareFrame(e) {
    return !!this.getLayer().getSource();
  }
  /**
   * Render the layer.
   * @param {import("../../Map.js").FrameState} frameState Frame state.
   * @param {HTMLElement} target Target that may be used to render content to.
   * @return {HTMLElement} The rendered element.
   */
  renderFrame(e, t) {
    const r = e.layerStatesArray[e.layerIndex], n = e.viewState, s = n.projection, a = n.resolution, o = n.center, A = n.rotation, l = e.pixelRatio, h = this.getLayer(), c = h.getSource(), u = c.getRevision(), f = c.getTileGridForProjection(s), g = f.getZForResolution(a, c.zDirection), p = f.getResolution(g);
    let y = e.extent;
    const v = e.viewState.resolution, w = c.getTilePixelRatio(l), C = Math.round(ir(y) / v * l), E = Math.round(_i(y) / v * l), S = r.extent && Os(r.extent);
    S && (y = jn(
      y,
      Os(r.extent)
    ));
    const M = p * C / 2 / w, T = p * E / 2 / w, F = [
      o[0] - M,
      o[1] - T,
      o[0] + M,
      o[1] + T
    ], k = f.getTileRangeForExtentAndZ(y, g), $ = {};
    $[g] = {};
    const I = this.createLoadedTileFinder(
      c,
      s,
      $
    ), L = this.tmpExtent, P = this.tmpTileRange_;
    this.newTiles_ = !1;
    const Q = A ? um(
      n.center,
      v,
      A,
      e.size
    ) : void 0;
    for (let H = k.minX; H <= k.maxX; ++H)
      for (let V = k.minY; V <= k.maxY; ++V) {
        if (A && !f.tileCoordIntersectsViewport([g, H, V], Q))
          continue;
        const j = this.getTile(g, H, V, e);
        if (this.isDrawableTile(j)) {
          const fe = st(this);
          if (j.getState() == He.LOADED) {
            $[g][j.tileCoord.toString()] = j;
            let ee = j.inTransition(fe);
            ee && r.opacity !== 1 && (j.endTransition(fe), ee = !1), !this.newTiles_ && (ee || !this.renderedTiles.includes(j)) && (this.newTiles_ = !0);
          }
          if (j.getAlpha(fe, e.time) === 1)
            continue;
        }
        const ie = f.getTileCoordChildTileRange(
          j.tileCoord,
          P,
          L
        );
        let ue = !1;
        ie && (ue = I(g + 1, ie)), ue || f.forEachTileCoordParentTileRange(
          j.tileCoord,
          I,
          P,
          L
        );
      }
    const X = p / a * l / w;
    Qs(
      this.pixelTransform,
      e.size[0] / 2,
      e.size[1] / 2,
      1 / l,
      1 / l,
      A,
      -C / 2,
      -E / 2
    );
    const W = nE(this.pixelTransform);
    this.useContainer(t, W, this.getBackground(e));
    const q = this.context, Z = q.canvas;
    Ag(this.inversePixelTransform, this.pixelTransform), Qs(
      this.tempTransform,
      C / 2,
      E / 2,
      X,
      X,
      0,
      -C / 2,
      -E / 2
    ), Z.width != C || Z.height != E ? (Z.width = C, Z.height = E) : this.containerReused || q.clearRect(0, 0, C, E), S && this.clipUnrotated(q, e, S), c.getInterpolate() || (q.imageSmoothingEnabled = !1), this.preRender(q, e), this.renderedTiles.length = 0;
    let oe = Object.keys($).map(Number);
    oe.sort(Al);
    let ne, me, b;
    r.opacity === 1 && (!this.containerReused || c.getOpaque(e.viewState.projection)) ? oe = oe.reverse() : (ne = [], me = []);
    for (let H = oe.length - 1; H >= 0; --H) {
      const V = oe[H], j = c.getTilePixelSize(
        V,
        l,
        s
      ), ue = f.getResolution(V) / p, fe = j[0] * ue * X, ee = j[1] * ue * X, xe = f.getTileCoordForCoordAndZ(
        Sa(F),
        V
      ), Ee = f.getTileCoordExtent(xe), Ue = vi(this.tempTransform, [
        w * (Ee[0] - F[0]) / p,
        w * (F[3] - Ee[3]) / p
      ]), ke = w * c.getGutterForProjection(s), We = $[V];
      for (const ve in We) {
        const Y = (
          /** @type {import("../../ImageTile.js").default} */
          We[ve]
        ), mt = Y.tileCoord, Ze = xe[1] - mt[1], Fe = Math.round(Ue[0] - (Ze - 1) * fe), Re = xe[2] - mt[2], De = Math.round(Ue[1] - (Re - 1) * ee), Le = Math.round(Ue[0] - Ze * fe), Ge = Math.round(Ue[1] - Re * ee), ze = Fe - Le, ft = De - Ge, Et = g === V, Mt = Et && Y.getAlpha(st(this), e.time) !== 1;
        let Ut = !1;
        if (!Mt)
          if (ne) {
            b = [Le, Ge, Le + ze, Ge, Le + ze, Ge + ft, Le, Ge + ft];
            for (let At = 0, vt = ne.length; At < vt; ++At)
              if (g !== V && V < me[At]) {
                const Ne = ne[At];
                ci(
                  [Le, Ge, Le + ze, Ge + ft],
                  [Ne[0], Ne[3], Ne[4], Ne[7]]
                ) && (Ut || (q.save(), Ut = !0), q.beginPath(), q.moveTo(b[0], b[1]), q.lineTo(b[2], b[3]), q.lineTo(b[4], b[5]), q.lineTo(b[6], b[7]), q.moveTo(Ne[6], Ne[7]), q.lineTo(Ne[4], Ne[5]), q.lineTo(Ne[2], Ne[3]), q.lineTo(Ne[0], Ne[1]), q.clip());
              }
            ne.push(b), me.push(V);
          } else
            q.clearRect(Le, Ge, ze, ft);
        this.drawTileImage(
          Y,
          e,
          Le,
          Ge,
          ze,
          ft,
          ke,
          Et
        ), ne && !Mt ? (Ut && q.restore(), this.renderedTiles.unshift(Y)) : this.renderedTiles.push(Y), this.updateUsedTiles(e.usedTiles, c, Y);
      }
    }
    return this.renderedRevision = u, this.renderedResolution = p, this.extentChanged = !this.renderedExtent_ || !Xa(this.renderedExtent_, F), this.renderedExtent_ = F, this.renderedPixelRatio = l, this.renderedProjection = s, this.manageTilePyramid(
      e,
      c,
      f,
      l,
      s,
      y,
      g,
      h.getPreload()
    ), this.scheduleExpireCache(e, c), this.postRender(q, e), r.extent && q.restore(), q.imageSmoothingEnabled = !0, W !== Z.style.transform && (Z.style.transform = W), this.container;
  }
  /**
   * @param {import("../../ImageTile.js").default} tile Tile.
   * @param {import("../../Map.js").FrameState} frameState Frame state.
   * @param {number} x Left of the tile.
   * @param {number} y Top of the tile.
   * @param {number} w Width of the tile.
   * @param {number} h Height of the tile.
   * @param {number} gutter Tile gutter.
   * @param {boolean} transition Apply an alpha transition.
   */
  drawTileImage(e, t, r, n, s, a, o, A) {
    const l = this.getTileImage(e);
    if (!l)
      return;
    const h = st(this), c = t.layerStatesArray[t.layerIndex], u = c.opacity * (A ? e.getAlpha(h, t.time) : 1), f = u !== this.context.globalAlpha;
    f && (this.context.save(), this.context.globalAlpha = u), this.context.drawImage(
      l,
      o,
      o,
      l.width - 2 * o,
      l.height - 2 * o,
      r,
      n,
      s,
      a
    ), f && this.context.restore(), u !== c.opacity ? t.animate = !0 : A && e.endTransition(h);
  }
  /**
   * @return {HTMLCanvasElement} Image
   */
  getImage() {
    const e = this.context;
    return e ? e.canvas : null;
  }
  /**
   * Get the image from a tile.
   * @param {import("../../ImageTile.js").default} tile Tile.
   * @return {HTMLCanvasElement|HTMLImageElement|HTMLVideoElement} Image.
   * @protected
   */
  getTileImage(e) {
    return e.getImage();
  }
  /**
   * @param {import("../../Map.js").FrameState} frameState Frame state.
   * @param {import("../../source/Tile.js").default} tileSource Tile source.
   * @protected
   */
  scheduleExpireCache(e, t) {
    if (t.canExpireCache()) {
      const r = function(n, s, a) {
        const o = st(n);
        o in a.usedTiles && n.expireCache(
          a.viewState.projection,
          a.usedTiles[o]
        );
      }.bind(null, t);
      e.postRenderFunctions.push(
        /** @type {import("../../Map.js").PostRenderFunction} */
        r
      );
    }
  }
  /**
   * @param {!Object<string, !Object<string, boolean>>} usedTiles Used tiles.
   * @param {import("../../source/Tile.js").default} tileSource Tile source.
   * @param {import('../../Tile.js').default} tile Tile.
   * @protected
   */
  updateUsedTiles(e, t, r) {
    const n = st(t);
    n in e || (e[n] = {}), e[n][r.getKey()] = !0;
  }
  /**
   * Manage tile pyramid.
   * This function performs a number of functions related to the tiles at the
   * current zoom and lower zoom levels:
   * - registers idle tiles in frameState.wantedTiles so that they are not
   *   discarded by the tile queue
   * - enqueues missing tiles
   * @param {import("../../Map.js").FrameState} frameState Frame state.
   * @param {import("../../source/Tile.js").default} tileSource Tile source.
   * @param {import("../../tilegrid/TileGrid.js").default} tileGrid Tile grid.
   * @param {number} pixelRatio Pixel ratio.
   * @param {import("../../proj/Projection.js").default} projection Projection.
   * @param {import("../../extent.js").Extent} extent Extent.
   * @param {number} currentZ Current Z.
   * @param {number} preload Load low resolution tiles up to `preload` levels.
   * @param {function(import("../../Tile.js").default):void} [tileCallback] Tile callback.
   * @protected
   */
  manageTilePyramid(e, t, r, n, s, a, o, A, l) {
    const h = st(t);
    h in e.wantedTiles || (e.wantedTiles[h] = {});
    const c = e.wantedTiles[h], u = e.tileQueue, f = r.getMinZoom(), g = e.viewState.rotation, p = g ? um(
      e.viewState.center,
      e.viewState.resolution,
      g,
      e.size
    ) : void 0;
    let y = 0, v, w, C, E, S, M;
    for (M = f; M <= o; ++M)
      for (w = r.getTileRangeForExtentAndZ(a, M, w), C = r.getResolution(M), E = w.minX; E <= w.maxX; ++E)
        for (S = w.minY; S <= w.maxY; ++S)
          g && !r.tileCoordIntersectsViewport([M, E, S], p) || (o - M <= A ? (++y, v = t.getTile(M, E, S, n, s), v.getState() == He.IDLE && (c[v.getKey()] = !0, u.isKeyQueued(v.getKey()) || u.enqueue([
            v,
            h,
            r.getTileCoordCenter(v.tileCoord),
            C
          ])), l !== void 0 && l(v)) : t.useTile(M, E, S, s));
    t.updateCacheSize(y, s);
  }
}
const GM = R$;
let M$ = class extends OM {
  /**
   * @param {import("./BaseTile.js").Options<TileSourceType>} [options] Tile layer options.
   */
  constructor(e) {
    super(e);
  }
  createRenderer() {
    return new GM(this);
  }
};
const t2 = M$, N$ = {
  props: {
    className: {
      type: String,
      default: "ol-layer"
    },
    opacity: {
      type: Number,
      default: 1
    },
    visible: {
      type: Boolean,
      default: !0
    },
    extent: {
      type: Array
    },
    zIndex: {
      type: Number
    },
    minResolution: {
      type: Number
    },
    maxResolution: {
      type: Number
    },
    minZoom: {
      type: Number
    },
    maxZoom: {
      type: Number
    },
    title: {
      type: String
    },
    name: {
      type: String
    },
    preview: {
      type: String
    },
    baseLayer: {
      type: Boolean
    },
    properties: {
      type: Object,
      default: () => ({})
    }
  }
};
function P$(i, e, t, r, n, s) {
  return xn(), Cn("div");
}
const Th = /* @__PURE__ */ qe(N$, [["render", P$]]), O$ = {
  extends: Th,
  name: "ol-tile-layer",
  setup(i) {
    const e = _t("map"), t = _t("overviewMap", null), { properties: r } = sr(i), n = cr(() => new t2(r)), s = () => {
      t != null ? (t.value.getOverviewMap().addLayer(n.value), t.value.changed()) : e.addLayer(n.value);
    }, a = () => {
      t != null ? (t.value.getOverviewMap().removeLayer(n.value), t.value.changed()) : e.removeLayer(n.value);
    };
    return t != null && at(t, () => {
      a(), s();
    }), tr(() => {
      s();
    }), nr(() => {
      a();
    }), Ur("tileLayer", n), {
      tileLayer: n
    };
  },
  props: {
    preload: {
      type: Number,
      default: 1
    }
  }
};
function U$(i, e, t, r, n, s) {
  return xn(), Cn("div", null, [
    mr(i.$slots, "default")
  ]);
}
const r2 = /* @__PURE__ */ qe(O$, [["render", U$]]);
class Q$ {
  /**
   * @param {number} [highWaterMark] High water mark.
   */
  constructor(e) {
    this.highWaterMark = e !== void 0 ? e : 2048, this.count_ = 0, this.entries_ = {}, this.oldest_ = null, this.newest_ = null;
  }
  /**
   * @return {boolean} Can expire cache.
   */
  canExpireCache() {
    return this.highWaterMark > 0 && this.getCount() > this.highWaterMark;
  }
  /**
   * Expire the cache.
   * @param {!Object<string, boolean>} [keep] Keys to keep. To be implemented by subclasses.
   */
  expireCache(e) {
    for (; this.canExpireCache(); )
      this.pop();
  }
  /**
   * FIXME empty description for jsdoc
   */
  clear() {
    this.count_ = 0, this.entries_ = {}, this.oldest_ = null, this.newest_ = null;
  }
  /**
   * @param {string} key Key.
   * @return {boolean} Contains key.
   */
  containsKey(e) {
    return this.entries_.hasOwnProperty(e);
  }
  /**
   * @param {function(T, string, LRUCache<T>): ?} f The function
   *     to call for every entry from the oldest to the newer. This function takes
   *     3 arguments (the entry value, the entry key and the LRUCache object).
   *     The return value is ignored.
   */
  forEach(e) {
    let t = this.oldest_;
    for (; t; )
      e(t.value_, t.key_, this), t = t.newer;
  }
  /**
   * @param {string} key Key.
   * @param {*} [options] Options (reserved for subclasses).
   * @return {T} Value.
   */
  get(e, t) {
    const r = this.entries_[e];
    return lt(r !== void 0, 15), r === this.newest_ || (r === this.oldest_ ? (this.oldest_ = /** @type {Entry} */
    this.oldest_.newer, this.oldest_.older = null) : (r.newer.older = r.older, r.older.newer = r.newer), r.newer = null, r.older = this.newest_, this.newest_.newer = r, this.newest_ = r), r.value_;
  }
  /**
   * Remove an entry from the cache.
   * @param {string} key The entry key.
   * @return {T} The removed entry.
   */
  remove(e) {
    const t = this.entries_[e];
    return lt(t !== void 0, 15), t === this.newest_ ? (this.newest_ = /** @type {Entry} */
    t.older, this.newest_ && (this.newest_.newer = null)) : t === this.oldest_ ? (this.oldest_ = /** @type {Entry} */
    t.newer, this.oldest_ && (this.oldest_.older = null)) : (t.newer.older = t.older, t.older.newer = t.newer), delete this.entries_[e], --this.count_, t.value_;
  }
  /**
   * @return {number} Count.
   */
  getCount() {
    return this.count_;
  }
  /**
   * @return {Array<string>} Keys.
   */
  getKeys() {
    const e = new Array(this.count_);
    let t = 0, r;
    for (r = this.newest_; r; r = r.older)
      e[t++] = r.key_;
    return e;
  }
  /**
   * @return {Array<T>} Values.
   */
  getValues() {
    const e = new Array(this.count_);
    let t = 0, r;
    for (r = this.newest_; r; r = r.older)
      e[t++] = r.value_;
    return e;
  }
  /**
   * @return {T} Last value.
   */
  peekLast() {
    return this.oldest_.value_;
  }
  /**
   * @return {string} Last key.
   */
  peekLastKey() {
    return this.oldest_.key_;
  }
  /**
   * Get the key of the newest item in the cache.  Throws if the cache is empty.
   * @return {string} The newest key.
   */
  peekFirstKey() {
    return this.newest_.key_;
  }
  /**
   * Return an entry without updating least recently used time.
   * @param {string} key Key.
   * @return {T} Value.
   */
  peek(e) {
    if (this.containsKey(e))
      return this.entries_[e].value_;
  }
  /**
   * @return {T} value Value.
   */
  pop() {
    const e = this.oldest_;
    return delete this.entries_[e.key_], e.newer && (e.newer.older = null), this.oldest_ = /** @type {Entry} */
    e.newer, this.oldest_ || (this.newest_ = null), --this.count_, e.value_;
  }
  /**
   * @param {string} key Key.
   * @param {T} value Value.
   */
  replace(e, t) {
    this.get(e), this.entries_[e].value_ = t;
  }
  /**
   * @param {string} key Key.
   * @param {T} value Value.
   */
  set(e, t) {
    lt(!(e in this.entries_), 16);
    const r = {
      key_: e,
      newer: null,
      older: this.newest_,
      value_: t
    };
    this.newest_ ? this.newest_.newer = r : this.oldest_ = r, this.newest_ = r, this.entries_[e] = r, ++this.count_;
  }
  /**
   * Set a maximum number of entries for the cache.
   * @param {number} size Cache size.
   * @api
   */
  setSize(e) {
    this.highWaterMark = e;
  }
}
const $M = Q$;
function Pm(i) {
  return i instanceof Image || i instanceof HTMLCanvasElement || i instanceof HTMLVideoElement ? i : null;
}
function i2(i) {
  return i instanceof Uint8Array || i instanceof Uint8ClampedArray || i instanceof Float32Array || i instanceof DataView ? i : null;
}
let Tf = null;
function D$(i) {
  Tf || (Tf = Ii(
    i.width,
    i.height,
    void 0,
    { willReadFrequently: !0 }
  ));
  const e = Tf.canvas, t = i.width;
  e.width !== t && (e.width = t);
  const r = i.height;
  return e.height !== r && (e.height = r), Tf.drawImage(i, t, r), Tf.getImageData(0, 0, t, r).data;
}
const k$ = [256, 256];
class H$ extends VE {
  /**
   * @param {Options} options Tile options.
   */
  constructor(e) {
    const t = He.IDLE;
    super(e.tileCoord, t, {
      transition: e.transition,
      interpolate: e.interpolate
    }), this.loader_ = e.loader, this.data_ = null, this.error_ = null, this.size_ = e.size || null;
  }
  /**
   * Get the tile size.
   * @return {import('./size.js').Size} Tile size.
   */
  getSize() {
    if (this.size_)
      return this.size_;
    const e = Pm(this.data_);
    return e ? [e.width, e.height] : k$;
  }
  /**
   * Get the data for the tile.
   * @return {Data} Tile data.
   * @api
   */
  getData() {
    return this.data_;
  }
  /**
   * Get any loading error.
   * @return {Error} Loading error.
   * @api
   */
  getError() {
    return this.error_;
  }
  /**
   * Load not yet loaded URI.
   * @api
   */
  load() {
    if (this.state !== He.IDLE && this.state !== He.ERROR)
      return;
    this.state = He.LOADING, this.changed();
    const e = this;
    this.loader_().then(function(t) {
      e.data_ = t, e.state = He.LOADED, e.changed();
    }).catch(function(t) {
      e.error_ = t, e.state = He.ERROR, e.changed();
    });
  }
}
const VM = H$;
class G$ extends VM {
  /**
   * @param {Options} options Tile options.
   */
  constructor(e) {
    super({
      tileCoord: e.tileCoord,
      loader: () => Promise.resolve(new Uint8Array(4)),
      interpolate: e.interpolate,
      transition: e.transition
    }), this.pixelRatio_ = e.pixelRatio, this.gutter_ = e.gutter, this.reprojData_ = null, this.reprojError_ = null, this.reprojSize_ = void 0, this.sourceTileGrid_ = e.sourceTileGrid, this.targetTileGrid_ = e.targetTileGrid, this.wrappedTileCoord_ = e.wrappedTileCoord || e.tileCoord, this.sourceTiles_ = [], this.sourcesListenerKeys_ = null, this.sourceZ_ = 0;
    const t = this.targetTileGrid_.getTileCoordExtent(
      this.wrappedTileCoord_
    ), r = this.targetTileGrid_.getExtent();
    let n = this.sourceTileGrid_.getExtent();
    const s = r ? jn(t, r) : t;
    if (ph(s) === 0) {
      this.state = He.EMPTY;
      return;
    }
    const a = e.sourceProj, o = a.getExtent();
    o && (n ? n = jn(n, o) : n = o);
    const A = this.targetTileGrid_.getResolution(
      this.wrappedTileCoord_[0]
    ), l = e.targetProj, h = kM(
      a,
      l,
      s,
      A
    );
    if (!isFinite(h) || h <= 0) {
      this.state = He.EMPTY;
      return;
    }
    const c = e.errorThreshold !== void 0 ? e.errorThreshold : jE;
    if (this.triangulation_ = new zE(
      a,
      l,
      s,
      n,
      h * c,
      A
    ), this.triangulation_.getTriangles().length === 0) {
      this.state = He.EMPTY;
      return;
    }
    this.sourceZ_ = this.sourceTileGrid_.getZForResolution(h);
    let u = this.triangulation_.calculateSourceExtent();
    if (n && (a.canWrapX() ? (u[1] = jr(
      u[1],
      n[1],
      n[3]
    ), u[3] = jr(
      u[3],
      n[1],
      n[3]
    )) : u = jn(u, n)), !ph(u))
      this.state = He.EMPTY;
    else {
      const f = this.sourceTileGrid_.getTileRangeForExtentAndZ(
        u,
        this.sourceZ_
      ), g = e.getTileFunction;
      for (let p = f.minX; p <= f.maxX; p++)
        for (let y = f.minY; y <= f.maxY; y++) {
          const v = g(this.sourceZ_, p, y, this.pixelRatio_);
          v && this.sourceTiles_.push(v);
        }
      this.sourceTiles_.length === 0 && (this.state = He.EMPTY);
    }
  }
  /**
   * Get the tile size.
   * @return {import('../size.js').Size} Tile size.
   */
  getSize() {
    return this.reprojSize_;
  }
  /**
   * Get the data for the tile.
   * @return {import("../DataTile.js").Data} Tile data.
   */
  getData() {
    return this.reprojData_;
  }
  /**
   * Get any loading error.
   * @return {Error} Loading error.
   */
  getError() {
    return this.reprojError_;
  }
  /**
   * @private
   */
  reproject_() {
    const e = [];
    if (this.sourceTiles_.forEach((t) => {
      if (!t || t.getState() !== He.LOADED)
        return;
      const r = t.getSize(), n = this.gutter_;
      let s;
      const a = i2(t.getData());
      a ? s = a : s = D$(Pm(t.getData()));
      const o = [r[0] + 2 * n, r[1] + 2 * n], A = s instanceof Float32Array, l = o[0] * o[1], h = A ? Float32Array : Uint8Array, c = new h(s.buffer), u = h.BYTES_PER_ELEMENT, f = u * c.length / l, g = c.byteLength / o[1], p = Math.floor(
        g / u / o[0]
      ), y = l * p;
      let v = c;
      if (c.length !== y) {
        v = new h(y);
        let w = 0, C = 0;
        const E = o[0] * p;
        for (let S = 0; S < o[1]; ++S) {
          for (let M = 0; M < E; ++M)
            v[w++] = c[C + M];
          C += g / u;
        }
      }
      e.push({
        extent: this.sourceTileGrid_.getTileCoordExtent(t.tileCoord),
        data: new Uint8Array(v.buffer),
        dataType: h,
        bytesPerPixel: f,
        pixelSize: o
      });
    }), this.sourceTiles_.length = 0, e.length === 0)
      this.state = He.ERROR;
    else {
      const t = this.wrappedTileCoord_[0], r = this.targetTileGrid_.getTileSize(t), n = typeof r == "number" ? r : r[0], s = typeof r == "number" ? r : r[1], a = this.targetTileGrid_.getResolution(t), o = this.sourceTileGrid_.getResolution(
        this.sourceZ_
      ), A = this.targetTileGrid_.getTileCoordExtent(
        this.wrappedTileCoord_
      );
      let l, h;
      const c = e[0].bytesPerPixel, u = Math.ceil(c / 3);
      for (let f = u - 1; f >= 0; --f) {
        const g = [];
        for (let E = 0, S = e.length; E < S; ++E) {
          const M = e[E], T = M.data, F = M.pixelSize, k = F[0], $ = F[1], I = Ii(k, $, $o), L = I.createImageData(k, $), P = L.data;
          let Q = f * 3;
          for (let X = 0, W = P.length; X < W; X += 4)
            P[X] = T[Q], P[X + 1] = T[Q + 1], P[X + 2] = T[Q + 2], P[X + 3] = 255, Q += c;
          I.putImageData(L, 0, 0), g.push({
            extent: M.extent,
            image: I.canvas
          });
        }
        const p = XE(
          n,
          s,
          this.pixelRatio_,
          o,
          this.sourceTileGrid_.getExtent(),
          a,
          A,
          this.triangulation_,
          g,
          this.gutter_,
          !1,
          !1
        );
        for (let E = 0, S = g.length; E < S; ++E) {
          const T = g[E].image.getContext("2d");
          gu(T), $o.push(T.canvas);
        }
        const y = p.getContext("2d"), v = y.getImageData(
          0,
          0,
          p.width,
          p.height
        );
        gu(y), $o.push(p), l || (h = new Uint8Array(
          c * v.width * v.height
        ), l = new e[0].dataType(h.buffer));
        const w = v.data;
        let C = f * 3;
        for (let E = 0, S = w.length; E < S; E += 4)
          w[E + 3] === 255 ? (h[C] = w[E], h[C + 1] = w[E + 1], h[C + 2] = w[E + 2]) : (h[C] = 0, h[C + 1] = 0, h[C + 2] = 0), C += c;
      }
      this.reprojData_ = l, this.reprojSize_ = [
        Math.round(n * this.pixelRatio_),
        Math.round(s * this.pixelRatio_)
      ], this.state = He.LOADED;
    }
    this.changed();
  }
  /**
   * Load not yet loaded URI.
   */
  load() {
    if (this.state !== He.IDLE && this.state !== He.ERROR)
      return;
    this.state = He.LOADING, this.changed();
    let e = 0;
    this.sourcesListenerKeys_ = [], this.sourceTiles_.forEach((t) => {
      const r = t.getState();
      if (r !== He.IDLE && r !== He.LOADING)
        return;
      e++;
      const n = St(
        t,
        ut.CHANGE,
        function() {
          const s = t.getState();
          (s == He.LOADED || s == He.ERROR || s == He.EMPTY) && (pr(n), e--, e === 0 && (this.unlistenSources_(), this.reproject_()));
        },
        this
      );
      this.sourcesListenerKeys_.push(n);
    }), e === 0 ? setTimeout(this.reproject_.bind(this), 0) : this.sourceTiles_.forEach(function(t) {
      t.getState() == He.IDLE && t.load();
    });
  }
  /**
   * @private
   */
  unlistenSources_() {
    this.sourcesListenerKeys_.forEach(pr), this.sourcesListenerKeys_ = null;
  }
}
const l5 = G$, Gd = 34962, $v = 34963, $$ = 35040, YE = 35044, $0 = 35048, V$ = 5121, K$ = 5123, j$ = 5125, KM = 5126, h5 = ["experimental-webgl", "webgl", "webkit-3d", "moz-webgl"];
function jM(i, e) {
  e = Object.assign(
    {
      preserveDrawingBuffer: !0,
      antialias: !PQ
      // https://bugs.webkit.org/show_bug.cgi?id=237906
    },
    e
  );
  const t = h5.length;
  for (let r = 0; r < t; ++r)
    try {
      const n = i.getContext(h5[r], e);
      if (n)
        return (
          /** @type {!WebGLRenderingContext} */
          n
        );
    } catch {
    }
  return null;
}
const z$ = {
  STATIC_DRAW: YE,
  STREAM_DRAW: $$,
  DYNAMIC_DRAW: $0
};
class X$ {
  /**
   * @param {number} type Buffer type, either ARRAY_BUFFER or ELEMENT_ARRAY_BUFFER.
   * @param {number} [usage] Intended usage, either `STATIC_DRAW`, `STREAM_DRAW` or `DYNAMIC_DRAW`.
   * Default is `DYNAMIC_DRAW`.
   */
  constructor(e, t) {
    this.array = null, this.type = e, lt(e === Gd || e === $v, 62), this.usage = t !== void 0 ? t : z$.STATIC_DRAW;
  }
  /**
   * Populates the buffer with an array of the given size (all values will be zeroes).
   * @param {number} size Array size
   */
  ofSize(e) {
    this.array = new (Q1(this.type))(e);
  }
  /**
   * Populates the buffer with an array of the given size.
   * @param {Array<number>} array Numerical array
   */
  fromArray(e) {
    this.array = Q1(this.type).from(e);
  }
  /**
   * Populates the buffer with a raw binary array buffer.
   * @param {ArrayBuffer} buffer Raw binary buffer to populate the array with. Note that this buffer must have been
   * initialized for the same typed array class.
   */
  fromArrayBuffer(e) {
    this.array = new (Q1(this.type))(e);
  }
  /**
   * @return {number} Buffer type.
   */
  getType() {
    return this.type;
  }
  /**
   * Will return null if the buffer was not initialized
   * @return {Float32Array|Uint32Array} Array.
   */
  getArray() {
    return this.array;
  }
  /**
   * @return {number} Usage.
   */
  getUsage() {
    return this.usage;
  }
  /**
   * Will return 0 if the buffer is not initialized
   * @return {number} Array size
   */
  getSize() {
    return this.array ? this.array.length : 0;
  }
}
function Q1(i) {
  switch (i) {
    case Gd:
      return Float32Array;
    case $v:
      return Uint32Array;
    default:
      return Float32Array;
  }
}
const cd = X$;
function zM(i, e, t) {
  const r = t ? i.LINEAR : i.NEAREST;
  i.bindTexture(i.TEXTURE_2D, e), i.texParameteri(i.TEXTURE_2D, i.TEXTURE_WRAP_S, i.CLAMP_TO_EDGE), i.texParameteri(i.TEXTURE_2D, i.TEXTURE_WRAP_T, i.CLAMP_TO_EDGE), i.texParameteri(i.TEXTURE_2D, i.TEXTURE_MIN_FILTER, r), i.texParameteri(i.TEXTURE_2D, i.TEXTURE_MAG_FILTER, r);
}
function W$(i, e, t, r) {
  zM(i, e, r), i.texImage2D(i.TEXTURE_2D, 0, i.RGBA, i.RGBA, i.UNSIGNED_BYTE, t);
}
function c5(i, e, t, r, n, s) {
  const a = i.getGL();
  let o, A;
  t instanceof Float32Array ? (o = a.FLOAT, i.getExtension("OES_texture_float"), A = i.getExtension("OES_texture_float_linear") !== null) : (o = a.UNSIGNED_BYTE, A = !0), zM(a, e, s && A);
  const l = t.byteLength / r[1];
  let h = 1;
  l % 8 === 0 ? h = 8 : l % 4 === 0 ? h = 4 : l % 2 === 0 && (h = 2);
  let c;
  switch (n) {
    case 1: {
      c = a.LUMINANCE;
      break;
    }
    case 2: {
      c = a.LUMINANCE_ALPHA;
      break;
    }
    case 3: {
      c = a.RGB;
      break;
    }
    case 4: {
      c = a.RGBA;
      break;
    }
    default:
      throw new Error(`Unsupported number of bands: ${n}`);
  }
  const u = a.getParameter(a.UNPACK_ALIGNMENT);
  a.pixelStorei(a.UNPACK_ALIGNMENT, h), a.texImage2D(
    a.TEXTURE_2D,
    0,
    c,
    r[0],
    r[1],
    0,
    c,
    o,
    t
  ), a.pixelStorei(a.UNPACK_ALIGNMENT, u);
}
let Sc = null;
function Y$() {
  Sc = Ii(1, 1, void 0, {
    willReadFrequently: !0
  });
}
class q$ extends bu {
  /**
   * @param {Options} options The tile texture options.
   */
  constructor(e) {
    super(), this.tile, this.textures = [], this.handleTileChange_ = this.handleTileChange_.bind(this), this.renderSize_ = An(
      e.grid.getTileSize(e.tile.tileCoord[0])
    ), this.gutter_ = e.gutter || 0, this.bandCount = NaN, this.helper_ = e.helper;
    const t = new cd(Gd, YE);
    t.fromArray([
      0,
      // P0
      1,
      1,
      // P1
      1,
      1,
      // P2
      0,
      0,
      // P3
      0
    ]), this.helper_.flushBufferData(t), this.coords = t, this.setTile(e.tile);
  }
  /**
   * @param {TileType} tile Tile.
   */
  setTile(e) {
    if (e !== this.tile)
      if (this.tile && this.tile.removeEventListener(ut.CHANGE, this.handleTileChange_), this.tile = e, this.textures.length = 0, this.loaded = e.getState() === He.LOADED, this.loaded)
        this.uploadTile_();
      else {
        if (e instanceof Nm) {
          const t = e.getImage();
          t instanceof Image && !t.crossOrigin && (t.crossOrigin = "anonymous");
        }
        e.addEventListener(ut.CHANGE, this.handleTileChange_);
      }
  }
  uploadTile_() {
    const e = this.helper_, t = e.getGL(), r = this.tile;
    let n;
    r instanceof Nm || r instanceof _u ? n = r.getImage() : n = r.getData();
    const s = Pm(n);
    if (s) {
      const w = t.createTexture();
      this.textures.push(w), this.bandCount = 4, W$(t, w, s, r.interpolate);
      return;
    }
    n = i2(n);
    const a = (
      /** @type {DataTile} */
      r.getSize()
    ), o = [
      a[0] + 2 * this.gutter_,
      a[1] + 2 * this.gutter_
    ], A = n instanceof Float32Array, l = o[0] * o[1], h = A ? Float32Array : Uint8Array, c = h.BYTES_PER_ELEMENT, u = n.byteLength / o[1];
    this.bandCount = Math.floor(u / c / o[0]);
    const f = Math.ceil(this.bandCount / 4);
    if (f === 1) {
      const w = t.createTexture();
      this.textures.push(w), c5(
        e,
        w,
        n,
        o,
        this.bandCount,
        r.interpolate
      );
      return;
    }
    const g = new Array(f);
    for (let w = 0; w < f; ++w) {
      const C = t.createTexture();
      this.textures.push(C);
      const E = w < f - 1 ? 4 : (this.bandCount - 1) % 4 + 1;
      g[w] = new h(l * E);
    }
    let p = 0, y = 0;
    const v = o[0] * this.bandCount;
    for (let w = 0; w < o[1]; ++w) {
      for (let C = 0; C < v; ++C) {
        const E = n[y + C], S = Math.floor(p / this.bandCount), M = C % this.bandCount, T = Math.floor(M / 4), F = g[T], k = F.length / l, $ = M % 4;
        F[S * k + $] = E, ++p;
      }
      y += u / c;
    }
    for (let w = 0; w < f; ++w) {
      const C = this.textures[w], E = g[w], S = E.length / l;
      c5(
        e,
        C,
        E,
        o,
        S,
        r.interpolate
      );
    }
  }
  handleTileChange_() {
    this.tile.getState() === He.LOADED && (this.loaded = !0, this.uploadTile_(), this.dispatchEvent(ut.CHANGE));
  }
  disposeInternal() {
    const e = this.helper_.getGL();
    this.helper_.deleteBuffer(this.coords);
    for (let t = 0; t < this.textures.length; ++t)
      e.deleteTexture(this.textures[t]);
    this.tile.removeEventListener(ut.CHANGE, this.handleTileChange_);
  }
  /**
   * @param {import("../DataTile.js").ImageLike} image The image.
   * @param {number} renderCol The column index (in rendered tile space).
   * @param {number} renderRow The row index (in rendered tile space).
   * @return {Uint8ClampedArray|null} The data.
   * @private
   */
  getImagePixelData_(e, t, r) {
    const n = this.gutter_, s = this.renderSize_[0], a = this.renderSize_[1];
    Sc || Y$(), Sc.clearRect(0, 0, 1, 1);
    const o = e.width, A = e.height, l = o - 2 * n, h = A - 2 * n, c = n + Math.floor(l * (t / s)), u = n + Math.floor(h * (r / a));
    let f;
    try {
      Sc.drawImage(e, c, u, 1, 1, 0, 0, 1, 1), f = Sc.getImageData(0, 0, 1, 1).data;
    } catch {
      return Sc = null, null;
    }
    return f;
  }
  /**
   * @param {import("../DataTile.js").ArrayLike} data The data.
   * @param {import("../size.js").Size} sourceSize The size.
   * @param {number} renderCol The column index (in rendered tile space).
   * @param {number} renderRow The row index (in rendered tile space).
   * @return {import("../DataTile.js").ArrayLike|null} The data.
   * @private
   */
  getArrayPixelData_(e, t, r, n) {
    const s = this.gutter_, a = this.renderSize_[0], o = this.renderSize_[1], A = t[0], l = t[1], h = A + 2 * s, c = l + 2 * s, u = s + Math.floor(A * (r / a)), f = s + Math.floor(l * (n / o));
    if (e instanceof DataView) {
      const p = e.byteLength / (h * c), y = p * (f * h + u), v = e.buffer.slice(y, y + p);
      return new DataView(v);
    }
    const g = this.bandCount * (f * h + u);
    return e.slice(g, g + this.bandCount);
  }
  /**
   * Get data for a pixel.  If the tile is not loaded, null is returned.
   * @param {number} renderCol The column index (in rendered tile space).
   * @param {number} renderRow The row index (in rendered tile space).
   * @return {import("../DataTile.js").ArrayLike|null} The data.
   */
  getPixelData(e, t) {
    if (!this.loaded)
      return null;
    if (this.tile instanceof VM) {
      const r = this.tile.getData(), n = i2(r);
      if (n) {
        const s = this.tile.getSize();
        return this.getArrayPixelData_(
          n,
          s,
          e,
          t
        );
      }
      return this.getImagePixelData_(Pm(r), e, t);
    }
    return this.getImagePixelData_(this.tile.getImage(), e, t);
  }
}
const Z$ = q$, Rp = {
  LOST: "webglcontextlost",
  RESTORED: "webglcontextrestored"
}, J$ = `
  precision mediump float;
  
  attribute vec2 a_position;
  varying vec2 v_texCoord;
  varying vec2 v_screenCoord;
  
  uniform vec2 u_screenSize;
   
  void main() {
    v_texCoord = a_position * 0.5 + 0.5;
    v_screenCoord = v_texCoord * u_screenSize;
    gl_Position = vec4(a_position, 0.0, 1.0);
  }
`, e9 = `
  precision mediump float;
   
  uniform sampler2D u_image;
  uniform float u_opacity;
   
  varying vec2 v_texCoord;
   
  void main() {
    gl_FragColor = texture2D(u_image, v_texCoord) * u_opacity;
  }
`;
class t9 {
  /**
   * @param {Options} options Options.
   */
  constructor(e) {
    this.gl_ = e.webGlContext;
    const t = this.gl_;
    this.scaleRatio_ = e.scaleRatio || 1, this.renderTargetTexture_ = t.createTexture(), this.renderTargetTextureSize_ = null, this.frameBuffer_ = t.createFramebuffer();
    const r = t.createShader(t.VERTEX_SHADER);
    t.shaderSource(
      r,
      e.vertexShader || J$
    ), t.compileShader(r);
    const n = t.createShader(t.FRAGMENT_SHADER);
    t.shaderSource(
      n,
      e.fragmentShader || e9
    ), t.compileShader(n), this.renderTargetProgram_ = t.createProgram(), t.attachShader(this.renderTargetProgram_, r), t.attachShader(this.renderTargetProgram_, n), t.linkProgram(this.renderTargetProgram_), this.renderTargetVerticesBuffer_ = t.createBuffer();
    const s = [-1, -1, 1, -1, -1, 1, 1, -1, 1, 1, -1, 1];
    t.bindBuffer(t.ARRAY_BUFFER, this.renderTargetVerticesBuffer_), t.bufferData(
      t.ARRAY_BUFFER,
      new Float32Array(s),
      t.STATIC_DRAW
    ), this.renderTargetAttribLocation_ = t.getAttribLocation(
      this.renderTargetProgram_,
      "a_position"
    ), this.renderTargetUniformLocation_ = t.getUniformLocation(
      this.renderTargetProgram_,
      "u_screenSize"
    ), this.renderTargetOpacityLocation_ = t.getUniformLocation(
      this.renderTargetProgram_,
      "u_opacity"
    ), this.renderTargetTextureLocation_ = t.getUniformLocation(
      this.renderTargetProgram_,
      "u_image"
    ), this.uniforms_ = [], e.uniforms && Object.keys(e.uniforms).forEach((a) => {
      this.uniforms_.push({
        value: e.uniforms[a],
        location: t.getUniformLocation(this.renderTargetProgram_, a)
      });
    });
  }
  /**
   * Get the WebGL rendering context
   * @return {WebGLRenderingContext} The rendering context.
   * @api
   */
  getGL() {
    return this.gl_;
  }
  /**
   * Initialize the render target texture of the post process, make sure it is at the
   * right size and bind it as a render target for the next draw calls.
   * The last step to be initialized will be the one where the primitives are rendered.
   * @param {import("../Map.js").FrameState} frameState current frame state
   * @api
   */
  init(e) {
    const t = this.getGL(), r = [
      t.drawingBufferWidth * this.scaleRatio_,
      t.drawingBufferHeight * this.scaleRatio_
    ];
    if (t.bindFramebuffer(t.FRAMEBUFFER, this.getFrameBuffer()), t.viewport(0, 0, r[0], r[1]), !this.renderTargetTextureSize_ || this.renderTargetTextureSize_[0] !== r[0] || this.renderTargetTextureSize_[1] !== r[1]) {
      this.renderTargetTextureSize_ = r;
      const n = 0, s = t.RGBA, a = 0, o = t.RGBA, A = t.UNSIGNED_BYTE, l = null;
      t.bindTexture(t.TEXTURE_2D, this.renderTargetTexture_), t.texImage2D(
        t.TEXTURE_2D,
        n,
        s,
        r[0],
        r[1],
        a,
        o,
        A,
        l
      ), t.texParameteri(t.TEXTURE_2D, t.TEXTURE_MIN_FILTER, t.LINEAR), t.texParameteri(t.TEXTURE_2D, t.TEXTURE_WRAP_S, t.CLAMP_TO_EDGE), t.texParameteri(t.TEXTURE_2D, t.TEXTURE_WRAP_T, t.CLAMP_TO_EDGE), t.framebufferTexture2D(
        t.FRAMEBUFFER,
        t.COLOR_ATTACHMENT0,
        t.TEXTURE_2D,
        this.renderTargetTexture_,
        0
      );
    }
  }
  /**
   * Render to the next postprocessing pass (or to the canvas if final pass).
   * @param {import("../Map.js").FrameState} frameState current frame state
   * @param {WebGLPostProcessingPass} [nextPass] Next pass, optional
   * @param {function(WebGLRenderingContext, import("../Map.js").FrameState):void} [preCompose] Called before composing.
   * @param {function(WebGLRenderingContext, import("../Map.js").FrameState):void} [postCompose] Called before composing.
   * @api
   */
  apply(e, t, r, n) {
    const s = this.getGL(), a = e.size;
    if (s.bindFramebuffer(
      s.FRAMEBUFFER,
      t ? t.getFrameBuffer() : null
    ), s.activeTexture(s.TEXTURE0), s.bindTexture(s.TEXTURE_2D, this.renderTargetTexture_), !t) {
      const A = st(s.canvas);
      if (!e.renderTargets[A]) {
        const l = s.getContextAttributes();
        l && l.preserveDrawingBuffer && (s.clearColor(0, 0, 0, 0), s.clear(s.COLOR_BUFFER_BIT)), e.renderTargets[A] = !0;
      }
    }
    s.enable(s.BLEND), s.blendFunc(s.ONE, s.ONE_MINUS_SRC_ALPHA), s.viewport(0, 0, s.drawingBufferWidth, s.drawingBufferHeight), s.bindBuffer(s.ARRAY_BUFFER, this.renderTargetVerticesBuffer_), s.useProgram(this.renderTargetProgram_), s.enableVertexAttribArray(this.renderTargetAttribLocation_), s.vertexAttribPointer(
      this.renderTargetAttribLocation_,
      2,
      s.FLOAT,
      !1,
      0,
      0
    ), s.uniform2f(this.renderTargetUniformLocation_, a[0], a[1]), s.uniform1i(this.renderTargetTextureLocation_, 0);
    const o = e.layerStatesArray[e.layerIndex].opacity;
    s.uniform1f(this.renderTargetOpacityLocation_, o), this.applyUniforms(e), r && r(s, e), s.drawArrays(s.TRIANGLES, 0, 6), n && n(s, e);
  }
  /**
   * @return {WebGLFramebuffer} Frame buffer
   * @api
   */
  getFrameBuffer() {
    return this.frameBuffer_;
  }
  /**
   * Sets the custom uniforms based on what was given in the constructor.
   * @param {import("../Map.js").FrameState} frameState Frame state.
   * @private
   */
  applyUniforms(e) {
    const t = this.getGL();
    let r, n = 1;
    this.uniforms_.forEach(function(s) {
      if (r = typeof s.value == "function" ? s.value(e) : s.value, r instanceof HTMLCanvasElement || r instanceof ImageData)
        s.texture || (s.texture = t.createTexture()), t.activeTexture(t[`TEXTURE${n}`]), t.bindTexture(t.TEXTURE_2D, s.texture), t.texParameteri(t.TEXTURE_2D, t.TEXTURE_MIN_FILTER, t.LINEAR), t.texParameteri(t.TEXTURE_2D, t.TEXTURE_WRAP_S, t.CLAMP_TO_EDGE), t.texParameteri(t.TEXTURE_2D, t.TEXTURE_WRAP_T, t.CLAMP_TO_EDGE), r instanceof ImageData ? t.texImage2D(
          t.TEXTURE_2D,
          0,
          t.RGBA,
          t.RGBA,
          r.width,
          r.height,
          0,
          t.UNSIGNED_BYTE,
          new Uint8Array(r.data)
        ) : t.texImage2D(
          t.TEXTURE_2D,
          0,
          t.RGBA,
          t.RGBA,
          t.UNSIGNED_BYTE,
          r
        ), t.uniform1i(s.location, n++);
      else if (Array.isArray(r))
        switch (r.length) {
          case 2:
            t.uniform2f(s.location, r[0], r[1]);
            return;
          case 3:
            t.uniform3f(s.location, r[0], r[1], r[2]);
            return;
          case 4:
            t.uniform4f(
              s.location,
              r[0],
              r[1],
              r[2],
              r[3]
            );
            return;
          default:
            return;
        }
      else
        typeof r == "number" && t.uniform1f(s.location, r);
    });
  }
}
const u5 = t9;
function XM() {
  return [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];
}
function V0(i, e) {
  return i[0] = e[0], i[1] = e[1], i[4] = e[2], i[5] = e[3], i[12] = e[4], i[13] = e[5], i;
}
const UA = {
  PROJECTION_MATRIX: "u_projectionMatrix",
  OFFSET_SCALE_MATRIX: "u_offsetScaleMatrix",
  OFFSET_ROTATION_MATRIX: "u_offsetRotateMatrix",
  TIME: "u_time",
  ZOOM: "u_zoom",
  RESOLUTION: "u_resolution",
  SIZE_PX: "u_sizePx",
  PIXEL_RATIO: "u_pixelRatio"
}, Xs = {
  UNSIGNED_BYTE: V$,
  UNSIGNED_SHORT: K$,
  UNSIGNED_INT: j$,
  FLOAT: KM
}, Om = {};
function f5(i) {
  return "shared/" + i;
}
let d5 = 0;
function r9() {
  const i = "unique/" + d5;
  return d5 += 1, i;
}
function i9(i) {
  let e = Om[i];
  if (!e) {
    const t = document.createElement("canvas");
    t.style.position = "absolute", t.style.left = "0", e = { users: 0, canvas: t }, Om[i] = e;
  }
  return e.users += 1, e.canvas;
}
function n9(i) {
  const e = Om[i];
  if (!e || (e.users -= 1, e.users > 0))
    return;
  const t = e.canvas, n = jM(t).getExtension("WEBGL_lose_context");
  n && n.loseContext(), delete Om[i];
}
class s9 extends Fv {
  /**
   * @param {Options} [options] Options.
   */
  constructor(e) {
    super(), e = e || {}, this.boundHandleWebGLContextLost_ = this.handleWebGLContextLost.bind(this), this.boundHandleWebGLContextRestored_ = this.handleWebGLContextRestored.bind(this), this.canvasCacheKey_ = e.canvasCacheKey ? f5(e.canvasCacheKey) : r9(), this.canvas_ = i9(this.canvasCacheKey_), this.gl_ = jM(this.canvas_), this.bufferCache_ = {}, this.extensionCache_ = {}, this.currentProgram_ = null, this.canvas_.addEventListener(
      Rp.LOST,
      this.boundHandleWebGLContextLost_
    ), this.canvas_.addEventListener(
      Rp.RESTORED,
      this.boundHandleWebGLContextRestored_
    ), this.offsetRotateMatrix_ = qi(), this.offsetScaleMatrix_ = qi(), this.tmpMat4_ = XM(), this.uniformLocations_ = {}, this.attribLocations_ = {}, this.uniforms_ = [], e.uniforms && this.setUniforms(e.uniforms);
    const t = this.getGL();
    this.postProcessPasses_ = e.postProcesses ? e.postProcesses.map(function(r) {
      return new u5({
        webGlContext: t,
        scaleRatio: r.scaleRatio,
        vertexShader: r.vertexShader,
        fragmentShader: r.fragmentShader,
        uniforms: r.uniforms
      });
    }) : [new u5({ webGlContext: t })], this.shaderCompileErrors_ = null, this.startTime_ = Date.now();
  }
  /**
   * @param {Object<string, UniformValue>} uniforms Uniform definitions.
   */
  setUniforms(e) {
    this.uniforms_ = [];
    for (const t in e)
      this.uniforms_.push({
        name: t,
        value: e[t]
      });
    this.uniformLocations_ = {};
  }
  /**
   * @param {string} canvasCacheKey The canvas cache key.
   * @return {boolean} The provided key matches the one this helper was constructed with.
   */
  canvasCacheKeyMatches(e) {
    return this.canvasCacheKey_ === f5(e);
  }
  /**
   * Get a WebGL extension.  If the extension is not supported, null is returned.
   * Extensions are cached after they are enabled for the first time.
   * @param {string} name The extension name.
   * @return {Object|null} The extension or null if not supported.
   */
  getExtension(e) {
    if (e in this.extensionCache_)
      return this.extensionCache_[e];
    const t = this.gl_.getExtension(e);
    return this.extensionCache_[e] = t, t;
  }
  /**
   * Just bind the buffer if it's in the cache. Otherwise create
   * the WebGL buffer, bind it, populate it, and add an entry to
   * the cache.
   * @param {import("./Buffer").default} buffer Buffer.
   */
  bindBuffer(e) {
    const t = this.getGL(), r = st(e);
    let n = this.bufferCache_[r];
    if (!n) {
      const s = t.createBuffer();
      n = {
        buffer: e,
        webGlBuffer: s
      }, this.bufferCache_[r] = n;
    }
    t.bindBuffer(e.getType(), n.webGlBuffer);
  }
  /**
   * Update the data contained in the buffer array; this is required for the
   * new data to be rendered
   * @param {import("./Buffer").default} buffer Buffer.
   */
  flushBufferData(e) {
    const t = this.getGL();
    this.bindBuffer(e), t.bufferData(e.getType(), e.getArray(), e.getUsage());
  }
  /**
   * @param {import("./Buffer.js").default} buf Buffer.
   */
  deleteBuffer(e) {
    const t = this.getGL(), r = st(e), n = this.bufferCache_[r];
    n && !t.isContextLost() && t.deleteBuffer(n.webGlBuffer), delete this.bufferCache_[r];
  }
  /**
   * Clean up.
   */
  disposeInternal() {
    this.canvas_.removeEventListener(
      Rp.LOST,
      this.boundHandleWebGLContextLost_
    ), this.canvas_.removeEventListener(
      Rp.RESTORED,
      this.boundHandleWebGLContextRestored_
    ), n9(this.canvasCacheKey_), delete this.gl_, delete this.canvas_;
  }
  /**
   * Clear the buffer & set the viewport to draw.
   * Post process passes will be initialized here, the first one being bound as a render target for
   * subsequent draw calls.
   * @param {import("../Map.js").FrameState} frameState current frame state
   * @param {boolean} [disableAlphaBlend] If true, no alpha blending will happen.
   */
  prepareDraw(e, t) {
    const r = this.getGL(), n = this.getCanvas(), s = e.size, a = e.pixelRatio;
    n.width = s[0] * a, n.height = s[1] * a, n.style.width = s[0] + "px", n.style.height = s[1] + "px";
    for (let o = this.postProcessPasses_.length - 1; o >= 0; o--)
      this.postProcessPasses_[o].init(e);
    r.bindTexture(r.TEXTURE_2D, null), r.clearColor(0, 0, 0, 0), r.clear(r.COLOR_BUFFER_BIT), r.enable(r.BLEND), r.blendFunc(r.ONE, t ? r.ZERO : r.ONE_MINUS_SRC_ALPHA);
  }
  /**
   * Clear the render target & bind it for future draw operations.
   * This is similar to `prepareDraw`, only post processes will not be applied.
   * Note: the whole viewport will be drawn to the render target, regardless of its size.
   * @param {import("../Map.js").FrameState} frameState current frame state
   * @param {import("./RenderTarget.js").default} renderTarget Render target to draw to
   * @param {boolean} [disableAlphaBlend] If true, no alpha blending will happen.
   */
  prepareDrawToRenderTarget(e, t, r) {
    const n = this.getGL(), s = t.getSize();
    n.bindFramebuffer(n.FRAMEBUFFER, t.getFramebuffer()), n.viewport(0, 0, s[0], s[1]), n.bindTexture(n.TEXTURE_2D, t.getTexture()), n.clearColor(0, 0, 0, 0), n.clear(n.COLOR_BUFFER_BIT), n.enable(n.BLEND), n.blendFunc(n.ONE, r ? n.ZERO : n.ONE_MINUS_SRC_ALPHA);
  }
  /**
   * Execute a draw call based on the currently bound program, texture, buffers, attributes.
   * @param {number} start Start index.
   * @param {number} end End index.
   */
  drawElements(e, t) {
    const r = this.getGL();
    this.getExtension("OES_element_index_uint");
    const n = r.UNSIGNED_INT, s = 4, a = t - e, o = e * s;
    r.drawElements(r.TRIANGLES, a, n, o);
  }
  /**
   * Apply the successive post process passes which will eventually render to the actual canvas.
   * @param {import("../Map.js").FrameState} frameState current frame state
   * @param {function(WebGLRenderingContext, import("../Map.js").FrameState):void} [preCompose] Called before composing.
   * @param {function(WebGLRenderingContext, import("../Map.js").FrameState):void} [postCompose] Called before composing.
   */
  finalizeDraw(e, t, r) {
    for (let n = 0, s = this.postProcessPasses_.length; n < s; n++)
      n === s - 1 ? this.postProcessPasses_[n].apply(
        e,
        null,
        t,
        r
      ) : this.postProcessPasses_[n].apply(
        e,
        this.postProcessPasses_[n + 1]
      );
  }
  /**
   * @return {HTMLCanvasElement} Canvas.
   */
  getCanvas() {
    return this.canvas_;
  }
  /**
   * Get the WebGL rendering context
   * @return {WebGLRenderingContext} The rendering context.
   */
  getGL() {
    return this.gl_;
  }
  /**
   * Sets the default matrix uniforms for a given frame state. This is called internally in `prepareDraw`.
   * @param {import("../Map.js").FrameState} frameState Frame state.
   */
  applyFrameState(e) {
    const t = e.size, r = e.viewState.rotation, n = e.pixelRatio, s = Wc(this.offsetScaleMatrix_);
    Yc(s, 2 / t[0], 2 / t[1]);
    const a = Wc(this.offsetRotateMatrix_);
    r !== 0 && yR(a, -r), this.setUniformMatrixValue(
      UA.OFFSET_SCALE_MATRIX,
      V0(this.tmpMat4_, s)
    ), this.setUniformMatrixValue(
      UA.OFFSET_ROTATION_MATRIX,
      V0(this.tmpMat4_, a)
    ), this.setUniformFloatValue(
      UA.TIME,
      (Date.now() - this.startTime_) * 1e-3
    ), this.setUniformFloatValue(UA.ZOOM, e.viewState.zoom), this.setUniformFloatValue(
      UA.RESOLUTION,
      e.viewState.resolution
    ), this.setUniformFloatValue(UA.PIXEL_RATIO, n), this.setUniformFloatVec2(UA.SIZE_PX, [t[0], t[1]]);
  }
  /**
   * Sets the custom uniforms based on what was given in the constructor. This is called internally in `prepareDraw`.
   * @param {import("../Map.js").FrameState} frameState Frame state.
   */
  applyUniforms(e) {
    const t = this.getGL();
    let r, n = 0;
    this.uniforms_.forEach((s) => {
      if (r = typeof s.value == "function" ? s.value(e) : s.value, r instanceof HTMLCanvasElement || r instanceof HTMLImageElement || r instanceof ImageData)
        s.texture || (s.prevValue = void 0, s.texture = t.createTexture()), t.activeTexture(t[`TEXTURE${n}`]), t.bindTexture(t.TEXTURE_2D, s.texture), t.texParameteri(t.TEXTURE_2D, t.TEXTURE_MIN_FILTER, t.LINEAR), t.texParameteri(t.TEXTURE_2D, t.TEXTURE_WRAP_S, t.CLAMP_TO_EDGE), t.texParameteri(t.TEXTURE_2D, t.TEXTURE_WRAP_T, t.CLAMP_TO_EDGE), (!(r instanceof HTMLImageElement) || /** @type {HTMLImageElement} */
        r.complete) && s.prevValue !== r && (s.prevValue = r, t.texImage2D(
          t.TEXTURE_2D,
          0,
          t.RGBA,
          t.RGBA,
          t.UNSIGNED_BYTE,
          r
        )), t.uniform1i(this.getUniformLocation(s.name), n++);
      else if (Array.isArray(r) && r.length === 6)
        this.setUniformMatrixValue(
          s.name,
          V0(this.tmpMat4_, r)
        );
      else if (Array.isArray(r) && r.length <= 4)
        switch (r.length) {
          case 2:
            t.uniform2f(
              this.getUniformLocation(s.name),
              r[0],
              r[1]
            );
            return;
          case 3:
            t.uniform3f(
              this.getUniformLocation(s.name),
              r[0],
              r[1],
              r[2]
            );
            return;
          case 4:
            t.uniform4f(
              this.getUniformLocation(s.name),
              r[0],
              r[1],
              r[2],
              r[3]
            );
            return;
          default:
            return;
        }
      else
        typeof r == "number" && t.uniform1f(this.getUniformLocation(s.name), r);
    });
  }
  /**
   * Set up a program for use. The program will be set as the current one. Then, the uniforms used
   * in the program will be set based on the current frame state and the helper configuration.
   * @param {WebGLProgram} program Program.
   * @param {import("../Map.js").FrameState} frameState Frame state.
   */
  useProgram(e, t) {
    this.getGL().useProgram(e), this.currentProgram_ = e, this.uniformLocations_ = {}, this.attribLocations_ = {}, this.applyFrameState(t), this.applyUniforms(t);
  }
  /**
   * Will attempt to compile a vertex or fragment shader based on source
   * On error, the shader will be returned but
   * `gl.getShaderParameter(shader, gl.COMPILE_STATUS)` will return `true`
   * Use `gl.getShaderInfoLog(shader)` to have details
   * @param {string} source Shader source
   * @param {ShaderType} type VERTEX_SHADER or FRAGMENT_SHADER
   * @return {WebGLShader} Shader object
   */
  compileShader(e, t) {
    const r = this.getGL(), n = r.createShader(t);
    return r.shaderSource(n, e), r.compileShader(n), n;
  }
  /**
   * Create a program for a vertex and fragment shader.  Throws if shader compilation fails.
   * @param {string} fragmentShaderSource Fragment shader source.
   * @param {string} vertexShaderSource Vertex shader source.
   * @return {WebGLProgram} Program
   */
  getProgram(e, t) {
    const r = this.getGL(), n = this.compileShader(
      e,
      r.FRAGMENT_SHADER
    ), s = this.compileShader(
      t,
      r.VERTEX_SHADER
    ), a = r.createProgram();
    if (r.attachShader(a, n), r.attachShader(a, s), r.linkProgram(a), !r.getShaderParameter(n, r.COMPILE_STATUS)) {
      const o = `Fragment shader compilation failed: ${r.getShaderInfoLog(
        n
      )}`;
      throw new Error(o);
    }
    if (r.deleteShader(n), !r.getShaderParameter(s, r.COMPILE_STATUS)) {
      const o = `Vertex shader compilation failed: ${r.getShaderInfoLog(
        s
      )}`;
      throw new Error(o);
    }
    if (r.deleteShader(s), !r.getProgramParameter(a, r.LINK_STATUS)) {
      const o = `GL program linking failed: ${r.getShaderInfoLog(
        s
      )}`;
      throw new Error(o);
    }
    return a;
  }
  /**
   * Will get the location from the shader or the cache
   * @param {string} name Uniform name
   * @return {WebGLUniformLocation} uniformLocation
   */
  getUniformLocation(e) {
    return this.uniformLocations_[e] === void 0 && (this.uniformLocations_[e] = this.getGL().getUniformLocation(
      this.currentProgram_,
      e
    )), this.uniformLocations_[e];
  }
  /**
   * Will get the location from the shader or the cache
   * @param {string} name Attribute name
   * @return {number} attribLocation
   */
  getAttributeLocation(e) {
    return this.attribLocations_[e] === void 0 && (this.attribLocations_[e] = this.getGL().getAttribLocation(
      this.currentProgram_,
      e
    )), this.attribLocations_[e];
  }
  /**
   * Modifies the given transform to apply the rotation/translation/scaling of the given frame state.
   * The resulting transform can be used to convert world space coordinates to view coordinates.
   * @param {import("../Map.js").FrameState} frameState Frame state.
   * @param {import("../transform").Transform} transform Transform to update.
   * @return {import("../transform").Transform} The updated transform object.
   */
  makeProjectionTransform(e, t) {
    const r = e.size, n = e.viewState.rotation, s = e.viewState.resolution, a = e.viewState.center;
    return Wc(t), Qs(
      t,
      0,
      0,
      2 / (s * r[0]),
      2 / (s * r[1]),
      -n,
      -a[0],
      -a[1]
    ), t;
  }
  /**
   * Give a value for a standard float uniform
   * @param {string} uniform Uniform name
   * @param {number} value Value
   */
  setUniformFloatValue(e, t) {
    this.getGL().uniform1f(this.getUniformLocation(e), t);
  }
  /**
   * Give a value for a vec2 uniform
   * @param {string} uniform Uniform name
   * @param {Array<number>} value Array of length 4.
   */
  setUniformFloatVec2(e, t) {
    this.getGL().uniform2fv(this.getUniformLocation(e), t);
  }
  /**
   * Give a value for a vec4 uniform
   * @param {string} uniform Uniform name
   * @param {Array<number>} value Array of length 4.
   */
  setUniformFloatVec4(e, t) {
    this.getGL().uniform4fv(this.getUniformLocation(e), t);
  }
  /**
   * Give a value for a standard matrix4 uniform
   * @param {string} uniform Uniform name
   * @param {Array<number>} value Matrix value
   */
  setUniformMatrixValue(e, t) {
    this.getGL().uniformMatrix4fv(
      this.getUniformLocation(e),
      !1,
      t
    );
  }
  /**
   * Will set the currently bound buffer to an attribute of the shader program. Used by `#enableAttributes`
   * internally.
   * @param {string} attribName Attribute name
   * @param {number} size Number of components per attributes
   * @param {number} type UNSIGNED_INT, UNSIGNED_BYTE, UNSIGNED_SHORT or FLOAT
   * @param {number} stride Stride in bytes (0 means attribs are packed)
   * @param {number} offset Offset in bytes
   * @private
   */
  enableAttributeArray_(e, t, r, n, s) {
    const a = this.getAttributeLocation(e);
    a < 0 || (this.getGL().enableVertexAttribArray(a), this.getGL().vertexAttribPointer(
      a,
      t,
      r,
      !1,
      n,
      s
    ));
  }
  /**
   * Will enable the following attributes to be read from the currently bound buffer,
   * i.e. tell the GPU where to read the different attributes in the buffer. An error in the
   * size/type/order of attributes will most likely break the rendering and throw a WebGL exception.
   * @param {Array<AttributeDescription>} attributes Ordered list of attributes to read from the buffer
   */
  enableAttributes(e) {
    const t = a9(e);
    let r = 0;
    for (let n = 0; n < e.length; n++) {
      const s = e[n];
      this.enableAttributeArray_(
        s.name,
        s.size,
        s.type || KM,
        t,
        r
      ), r += s.size * WM(s.type);
    }
  }
  /**
   * WebGL context was lost
   * @private
   */
  handleWebGLContextLost() {
    Bh(this.bufferCache_), this.currentProgram_ = null;
  }
  /**
   * WebGL context was restored
   * @private
   */
  handleWebGLContextRestored() {
  }
  /**
   * Will create or reuse a given webgl texture and apply the given size. If no image data
   * specified, the texture will be empty, otherwise image data will be used and the `size`
   * parameter will be ignored.
   * Note: wrap parameters are set to clamp to edge, min filter is set to linear.
   * @param {Array<number>} size Expected size of the texture
   * @param {ImageData|HTMLImageElement|HTMLCanvasElement} [data] Image data/object to bind to the texture
   * @param {WebGLTexture} [texture] Existing texture to reuse
   * @return {WebGLTexture} The generated texture
   */
  createTexture(e, t, r) {
    const n = this.getGL();
    r = r || n.createTexture();
    const s = 0, a = n.RGBA, o = 0, A = n.RGBA, l = n.UNSIGNED_BYTE;
    return n.bindTexture(n.TEXTURE_2D, r), t ? n.texImage2D(n.TEXTURE_2D, s, a, A, l, t) : n.texImage2D(
      n.TEXTURE_2D,
      s,
      a,
      e[0],
      e[1],
      o,
      A,
      l,
      null
    ), n.texParameteri(n.TEXTURE_2D, n.TEXTURE_MIN_FILTER, n.LINEAR), n.texParameteri(n.TEXTURE_2D, n.TEXTURE_WRAP_S, n.CLAMP_TO_EDGE), n.texParameteri(n.TEXTURE_2D, n.TEXTURE_WRAP_T, n.CLAMP_TO_EDGE), r;
  }
}
function a9(i) {
  let e = 0;
  for (let t = 0; t < i.length; t++) {
    const r = i[t];
    e += r.size * WM(r.type);
  }
  return e;
}
function WM(i) {
  switch (i) {
    case Xs.UNSIGNED_BYTE:
      return Uint8Array.BYTES_PER_ELEMENT;
    case Xs.UNSIGNED_SHORT:
      return Uint16Array.BYTES_PER_ELEMENT;
    case Xs.UNSIGNED_INT:
      return Uint32Array.BYTES_PER_ELEMENT;
    case Xs.FLOAT:
    default:
      return Float32Array.BYTES_PER_ELEMENT;
  }
}
class qE extends UM {
  /**
   * @param {LayerType} layer Layer.
   * @param {Options} [options] Options.
   */
  constructor(e, t) {
    super(e), t = t || {}, this.inversePixelTransform_ = qi(), this.pixelContext_ = null, this.postProcesses_ = t.postProcesses, this.uniforms_ = t.uniforms, this.helper, e.addChangeListener(Fr.MAP, this.removeHelper.bind(this)), this.dispatchPreComposeEvent = this.dispatchPreComposeEvent.bind(this), this.dispatchPostComposeEvent = this.dispatchPostComposeEvent.bind(this);
  }
  /**
   * @param {WebGLRenderingContext} context The WebGL rendering context.
   * @param {import("../../Map.js").FrameState} frameState Frame state.
   * @protected
   */
  dispatchPreComposeEvent(e, t) {
    const r = this.getLayer();
    if (r.hasListener(ds.PRECOMPOSE)) {
      const n = new ld(
        ds.PRECOMPOSE,
        void 0,
        t,
        e
      );
      r.dispatchEvent(n);
    }
  }
  /**
   * @param {WebGLRenderingContext} context The WebGL rendering context.
   * @param {import("../../Map.js").FrameState} frameState Frame state.
   * @protected
   */
  dispatchPostComposeEvent(e, t) {
    const r = this.getLayer();
    if (r.hasListener(ds.POSTCOMPOSE)) {
      const n = new ld(
        ds.POSTCOMPOSE,
        void 0,
        t,
        e
      );
      r.dispatchEvent(n);
    }
  }
  /**
   * Reset options (only handles uniforms).
   * @param {Options} options Options.
   */
  reset(e) {
    this.uniforms_ = e.uniforms, this.helper && this.helper.setUniforms(this.uniforms_);
  }
  /**
   * @protected
   */
  removeHelper() {
    this.helper && (this.helper.dispose(), delete this.helper);
  }
  /**
   * Determine whether renderFrame should be called.
   * @param {import("../../Map.js").FrameState} frameState Frame state.
   * @return {boolean} Layer is ready to be rendered.
   */
  prepareFrame(e) {
    if (this.getLayer().getRenderSource()) {
      let t = !0, r = -1, n;
      for (let a = 0, o = e.layerStatesArray.length; a < o; a++) {
        const A = e.layerStatesArray[a].layer, l = A.getRenderer();
        if (!(l instanceof qE)) {
          t = !0;
          continue;
        }
        const h = A.getClassName();
        if ((t || h !== n) && (r += 1, t = !1), n = h, l === this)
          break;
      }
      const s = "map/" + e.mapId + "/group/" + r;
      (!this.helper || !this.helper.canvasCacheKeyMatches(s)) && (this.removeHelper(), this.helper = new s9({
        postProcesses: this.postProcesses_,
        uniforms: this.uniforms_,
        canvasCacheKey: s
      }), n && (this.helper.getCanvas().className = n), this.afterHelperCreated());
    }
    return this.prepareFrameInternal(e);
  }
  /**
   * @protected
   */
  afterHelperCreated() {
  }
  /**
   * Determine whether renderFrame should be called.
   * @param {import("../../Map.js").FrameState} frameState Frame state.
   * @return {boolean} Layer is ready to be rendered.
   * @protected
   */
  prepareFrameInternal(e) {
    return !0;
  }
  /**
   * Clean up.
   */
  disposeInternal() {
    this.removeHelper(), super.disposeInternal();
  }
  /**
   * @param {import("../../render/EventType.js").default} type Event type.
   * @param {WebGLRenderingContext} context The rendering context.
   * @param {import("../../Map.js").FrameState} frameState Frame state.
   * @private
   */
  dispatchRenderEvent_(e, t, r) {
    const n = this.getLayer();
    if (n.hasListener(e)) {
      Qs(
        this.inversePixelTransform_,
        0,
        0,
        r.pixelRatio,
        -r.pixelRatio,
        0,
        0,
        -r.size[1]
      );
      const s = new ld(
        e,
        this.inversePixelTransform_,
        r,
        t
      );
      n.dispatchEvent(s);
    }
  }
  /**
   * @param {WebGLRenderingContext} context The rendering context.
   * @param {import("../../Map.js").FrameState} frameState Frame state.
   * @protected
   */
  preRender(e, t) {
    this.dispatchRenderEvent_(ds.PRERENDER, e, t);
  }
  /**
   * @param {WebGLRenderingContext} context The rendering context.
   * @param {import("../../Map.js").FrameState} frameState Frame state.
   * @protected
   */
  postRender(e, t) {
    this.dispatchRenderEvent_(ds.POSTRENDER, e, t);
  }
}
const YM = qE;
function $d(i, e, t, r) {
  return r !== void 0 ? (r[0] = i, r[1] = e, r[2] = t, r) : [i, e, t];
}
function Vv(i, e, t) {
  return i + "/" + e + "/" + t;
}
function Vd(i) {
  return Vv(i[0], i[1], i[2]);
}
function o9(i) {
  return i.split("/").map(Number);
}
function qM(i) {
  return (i[1] << i[0]) + i[2];
}
function A9(i, e) {
  const t = i[0], r = i[1], n = i[2];
  if (e.getMinZoom() > t || t > e.getMaxZoom())
    return !1;
  const s = e.getFullTileRange(t);
  return s ? s.containsXY(r, n) : !0;
}
const Vt = {
  TILE_TEXTURE_ARRAY: "u_tileTextures",
  TILE_TRANSFORM: "u_tileTransform",
  TRANSITION_ALPHA: "u_transitionAlpha",
  DEPTH: "u_depth",
  TEXTURE_PIXEL_WIDTH: "u_texturePixelWidth",
  TEXTURE_PIXEL_HEIGHT: "u_texturePixelHeight",
  TEXTURE_RESOLUTION: "u_textureResolution",
  // map units per texture pixel
  TEXTURE_ORIGIN_X: "u_textureOriginX",
  // map x coordinate of left edge of texture
  TEXTURE_ORIGIN_Y: "u_textureOriginY",
  // map y coordinate of top edge of texture
  RENDER_EXTENT: "u_renderExtent",
  // intersection of layer, source, and view extent
  RESOLUTION: "u_resolution",
  ZOOM: "u_zoom"
}, K0 = {
  TEXTURE_COORD: "a_textureCoord"
}, l9 = [
  {
    name: K0.TEXTURE_COORD,
    size: 2,
    type: Xs.FLOAT
  }
], h9 = {};
function c9(i) {
  return 2 * (1 - 1 / (i + 1)) - 1;
}
function g5(i, e, t) {
  t in i || (i[t] = []), i[t].push(e);
}
function D1(i, e) {
  const t = i.layerStatesArray[i.layerIndex];
  t.extent && (e = jn(
    e,
    Os(t.extent, i.viewState.projection)
  ));
  const r = (
    /** @type {import("../../source/Tile.js").default} */
    t.layer.getRenderSource()
  );
  if (!r.getWrapX()) {
    const n = r.getTileGridForProjection(i.viewState.projection).getExtent();
    n && (e = jn(e, n));
  }
  return e;
}
function k1(i, e) {
  return `${i.getKey()},${Vd(e)}`;
}
class u9 extends YM {
  /**
   * @param {LayerType} tileLayer Tile layer.
   * @param {Options} options Options.
   */
  constructor(e, t) {
    super(e, {
      uniforms: t.uniforms
    }), this.renderComplete = !1, this.tileTransform_ = qi(), this.tempMat4_ = XM(), this.tempTileRange_ = new WE(0, 0, 0, 0), this.tempTileCoord_ = $d(0, 0, 0), this.tempSize_ = [0, 0], this.program_, this.vertexShader_ = t.vertexShader, this.fragmentShader_ = t.fragmentShader, this.indices_ = new cd($v, YE), this.indices_.fromArray([0, 1, 3, 1, 2, 3]);
    const r = t.cacheSize !== void 0 ? t.cacheSize : 512;
    this.tileTextureCache_ = new $M(r), this.paletteTextures_ = t.paletteTextures || [], this.frameState_ = null, this.projection_ = void 0;
  }
  /**
   * @param {Options} options Options.
   */
  reset(e) {
    super.reset({
      uniforms: e.uniforms
    }), this.vertexShader_ = e.vertexShader, this.fragmentShader_ = e.fragmentShader, this.paletteTextures_ = e.paletteTextures || [], this.helper && (this.program_ = this.helper.getProgram(
      this.fragmentShader_,
      this.vertexShader_
    ));
  }
  afterHelperCreated() {
    this.program_ = this.helper.getProgram(
      this.fragmentShader_,
      this.vertexShader_
    ), this.helper.flushBufferData(this.indices_);
  }
  /**
   * @param {import("../../webgl/TileTexture").TileType} tile Tile.
   * @return {boolean} Tile is drawable.
   * @private
   */
  isDrawableTile_(e) {
    const t = this.getLayer(), r = e.getState(), n = t.getUseInterimTilesOnError();
    return r == He.LOADED || r == He.EMPTY || r == He.ERROR && !n;
  }
  /**
   * Determine whether renderFrame should be called.
   * @param {import("../../Map.js").FrameState} frameState Frame state.
   * @return {boolean} Layer is ready to be rendered.
   */
  prepareFrameInternal(e) {
    this.projection_ ? e.viewState.projection !== this.projection_ && (this.clearCache(), this.projection_ = e.viewState.projection) : this.projection_ = e.viewState.projection;
    const r = this.getLayer().getRenderSource();
    return !r || Tu(D1(e, e.extent)) ? !1 : r.getState() === "ready";
  }
  /**
   * @param {import("../../Map.js").FrameState} frameState Frame state.
   * @param {import("../../extent.js").Extent} extent The extent to be rendered.
   * @param {number} initialZ The zoom level.
   * @param {Object<number, Array<TileTexture>>} tileTexturesByZ The zoom level.
   * @param {number} preload Number of additional levels to load.
   */
  enqueueTiles(e, t, r, n, s) {
    const a = e.viewState, o = this.getLayer(), A = o.getRenderSource(), l = A.getTileGridForProjection(a.projection), h = A.getGutterForProjection(a.projection), c = st(A);
    c in e.wantedTiles || (e.wantedTiles[c] = {});
    const u = e.wantedTiles[c], f = this.tileTextureCache_, g = o.getMapInternal(), p = Math.max(
      r - s,
      l.getMinZoom(),
      l.getZForResolution(
        Math.min(
          o.getMaxResolution(),
          g ? g.getView().getResolutionForZoom(Math.max(o.getMinZoom(), 0)) : l.getResolution(0)
        ),
        A.zDirection
      )
    );
    for (let y = r; y >= p; --y) {
      const v = l.getTileRangeForExtentAndZ(
        t,
        y,
        this.tempTileRange_
      ), w = l.getResolution(y);
      for (let C = v.minX; C <= v.maxX; ++C)
        for (let E = v.minY; E <= v.maxY; ++E) {
          const S = $d(y, C, E, this.tempTileCoord_), M = k1(A, S);
          let T, F;
          if (f.containsKey(M) && (T = f.get(M), F = T.tile), !T || T.tile.key !== A.getKey())
            if (F = A.getTile(
              y,
              C,
              E,
              e.pixelRatio,
              a.projection
            ), !T)
              T = new Z$({
                tile: F,
                grid: l,
                helper: this.helper,
                gutter: h
              }), f.set(M, T);
            else if (this.isDrawableTile_(F))
              T.setTile(F);
            else {
              const $ = (
                /** @type {import("../../webgl/TileTexture").TileType} */
                F.getInterimTile()
              );
              T.setTile($);
            }
          g5(n, T, y);
          const k = F.getKey();
          u[k] = !0, F.getState() === He.IDLE && (e.tileQueue.isKeyQueued(k) || e.tileQueue.enqueue([
            F,
            c,
            l.getTileCoordCenter(S),
            w
          ]));
        }
    }
  }
  /**
   * Render the layer.
   * @param {import("../../Map.js").FrameState} frameState Frame state.
   * @return {HTMLElement} The rendered element.
   */
  renderFrame(e) {
    this.frameState_ = e, this.renderComplete = !0;
    const t = this.helper.getGL();
    this.preRender(t, e);
    const r = e.viewState, n = this.getLayer(), s = n.getRenderSource(), a = s.getTileGridForProjection(r.projection), o = s.getGutterForProjection(r.projection), A = D1(e, e.extent), l = a.getZForResolution(
      r.resolution,
      s.zDirection
    ), h = {}, c = n.getPreload();
    if (e.nextExtent) {
      const T = a.getZForResolution(
        r.nextResolution,
        s.zDirection
      ), F = D1(e, e.nextExtent);
      this.enqueueTiles(
        e,
        F,
        T,
        h,
        c
      );
    }
    this.enqueueTiles(e, A, l, h, 0), c > 0 && setTimeout(() => {
      this.enqueueTiles(
        e,
        A,
        l - 1,
        h,
        c - 1
      );
    }, 0);
    const u = {}, f = st(this), g = e.time;
    let p = !1;
    const y = h[l];
    for (let T = 0, F = y.length; T < F; ++T) {
      const k = y[T], $ = k.tile;
      if (($ instanceof _u || $ instanceof l5) && $.getState() === He.EMPTY)
        continue;
      const I = $.tileCoord;
      if (k.loaded) {
        const Q = $.getAlpha(f, g);
        if (Q === 1) {
          $.endTransition(f);
          continue;
        }
        p = !0;
        const X = Vd(I);
        u[X] = Q;
      }
      if (this.renderComplete = !1, this.findAltTiles_(
        a,
        I,
        l + 1,
        h
      ))
        continue;
      const P = a.getMinZoom();
      for (let Q = l - 1; Q >= P && !this.findAltTiles_(
        a,
        I,
        Q,
        h
      ); --Q)
        ;
    }
    this.helper.useProgram(this.program_, e), this.helper.prepareDraw(e, !p);
    const v = Object.keys(h).map(Number).sort(Al), w = r.center[0], C = r.center[1];
    for (let T = 0, F = v.length; T < F; ++T) {
      const k = v[T], $ = a.getResolution(k), I = An(a.getTileSize(k), this.tempSize_), L = a.getOrigin(k), P = I[0] + 2 * o, Q = I[1] + 2 * o, X = P / Q, W = (w - L[0]) / (I[0] * $), q = (L[1] - C) / (I[1] * $), Z = r.resolution / $, oe = c9(k), ne = h[k];
      for (let me = 0, b = ne.length; me < b; ++me) {
        const H = ne[me];
        if (!H.loaded)
          continue;
        const j = H.tile.tileCoord, ie = Vd(j), ue = j[1], fe = j[2];
        Wc(this.tileTransform_), Yc(
          this.tileTransform_,
          2 / (e.size[0] * Z / P),
          -2 / (e.size[1] * Z / P)
        ), yR(this.tileTransform_, r.rotation), Yc(this.tileTransform_, 1, 1 / X), hm(
          this.tileTransform_,
          (I[0] * (ue - W) - o) / P,
          (I[1] * (fe - q) - o) / Q
        ), this.helper.setUniformMatrixValue(
          Vt.TILE_TRANSFORM,
          V0(this.tempMat4_, this.tileTransform_)
        ), this.helper.bindBuffer(H.coords), this.helper.bindBuffer(this.indices_), this.helper.enableAttributes(l9);
        let ee = 0;
        for (; ee < H.textures.length; ) {
          const Ue = "TEXTURE" + ee, ke = `${Vt.TILE_TEXTURE_ARRAY}[${ee}]`;
          t.activeTexture(t[Ue]), t.bindTexture(t.TEXTURE_2D, H.textures[ee]), t.uniform1i(
            this.helper.getUniformLocation(ke),
            ee
          ), ++ee;
        }
        for (let Ue = 0; Ue < this.paletteTextures_.length; ++Ue) {
          const ke = this.paletteTextures_[Ue];
          t.activeTexture(t["TEXTURE" + ee]);
          const We = ke.getTexture(t);
          t.bindTexture(t.TEXTURE_2D, We), t.uniform1i(
            this.helper.getUniformLocation(ke.name),
            ee
          ), ++ee;
        }
        const xe = ie in u ? u[ie] : 1;
        xe < 1 && (e.animate = !0), this.helper.setUniformFloatValue(Vt.TRANSITION_ALPHA, xe), this.helper.setUniformFloatValue(Vt.DEPTH, oe), this.helper.setUniformFloatValue(
          Vt.TEXTURE_PIXEL_WIDTH,
          P
        ), this.helper.setUniformFloatValue(
          Vt.TEXTURE_PIXEL_HEIGHT,
          Q
        ), this.helper.setUniformFloatValue(
          Vt.TEXTURE_RESOLUTION,
          $
        ), this.helper.setUniformFloatValue(
          Vt.TEXTURE_ORIGIN_X,
          L[0] + ue * I[0] * $ - o * $
        ), this.helper.setUniformFloatValue(
          Vt.TEXTURE_ORIGIN_Y,
          L[1] - fe * I[1] * $ + o * $
        );
        let Ee = A;
        o > 0 && (Ee = a.getTileCoordExtent(j), jn(Ee, A, Ee)), this.helper.setUniformFloatVec4(Vt.RENDER_EXTENT, Ee), this.helper.setUniformFloatValue(
          Vt.RESOLUTION,
          r.resolution
        ), this.helper.setUniformFloatValue(Vt.ZOOM, r.zoom), this.helper.drawElements(0, this.indices_.getSize());
      }
    }
    this.helper.finalizeDraw(
      e,
      this.dispatchPreComposeEvent,
      this.dispatchPostComposeEvent
    );
    const E = this.helper.getCanvas(), S = this.tileTextureCache_;
    for (; S.canExpireCache(); )
      S.pop().dispose();
    const M = function(T, F) {
      s.updateCacheSize(0.1, F.viewState.projection), s.expireCache(F.viewState.projection, h9);
    };
    return e.postRenderFunctions.push(M), this.postRender(t, e), E;
  }
  /**
   * @param {import("../../pixel.js").Pixel} pixel Pixel.
   * @return {Uint8ClampedArray|Uint8Array|Float32Array|DataView} Data at the pixel location.
   */
  getData(e) {
    if (!this.helper.getGL())
      return null;
    const r = this.frameState_;
    if (!r)
      return null;
    const n = this.getLayer(), s = vi(
      r.pixelToCoordinateTransform,
      e.slice()
    ), a = r.viewState, o = n.getExtent();
    if (o && !Wo(
      Os(o, a.projection),
      s
    ))
      return null;
    const A = n.getSources(
      Xi([s]),
      a.resolution
    );
    let l, h, c;
    for (l = A.length - 1; l >= 0; --l)
      if (h = A[l], h.getState() === "ready") {
        if (c = h.getTileGridForProjection(a.projection), h.getWrapX())
          break;
        const f = c.getExtent();
        if (!f || Wo(f, s))
          break;
      }
    if (l < 0)
      return null;
    const u = this.tileTextureCache_;
    for (let f = c.getZForResolution(a.resolution); f >= c.getMinZoom(); --f) {
      const g = c.getTileCoordForCoordAndZ(s, f), p = k1(h, g);
      if (!u.containsKey(p))
        continue;
      const y = u.get(p), v = y.tile;
      if ((v instanceof _u || v instanceof l5) && v.getState() === He.EMPTY)
        return null;
      if (!y.loaded)
        continue;
      const w = c.getOrigin(f), C = An(c.getTileSize(f)), E = c.getResolution(f), S = (s[0] - w[0]) / E - g[1] * C[0], M = (w[1] - s[1]) / E - g[2] * C[1];
      return y.getPixelData(S, M);
    }
    return null;
  }
  /**
   * Look for tiles covering the provided tile coordinate at an alternate
   * zoom level.  Loaded tiles will be added to the provided tile texture lookup.
   * @param {import("../../tilegrid/TileGrid.js").default} tileGrid The tile grid.
   * @param {import("../../tilecoord.js").TileCoord} tileCoord The target tile coordinate.
   * @param {number} altZ The alternate zoom level.
   * @param {Object<number, Array<import("../../webgl/TileTexture.js").default>>} tileTexturesByZ Lookup of
   * tile textures by zoom level.
   * @return {boolean} The tile coordinate is covered by loaded tiles at the alternate zoom level.
   * @private
   */
  findAltTiles_(e, t, r, n) {
    const s = e.getTileRangeForTileCoordAndZ(
      t,
      r,
      this.tempTileRange_
    );
    if (!s)
      return !1;
    let a = !0;
    const o = this.tileTextureCache_, A = this.getLayer().getRenderSource();
    for (let l = s.minX; l <= s.maxX; ++l)
      for (let h = s.minY; h <= s.maxY; ++h) {
        const c = k1(A, [r, l, h]);
        let u = !1;
        if (o.containsKey(c)) {
          const f = o.get(c);
          f.loaded && (g5(n, f, r), u = !0);
        }
        u || (a = !1);
      }
    return a;
  }
  clearCache() {
    const e = this.tileTextureCache_;
    e.forEach((t) => t.dispose()), e.clear();
  }
  removeHelper() {
    this.helper && this.clearCache(), super.removeHelper();
  }
  /**
   * Clean up.
   */
  disposeInternal() {
    const e = this.helper;
    e && (e.getGL().deleteProgram(this.program_), delete this.program_, e.deleteBuffer(this.indices_)), super.disposeInternal(), delete this.indices_, delete this.tileTextureCache_, delete this.frameState_;
  }
}
const f9 = u9;
class d9 {
  /**
   * @param {string} name The name of the texture.
   * @param {Uint8Array} data The texture data.
   */
  constructor(e, t) {
    this.name = e, this.data = t, this.texture_ = null;
  }
  /**
   * @param {WebGLRenderingContext} gl Rendering context.
   * @return {WebGLTexture} The texture.
   */
  getTexture(e) {
    if (!this.texture_) {
      const t = e.createTexture();
      e.bindTexture(e.TEXTURE_2D, t), e.texParameteri(e.TEXTURE_2D, e.TEXTURE_WRAP_S, e.CLAMP_TO_EDGE), e.texParameteri(e.TEXTURE_2D, e.TEXTURE_WRAP_T, e.CLAMP_TO_EDGE), e.texParameteri(e.TEXTURE_2D, e.TEXTURE_MIN_FILTER, e.NEAREST), e.texParameteri(e.TEXTURE_2D, e.TEXTURE_MAG_FILTER, e.NEAREST), e.texImage2D(
        e.TEXTURE_2D,
        0,
        e.RGBA,
        this.data.length / 4,
        1,
        0,
        e.RGBA,
        e.UNSIGNED_BYTE,
        this.data
      ), this.texture_ = t;
    }
    return this.texture_;
  }
}
const g9 = d9, Ve = {
  NUMBER: 1,
  STRING: 2,
  COLOR: 4,
  BOOLEAN: 8,
  NUMBER_ARRAY: 16,
  ANY: 31,
  NONE: 0
}, Wt = {};
function qa(i) {
  if (typeof i == "number")
    return Ve.NUMBER;
  if (typeof i == "boolean")
    return Ve.BOOLEAN;
  if (typeof i == "string")
    return JQ(i) ? Ve.COLOR | Ve.STRING : Ve.STRING;
  if (!Array.isArray(i))
    throw new Error(`Unhandled value type: ${JSON.stringify(i)}`);
  const e = (
    /** @type {Array<*>} */
    i
  );
  if (e.every(function(n) {
    return typeof n == "number";
  }))
    return e.length === 3 || e.length === 4 ? Ve.COLOR | Ve.NUMBER_ARRAY : Ve.NUMBER_ARRAY;
  if (typeof e[0] != "string")
    throw new Error(
      `Expected an expression operator but received: ${JSON.stringify(
        e
      )}`
    );
  const r = Wt[e[0]];
  if (r === void 0)
    throw new Error(
      `Unrecognized expression operator: ${JSON.stringify(e)}`
    );
  return r.getReturnType(e.slice(1));
}
function p9(i) {
  return Math.log2(i) % 1 === 0;
}
function Kv(i) {
  const e = i.toString();
  return e.includes(".") ? e : e + ".0";
}
function ZM(i) {
  if (i.length < 2 || i.length > 4)
    throw new Error(
      "`formatArray` can only output `vec2`, `vec3` or `vec4` arrays."
    );
  return `vec${i.length}(${i.map(Kv).join(", ")})`;
}
function m9(i) {
  const e = hl(i).slice();
  return e.length < 4 && e.push(1), ZM(
    e.map(function(t, r) {
      return r < 3 ? t / 255 : t;
    })
  );
}
function Um(i, e) {
  return i.stringLiteralsMap[e] === void 0 && (i.stringLiteralsMap[e] = Object.keys(
    i.stringLiteralsMap
  ).length), i.stringLiteralsMap[e];
}
function v9(i, e) {
  return Kv(Um(i, e));
}
function rt(i, e, t) {
  if (Array.isArray(e) && typeof e[0] == "string") {
    const n = Wt[e[0]];
    if (n === void 0)
      throw new Error(
        `Unrecognized expression operator: ${JSON.stringify(e)}`
      );
    return n.toGlsl(i, e.slice(1), t);
  }
  const r = qa(e);
  if ((r & Ve.NUMBER) > 0)
    return Kv(
      /** @type {number} */
      e
    );
  if ((r & Ve.BOOLEAN) > 0)
    return e.toString();
  if ((r & Ve.STRING) > 0 && (t === void 0 || t == Ve.STRING))
    return v9(i, e.toString());
  if ((r & Ve.COLOR) > 0 && (t === void 0 || t == Ve.COLOR))
    return m9(
      /** @type {Array<number> | string} */
      e
    );
  if ((r & Ve.NUMBER_ARRAY) > 0)
    return ZM(
      /** @type {Array<number>} */
      e
    );
  throw new Error(`Unexpected expression ${e} (expected type ${t})`);
}
function JM(i) {
  if (!(qa(i) & Ve.NUMBER))
    throw new Error(
      `A numeric value was expected, got ${JSON.stringify(i)} instead`
    );
}
function Gi(i) {
  for (let e = 0; e < i.length; e++)
    JM(i[e]);
}
function e4(i) {
  if (!(qa(i) & Ve.STRING))
    throw new Error(
      `A string value was expected, got ${JSON.stringify(i)} instead`
    );
}
function ZE(i) {
  if (!(qa(i) & Ve.BOOLEAN))
    throw new Error(
      `A boolean value was expected, got ${JSON.stringify(i)} instead`
    );
}
function fi(i, e) {
  if (i.length !== e)
    throw new Error(
      `Exactly ${e} arguments were expected, got ${i.length} instead`
    );
}
function to(i, e) {
  if (i.length < e)
    throw new Error(
      `At least ${e} arguments were expected, got ${i.length} instead`
    );
}
function jv(i, e) {
  if (i.length > e)
    throw new Error(
      `At most ${e} arguments were expected, got ${i.length} instead`
    );
}
function t4(i) {
  if (i.length % 2 !== 0)
    throw new Error(
      `An even amount of arguments was expected, got ${i} instead`
    );
}
function y9(i) {
  if (i.length % 2 === 0)
    throw new Error(
      `An odd amount of arguments was expected, got ${i} instead`
    );
}
function JE(i, e) {
  if (!p9(e))
    throw new Error(
      `Could not infer only one type from the following expression: ${JSON.stringify(
        i
      )}`
    );
}
Wt.get = {
  getReturnType: function(i) {
    return Ve.ANY;
  },
  toGlsl: function(i, e) {
    fi(e, 1), e4(e[0]);
    const t = e[0].toString();
    return i.attributes.includes(t) || i.attributes.push(t), (i.inFragmentShader ? "v_" : "a_") + t;
  }
};
function eB(i) {
  return "u_var_" + i;
}
Wt.var = {
  getReturnType: function(i) {
    return Ve.ANY;
  },
  toGlsl: function(i, e) {
    fi(e, 1), e4(e[0]);
    const t = e[0].toString();
    return i.variables.includes(t) || i.variables.push(t), eB(t);
  }
};
const r4 = "u_paletteTextures";
Wt.palette = {
  getReturnType: function(i) {
    return Ve.COLOR;
  },
  toGlsl: function(i, e) {
    fi(e, 2), JM(e[0]);
    const t = rt(i, e[0]), r = e[1];
    if (!Array.isArray(r))
      throw new Error("The second argument of palette must be an array");
    const n = r.length, s = new Uint8Array(n * 4);
    for (let A = 0; A < n; A++) {
      const l = r[A];
      let h;
      if (typeof l == "string")
        h = LR(l);
      else {
        if (!Array.isArray(l))
          throw new Error(
            "The second argument of palette must be an array of strings or colors"
          );
        const u = l.length;
        if (u === 4)
          h = l;
        else {
          if (u !== 3)
            throw new Error(
              `Expected palette color to have 3 or 4 values, got ${u}`
            );
          h = [l[0], l[1], l[2], 1];
        }
      }
      const c = A * 4;
      s[c] = h[0], s[c + 1] = h[1], s[c + 2] = h[2], s[c + 3] = h[3] * 255;
    }
    i.paletteTextures || (i.paletteTextures = []);
    const a = `${r4}[${i.paletteTextures.length}]`, o = new g9(a, s);
    return i.paletteTextures.push(o), `texture2D(${a}, vec2((${t} + 0.5) / ${n}.0, 0.5))`;
  }
};
const H1 = "getBandValue";
Wt.band = {
  getReturnType: function(i) {
    return Ve.NUMBER;
  },
  toGlsl: function(i, e) {
    to(e, 1), jv(e, 3);
    const t = e[0];
    if (!(H1 in i.functions)) {
      let a = "";
      const o = i.bandCount || 1;
      for (let A = 0; A < o; A++) {
        const l = Math.floor(A / 4);
        let h = A % 4;
        A === o - 1 && h === 1 && (h = 3);
        const c = `${Vt.TILE_TEXTURE_ARRAY}[${l}]`;
        a += `
          if (band == ${A + 1}.0) {
            return texture2D(${c}, v_textureCoord + vec2(dx, dy))[${h}];
          }
        `;
      }
      i.functions[H1] = `
        float getBandValue(float band, float xOffset, float yOffset) {
          float dx = xOffset / ${Vt.TEXTURE_PIXEL_WIDTH};
          float dy = yOffset / ${Vt.TEXTURE_PIXEL_HEIGHT};
          ${a}
        }
      `;
    }
    const r = rt(i, t), n = rt(i, e[1] || 0), s = rt(i, e[2] || 0);
    return `${H1}(${r}, ${n}, ${s})`;
  }
};
Wt.time = {
  getReturnType: function(i) {
    return Ve.NUMBER;
  },
  toGlsl: function(i, e) {
    return fi(e, 0), "u_time";
  }
};
Wt.zoom = {
  getReturnType: function(i) {
    return Ve.NUMBER;
  },
  toGlsl: function(i, e) {
    return fi(e, 0), "u_zoom";
  }
};
Wt.resolution = {
  getReturnType: function(i) {
    return Ve.NUMBER;
  },
  toGlsl: function(i, e) {
    return fi(e, 0), "u_resolution";
  }
};
Wt["*"] = {
  getReturnType: function(i) {
    return Ve.NUMBER;
  },
  toGlsl: function(i, e) {
    return to(e, 2), Gi(e), `(${e.map((t) => rt(i, t)).join(" * ")})`;
  }
};
Wt["/"] = {
  getReturnType: function(i) {
    return Ve.NUMBER;
  },
  toGlsl: function(i, e) {
    return fi(e, 2), Gi(e), `(${rt(i, e[0])} / ${rt(
      i,
      e[1]
    )})`;
  }
};
Wt["+"] = {
  getReturnType: function(i) {
    return Ve.NUMBER;
  },
  toGlsl: function(i, e) {
    return to(e, 2), Gi(e), `(${e.map((t) => rt(i, t)).join(" + ")})`;
  }
};
Wt["-"] = {
  getReturnType: function(i) {
    return Ve.NUMBER;
  },
  toGlsl: function(i, e) {
    return fi(e, 2), Gi(e), `(${rt(i, e[0])} - ${rt(
      i,
      e[1]
    )})`;
  }
};
Wt.clamp = {
  getReturnType: function(i) {
    return Ve.NUMBER;
  },
  toGlsl: function(i, e) {
    fi(e, 3), Gi(e);
    const t = rt(i, e[1]), r = rt(i, e[2]);
    return `clamp(${rt(i, e[0])}, ${t}, ${r})`;
  }
};
Wt["%"] = {
  getReturnType: function(i) {
    return Ve.NUMBER;
  },
  toGlsl: function(i, e) {
    return fi(e, 2), Gi(e), `mod(${rt(i, e[0])}, ${rt(
      i,
      e[1]
    )})`;
  }
};
Wt["^"] = {
  getReturnType: function(i) {
    return Ve.NUMBER;
  },
  toGlsl: function(i, e) {
    return fi(e, 2), Gi(e), `pow(${rt(i, e[0])}, ${rt(
      i,
      e[1]
    )})`;
  }
};
Wt.abs = {
  getReturnType: function(i) {
    return Ve.NUMBER;
  },
  toGlsl: function(i, e) {
    return fi(e, 1), Gi(e), `abs(${rt(i, e[0])})`;
  }
};
Wt.floor = {
  getReturnType: function(i) {
    return Ve.NUMBER;
  },
  toGlsl: function(i, e) {
    return fi(e, 1), Gi(e), `floor(${rt(i, e[0])})`;
  }
};
Wt.round = {
  getReturnType: function(i) {
    return Ve.NUMBER;
  },
  toGlsl: function(i, e) {
    return fi(e, 1), Gi(e), `floor(${rt(i, e[0])} + 0.5)`;
  }
};
Wt.ceil = {
  getReturnType: function(i) {
    return Ve.NUMBER;
  },
  toGlsl: function(i, e) {
    return fi(e, 1), Gi(e), `ceil(${rt(i, e[0])})`;
  }
};
Wt.sin = {
  getReturnType: function(i) {
    return Ve.NUMBER;
  },
  toGlsl: function(i, e) {
    return fi(e, 1), Gi(e), `sin(${rt(i, e[0])})`;
  }
};
Wt.cos = {
  getReturnType: function(i) {
    return Ve.NUMBER;
  },
  toGlsl: function(i, e) {
    return fi(e, 1), Gi(e), `cos(${rt(i, e[0])})`;
  }
};
Wt.atan = {
  getReturnType: function(i) {
    return Ve.NUMBER;
  },
  toGlsl: function(i, e) {
    return to(e, 1), jv(e, 2), Gi(e), e.length === 2 ? `atan(${rt(i, e[0])}, ${rt(
      i,
      e[1]
    )})` : `atan(${rt(i, e[0])})`;
  }
};
Wt[">"] = {
  getReturnType: function(i) {
    return Ve.BOOLEAN;
  },
  toGlsl: function(i, e) {
    return fi(e, 2), Gi(e), `(${rt(i, e[0])} > ${rt(
      i,
      e[1]
    )})`;
  }
};
Wt[">="] = {
  getReturnType: function(i) {
    return Ve.BOOLEAN;
  },
  toGlsl: function(i, e) {
    return fi(e, 2), Gi(e), `(${rt(i, e[0])} >= ${rt(
      i,
      e[1]
    )})`;
  }
};
Wt["<"] = {
  getReturnType: function(i) {
    return Ve.BOOLEAN;
  },
  toGlsl: function(i, e) {
    return fi(e, 2), Gi(e), `(${rt(i, e[0])} < ${rt(
      i,
      e[1]
    )})`;
  }
};
Wt["<="] = {
  getReturnType: function(i) {
    return Ve.BOOLEAN;
  },
  toGlsl: function(i, e) {
    return fi(e, 2), Gi(e), `(${rt(i, e[0])} <= ${rt(
      i,
      e[1]
    )})`;
  }
};
function i4(i) {
  return {
    getReturnType: function(e) {
      return Ve.BOOLEAN;
    },
    toGlsl: function(e, t) {
      fi(t, 2);
      let r = Ve.ANY;
      for (let n = 0; n < t.length; n++)
        r &= qa(t[n]);
      if (r === Ve.NONE)
        throw new Error(
          `All arguments should be of compatible type, got ${JSON.stringify(
            t
          )} instead`
        );
      return r &= ~Ve.COLOR, `(${rt(
        e,
        t[0],
        r
      )} ${i} ${rt(e, t[1], r)})`;
    }
  };
}
Wt["=="] = i4("==");
Wt["!="] = i4("!=");
Wt["!"] = {
  getReturnType: function(i) {
    return Ve.BOOLEAN;
  },
  toGlsl: function(i, e) {
    return fi(e, 1), ZE(e[0]), `(!${rt(i, e[0])})`;
  }
};
function n4(i) {
  return {
    getReturnType: function(e) {
      return Ve.BOOLEAN;
    },
    toGlsl: function(e, t) {
      to(t, 2);
      for (let n = 0; n < t.length; n++)
        ZE(t[n]);
      let r = "";
      return r = t.map((n) => rt(e, n)).join(` ${i} `), r = `(${r})`, r;
    }
  };
}
Wt.all = n4("&&");
Wt.any = n4("||");
Wt.between = {
  getReturnType: function(i) {
    return Ve.BOOLEAN;
  },
  toGlsl: function(i, e) {
    fi(e, 3), Gi(e);
    const t = rt(i, e[1]), r = rt(i, e[2]), n = rt(i, e[0]);
    return `(${n} >= ${t} && ${n} <= ${r})`;
  }
};
Wt.array = {
  getReturnType: function(i) {
    return Ve.NUMBER_ARRAY;
  },
  toGlsl: function(i, e) {
    to(e, 2), jv(e, 4), Gi(e);
    const t = e.map(function(r) {
      return rt(i, r, Ve.NUMBER);
    });
    return `vec${e.length}(${t.join(", ")})`;
  }
};
Wt.color = {
  getReturnType: function(i) {
    return Ve.COLOR;
  },
  toGlsl: function(i, e) {
    to(e, 3), jv(e, 4), Gi(e);
    const t = (
      /** @type {Array<number>} */
      e
    );
    e.length === 3 && t.push(1);
    const r = e.map(function(n, s) {
      return rt(i, n, Ve.NUMBER) + (s < 3 ? " / 255.0" : "");
    });
    return `vec${e.length}(${r.join(", ")})`;
  }
};
Wt.interpolate = {
  getReturnType: function(i) {
    let e = Ve.COLOR | Ve.NUMBER;
    for (let t = 3; t < i.length; t += 2)
      e = e & qa(i[t]);
    return e;
  },
  toGlsl: function(i, e, t) {
    t4(e), to(e, 6);
    const r = e[0];
    let n;
    switch (r[0]) {
      case "linear":
        n = 1;
        break;
      case "exponential":
        n = r[1];
        break;
      default:
        n = null;
    }
    if (!n)
      throw new Error(
        `Invalid interpolation type for "interpolate" operator, received: ${JSON.stringify(
          r
        )}`
      );
    t = t !== void 0 ? t : Ve.ANY;
    const s = Wt.interpolate.getReturnType(e) & t;
    JE(e, s);
    const a = rt(i, e[1]), o = Kv(n);
    let A = "";
    for (let l = 2; l < e.length - 2; l += 2) {
      const h = rt(i, e[l]), c = A || rt(i, e[l + 1], s), u = rt(i, e[l + 2]), f = rt(i, e[l + 3], s);
      A = `mix(${c}, ${f}, pow(clamp((${a} - ${h}) / (${u} - ${h}), 0.0, 1.0), ${o}))`;
    }
    return A;
  }
};
Wt.match = {
  getReturnType: function(i) {
    let e = Ve.ANY;
    for (let t = 2; t < i.length; t += 2)
      e = e & qa(i[t]);
    return e = e & qa(i[i.length - 1]), e;
  },
  toGlsl: function(i, e, t) {
    t4(e), to(e, 4), t = t !== void 0 ? t : Ve.ANY;
    const r = Wt.match.getReturnType(e) & t;
    JE(e, r);
    const n = rt(i, e[0]), s = rt(
      i,
      e[e.length - 1],
      r
    );
    let a = null;
    for (let o = e.length - 3; o >= 1; o -= 2) {
      const A = rt(i, e[o]), l = rt(i, e[o + 1], r);
      a = `(${n} == ${A} ? ${l} : ${a || s})`;
    }
    return a;
  }
};
Wt.case = {
  getReturnType: function(i) {
    let e = Ve.ANY;
    for (let t = 1; t < i.length; t += 2)
      e = e & qa(i[t]);
    return e = e & qa(i[i.length - 1]), e;
  },
  toGlsl: function(i, e, t) {
    y9(e), to(e, 3), t = t !== void 0 ? t : Ve.ANY;
    const r = Wt.case.getReturnType(e) & t;
    JE(e, r);
    for (let a = 0; a < e.length - 1; a += 2)
      ZE(e[a]);
    const n = rt(
      i,
      e[e.length - 1],
      r
    );
    let s = null;
    for (let a = e.length - 3; a >= 0; a -= 2) {
      const o = rt(i, e[a]), A = rt(i, e[a + 1], r);
      s = `(${o} ? ${A} : ${s || n})`;
    }
    return s;
  }
};
function p5(i, e) {
  const t = `
    attribute vec2 ${K0.TEXTURE_COORD};
    uniform mat4 ${Vt.TILE_TRANSFORM};
    uniform float ${Vt.TEXTURE_PIXEL_WIDTH};
    uniform float ${Vt.TEXTURE_PIXEL_HEIGHT};
    uniform float ${Vt.TEXTURE_RESOLUTION};
    uniform float ${Vt.TEXTURE_ORIGIN_X};
    uniform float ${Vt.TEXTURE_ORIGIN_Y};
    uniform float ${Vt.DEPTH};

    varying vec2 v_textureCoord;
    varying vec2 v_mapCoord;

    void main() {
      v_textureCoord = ${K0.TEXTURE_COORD};
      v_mapCoord = vec2(
        ${Vt.TEXTURE_ORIGIN_X} + ${Vt.TEXTURE_RESOLUTION} * ${Vt.TEXTURE_PIXEL_WIDTH} * v_textureCoord[0],
        ${Vt.TEXTURE_ORIGIN_Y} - ${Vt.TEXTURE_RESOLUTION} * ${Vt.TEXTURE_PIXEL_HEIGHT} * v_textureCoord[1]
      );
      gl_Position = ${Vt.TILE_TRANSFORM} * vec4(${K0.TEXTURE_COORD}, ${Vt.DEPTH}, 1.0);
    }
  `, r = {
    inFragmentShader: !0,
    variables: [],
    attributes: [],
    stringLiteralsMap: {},
    functions: {},
    bandCount: e
  }, n = [];
  if (i.color !== void 0) {
    const c = rt(r, i.color, Ve.COLOR);
    n.push(`color = ${c};`);
  }
  if (i.contrast !== void 0) {
    const c = rt(
      r,
      i.contrast,
      Ve.NUMBER
    );
    n.push(
      `color.rgb = clamp((${c} + 1.0) * color.rgb - (${c} / 2.0), vec3(0.0, 0.0, 0.0), vec3(1.0, 1.0, 1.0));`
    );
  }
  if (i.exposure !== void 0) {
    const c = rt(
      r,
      i.exposure,
      Ve.NUMBER
    );
    n.push(
      `color.rgb = clamp((${c} + 1.0) * color.rgb, vec3(0.0, 0.0, 0.0), vec3(1.0, 1.0, 1.0));`
    );
  }
  if (i.saturation !== void 0) {
    const c = rt(
      r,
      i.saturation,
      Ve.NUMBER
    );
    n.push(`
      float saturation = ${c} + 1.0;
      float sr = (1.0 - saturation) * 0.2126;
      float sg = (1.0 - saturation) * 0.7152;
      float sb = (1.0 - saturation) * 0.0722;
      mat3 saturationMatrix = mat3(
        sr + saturation, sr, sr,
        sg, sg + saturation, sg,
        sb, sb, sb + saturation
      );
      color.rgb = clamp(saturationMatrix * color.rgb, vec3(0.0, 0.0, 0.0), vec3(1.0, 1.0, 1.0));
    `);
  }
  if (i.gamma !== void 0) {
    const c = rt(r, i.gamma, Ve.NUMBER);
    n.push(`color.rgb = pow(color.rgb, vec3(1.0 / ${c}));`);
  }
  if (i.brightness !== void 0) {
    const c = rt(
      r,
      i.brightness,
      Ve.NUMBER
    );
    n.push(
      `color.rgb = clamp(color.rgb + ${c}, vec3(0.0, 0.0, 0.0), vec3(1.0, 1.0, 1.0));`
    );
  }
  const s = {}, a = r.variables.length;
  if (a > 1 && !i.variables)
    throw new Error(
      `Missing variables in style (expected ${r.variables})`
    );
  for (let c = 0; c < a; ++c) {
    const u = r.variables[c];
    if (!(u in i.variables))
      throw new Error(`Missing '${u}' in style variables`);
    const f = eB(u);
    s[f] = function() {
      let g = i.variables[u];
      return typeof g == "string" && (g = Um(r, g)), g !== void 0 ? g : -9999999;
    };
  }
  const o = Object.keys(s).map(function(c) {
    return `uniform float ${c};`;
  }), A = Math.ceil(e / 4);
  o.push(
    `uniform sampler2D ${Vt.TILE_TEXTURE_ARRAY}[${A}];`
  ), r.paletteTextures && o.push(
    `uniform sampler2D ${r4}[${r.paletteTextures.length}];`
  );
  const l = Object.keys(r.functions).map(function(c) {
    return r.functions[c];
  }), h = `
    #ifdef GL_FRAGMENT_PRECISION_HIGH
    precision highp float;
    #else
    precision mediump float;
    #endif

    varying vec2 v_textureCoord;
    varying vec2 v_mapCoord;
    uniform vec4 ${Vt.RENDER_EXTENT};
    uniform float ${Vt.TRANSITION_ALPHA};
    uniform float ${Vt.TEXTURE_PIXEL_WIDTH};
    uniform float ${Vt.TEXTURE_PIXEL_HEIGHT};
    uniform float ${Vt.RESOLUTION};
    uniform float ${Vt.ZOOM};

    ${o.join(`
`)}

    ${l.join(`
`)}

    void main() {
      if (
        v_mapCoord[0] < ${Vt.RENDER_EXTENT}[0] ||
        v_mapCoord[1] < ${Vt.RENDER_EXTENT}[1] ||
        v_mapCoord[0] > ${Vt.RENDER_EXTENT}[2] ||
        v_mapCoord[1] > ${Vt.RENDER_EXTENT}[3]
      ) {
        discard;
      }

      vec4 color = texture2D(${Vt.TILE_TEXTURE_ARRAY}[0],  v_textureCoord);

      ${n.join(`
`)}

      if (color.a == 0.0) {
        discard;
      }

      gl_FragColor = color;
      gl_FragColor.rgb *= gl_FragColor.a;
      gl_FragColor *= ${Vt.TRANSITION_ALPHA};
    }`;
  return {
    vertexShader: t,
    fragmentShader: h,
    uniforms: s,
    paletteTextures: r.paletteTextures
  };
}
let s4 = class extends OM {
  /**
   * @param {Options} options Tile layer options.
   */
  constructor(e) {
    e = e ? Object.assign({}, e) : {};
    const t = e.style || {};
    delete e.style;
    const r = e.cacheSize;
    delete e.cacheSize, super(e), this.sources_ = e.sources, this.renderedSource_ = null, this.renderedResolution_ = NaN, this.style_ = t, this.cacheSize_ = r, this.styleVariables_ = this.style_.variables || {}, this.addChangeListener(Fr.SOURCE, this.handleSourceUpdate_);
  }
  /**
   * Gets the sources for this layer, for a given extent and resolution.
   * @param {import("../extent.js").Extent} extent Extent.
   * @param {number} resolution Resolution.
   * @return {Array<SourceType>} Sources.
   */
  getSources(e, t) {
    const r = this.getSource();
    return this.sources_ ? typeof this.sources_ == "function" ? this.sources_(e, t) : this.sources_ : r ? [r] : [];
  }
  /**
   * @return {SourceType} The source being rendered.
   */
  getRenderSource() {
    return this.renderedSource_ || this.getSource();
  }
  /**
   * @return {import("../source/Source.js").State} Source state.
   */
  getSourceState() {
    const e = this.getRenderSource();
    return e ? e.getState() : "undefined";
  }
  /**
   * @private
   */
  handleSourceUpdate_() {
    this.hasRenderer() && this.getRenderer().clearCache(), this.getSource() && this.setStyle(this.style_);
  }
  /**
   * @private
   * @return {number} The number of source bands.
   */
  getSourceBandCount_() {
    const e = Number.MAX_SAFE_INTEGER, t = this.getSources([-e, -e, e, e], e);
    return t && t.length && "bandCount" in t[0] ? t[0].bandCount : 4;
  }
  createRenderer() {
    const e = p5(this.style_, this.getSourceBandCount_());
    return new f9(this, {
      vertexShader: e.vertexShader,
      fragmentShader: e.fragmentShader,
      uniforms: e.uniforms,
      cacheSize: this.cacheSize_,
      paletteTextures: e.paletteTextures
    });
  }
  /**
   * @param {import("../Map").FrameState} frameState Frame state.
   * @param {Array<SourceType>} sources Sources.
   * @return {HTMLElement} Canvas.
   */
  renderSources(e, t) {
    const r = this.getRenderer();
    let n;
    for (let s = 0, a = t.length; s < a; ++s)
      this.renderedSource_ = t[s], r.prepareFrame(e) && (n = r.renderFrame(e));
    return n;
  }
  /**
   * @param {?import("../Map.js").FrameState} frameState Frame state.
   * @param {HTMLElement} target Target which the renderer may (but need not) use
   * for rendering its content.
   * @return {HTMLElement} The rendered element.
   */
  render(e, t) {
    this.rendered = !0;
    const r = e.viewState, n = this.getSources(e.extent, r.resolution);
    let s = !0;
    for (let o = 0, A = n.length; o < A; ++o) {
      const l = n[o], h = l.getState();
      if (h == "loading") {
        const c = () => {
          l.getState() == "ready" && (l.removeEventListener("change", c), this.changed());
        };
        l.addEventListener("change", c);
      }
      s = s && h == "ready";
    }
    const a = this.renderSources(e, n);
    if (this.getRenderer().renderComplete && s)
      return this.renderedResolution_ = r.resolution, a;
    if (this.renderedResolution_ > 0.5 * r.resolution) {
      const o = this.getSources(
        e.extent,
        this.renderedResolution_
      ).filter((A) => !n.includes(A));
      if (o.length > 0)
        return this.renderSources(e, o);
    }
    return a;
  }
  /**
   * Update the layer style.  The `updateStyleVariables` function is a more efficient
   * way to update layer rendering.  In cases where the whole style needs to be updated,
   * this method may be called instead.  Note that calling this method will also replace
   * any previously set variables, so the new style also needs to include new variables,
   * if needed.
   * @param {Style} style The new style.
   */
  setStyle(e) {
    this.styleVariables_ = e.variables || {}, this.style_ = e;
    const t = p5(this.style_, this.getSourceBandCount_());
    this.getRenderer().reset({
      vertexShader: t.vertexShader,
      fragmentShader: t.fragmentShader,
      uniforms: t.uniforms,
      paletteTextures: t.paletteTextures
    }), this.changed();
  }
  /**
   * Update any variables used by the layer style and trigger a re-render.
   * @param {Object<string, number>} variables Variables to update.
   * @api
   */
  updateStyleVariables(e) {
    Object.assign(this.styleVariables_, e), this.changed();
  }
};
s4.prototype.dispose;
const _9 = s4, w9 = {
  extends: Th,
  name: "ol-webgl-tile-layer",
  setup(i) {
    const e = _t("map"), t = _t("overviewMap", null), { properties: r } = sr(i), n = cr(() => new _9(r)), s = () => {
      t != null ? (t.value.getOverviewMap().addLayer(n.value), t.value.changed()) : e.addLayer(n.value);
    }, a = () => {
      t != null ? (t.value.getOverviewMap().removeLayer(n.value), t.value.changed()) : e.removeLayer(n.value);
    };
    return t != null && at(t, () => {
      a(), s();
    }), tr(() => {
      s();
    }), nr(() => {
      a();
    }), Ur("tileLayer", n), {
      tileLayer: n
    };
  },
  props: {
    preload: {
      type: Number,
      default: 1
    }
  }
};
function x9(i, e, t, r, n, s) {
  return xn(), Cn("div", null, [
    mr(i.$slots, "default")
  ]);
}
const n2 = /* @__PURE__ */ qe(w9, [["render", x9]]);
class C9 extends bh {
  /**
   * @param {Options<ImageSourceType>} [options] Layer options.
   */
  constructor(e) {
    e = e || {}, super(e);
  }
}
const E9 = C9;
class B9 extends $E {
  /**
   * @param {import("../../layer/Image.js").default} imageLayer Image layer.
   */
  constructor(e) {
    super(e), this.image_ = null;
  }
  /**
   * @return {HTMLCanvasElement|HTMLImageElement|HTMLVideoElement} Image.
   */
  getImage() {
    return this.image_ ? this.image_.getImage() : null;
  }
  /**
   * Determine whether render should be called.
   * @param {import("../../Map.js").FrameState} frameState Frame state.
   * @return {boolean} Layer is ready to be rendered.
   */
  prepareFrame(e) {
    const t = e.layerStatesArray[e.layerIndex], r = e.pixelRatio, n = e.viewState, s = n.resolution, a = this.getLayer().getSource(), o = e.viewHints;
    let A = e.extent;
    if (t.extent !== void 0 && (A = jn(
      A,
      Os(t.extent, n.projection)
    )), !o[ei.ANIMATING] && !o[ei.INTERACTING] && !Tu(A))
      if (a) {
        const l = n.projection, h = a.getImage(
          A,
          s,
          r,
          l
        );
        h && (this.loadImage(h) ? this.image_ = h : h.getState() === Pt.EMPTY && (this.image_ = null));
      } else
        this.image_ = null;
    return !!this.image_;
  }
  /**
   * @param {import("../../pixel.js").Pixel} pixel Pixel.
   * @return {Uint8ClampedArray} Data at the pixel location.
   */
  getData(e) {
    const t = this.frameState;
    if (!t)
      return null;
    const r = this.getLayer(), n = vi(
      t.pixelToCoordinateTransform,
      e.slice()
    ), s = r.getExtent();
    if (s && !Wo(s, n))
      return null;
    const a = this.image_.getExtent(), o = this.getImage(), A = ir(a), l = Math.floor(
      o.width * ((n[0] - a[0]) / A)
    );
    if (l < 0 || l >= o.width)
      return null;
    const h = _i(a), c = Math.floor(
      o.height * ((a[3] - n[1]) / h)
    );
    return c < 0 || c >= o.height ? null : this.getImageData(o, l, c);
  }
  /**
   * Render the layer.
   * @param {import("../../Map.js").FrameState} frameState Frame state.
   * @param {HTMLElement} target Target that may be used to render content to.
   * @return {HTMLElement} The rendered element.
   */
  renderFrame(e, t) {
    const r = this.image_, n = r.getExtent(), s = r.getResolution(), a = r.getPixelRatio(), o = e.layerStatesArray[e.layerIndex], A = e.pixelRatio, l = e.viewState, h = l.center, c = l.resolution, u = A * s / (c * a), f = e.extent, g = l.resolution, p = l.rotation, y = Math.round(ir(f) / g * A), v = Math.round(_i(f) / g * A);
    Qs(
      this.pixelTransform,
      e.size[0] / 2,
      e.size[1] / 2,
      1 / A,
      1 / A,
      p,
      -y / 2,
      -v / 2
    ), Ag(this.inversePixelTransform, this.pixelTransform);
    const w = nE(this.pixelTransform);
    this.useContainer(t, w, this.getBackground(e));
    const C = this.context, E = C.canvas;
    E.width != y || E.height != v ? (E.width = y, E.height = v) : this.containerReused || C.clearRect(0, 0, y, v);
    let S = !1, M = !0;
    if (o.extent) {
      const I = Os(
        o.extent,
        l.projection
      );
      M = ci(I, e.extent), S = M && !Ps(I, e.extent), S && this.clipUnrotated(C, e, I);
    }
    const T = this.getImage(), F = Qs(
      this.tempTransform,
      y / 2,
      v / 2,
      u,
      u,
      0,
      a * (n[0] - h[0]) / s,
      a * (h[1] - n[3]) / s
    );
    this.renderedResolution = s * A / a;
    const k = T.width * F[0], $ = T.height * F[3];
    if (this.getLayer().getSource().getInterpolate() || (C.imageSmoothingEnabled = !1), this.preRender(C, e), M && k >= 0.5 && $ >= 0.5) {
      const I = F[4], L = F[5], P = o.opacity;
      let Q;
      P !== 1 && (Q = C.globalAlpha, C.globalAlpha = P), C.drawImage(T, 0, 0, +T.width, +T.height, I, L, k, $), P !== 1 && (C.globalAlpha = Q);
    }
    return this.postRender(C, e), S && C.restore(), C.imageSmoothingEnabled = !0, w !== E.style.transform && (E.style.transform = w), this.container;
  }
}
const b9 = B9;
let S9 = class extends E9 {
  /**
   * @param {import("./BaseImage.js").Options<ImageSourceType>} [options] Layer options.
   */
  constructor(e) {
    super(e);
  }
  createRenderer() {
    return new b9(this);
  }
  /**
   * Get data for a pixel location.  A four element RGBA array will be returned.  For requests outside the
   * layer extent, `null` will be returned.  Data for an image can only be retrieved if the
   * source's `crossOrigin` property is set.
   *
   * ```js
   * // display layer data on every pointer move
   * map.on('pointermove', (event) => {
   *   console.log(layer.getData(event.pixel));
   * });
   * ```
   * @param {import("../pixel").Pixel} pixel Pixel.
   * @return {Uint8ClampedArray|Uint8Array|Float32Array|DataView|null} Pixel data.
   * @api
   */
  getData(e) {
    return super.getData(e);
  }
};
const a4 = S9, T9 = {
  extends: Th,
  name: "ol-image-layer",
  setup(i) {
    const e = _t("map"), { properties: t } = sr(i), r = new a4(t);
    return at(t, () => {
      r.setProperties(t);
    }), tr(() => {
      e.addLayer(r);
    }), nr(() => {
      e.removeLayer(r);
    }), Ur("imageLayer", r), {
      imageLayer: r
    };
  }
};
function F9(i, e, t, r, n, s) {
  return xn(), Cn("div", null, [
    mr(i.$slots, "default")
  ]);
}
const s2 = /* @__PURE__ */ qe(T9, [["render", F9]]);
function L9(i, e, t, r, n) {
  o4(i, e, t || 0, r || i.length - 1, n || I9);
}
function o4(i, e, t, r, n) {
  for (; r > t; ) {
    if (r - t > 600) {
      var s = r - t + 1, a = e - t + 1, o = Math.log(s), A = 0.5 * Math.exp(2 * o / 3), l = 0.5 * Math.sqrt(o * A * (s - A) / s) * (a - s / 2 < 0 ? -1 : 1), h = Math.max(t, Math.floor(e - a * A / s + l)), c = Math.min(r, Math.floor(e + (s - a) * A / s + l));
      o4(i, e, h, c, n);
    }
    var u = i[e], f = t, g = r;
    for (Ff(i, t, e), n(i[r], u) > 0 && Ff(i, t, r); f < g; ) {
      for (Ff(i, f, g), f++, g--; n(i[f], u) < 0; )
        f++;
      for (; n(i[g], u) > 0; )
        g--;
    }
    n(i[t], u) === 0 ? Ff(i, t, g) : (g++, Ff(i, g, r)), g <= e && (t = g + 1), e <= g && (r = g - 1);
  }
}
function Ff(i, e, t) {
  var r = i[e];
  i[e] = i[t], i[t] = r;
}
function I9(i, e) {
  return i < e ? -1 : i > e ? 1 : 0;
}
let A4 = class {
  constructor(e = 9) {
    this._maxEntries = Math.max(4, e), this._minEntries = Math.max(2, Math.ceil(this._maxEntries * 0.4)), this.clear();
  }
  all() {
    return this._all(this.data, []);
  }
  search(e) {
    let t = this.data;
    const r = [];
    if (!Np(e, t))
      return r;
    const n = this.toBBox, s = [];
    for (; t; ) {
      for (let a = 0; a < t.children.length; a++) {
        const o = t.children[a], A = t.leaf ? n(o) : o;
        Np(e, A) && (t.leaf ? r.push(o) : $1(e, A) ? this._all(o, r) : s.push(o));
      }
      t = s.pop();
    }
    return r;
  }
  collides(e) {
    let t = this.data;
    if (!Np(e, t))
      return !1;
    const r = [];
    for (; t; ) {
      for (let n = 0; n < t.children.length; n++) {
        const s = t.children[n], a = t.leaf ? this.toBBox(s) : s;
        if (Np(e, a)) {
          if (t.leaf || $1(e, a))
            return !0;
          r.push(s);
        }
      }
      t = r.pop();
    }
    return !1;
  }
  load(e) {
    if (!(e && e.length))
      return this;
    if (e.length < this._minEntries) {
      for (let r = 0; r < e.length; r++)
        this.insert(e[r]);
      return this;
    }
    let t = this._build(e.slice(), 0, e.length - 1, 0);
    if (!this.data.children.length)
      this.data = t;
    else if (this.data.height === t.height)
      this._splitRoot(this.data, t);
    else {
      if (this.data.height < t.height) {
        const r = this.data;
        this.data = t, t = r;
      }
      this._insert(t, this.data.height - t.height - 1, !0);
    }
    return this;
  }
  insert(e) {
    return e && this._insert(e, this.data.height - 1), this;
  }
  clear() {
    return this.data = Tc([]), this;
  }
  remove(e, t) {
    if (!e)
      return this;
    let r = this.data;
    const n = this.toBBox(e), s = [], a = [];
    let o, A, l;
    for (; r || s.length; ) {
      if (r || (r = s.pop(), A = s[s.length - 1], o = a.pop(), l = !0), r.leaf) {
        const h = R9(e, r.children, t);
        if (h !== -1)
          return r.children.splice(h, 1), s.push(r), this._condense(s), this;
      }
      !l && !r.leaf && $1(r, n) ? (s.push(r), a.push(o), o = 0, A = r, r = r.children[0]) : A ? (o++, r = A.children[o], l = !1) : r = null;
    }
    return this;
  }
  toBBox(e) {
    return e;
  }
  compareMinX(e, t) {
    return e.minX - t.minX;
  }
  compareMinY(e, t) {
    return e.minY - t.minY;
  }
  toJSON() {
    return this.data;
  }
  fromJSON(e) {
    return this.data = e, this;
  }
  _all(e, t) {
    const r = [];
    for (; e; )
      e.leaf ? t.push(...e.children) : r.push(...e.children), e = r.pop();
    return t;
  }
  _build(e, t, r, n) {
    const s = r - t + 1;
    let a = this._maxEntries, o;
    if (s <= a)
      return o = Tc(e.slice(t, r + 1)), sc(o, this.toBBox), o;
    n || (n = Math.ceil(Math.log(s) / Math.log(a)), a = Math.ceil(s / Math.pow(a, n - 1))), o = Tc([]), o.leaf = !1, o.height = n;
    const A = Math.ceil(s / a), l = A * Math.ceil(Math.sqrt(a));
    m5(e, t, r, l, this.compareMinX);
    for (let h = t; h <= r; h += l) {
      const c = Math.min(h + l - 1, r);
      m5(e, h, c, A, this.compareMinY);
      for (let u = h; u <= c; u += A) {
        const f = Math.min(u + A - 1, c);
        o.children.push(this._build(e, u, f, n - 1));
      }
    }
    return sc(o, this.toBBox), o;
  }
  _chooseSubtree(e, t, r, n) {
    for (; n.push(t), !(t.leaf || n.length - 1 === r); ) {
      let s = 1 / 0, a = 1 / 0, o;
      for (let A = 0; A < t.children.length; A++) {
        const l = t.children[A], h = G1(l), c = P9(e, l) - h;
        c < a ? (a = c, s = h < s ? h : s, o = l) : c === a && h < s && (s = h, o = l);
      }
      t = o || t.children[0];
    }
    return t;
  }
  _insert(e, t, r) {
    const n = r ? e : this.toBBox(e), s = [], a = this._chooseSubtree(n, this.data, t, s);
    for (a.children.push(e), Jf(a, n); t >= 0 && s[t].children.length > this._maxEntries; )
      this._split(s, t), t--;
    this._adjustParentBBoxes(n, s, t);
  }
  // split overflowed node into two
  _split(e, t) {
    const r = e[t], n = r.children.length, s = this._minEntries;
    this._chooseSplitAxis(r, s, n);
    const a = this._chooseSplitIndex(r, s, n), o = Tc(r.children.splice(a, r.children.length - a));
    o.height = r.height, o.leaf = r.leaf, sc(r, this.toBBox), sc(o, this.toBBox), t ? e[t - 1].children.push(o) : this._splitRoot(r, o);
  }
  _splitRoot(e, t) {
    this.data = Tc([e, t]), this.data.height = e.height + 1, this.data.leaf = !1, sc(this.data, this.toBBox);
  }
  _chooseSplitIndex(e, t, r) {
    let n, s = 1 / 0, a = 1 / 0;
    for (let o = t; o <= r - t; o++) {
      const A = Zf(e, 0, o, this.toBBox), l = Zf(e, o, r, this.toBBox), h = O9(A, l), c = G1(A) + G1(l);
      h < s ? (s = h, n = o, a = c < a ? c : a) : h === s && c < a && (a = c, n = o);
    }
    return n || r - t;
  }
  // sorts node children by the best axis for split
  _chooseSplitAxis(e, t, r) {
    const n = e.leaf ? this.compareMinX : M9, s = e.leaf ? this.compareMinY : N9, a = this._allDistMargin(e, t, r, n), o = this._allDistMargin(e, t, r, s);
    a < o && e.children.sort(n);
  }
  // total margin of all possible split distributions where each node is at least m full
  _allDistMargin(e, t, r, n) {
    e.children.sort(n);
    const s = this.toBBox, a = Zf(e, 0, t, s), o = Zf(e, r - t, r, s);
    let A = Mp(a) + Mp(o);
    for (let l = t; l < r - t; l++) {
      const h = e.children[l];
      Jf(a, e.leaf ? s(h) : h), A += Mp(a);
    }
    for (let l = r - t - 1; l >= t; l--) {
      const h = e.children[l];
      Jf(o, e.leaf ? s(h) : h), A += Mp(o);
    }
    return A;
  }
  _adjustParentBBoxes(e, t, r) {
    for (let n = r; n >= 0; n--)
      Jf(t[n], e);
  }
  _condense(e) {
    for (let t = e.length - 1, r; t >= 0; t--)
      e[t].children.length === 0 ? t > 0 ? (r = e[t - 1].children, r.splice(r.indexOf(e[t]), 1)) : this.clear() : sc(e[t], this.toBBox);
  }
};
function R9(i, e, t) {
  if (!t)
    return e.indexOf(i);
  for (let r = 0; r < e.length; r++)
    if (t(i, e[r]))
      return r;
  return -1;
}
function sc(i, e) {
  Zf(i, 0, i.children.length, e, i);
}
function Zf(i, e, t, r, n) {
  n || (n = Tc(null)), n.minX = 1 / 0, n.minY = 1 / 0, n.maxX = -1 / 0, n.maxY = -1 / 0;
  for (let s = e; s < t; s++) {
    const a = i.children[s];
    Jf(n, i.leaf ? r(a) : a);
  }
  return n;
}
function Jf(i, e) {
  return i.minX = Math.min(i.minX, e.minX), i.minY = Math.min(i.minY, e.minY), i.maxX = Math.max(i.maxX, e.maxX), i.maxY = Math.max(i.maxY, e.maxY), i;
}
function M9(i, e) {
  return i.minX - e.minX;
}
function N9(i, e) {
  return i.minY - e.minY;
}
function G1(i) {
  return (i.maxX - i.minX) * (i.maxY - i.minY);
}
function Mp(i) {
  return i.maxX - i.minX + (i.maxY - i.minY);
}
function P9(i, e) {
  return (Math.max(e.maxX, i.maxX) - Math.min(e.minX, i.minX)) * (Math.max(e.maxY, i.maxY) - Math.min(e.minY, i.minY));
}
function O9(i, e) {
  const t = Math.max(i.minX, e.minX), r = Math.max(i.minY, e.minY), n = Math.min(i.maxX, e.maxX), s = Math.min(i.maxY, e.maxY);
  return Math.max(0, n - t) * Math.max(0, s - r);
}
function $1(i, e) {
  return i.minX <= e.minX && i.minY <= e.minY && e.maxX <= i.maxX && e.maxY <= i.maxY;
}
function Np(i, e) {
  return e.minX <= i.maxX && e.minY <= i.maxY && e.maxX >= i.minX && e.maxY >= i.minY;
}
function Tc(i) {
  return {
    children: i,
    height: 1,
    leaf: !0,
    minX: 1 / 0,
    minY: 1 / 0,
    maxX: -1 / 0,
    maxY: -1 / 0
  };
}
function m5(i, e, t, r, n) {
  const s = [e, t];
  for (; s.length; ) {
    if (t = s.pop(), e = s.pop(), t - e <= r)
      continue;
    const a = e + Math.ceil((t - e) / r / 2) * r;
    L9(i, a, e, t, n), s.push(e, a, a, t);
  }
}
class tB {
  /**
   * @param {Options} options Options.
   */
  constructor(e) {
    this.opacity_ = e.opacity, this.rotateWithView_ = e.rotateWithView, this.rotation_ = e.rotation, this.scale_ = e.scale, this.scaleArray_ = An(e.scale), this.displacement_ = e.displacement, this.declutterMode_ = e.declutterMode;
  }
  /**
   * Clones the style.
   * @return {ImageStyle} The cloned style.
   * @api
   */
  clone() {
    const e = this.getScale();
    return new tB({
      opacity: this.getOpacity(),
      scale: Array.isArray(e) ? e.slice() : e,
      rotation: this.getRotation(),
      rotateWithView: this.getRotateWithView(),
      displacement: this.getDisplacement().slice(),
      declutterMode: this.getDeclutterMode()
    });
  }
  /**
   * Get the symbolizer opacity.
   * @return {number} Opacity.
   * @api
   */
  getOpacity() {
    return this.opacity_;
  }
  /**
   * Determine whether the symbolizer rotates with the map.
   * @return {boolean} Rotate with map.
   * @api
   */
  getRotateWithView() {
    return this.rotateWithView_;
  }
  /**
   * Get the symoblizer rotation.
   * @return {number} Rotation.
   * @api
   */
  getRotation() {
    return this.rotation_;
  }
  /**
   * Get the symbolizer scale.
   * @return {number|import("../size.js").Size} Scale.
   * @api
   */
  getScale() {
    return this.scale_;
  }
  /**
   * Get the symbolizer scale array.
   * @return {import("../size.js").Size} Scale array.
   */
  getScaleArray() {
    return this.scaleArray_;
  }
  /**
   * Get the displacement of the shape
   * @return {Array<number>} Shape's center displacement
   * @api
   */
  getDisplacement() {
    return this.displacement_;
  }
  /**
   * Get the declutter mode of the shape
   * @return {"declutter"|"obstacle"|"none"|undefined} Shape's declutter mode
   * @api
   */
  getDeclutterMode() {
    return this.declutterMode_;
  }
  /**
   * Get the anchor point in pixels. The anchor determines the center point for the
   * symbolizer.
   * @abstract
   * @return {Array<number>} Anchor.
   */
  getAnchor() {
    return pt();
  }
  /**
   * Get the image element for the symbolizer.
   * @abstract
   * @param {number} pixelRatio Pixel ratio.
   * @return {HTMLCanvasElement|HTMLVideoElement|HTMLImageElement} Image element.
   */
  getImage(e) {
    return pt();
  }
  /**
   * @abstract
   * @return {HTMLCanvasElement|HTMLVideoElement|HTMLImageElement} Image element.
   */
  getHitDetectionImage() {
    return pt();
  }
  /**
   * Get the image pixel ratio.
   * @param {number} pixelRatio Pixel ratio.
   * @return {number} Pixel ratio.
   */
  getPixelRatio(e) {
    return 1;
  }
  /**
   * @abstract
   * @return {import("../ImageState.js").default} Image state.
   */
  getImageState() {
    return pt();
  }
  /**
   * @abstract
   * @return {import("../size.js").Size} Image size.
   */
  getImageSize() {
    return pt();
  }
  /**
   * Get the origin of the symbolizer.
   * @abstract
   * @return {Array<number>} Origin.
   */
  getOrigin() {
    return pt();
  }
  /**
   * Get the size of the symbolizer (in pixels).
   * @abstract
   * @return {import("../size.js").Size} Size.
   */
  getSize() {
    return pt();
  }
  /**
   * Set the displacement.
   *
   * @param {Array<number>} displacement Displacement.
   * @api
   */
  setDisplacement(e) {
    this.displacement_ = e;
  }
  /**
   * Set the opacity.
   *
   * @param {number} opacity Opacity.
   * @api
   */
  setOpacity(e) {
    this.opacity_ = e;
  }
  /**
   * Set whether to rotate the style with the view.
   *
   * @param {boolean} rotateWithView Rotate with map.
   * @api
   */
  setRotateWithView(e) {
    this.rotateWithView_ = e;
  }
  /**
   * Set the rotation.
   *
   * @param {number} rotation Rotation.
   * @api
   */
  setRotation(e) {
    this.rotation_ = e;
  }
  /**
   * Set the scale.
   *
   * @param {number|import("../size.js").Size} scale Scale.
   * @api
   */
  setScale(e) {
    this.scale_ = e, this.scaleArray_ = An(e);
  }
  /**
   * @abstract
   * @param {function(import("../events/Event.js").default): void} listener Listener function.
   */
  listenImageChange(e) {
    pt();
  }
  /**
   * Load not yet loaded URI.
   * @abstract
   */
  load() {
    pt();
  }
  /**
   * @abstract
   * @param {function(import("../events/Event.js").default): void} listener Listener function.
   */
  unlistenImageChange(e) {
    pt();
  }
}
const l4 = tB;
function Ga(i) {
  return Array.isArray(i) ? IR(i) : i;
}
class rB extends l4 {
  /**
   * @param {Options} options Options.
   */
  constructor(e) {
    const t = e.rotateWithView !== void 0 ? e.rotateWithView : !1;
    super({
      opacity: 1,
      rotateWithView: t,
      rotation: e.rotation !== void 0 ? e.rotation : 0,
      scale: e.scale !== void 0 ? e.scale : 1,
      displacement: e.displacement !== void 0 ? e.displacement : [0, 0],
      declutterMode: e.declutterMode
    }), this.canvas_ = void 0, this.hitDetectionCanvas_ = null, this.fill_ = e.fill !== void 0 ? e.fill : null, this.origin_ = [0, 0], this.points_ = e.points, this.radius_ = e.radius !== void 0 ? e.radius : e.radius1, this.radius2_ = e.radius2, this.angle_ = e.angle !== void 0 ? e.angle : 0, this.stroke_ = e.stroke !== void 0 ? e.stroke : null, this.size_ = null, this.renderOptions_ = null, this.render();
  }
  /**
   * Clones the style.
   * @return {RegularShape} The cloned style.
   * @api
   */
  clone() {
    const e = this.getScale(), t = new rB({
      fill: this.getFill() ? this.getFill().clone() : void 0,
      points: this.getPoints(),
      radius: this.getRadius(),
      radius2: this.getRadius2(),
      angle: this.getAngle(),
      stroke: this.getStroke() ? this.getStroke().clone() : void 0,
      rotation: this.getRotation(),
      rotateWithView: this.getRotateWithView(),
      scale: Array.isArray(e) ? e.slice() : e,
      displacement: this.getDisplacement().slice(),
      declutterMode: this.getDeclutterMode()
    });
    return t.setOpacity(this.getOpacity()), t;
  }
  /**
   * Get the anchor point in pixels. The anchor determines the center point for the
   * symbolizer.
   * @return {Array<number>} Anchor.
   * @api
   */
  getAnchor() {
    const e = this.size_;
    if (!e)
      return null;
    const t = this.getDisplacement(), r = this.getScaleArray();
    return [
      e[0] / 2 - t[0] / r[0],
      e[1] / 2 + t[1] / r[1]
    ];
  }
  /**
   * Get the angle used in generating the shape.
   * @return {number} Shape's rotation in radians.
   * @api
   */
  getAngle() {
    return this.angle_;
  }
  /**
   * Get the fill style for the shape.
   * @return {import("./Fill.js").default} Fill style.
   * @api
   */
  getFill() {
    return this.fill_;
  }
  /**
   * Set the fill style.
   * @param {import("./Fill.js").default} fill Fill style.
   * @api
   */
  setFill(e) {
    this.fill_ = e, this.render();
  }
  /**
   * @return {HTMLCanvasElement} Image element.
   */
  getHitDetectionImage() {
    return this.hitDetectionCanvas_ || this.createHitDetectionCanvas_(this.renderOptions_), this.hitDetectionCanvas_;
  }
  /**
   * Get the image icon.
   * @param {number} pixelRatio Pixel ratio.
   * @return {HTMLCanvasElement} Image or Canvas element.
   * @api
   */
  getImage(e) {
    let t = this.canvas_[e];
    if (!t) {
      const r = this.renderOptions_, n = Ii(
        r.size * e,
        r.size * e
      );
      this.draw_(r, n, e), t = n.canvas, this.canvas_[e] = t;
    }
    return t;
  }
  /**
   * Get the image pixel ratio.
   * @param {number} pixelRatio Pixel ratio.
   * @return {number} Pixel ratio.
   */
  getPixelRatio(e) {
    return e;
  }
  /**
   * @return {import("../size.js").Size} Image size.
   */
  getImageSize() {
    return this.size_;
  }
  /**
   * @return {import("../ImageState.js").default} Image state.
   */
  getImageState() {
    return Pt.LOADED;
  }
  /**
   * Get the origin of the symbolizer.
   * @return {Array<number>} Origin.
   * @api
   */
  getOrigin() {
    return this.origin_;
  }
  /**
   * Get the number of points for generating the shape.
   * @return {number} Number of points for stars and regular polygons.
   * @api
   */
  getPoints() {
    return this.points_;
  }
  /**
   * Get the (primary) radius for the shape.
   * @return {number} Radius.
   * @api
   */
  getRadius() {
    return this.radius_;
  }
  /**
   * Get the secondary radius for the shape.
   * @return {number|undefined} Radius2.
   * @api
   */
  getRadius2() {
    return this.radius2_;
  }
  /**
   * Get the size of the symbolizer (in pixels).
   * @return {import("../size.js").Size} Size.
   * @api
   */
  getSize() {
    return this.size_;
  }
  /**
   * Get the stroke style for the shape.
   * @return {import("./Stroke.js").default} Stroke style.
   * @api
   */
  getStroke() {
    return this.stroke_;
  }
  /**
   * Set the stroke style.
   * @param {import("./Stroke.js").default} stroke Stroke style.
   * @api
   */
  setStroke(e) {
    this.stroke_ = e, this.render();
  }
  /**
   * @param {function(import("../events/Event.js").default): void} listener Listener function.
   */
  listenImageChange(e) {
  }
  /**
   * Load not yet loaded URI.
   */
  load() {
  }
  /**
   * @param {function(import("../events/Event.js").default): void} listener Listener function.
   */
  unlistenImageChange(e) {
  }
  /**
   * Calculate additional canvas size needed for the miter.
   * @param {string} lineJoin Line join
   * @param {number} strokeWidth Stroke width
   * @param {number} miterLimit Miter limit
   * @return {number} Additional canvas size needed
   * @private
   */
  calculateLineJoinSize_(e, t, r) {
    if (t === 0 || this.points_ === 1 / 0 || e !== "bevel" && e !== "miter")
      return t;
    let n = this.radius_, s = this.radius2_ === void 0 ? n : this.radius2_;
    if (n < s) {
      const M = n;
      n = s, s = M;
    }
    const a = this.radius2_ === void 0 ? this.points_ : this.points_ * 2, o = 2 * Math.PI / a, A = s * Math.sin(o), l = Math.sqrt(s * s - A * A), h = n - l, c = Math.sqrt(A * A + h * h), u = c / A;
    if (e === "miter" && u <= r)
      return u * t;
    const f = t / 2 / u, g = t / 2 * (h / c), y = Math.sqrt((n + f) * (n + f) + g * g) - n;
    if (this.radius2_ === void 0 || e === "bevel")
      return y * 2;
    const v = n * Math.sin(o), w = Math.sqrt(n * n - v * v), C = s - w, S = Math.sqrt(v * v + C * C) / v;
    if (S <= r) {
      const M = S * t / 2 - s - n;
      return 2 * Math.max(y, M);
    }
    return y * 2;
  }
  /**
   * @return {RenderOptions}  The render options
   * @protected
   */
  createRenderOptions() {
    let e = mu, t = 0, r = null, n = 0, s, a = 0;
    this.stroke_ && (s = this.stroke_.getColor(), s === null && (s = Nd), s = Ga(s), a = this.stroke_.getWidth(), a === void 0 && (a = Od), r = this.stroke_.getLineDash(), n = this.stroke_.getLineDashOffset(), e = this.stroke_.getLineJoin(), e === void 0 && (e = mu), t = this.stroke_.getMiterLimit(), t === void 0 && (t = Md));
    const o = this.calculateLineJoinSize_(e, a, t), A = Math.max(this.radius_, this.radius2_ || 0), l = Math.ceil(2 * A + o);
    return {
      strokeStyle: s,
      strokeWidth: a,
      size: l,
      lineDash: r,
      lineDashOffset: n,
      lineJoin: e,
      miterLimit: t
    };
  }
  /**
   * @protected
   */
  render() {
    this.renderOptions_ = this.createRenderOptions();
    const e = this.renderOptions_.size;
    this.canvas_ = {}, this.size_ = [e, e];
  }
  /**
   * @private
   * @param {RenderOptions} renderOptions Render options.
   * @param {CanvasRenderingContext2D} context The rendering context.
   * @param {number} pixelRatio The pixel ratio.
   */
  draw_(e, t, r) {
    if (t.scale(r, r), t.translate(e.size / 2, e.size / 2), this.createPath_(t), this.fill_) {
      let n = this.fill_.getColor();
      n === null && (n = Go), t.fillStyle = Ga(n), t.fill();
    }
    this.stroke_ && (t.strokeStyle = e.strokeStyle, t.lineWidth = e.strokeWidth, e.lineDash && (t.setLineDash(e.lineDash), t.lineDashOffset = e.lineDashOffset), t.lineJoin = e.lineJoin, t.miterLimit = e.miterLimit, t.stroke());
  }
  /**
   * @private
   * @param {RenderOptions} renderOptions Render options.
   */
  createHitDetectionCanvas_(e) {
    if (this.fill_) {
      let t = this.fill_.getColor(), r = 0;
      if (typeof t == "string" && (t = hl(t)), t === null ? r = 1 : Array.isArray(t) && (r = t.length === 4 ? t[3] : 1), r === 0) {
        const n = Ii(
          e.size,
          e.size
        );
        this.hitDetectionCanvas_ = n.canvas, this.drawHitDetectionCanvas_(e, n);
      }
    }
    this.hitDetectionCanvas_ || (this.hitDetectionCanvas_ = this.getImage(1));
  }
  /**
   * @private
   * @param {CanvasRenderingContext2D} context The context to draw in.
   */
  createPath_(e) {
    let t = this.points_;
    const r = this.radius_;
    if (t === 1 / 0)
      e.arc(0, 0, r, 0, 2 * Math.PI);
    else {
      const n = this.radius2_ === void 0 ? r : this.radius2_;
      this.radius2_ !== void 0 && (t *= 2);
      const s = this.angle_ - Math.PI / 2, a = 2 * Math.PI / t;
      for (let o = 0; o < t; o++) {
        const A = s + o * a, l = o % 2 === 0 ? r : n;
        e.lineTo(l * Math.cos(A), l * Math.sin(A));
      }
      e.closePath();
    }
  }
  /**
   * @private
   * @param {RenderOptions} renderOptions Render options.
   * @param {CanvasRenderingContext2D} context The context.
   */
  drawHitDetectionCanvas_(e, t) {
    t.translate(e.size / 2, e.size / 2), this.createPath_(t), t.fillStyle = Go, t.fill(), this.stroke_ && (t.strokeStyle = e.strokeStyle, t.lineWidth = e.strokeWidth, e.lineDash && (t.setLineDash(e.lineDash), t.lineDashOffset = e.lineDashOffset), t.lineJoin = e.lineJoin, t.miterLimit = e.miterLimit, t.stroke());
  }
}
const ud = rB;
class iB extends ud {
  /**
   * @param {Options} [options] Options.
   */
  constructor(e) {
    e = e || { radius: 5 }, super({
      points: 1 / 0,
      fill: e.fill,
      radius: e.radius,
      stroke: e.stroke,
      scale: e.scale !== void 0 ? e.scale : 1,
      rotation: e.rotation !== void 0 ? e.rotation : 0,
      rotateWithView: e.rotateWithView !== void 0 ? e.rotateWithView : !1,
      displacement: e.displacement !== void 0 ? e.displacement : [0, 0],
      declutterMode: e.declutterMode
    });
  }
  /**
   * Clones the style.
   * @return {CircleStyle} The cloned style.
   * @api
   */
  clone() {
    const e = this.getScale(), t = new iB({
      fill: this.getFill() ? this.getFill().clone() : void 0,
      stroke: this.getStroke() ? this.getStroke().clone() : void 0,
      radius: this.getRadius(),
      scale: Array.isArray(e) ? e.slice() : e,
      rotation: this.getRotation(),
      rotateWithView: this.getRotateWithView(),
      displacement: this.getDisplacement().slice(),
      declutterMode: this.getDeclutterMode()
    });
    return t.setOpacity(this.getOpacity()), t;
  }
  /**
   * Set the circle radius.
   *
   * @param {number} radius Circle radius.
   * @api
   */
  setRadius(e) {
    this.radius_ = e, this.render();
  }
}
const Ru = iB;
let U9 = class h4 {
  /**
   * @param {Options} [options] Options.
   */
  constructor(e) {
    e = e || {}, this.color_ = e.color !== void 0 ? e.color : null;
  }
  /**
   * Clones the style. The color is not cloned if it is an {@link module:ol/colorlike~ColorLike}.
   * @return {Fill} The cloned style.
   * @api
   */
  clone() {
    const e = this.getColor();
    return new h4({
      color: Array.isArray(e) ? e.slice() : e || void 0
    });
  }
  /**
   * Get the fill color.
   * @return {import("../color.js").Color|import("../colorlike.js").ColorLike|null} Color.
   * @api
   */
  getColor() {
    return this.color_;
  }
  /**
   * Set the color.
   *
   * @param {import("../color.js").Color|import("../colorlike.js").ColorLike|null} color Color.
   * @api
   */
  setColor(e) {
    this.color_ = e;
  }
};
const Wn = U9;
let Q9 = class c4 {
  /**
   * @param {Options} [options] Options.
   */
  constructor(e) {
    e = e || {}, this.color_ = e.color !== void 0 ? e.color : null, this.lineCap_ = e.lineCap, this.lineDash_ = e.lineDash !== void 0 ? e.lineDash : null, this.lineDashOffset_ = e.lineDashOffset, this.lineJoin_ = e.lineJoin, this.miterLimit_ = e.miterLimit, this.width_ = e.width;
  }
  /**
   * Clones the style.
   * @return {Stroke} The cloned style.
   * @api
   */
  clone() {
    const e = this.getColor();
    return new c4({
      color: Array.isArray(e) ? e.slice() : e || void 0,
      lineCap: this.getLineCap(),
      lineDash: this.getLineDash() ? this.getLineDash().slice() : void 0,
      lineDashOffset: this.getLineDashOffset(),
      lineJoin: this.getLineJoin(),
      miterLimit: this.getMiterLimit(),
      width: this.getWidth()
    });
  }
  /**
   * Get the stroke color.
   * @return {import("../color.js").Color|import("../colorlike.js").ColorLike} Color.
   * @api
   */
  getColor() {
    return this.color_;
  }
  /**
   * Get the line cap type for the stroke.
   * @return {CanvasLineCap|undefined} Line cap.
   * @api
   */
  getLineCap() {
    return this.lineCap_;
  }
  /**
   * Get the line dash style for the stroke.
   * @return {Array<number>|null} Line dash.
   * @api
   */
  getLineDash() {
    return this.lineDash_;
  }
  /**
   * Get the line dash offset for the stroke.
   * @return {number|undefined} Line dash offset.
   * @api
   */
  getLineDashOffset() {
    return this.lineDashOffset_;
  }
  /**
   * Get the line join type for the stroke.
   * @return {CanvasLineJoin|undefined} Line join.
   * @api
   */
  getLineJoin() {
    return this.lineJoin_;
  }
  /**
   * Get the miter limit for the stroke.
   * @return {number|undefined} Miter limit.
   * @api
   */
  getMiterLimit() {
    return this.miterLimit_;
  }
  /**
   * Get the stroke width.
   * @return {number|undefined} Width.
   * @api
   */
  getWidth() {
    return this.width_;
  }
  /**
   * Set the color.
   *
   * @param {import("../color.js").Color|import("../colorlike.js").ColorLike} color Color.
   * @api
   */
  setColor(e) {
    this.color_ = e;
  }
  /**
   * Set the line cap.
   *
   * @param {CanvasLineCap|undefined} lineCap Line cap.
   * @api
   */
  setLineCap(e) {
    this.lineCap_ = e;
  }
  /**
   * Set the line dash.
   *
   * @param {Array<number>|null} lineDash Line dash.
   * @api
   */
  setLineDash(e) {
    this.lineDash_ = e;
  }
  /**
   * Set the line dash offset.
   *
   * @param {number|undefined} lineDashOffset Line dash offset.
   * @api
   */
  setLineDashOffset(e) {
    this.lineDashOffset_ = e;
  }
  /**
   * Set the line join.
   *
   * @param {CanvasLineJoin|undefined} lineJoin Line join.
   * @api
   */
  setLineJoin(e) {
    this.lineJoin_ = e;
  }
  /**
   * Set the miter limit.
   *
   * @param {number|undefined} miterLimit Miter limit.
   * @api
   */
  setMiterLimit(e) {
    this.miterLimit_ = e;
  }
  /**
   * Set the width.
   *
   * @param {number|undefined} width Width.
   * @api
   */
  setWidth(e) {
    this.width_ = e;
  }
};
const Zi = Q9;
let kc = class u4 {
  /**
   * @param {Options} [options] Style options.
   */
  constructor(e) {
    e = e || {}, this.geometry_ = null, this.geometryFunction_ = v5, e.geometry !== void 0 && this.setGeometry(e.geometry), this.fill_ = e.fill !== void 0 ? e.fill : null, this.image_ = e.image !== void 0 ? e.image : null, this.renderer_ = e.renderer !== void 0 ? e.renderer : null, this.hitDetectionRenderer_ = e.hitDetectionRenderer !== void 0 ? e.hitDetectionRenderer : null, this.stroke_ = e.stroke !== void 0 ? e.stroke : null, this.text_ = e.text !== void 0 ? e.text : null, this.zIndex_ = e.zIndex;
  }
  /**
   * Clones the style.
   * @return {Style} The cloned style.
   * @api
   */
  clone() {
    let e = this.getGeometry();
    return e && typeof e == "object" && (e = /** @type {import("../geom/Geometry.js").default} */
    e.clone()), new u4({
      geometry: e,
      fill: this.getFill() ? this.getFill().clone() : void 0,
      image: this.getImage() ? this.getImage().clone() : void 0,
      renderer: this.getRenderer(),
      stroke: this.getStroke() ? this.getStroke().clone() : void 0,
      text: this.getText() ? this.getText().clone() : void 0,
      zIndex: this.getZIndex()
    });
  }
  /**
   * Get the custom renderer function that was configured with
   * {@link #setRenderer} or the `renderer` constructor option.
   * @return {RenderFunction|null} Custom renderer function.
   * @api
   */
  getRenderer() {
    return this.renderer_;
  }
  /**
   * Sets a custom renderer function for this style. When set, `fill`, `stroke`
   * and `image` options of the style will be ignored.
   * @param {RenderFunction|null} renderer Custom renderer function.
   * @api
   */
  setRenderer(e) {
    this.renderer_ = e;
  }
  /**
   * Sets a custom renderer function for this style used
   * in hit detection.
   * @param {RenderFunction|null} renderer Custom renderer function.
   * @api
   */
  setHitDetectionRenderer(e) {
    this.hitDetectionRenderer_ = e;
  }
  /**
   * Get the custom renderer function that was configured with
   * {@link #setHitDetectionRenderer} or the `hitDetectionRenderer` constructor option.
   * @return {RenderFunction|null} Custom renderer function.
   * @api
   */
  getHitDetectionRenderer() {
    return this.hitDetectionRenderer_;
  }
  /**
   * Get the geometry to be rendered.
   * @return {string|import("../geom/Geometry.js").default|GeometryFunction}
   * Feature property or geometry or function that returns the geometry that will
   * be rendered with this style.
   * @api
   */
  getGeometry() {
    return this.geometry_;
  }
  /**
   * Get the function used to generate a geometry for rendering.
   * @return {!GeometryFunction} Function that is called with a feature
   * and returns the geometry to render instead of the feature's geometry.
   * @api
   */
  getGeometryFunction() {
    return this.geometryFunction_;
  }
  /**
   * Get the fill style.
   * @return {import("./Fill.js").default} Fill style.
   * @api
   */
  getFill() {
    return this.fill_;
  }
  /**
   * Set the fill style.
   * @param {import("./Fill.js").default} fill Fill style.
   * @api
   */
  setFill(e) {
    this.fill_ = e;
  }
  /**
   * Get the image style.
   * @return {import("./Image.js").default} Image style.
   * @api
   */
  getImage() {
    return this.image_;
  }
  /**
   * Set the image style.
   * @param {import("./Image.js").default} image Image style.
   * @api
   */
  setImage(e) {
    this.image_ = e;
  }
  /**
   * Get the stroke style.
   * @return {import("./Stroke.js").default} Stroke style.
   * @api
   */
  getStroke() {
    return this.stroke_;
  }
  /**
   * Set the stroke style.
   * @param {import("./Stroke.js").default} stroke Stroke style.
   * @api
   */
  setStroke(e) {
    this.stroke_ = e;
  }
  /**
   * Get the text style.
   * @return {import("./Text.js").default} Text style.
   * @api
   */
  getText() {
    return this.text_;
  }
  /**
   * Set the text style.
   * @param {import("./Text.js").default} text Text style.
   * @api
   */
  setText(e) {
    this.text_ = e;
  }
  /**
   * Get the z-index for the style.
   * @return {number|undefined} ZIndex.
   * @api
   */
  getZIndex() {
    return this.zIndex_;
  }
  /**
   * Set a geometry that is rendered instead of the feature's geometry.
   *
   * @param {string|import("../geom/Geometry.js").default|GeometryFunction} geometry
   *     Feature property or geometry or function returning a geometry to render
   *     for this style.
   * @api
   */
  setGeometry(e) {
    typeof e == "function" ? this.geometryFunction_ = e : typeof e == "string" ? this.geometryFunction_ = function(t) {
      return (
        /** @type {import("../geom/Geometry.js").default} */
        t.get(e)
      );
    } : e ? e !== void 0 && (this.geometryFunction_ = function() {
      return (
        /** @type {import("../geom/Geometry.js").default} */
        e
      );
    }) : this.geometryFunction_ = v5, this.geometry_ = e;
  }
  /**
   * Set the z-index.
   *
   * @param {number|undefined} zIndex ZIndex.
   * @api
   */
  setZIndex(e) {
    this.zIndex_ = e;
  }
};
function D9(i) {
  let e;
  if (typeof i == "function")
    e = i;
  else {
    let t;
    Array.isArray(i) ? t = i : (lt(typeof /** @type {?} */
    i.getZIndex == "function", 41), t = [
      /** @type {Style} */
      i
    ]), e = function() {
      return t;
    };
  }
  return e;
}
let V1 = null;
function k9(i, e) {
  if (!V1) {
    const t = new Wn({
      color: "rgba(255,255,255,0.4)"
    }), r = new Zi({
      color: "#3399CC",
      width: 1.25
    });
    V1 = [
      new kc({
        image: new Ru({
          fill: t,
          stroke: r,
          radius: 5
        }),
        fill: t,
        stroke: r
      })
    ];
  }
  return V1;
}
function nB() {
  const i = {}, e = [255, 255, 255, 1], t = [0, 153, 255, 1], r = 3;
  return i.Polygon = [
    new kc({
      fill: new Wn({
        color: [255, 255, 255, 0.5]
      })
    })
  ], i.MultiPolygon = i.Polygon, i.LineString = [
    new kc({
      stroke: new Zi({
        color: e,
        width: r + 2
      })
    }),
    new kc({
      stroke: new Zi({
        color: t,
        width: r
      })
    })
  ], i.MultiLineString = i.LineString, i.Circle = i.Polygon.concat(i.LineString), i.Point = [
    new kc({
      image: new Ru({
        radius: r * 2,
        fill: new Wn({
          color: t
        }),
        stroke: new Zi({
          color: e,
          width: r / 2
        })
      }),
      zIndex: 1 / 0
    })
  ], i.MultiPoint = i.Point, i.GeometryCollection = i.Polygon.concat(
    i.LineString,
    i.Point
  ), i;
}
function v5(i) {
  return i.getGeometry();
}
const ln = kc;
let Lf = null;
class H9 extends bu {
  /**
   * @param {HTMLImageElement|HTMLCanvasElement} image Image.
   * @param {string|undefined} src Src.
   * @param {import("../size.js").Size} size Size.
   * @param {?string} crossOrigin Cross origin.
   * @param {import("../ImageState.js").default} imageState Image state.
   * @param {import("../color.js").Color} color Color.
   */
  constructor(e, t, r, n, s, a) {
    super(), this.hitDetectionImage_ = null, this.image_ = e, this.crossOrigin_ = n, this.canvas_ = {}, this.color_ = a, this.unlisten_ = null, this.imageState_ = s, this.size_ = r, this.src_ = t, this.tainted_;
  }
  /**
   * @private
   */
  initializeImage_() {
    this.image_ = new Image(), this.crossOrigin_ !== null && (this.image_.crossOrigin = this.crossOrigin_);
  }
  /**
   * @private
   * @return {boolean} The image canvas is tainted.
   */
  isTainted_() {
    if (this.tainted_ === void 0 && this.imageState_ === Pt.LOADED) {
      Lf || (Lf = Ii(1, 1, void 0, {
        willReadFrequently: !0
      })), Lf.drawImage(this.image_, 0, 0);
      try {
        Lf.getImageData(0, 0, 1, 1), this.tainted_ = !1;
      } catch {
        Lf = null, this.tainted_ = !0;
      }
    }
    return this.tainted_ === !0;
  }
  /**
   * @private
   */
  dispatchChangeEvent_() {
    this.dispatchEvent(ut.CHANGE);
  }
  /**
   * @private
   */
  handleImageError_() {
    this.imageState_ = Pt.ERROR, this.unlistenImage_(), this.dispatchChangeEvent_();
  }
  /**
   * @private
   */
  handleImageLoad_() {
    this.imageState_ = Pt.LOADED, this.size_ ? (this.image_.width = this.size_[0], this.image_.height = this.size_[1]) : this.size_ = [this.image_.width, this.image_.height], this.unlistenImage_(), this.dispatchChangeEvent_();
  }
  /**
   * @param {number} pixelRatio Pixel ratio.
   * @return {HTMLImageElement|HTMLCanvasElement} Image or Canvas element.
   */
  getImage(e) {
    return this.image_ || this.initializeImage_(), this.replaceColor_(e), this.canvas_[e] ? this.canvas_[e] : this.image_;
  }
  /**
   * @param {number} pixelRatio Pixel ratio.
   * @return {number} Image or Canvas element.
   */
  getPixelRatio(e) {
    return this.replaceColor_(e), this.canvas_[e] ? e : 1;
  }
  /**
   * @return {import("../ImageState.js").default} Image state.
   */
  getImageState() {
    return this.imageState_;
  }
  /**
   * @return {HTMLImageElement|HTMLCanvasElement} Image element.
   */
  getHitDetectionImage() {
    if (this.image_ || this.initializeImage_(), !this.hitDetectionImage_)
      if (this.isTainted_()) {
        const e = this.size_[0], t = this.size_[1], r = Ii(e, t);
        r.fillRect(0, 0, e, t), this.hitDetectionImage_ = r.canvas;
      } else
        this.hitDetectionImage_ = this.image_;
    return this.hitDetectionImage_;
  }
  /**
   * Get the size of the icon (in pixels).
   * @return {import("../size.js").Size} Image size.
   */
  getSize() {
    return this.size_;
  }
  /**
   * @return {string|undefined} Image src.
   */
  getSrc() {
    return this.src_;
  }
  /**
   * Load not yet loaded URI.
   */
  load() {
    if (this.imageState_ === Pt.IDLE) {
      this.image_ || this.initializeImage_(), this.imageState_ = Pt.LOADING;
      try {
        this.image_.src = this.src_;
      } catch {
        this.handleImageError_();
      }
      this.unlisten_ = KE(
        this.image_,
        this.handleImageLoad_.bind(this),
        this.handleImageError_.bind(this)
      );
    }
  }
  /**
   * @param {number} pixelRatio Pixel ratio.
   * @private
   */
  replaceColor_(e) {
    if (!this.color_ || this.canvas_[e] || this.imageState_ !== Pt.LOADED)
      return;
    const t = this.image_, r = document.createElement("canvas");
    r.width = Math.ceil(t.width * e), r.height = Math.ceil(t.height * e);
    const n = r.getContext("2d");
    n.scale(e, e), n.drawImage(t, 0, 0), n.globalCompositeOperation = "multiply", n.fillStyle = rl(this.color_), n.fillRect(0, 0, r.width / e, r.height / e), n.globalCompositeOperation = "destination-in", n.drawImage(t, 0, 0), this.canvas_[e] = r;
  }
  /**
   * Discards event handlers which listen for load completion or errors.
   *
   * @private
   */
  unlistenImage_() {
    this.unlisten_ && (this.unlisten_(), this.unlisten_ = null);
  }
}
function G9(i, e, t, r, n, s) {
  let a = fm.get(e, r, s);
  return a || (a = new H9(i, e, t, r, n, s), fm.set(e, r, s, a)), a;
}
let $9 = class f4 extends l4 {
  /**
   * @param {Options} [options] Options.
   */
  constructor(e) {
    e = e || {};
    const t = e.opacity !== void 0 ? e.opacity : 1, r = e.rotation !== void 0 ? e.rotation : 0, n = e.scale !== void 0 ? e.scale : 1, s = e.rotateWithView !== void 0 ? e.rotateWithView : !1;
    super({
      opacity: t,
      rotation: r,
      scale: n,
      displacement: e.displacement !== void 0 ? e.displacement : [0, 0],
      rotateWithView: s,
      declutterMode: e.declutterMode
    }), this.anchor_ = e.anchor !== void 0 ? e.anchor : [0.5, 0.5], this.normalizedAnchor_ = null, this.anchorOrigin_ = e.anchorOrigin !== void 0 ? e.anchorOrigin : "top-left", this.anchorXUnits_ = e.anchorXUnits !== void 0 ? e.anchorXUnits : "fraction", this.anchorYUnits_ = e.anchorYUnits !== void 0 ? e.anchorYUnits : "fraction", this.crossOrigin_ = e.crossOrigin !== void 0 ? e.crossOrigin : null;
    const a = e.img !== void 0 ? e.img : null;
    this.imgSize_ = e.imgSize;
    let o = e.src;
    lt(!(o !== void 0 && a), 4), lt(!a || a && this.imgSize_, 5), (o === void 0 || o.length === 0) && a && (o = /** @type {HTMLImageElement} */
    a.src || st(a)), lt(o !== void 0 && o.length > 0, 6), lt(
      !((e.width !== void 0 || e.height !== void 0) && e.scale !== void 0),
      69
    );
    const A = e.src !== void 0 ? Pt.IDLE : Pt.LOADED;
    if (this.color_ = e.color !== void 0 ? hl(e.color) : null, this.iconImage_ = G9(
      a,
      /** @type {string} */
      o,
      this.imgSize_ !== void 0 ? this.imgSize_ : null,
      this.crossOrigin_,
      A,
      this.color_
    ), this.offset_ = e.offset !== void 0 ? e.offset : [0, 0], this.offsetOrigin_ = e.offsetOrigin !== void 0 ? e.offsetOrigin : "top-left", this.origin_ = null, this.size_ = e.size !== void 0 ? e.size : null, this.width_ = e.width, this.height_ = e.height, this.width_ !== void 0 || this.height_ !== void 0) {
      const l = this.getImage(1), h = () => {
        this.updateScaleFromWidthAndHeight(this.width_, this.height_);
      };
      l.width > 0 ? this.updateScaleFromWidthAndHeight(this.width_, this.height_) : l.addEventListener("load", h);
    }
  }
  /**
   * Clones the style. The underlying Image/HTMLCanvasElement is not cloned.
   * @return {Icon} The cloned style.
   * @api
   */
  clone() {
    let e = this.getScale();
    return e = Array.isArray(e) ? e.slice() : e, (this.width_ !== void 0 || this.height_ !== void 0) && (e = void 0), new f4({
      anchor: this.anchor_.slice(),
      anchorOrigin: this.anchorOrigin_,
      anchorXUnits: this.anchorXUnits_,
      anchorYUnits: this.anchorYUnits_,
      color: this.color_ && this.color_.slice ? this.color_.slice() : this.color_ || void 0,
      crossOrigin: this.crossOrigin_,
      imgSize: this.imgSize_,
      offset: this.offset_.slice(),
      offsetOrigin: this.offsetOrigin_,
      opacity: this.getOpacity(),
      rotateWithView: this.getRotateWithView(),
      rotation: this.getRotation(),
      scale: e,
      size: this.size_ !== null ? this.size_.slice() : void 0,
      src: this.getSrc(),
      displacement: this.getDisplacement().slice(),
      declutterMode: this.getDeclutterMode(),
      width: this.width_,
      height: this.height_
    });
  }
  /**
   * Set the scale of the Icon by calculating it from given width and height and the
   * width and height of the image.
   *
   * @private
   * @param {number} width The width.
   * @param {number} height The height.
   */
  updateScaleFromWidthAndHeight(e, t) {
    const r = this.getImage(1);
    e !== void 0 && t !== void 0 ? super.setScale([e / r.width, t / r.height]) : e !== void 0 ? super.setScale([e / r.width, e / r.width]) : t !== void 0 ? super.setScale([t / r.height, t / r.height]) : super.setScale([1, 1]);
  }
  /**
   * Get the anchor point in pixels. The anchor determines the center point for the
   * symbolizer.
   * @return {Array<number>} Anchor.
   * @api
   */
  getAnchor() {
    let e = this.normalizedAnchor_;
    if (!e) {
      e = this.anchor_;
      const n = this.getSize();
      if (this.anchorXUnits_ == "fraction" || this.anchorYUnits_ == "fraction") {
        if (!n)
          return null;
        e = this.anchor_.slice(), this.anchorXUnits_ == "fraction" && (e[0] *= n[0]), this.anchorYUnits_ == "fraction" && (e[1] *= n[1]);
      }
      if (this.anchorOrigin_ != "top-left") {
        if (!n)
          return null;
        e === this.anchor_ && (e = this.anchor_.slice()), (this.anchorOrigin_ == "top-right" || this.anchorOrigin_ == "bottom-right") && (e[0] = -e[0] + n[0]), (this.anchorOrigin_ == "bottom-left" || this.anchorOrigin_ == "bottom-right") && (e[1] = -e[1] + n[1]);
      }
      this.normalizedAnchor_ = e;
    }
    const t = this.getDisplacement(), r = this.getScaleArray();
    return [
      e[0] - t[0] / r[0],
      e[1] + t[1] / r[1]
    ];
  }
  /**
   * Set the anchor point. The anchor determines the center point for the
   * symbolizer.
   *
   * @param {Array<number>} anchor Anchor.
   * @api
   */
  setAnchor(e) {
    this.anchor_ = e, this.normalizedAnchor_ = null;
  }
  /**
   * Get the icon color.
   * @return {import("../color.js").Color} Color.
   * @api
   */
  getColor() {
    return this.color_;
  }
  /**
   * Get the image icon.
   * @param {number} pixelRatio Pixel ratio.
   * @return {HTMLImageElement|HTMLCanvasElement} Image or Canvas element.
   * @api
   */
  getImage(e) {
    return this.iconImage_.getImage(e);
  }
  /**
   * Get the pixel ratio.
   * @param {number} pixelRatio Pixel ratio.
   * @return {number} The pixel ratio of the image.
   * @api
   */
  getPixelRatio(e) {
    return this.iconImage_.getPixelRatio(e);
  }
  /**
   * @return {import("../size.js").Size} Image size.
   */
  getImageSize() {
    return this.iconImage_.getSize();
  }
  /**
   * @return {import("../ImageState.js").default} Image state.
   */
  getImageState() {
    return this.iconImage_.getImageState();
  }
  /**
   * @return {HTMLImageElement|HTMLCanvasElement} Image element.
   */
  getHitDetectionImage() {
    return this.iconImage_.getHitDetectionImage();
  }
  /**
   * Get the origin of the symbolizer.
   * @return {Array<number>} Origin.
   * @api
   */
  getOrigin() {
    if (this.origin_)
      return this.origin_;
    let e = this.offset_;
    if (this.offsetOrigin_ != "top-left") {
      const t = this.getSize(), r = this.iconImage_.getSize();
      if (!t || !r)
        return null;
      e = e.slice(), (this.offsetOrigin_ == "top-right" || this.offsetOrigin_ == "bottom-right") && (e[0] = r[0] - t[0] - e[0]), (this.offsetOrigin_ == "bottom-left" || this.offsetOrigin_ == "bottom-right") && (e[1] = r[1] - t[1] - e[1]);
    }
    return this.origin_ = e, this.origin_;
  }
  /**
   * Get the image URL.
   * @return {string|undefined} Image src.
   * @api
   */
  getSrc() {
    return this.iconImage_.getSrc();
  }
  /**
   * Get the size of the icon (in pixels).
   * @return {import("../size.js").Size} Image size.
   * @api
   */
  getSize() {
    return this.size_ ? this.size_ : this.iconImage_.getSize();
  }
  /**
   * Get the width of the icon (in pixels).
   * @return {number} Icon width (in pixels).
   * @api
   */
  getWidth() {
    return this.width_;
  }
  /**
   * Get the height of the icon (in pixels).
   * @return {number} Icon height (in pixels).
   * @api
   */
  getHeight() {
    return this.height_;
  }
  /**
   * Set the width of the icon in pixels.
   *
   * @param {number} width The width to set.
   */
  setWidth(e) {
    this.width_ = e, this.updateScaleFromWidthAndHeight(e, this.height_);
  }
  /**
   * Set the height of the icon in pixels.
   *
   * @param {number} height The height to set.
   */
  setHeight(e) {
    this.height_ = e, this.updateScaleFromWidthAndHeight(this.width_, e);
  }
  /**
   * Set the scale and updates the width and height correspondingly.
   *
   * @param {number|import("../size.js").Size} scale Scale.
   * @override
   * @api
   */
  setScale(e) {
    super.setScale(e);
    const t = this.getImage(1);
    if (t) {
      const r = Array.isArray(e) ? e[0] : e;
      r !== void 0 && (this.width_ = r * t.width);
      const n = Array.isArray(e) ? e[1] : e;
      n !== void 0 && (this.height_ = n * t.height);
    }
  }
  /**
   * @param {function(import("../events/Event.js").default): void} listener Listener function.
   */
  listenImageChange(e) {
    this.iconImage_.addEventListener(ut.CHANGE, e);
  }
  /**
   * Load not yet loaded URI.
   * When rendering a feature with an icon style, the vector renderer will
   * automatically call this method. However, you might want to call this
   * method yourself for preloading or other purposes.
   * @api
   */
  load() {
    this.iconImage_.load();
  }
  /**
   * @param {function(import("../events/Event.js").default): void} listener Listener function.
   */
  unlistenImageChange(e) {
    this.iconImage_.removeEventListener(ut.CHANGE, e);
  }
};
const Mu = $9, V9 = "#333";
let K9 = class d4 {
  /**
   * @param {Options} [options] Options.
   */
  constructor(e) {
    e = e || {}, this.font_ = e.font, this.rotation_ = e.rotation, this.rotateWithView_ = e.rotateWithView, this.scale_ = e.scale, this.scaleArray_ = An(e.scale !== void 0 ? e.scale : 1), this.text_ = e.text, this.textAlign_ = e.textAlign, this.justify_ = e.justify, this.repeat_ = e.repeat, this.textBaseline_ = e.textBaseline, this.fill_ = e.fill !== void 0 ? e.fill : new Wn({ color: V9 }), this.maxAngle_ = e.maxAngle !== void 0 ? e.maxAngle : Math.PI / 4, this.placement_ = e.placement !== void 0 ? e.placement : "point", this.overflow_ = !!e.overflow, this.stroke_ = e.stroke !== void 0 ? e.stroke : null, this.offsetX_ = e.offsetX !== void 0 ? e.offsetX : 0, this.offsetY_ = e.offsetY !== void 0 ? e.offsetY : 0, this.backgroundFill_ = e.backgroundFill ? e.backgroundFill : null, this.backgroundStroke_ = e.backgroundStroke ? e.backgroundStroke : null, this.padding_ = e.padding === void 0 ? null : e.padding;
  }
  /**
   * Clones the style.
   * @return {Text} The cloned style.
   * @api
   */
  clone() {
    const e = this.getScale();
    return new d4({
      font: this.getFont(),
      placement: this.getPlacement(),
      repeat: this.getRepeat(),
      maxAngle: this.getMaxAngle(),
      overflow: this.getOverflow(),
      rotation: this.getRotation(),
      rotateWithView: this.getRotateWithView(),
      scale: Array.isArray(e) ? e.slice() : e,
      text: this.getText(),
      textAlign: this.getTextAlign(),
      justify: this.getJustify(),
      textBaseline: this.getTextBaseline(),
      fill: this.getFill() ? this.getFill().clone() : void 0,
      stroke: this.getStroke() ? this.getStroke().clone() : void 0,
      offsetX: this.getOffsetX(),
      offsetY: this.getOffsetY(),
      backgroundFill: this.getBackgroundFill() ? this.getBackgroundFill().clone() : void 0,
      backgroundStroke: this.getBackgroundStroke() ? this.getBackgroundStroke().clone() : void 0,
      padding: this.getPadding() || void 0
    });
  }
  /**
   * Get the `overflow` configuration.
   * @return {boolean} Let text overflow the length of the path they follow.
   * @api
   */
  getOverflow() {
    return this.overflow_;
  }
  /**
   * Get the font name.
   * @return {string|undefined} Font.
   * @api
   */
  getFont() {
    return this.font_;
  }
  /**
   * Get the maximum angle between adjacent characters.
   * @return {number} Angle in radians.
   * @api
   */
  getMaxAngle() {
    return this.maxAngle_;
  }
  /**
   * Get the label placement.
   * @return {TextPlacement} Text placement.
   * @api
   */
  getPlacement() {
    return this.placement_;
  }
  /**
   * Get the repeat interval of the text.
   * @return {number|undefined} Repeat interval in pixels.
   * @api
   */
  getRepeat() {
    return this.repeat_;
  }
  /**
   * Get the x-offset for the text.
   * @return {number} Horizontal text offset.
   * @api
   */
  getOffsetX() {
    return this.offsetX_;
  }
  /**
   * Get the y-offset for the text.
   * @return {number} Vertical text offset.
   * @api
   */
  getOffsetY() {
    return this.offsetY_;
  }
  /**
   * Get the fill style for the text.
   * @return {import("./Fill.js").default} Fill style.
   * @api
   */
  getFill() {
    return this.fill_;
  }
  /**
   * Determine whether the text rotates with the map.
   * @return {boolean|undefined} Rotate with map.
   * @api
   */
  getRotateWithView() {
    return this.rotateWithView_;
  }
  /**
   * Get the text rotation.
   * @return {number|undefined} Rotation.
   * @api
   */
  getRotation() {
    return this.rotation_;
  }
  /**
   * Get the text scale.
   * @return {number|import("../size.js").Size|undefined} Scale.
   * @api
   */
  getScale() {
    return this.scale_;
  }
  /**
   * Get the symbolizer scale array.
   * @return {import("../size.js").Size} Scale array.
   */
  getScaleArray() {
    return this.scaleArray_;
  }
  /**
   * Get the stroke style for the text.
   * @return {import("./Stroke.js").default} Stroke style.
   * @api
   */
  getStroke() {
    return this.stroke_;
  }
  /**
   * Get the text to be rendered.
   * @return {string|Array<string>|undefined} Text.
   * @api
   */
  getText() {
    return this.text_;
  }
  /**
   * Get the text alignment.
   * @return {CanvasTextAlign|undefined} Text align.
   * @api
   */
  getTextAlign() {
    return this.textAlign_;
  }
  /**
   * Get the justification.
   * @return {TextJustify|undefined} Justification.
   * @api
   */
  getJustify() {
    return this.justify_;
  }
  /**
   * Get the text baseline.
   * @return {CanvasTextBaseline|undefined} Text baseline.
   * @api
   */
  getTextBaseline() {
    return this.textBaseline_;
  }
  /**
   * Get the background fill style for the text.
   * @return {import("./Fill.js").default} Fill style.
   * @api
   */
  getBackgroundFill() {
    return this.backgroundFill_;
  }
  /**
   * Get the background stroke style for the text.
   * @return {import("./Stroke.js").default} Stroke style.
   * @api
   */
  getBackgroundStroke() {
    return this.backgroundStroke_;
  }
  /**
   * Get the padding for the text.
   * @return {Array<number>|null} Padding.
   * @api
   */
  getPadding() {
    return this.padding_;
  }
  /**
   * Set the `overflow` property.
   *
   * @param {boolean} overflow Let text overflow the path that it follows.
   * @api
   */
  setOverflow(e) {
    this.overflow_ = e;
  }
  /**
   * Set the font.
   *
   * @param {string|undefined} font Font.
   * @api
   */
  setFont(e) {
    this.font_ = e;
  }
  /**
   * Set the maximum angle between adjacent characters.
   *
   * @param {number} maxAngle Angle in radians.
   * @api
   */
  setMaxAngle(e) {
    this.maxAngle_ = e;
  }
  /**
   * Set the x offset.
   *
   * @param {number} offsetX Horizontal text offset.
   * @api
   */
  setOffsetX(e) {
    this.offsetX_ = e;
  }
  /**
   * Set the y offset.
   *
   * @param {number} offsetY Vertical text offset.
   * @api
   */
  setOffsetY(e) {
    this.offsetY_ = e;
  }
  /**
   * Set the text placement.
   *
   * @param {TextPlacement} placement Placement.
   * @api
   */
  setPlacement(e) {
    this.placement_ = e;
  }
  /**
   * Set the repeat interval of the text.
   * @param {number|undefined} [repeat] Repeat interval in pixels.
   * @api
   */
  setRepeat(e) {
    this.repeat_ = e;
  }
  /**
   * Set whether to rotate the text with the view.
   *
   * @param {boolean} rotateWithView Rotate with map.
   * @api
   */
  setRotateWithView(e) {
    this.rotateWithView_ = e;
  }
  /**
   * Set the fill.
   *
   * @param {import("./Fill.js").default} fill Fill style.
   * @api
   */
  setFill(e) {
    this.fill_ = e;
  }
  /**
   * Set the rotation.
   *
   * @param {number|undefined} rotation Rotation.
   * @api
   */
  setRotation(e) {
    this.rotation_ = e;
  }
  /**
   * Set the scale.
   *
   * @param {number|import("../size.js").Size|undefined} scale Scale.
   * @api
   */
  setScale(e) {
    this.scale_ = e, this.scaleArray_ = An(e !== void 0 ? e : 1);
  }
  /**
   * Set the stroke.
   *
   * @param {import("./Stroke.js").default} stroke Stroke style.
   * @api
   */
  setStroke(e) {
    this.stroke_ = e;
  }
  /**
   * Set the text.
   *
   * @param {string|Array<string>|undefined} text Text.
   * @api
   */
  setText(e) {
    this.text_ = e;
  }
  /**
   * Set the text alignment.
   *
   * @param {CanvasTextAlign|undefined} textAlign Text align.
   * @api
   */
  setTextAlign(e) {
    this.textAlign_ = e;
  }
  /**
   * Set the justification.
   *
   * @param {TextJustify|undefined} justify Justification.
   * @api
   */
  setJustify(e) {
    this.justify_ = e;
  }
  /**
   * Set the text baseline.
   *
   * @param {CanvasTextBaseline|undefined} textBaseline Text baseline.
   * @api
   */
  setTextBaseline(e) {
    this.textBaseline_ = e;
  }
  /**
   * Set the background fill.
   *
   * @param {import("./Fill.js").default} fill Fill style.
   * @api
   */
  setBackgroundFill(e) {
    this.backgroundFill_ = e;
  }
  /**
   * Set the background stroke.
   *
   * @param {import("./Stroke.js").default} stroke Stroke style.
   * @api
   */
  setBackgroundStroke(e) {
    this.backgroundStroke_ = e;
  }
  /**
   * Set the padding (`[top, right, bottom, left]`).
   *
   * @param {Array<number>|null} padding Padding.
   * @api
   */
  setPadding(e) {
    this.padding_ = e;
  }
};
const ih = K9;
function y5(i) {
  return new ln({
    fill: Kd(i, ""),
    stroke: jd(i, ""),
    text: j9(i),
    image: z9(i)
  });
}
function Kd(i, e) {
  const t = i[e + "fill-color"];
  if (t)
    return new Wn({ color: t });
}
function jd(i, e) {
  const t = i[e + "stroke-width"], r = i[e + "stroke-color"];
  if (!(!t && !r))
    return new Zi({
      width: t,
      color: r,
      lineCap: i[e + "stroke-line-cap"],
      lineJoin: i[e + "stroke-line-join"],
      lineDash: i[e + "stroke-line-dash"],
      lineDashOffset: i[e + "stroke-line-dash-offset"],
      miterLimit: i[e + "stroke-miter-limit"]
    });
}
function j9(i) {
  const e = i["text-value"];
  return e ? new ih({
    text: e,
    font: i["text-font"],
    maxAngle: i["text-max-angle"],
    offsetX: i["text-offset-x"],
    offsetY: i["text-offset-y"],
    overflow: i["text-overflow"],
    placement: i["text-placement"],
    repeat: i["text-repeat"],
    scale: i["text-scale"],
    rotateWithView: i["text-rotate-with-view"],
    rotation: i["text-rotation"],
    textAlign: i["text-align"],
    justify: i["text-justify"],
    textBaseline: i["text-baseline"],
    padding: i["text-padding"],
    fill: Kd(i, "text-"),
    backgroundFill: Kd(i, "text-background-"),
    stroke: jd(i, "text-"),
    backgroundStroke: jd(i, "text-background-")
  }) : void 0;
}
function z9(i) {
  const e = i["icon-src"], t = i["icon-img"];
  if (e || t)
    return new Mu({
      src: e,
      img: t,
      imgSize: i["icon-img-size"],
      anchor: i["icon-anchor"],
      anchorOrigin: i["icon-anchor-origin"],
      anchorXUnits: i["icon-anchor-x-units"],
      anchorYUnits: i["icon-anchor-y-units"],
      color: i["icon-color"],
      crossOrigin: i["icon-cross-origin"],
      offset: i["icon-offset"],
      displacement: i["icon-displacement"],
      opacity: i["icon-opacity"],
      scale: i["icon-scale"],
      rotation: i["icon-rotation"],
      rotateWithView: i["icon-rotate-with-view"],
      size: i["icon-size"],
      declutterMode: i["icon-declutter-mode"]
    });
  const r = i["shape-points"];
  if (r) {
    const s = "shape-";
    return new ud({
      points: r,
      fill: Kd(i, s),
      stroke: jd(i, s),
      radius: i["shape-radius"],
      radius1: i["shape-radius1"],
      radius2: i["shape-radius2"],
      angle: i["shape-angle"],
      displacement: i["shape-displacement"],
      rotation: i["shape-rotation"],
      rotateWithView: i["shape-rotate-with-view"],
      scale: i["shape-scale"],
      declutterMode: i["shape-declutter-mode"]
    });
  }
  const n = i["circle-radius"];
  if (n) {
    const s = "circle-";
    return new Ru({
      radius: n,
      fill: Kd(i, s),
      stroke: jd(i, s),
      displacement: i["circle-displacement"],
      scale: i["circle-scale"],
      rotation: i["circle-rotation"],
      rotateWithView: i["circle-rotate-with-view"],
      declutterMode: i["circle-declutter-mode"]
    });
  }
}
const _5 = {
  RENDER_ORDER: "renderOrder"
};
class X9 extends bh {
  /**
   * @param {Options<VectorSourceType>} [options] Options.
   */
  constructor(e) {
    e = e || {};
    const t = Object.assign({}, e);
    delete t.style, delete t.renderBuffer, delete t.updateWhileAnimating, delete t.updateWhileInteracting, super(t), this.declutter_ = e.declutter !== void 0 ? e.declutter : !1, this.renderBuffer_ = e.renderBuffer !== void 0 ? e.renderBuffer : 100, this.style_ = null, this.styleFunction_ = void 0, this.setStyle(e.style), this.updateWhileAnimating_ = e.updateWhileAnimating !== void 0 ? e.updateWhileAnimating : !1, this.updateWhileInteracting_ = e.updateWhileInteracting !== void 0 ? e.updateWhileInteracting : !1;
  }
  /**
   * @return {boolean} Declutter.
   */
  getDeclutter() {
    return this.declutter_;
  }
  /**
   * Get the topmost feature that intersects the given pixel on the viewport. Returns a promise
   * that resolves with an array of features. The array will either contain the topmost feature
   * when a hit was detected, or it will be empty.
   *
   * The hit detection algorithm used for this method is optimized for performance, but is less
   * accurate than the one used in [map.getFeaturesAtPixel()]{@link import("../Map.js").default#getFeaturesAtPixel}.
   * Text is not considered, and icons are only represented by their bounding box instead of the exact
   * image.
   *
   * @param {import("../pixel.js").Pixel} pixel Pixel.
   * @return {Promise<Array<import("../Feature").FeatureLike>>} Promise that resolves with an array of features.
   * @api
   */
  getFeatures(e) {
    return super.getFeatures(e);
  }
  /**
   * @return {number|undefined} Render buffer.
   */
  getRenderBuffer() {
    return this.renderBuffer_;
  }
  /**
   * @return {function(import("../Feature.js").default, import("../Feature.js").default): number|null|undefined} Render
   *     order.
   */
  getRenderOrder() {
    return (
      /** @type {import("../render.js").OrderFunction|null|undefined} */
      this.get(_5.RENDER_ORDER)
    );
  }
  /**
   * Get the style for features.  This returns whatever was passed to the `style`
   * option at construction or to the `setStyle` method.
   * @return {import("../style/Style.js").StyleLike|null|undefined} Layer style.
   * @api
   */
  getStyle() {
    return this.style_;
  }
  /**
   * Get the style function.
   * @return {import("../style/Style.js").StyleFunction|undefined} Layer style function.
   * @api
   */
  getStyleFunction() {
    return this.styleFunction_;
  }
  /**
   * @return {boolean} Whether the rendered layer should be updated while
   *     animating.
   */
  getUpdateWhileAnimating() {
    return this.updateWhileAnimating_;
  }
  /**
   * @return {boolean} Whether the rendered layer should be updated while
   *     interacting.
   */
  getUpdateWhileInteracting() {
    return this.updateWhileInteracting_;
  }
  /**
   * Render declutter items for this layer
   * @param {import("../Map.js").FrameState} frameState Frame state.
   */
  renderDeclutter(e) {
    e.declutterTree || (e.declutterTree = new A4(9)), this.getRenderer().renderDeclutter(e);
  }
  /**
   * @param {import("../render.js").OrderFunction|null|undefined} renderOrder
   *     Render order.
   */
  setRenderOrder(e) {
    this.set(_5.RENDER_ORDER, e);
  }
  /**
   * Set the style for features.  This can be a single style object, an array
   * of styles, or a function that takes a feature and resolution and returns
   * an array of styles. If set to `null`, the layer has no style (a `null` style),
   * so only features that have their own styles will be rendered in the layer. Call
   * `setStyle()` without arguments to reset to the default style. See
   * [the ol/style/Style module]{@link module:ol/style/Style~Style} for information on the default style.
   *
   * If your layer has a static style, you can use "flat" style object literals instead of
   * using the `Style` and symbolizer constructors (`Fill`, `Stroke`, etc.).  See the documentation
   * for the [flat style types]{@link module:ol/style/flat~FlatStyle} to see what properties are supported.
   *
   * @param {import("../style/Style.js").StyleLike|import("../style/flat.js").FlatStyleLike|null} [style] Layer style.
   * @api
   */
  setStyle(e) {
    let t;
    if (e === void 0)
      t = k9;
    else if (e === null)
      t = null;
    else if (typeof e == "function")
      t = e;
    else if (e instanceof ln)
      t = e;
    else if (Array.isArray(e)) {
      const r = e.length, n = new Array(r);
      for (let s = 0; s < r; ++s) {
        const a = e[s];
        a instanceof ln ? n[s] = a : n[s] = y5(a);
      }
      t = n;
    } else
      t = y5(e);
    this.style_ = t, this.styleFunction_ = e === null ? void 0 : D9(this.style_), this.changed();
  }
}
const zv = X9, Eg = {
  BEGIN_GEOMETRY: 0,
  BEGIN_PATH: 1,
  CIRCLE: 2,
  CLOSE_PATH: 3,
  CUSTOM: 4,
  DRAW_CHARS: 5,
  DRAW_IMAGE: 6,
  END_GEOMETRY: 7,
  FILL: 8,
  MOVE_TO_LINE_TO: 9,
  SET_FILL_STYLE: 10,
  SET_STROKE_STYLE: 11,
  STROKE: 12
}, Pp = [Eg.FILL], XA = [Eg.STROKE], Xl = [Eg.BEGIN_PATH], w5 = [Eg.CLOSE_PATH], Ft = Eg;
class W9 {
  /**
   * Render a geometry with a custom renderer.
   *
   * @param {import("../geom/SimpleGeometry.js").default} geometry Geometry.
   * @param {import("../Feature.js").FeatureLike} feature Feature.
   * @param {Function} renderer Renderer.
   * @param {Function} hitDetectionRenderer Renderer.
   */
  drawCustom(e, t, r, n) {
  }
  /**
   * Render a geometry.
   *
   * @param {import("../geom/Geometry.js").default} geometry The geometry to render.
   */
  drawGeometry(e) {
  }
  /**
   * Set the rendering style.
   *
   * @param {import("../style/Style.js").default} style The rendering style.
   */
  setStyle(e) {
  }
  /**
   * @param {import("../geom/Circle.js").default} circleGeometry Circle geometry.
   * @param {import("../Feature.js").default} feature Feature.
   */
  drawCircle(e, t) {
  }
  /**
   * @param {import("../Feature.js").default} feature Feature.
   * @param {import("../style/Style.js").default} style Style.
   */
  drawFeature(e, t) {
  }
  /**
   * @param {import("../geom/GeometryCollection.js").default} geometryCollectionGeometry Geometry collection.
   * @param {import("../Feature.js").default} feature Feature.
   */
  drawGeometryCollection(e, t) {
  }
  /**
   * @param {import("../geom/LineString.js").default|import("./Feature.js").default} lineStringGeometry Line string geometry.
   * @param {import("../Feature.js").FeatureLike} feature Feature.
   */
  drawLineString(e, t) {
  }
  /**
   * @param {import("../geom/MultiLineString.js").default|import("./Feature.js").default} multiLineStringGeometry MultiLineString geometry.
   * @param {import("../Feature.js").FeatureLike} feature Feature.
   */
  drawMultiLineString(e, t) {
  }
  /**
   * @param {import("../geom/MultiPoint.js").default|import("./Feature.js").default} multiPointGeometry MultiPoint geometry.
   * @param {import("../Feature.js").FeatureLike} feature Feature.
   */
  drawMultiPoint(e, t) {
  }
  /**
   * @param {import("../geom/MultiPolygon.js").default} multiPolygonGeometry MultiPolygon geometry.
   * @param {import("../Feature.js").FeatureLike} feature Feature.
   */
  drawMultiPolygon(e, t) {
  }
  /**
   * @param {import("../geom/Point.js").default|import("./Feature.js").default} pointGeometry Point geometry.
   * @param {import("../Feature.js").FeatureLike} feature Feature.
   */
  drawPoint(e, t) {
  }
  /**
   * @param {import("../geom/Polygon.js").default|import("./Feature.js").default} polygonGeometry Polygon geometry.
   * @param {import("../Feature.js").FeatureLike} feature Feature.
   */
  drawPolygon(e, t) {
  }
  /**
   * @param {import("../geom/SimpleGeometry.js").default|import("./Feature.js").default} geometry Geometry.
   * @param {import("../Feature.js").FeatureLike} feature Feature.
   */
  drawText(e, t) {
  }
  /**
   * @param {import("../style/Fill.js").default} fillStyle Fill style.
   * @param {import("../style/Stroke.js").default} strokeStyle Stroke style.
   */
  setFillStrokeStyle(e, t) {
  }
  /**
   * @param {import("../style/Image.js").default} imageStyle Image style.
   * @param {import("../render/canvas.js").DeclutterImageWithText} [declutterImageWithText] Shared data for combined decluttering with a text style.
   */
  setImageStyle(e, t) {
  }
  /**
   * @param {import("../style/Text.js").default} textStyle Text style.
   * @param {import("../render/canvas.js").DeclutterImageWithText} [declutterImageWithText] Shared data for combined decluttering with an image style.
   */
  setTextStyle(e, t) {
  }
}
const g4 = W9;
class Y9 extends g4 {
  /**
   * @param {number} tolerance Tolerance.
   * @param {import("../../extent.js").Extent} maxExtent Maximum extent.
   * @param {number} resolution Resolution.
   * @param {number} pixelRatio Pixel ratio.
   */
  constructor(e, t, r, n) {
    super(), this.tolerance = e, this.maxExtent = t, this.pixelRatio = n, this.maxLineWidth = 0, this.resolution = r, this.beginGeometryInstruction1_ = null, this.beginGeometryInstruction2_ = null, this.bufferedMaxExtent_ = null, this.instructions = [], this.coordinates = [], this.tmpCoordinate_ = [], this.hitDetectionInstructions = [], this.state = /** @type {import("../canvas.js").FillStrokeState} */
    {};
  }
  /**
   * @protected
   * @param {Array<number>} dashArray Dash array.
   * @return {Array<number>} Dash array with pixel ratio applied
   */
  applyPixelRatio(e) {
    const t = this.pixelRatio;
    return t == 1 ? e : e.map(function(r) {
      return r * t;
    });
  }
  /**
   * @param {Array<number>} flatCoordinates Flat coordinates.
   * @param {number} stride Stride.
   * @protected
   * @return {number} My end
   */
  appendFlatPointCoordinates(e, t) {
    const r = this.getBufferedMaxExtent(), n = this.tmpCoordinate_, s = this.coordinates;
    let a = s.length;
    for (let o = 0, A = e.length; o < A; o += t)
      n[0] = e[o], n[1] = e[o + 1], Wo(r, n) && (s[a++] = n[0], s[a++] = n[1]);
    return a;
  }
  /**
   * @param {Array<number>} flatCoordinates Flat coordinates.
   * @param {number} offset Offset.
   * @param {number} end End.
   * @param {number} stride Stride.
   * @param {boolean} closed Last input coordinate equals first.
   * @param {boolean} skipFirst Skip first coordinate.
   * @protected
   * @return {number} My end.
   */
  appendFlatLineCoordinates(e, t, r, n, s, a) {
    const o = this.coordinates;
    let A = o.length;
    const l = this.getBufferedMaxExtent();
    a && (t += n);
    let h = e[t], c = e[t + 1];
    const u = this.tmpCoordinate_;
    let f = !0, g, p, y;
    for (g = t + n; g < r; g += n)
      u[0] = e[g], u[1] = e[g + 1], y = cm(l, u), y !== p ? (f && (o[A++] = h, o[A++] = c, f = !1), o[A++] = u[0], o[A++] = u[1]) : y === vn.INTERSECTING ? (o[A++] = u[0], o[A++] = u[1], f = !1) : f = !0, h = u[0], c = u[1], p = y;
    return (s && f || g === t + n) && (o[A++] = h, o[A++] = c), A;
  }
  /**
   * @param {Array<number>} flatCoordinates Flat coordinates.
   * @param {number} offset Offset.
   * @param {Array<number>} ends Ends.
   * @param {number} stride Stride.
   * @param {Array<number>} builderEnds Builder ends.
   * @return {number} Offset.
   */
  drawCustomCoordinates_(e, t, r, n, s) {
    for (let a = 0, o = r.length; a < o; ++a) {
      const A = r[a], l = this.appendFlatLineCoordinates(
        e,
        t,
        A,
        n,
        !1,
        !1
      );
      s.push(l), t = A;
    }
    return t;
  }
  /**
   * @param {import("../../geom/SimpleGeometry.js").default} geometry Geometry.
   * @param {import("../../Feature.js").FeatureLike} feature Feature.
   * @param {Function} renderer Renderer.
   * @param {Function} hitDetectionRenderer Renderer.
   */
  drawCustom(e, t, r, n) {
    this.beginGeometry(e, t);
    const s = e.getType(), a = e.getStride(), o = this.coordinates.length;
    let A, l, h, c, u;
    switch (s) {
      case "MultiPolygon":
        A = /** @type {import("../../geom/MultiPolygon.js").default} */
        e.getOrientedFlatCoordinates(), c = [];
        const f = (
          /** @type {import("../../geom/MultiPolygon.js").default} */
          e.getEndss()
        );
        u = 0;
        for (let g = 0, p = f.length; g < p; ++g) {
          const y = [];
          u = this.drawCustomCoordinates_(
            A,
            u,
            f[g],
            a,
            y
          ), c.push(y);
        }
        this.instructions.push([
          Ft.CUSTOM,
          o,
          c,
          e,
          r,
          Qw
        ]), this.hitDetectionInstructions.push([
          Ft.CUSTOM,
          o,
          c,
          e,
          n || r,
          Qw
        ]);
        break;
      case "Polygon":
      case "MultiLineString":
        h = [], A = s == "Polygon" ? (
          /** @type {import("../../geom/Polygon.js").default} */
          e.getOrientedFlatCoordinates()
        ) : e.getFlatCoordinates(), u = this.drawCustomCoordinates_(
          A,
          0,
          /** @type {import("../../geom/Polygon.js").default|import("../../geom/MultiLineString.js").default} */
          e.getEnds(),
          a,
          h
        ), this.instructions.push([
          Ft.CUSTOM,
          o,
          h,
          e,
          r,
          Ld
        ]), this.hitDetectionInstructions.push([
          Ft.CUSTOM,
          o,
          h,
          e,
          n || r,
          Ld
        ]);
        break;
      case "LineString":
      case "Circle":
        A = e.getFlatCoordinates(), l = this.appendFlatLineCoordinates(
          A,
          0,
          A.length,
          a,
          !1,
          !1
        ), this.instructions.push([
          Ft.CUSTOM,
          o,
          l,
          e,
          r,
          Qo
        ]), this.hitDetectionInstructions.push([
          Ft.CUSTOM,
          o,
          l,
          e,
          n || r,
          Qo
        ]);
        break;
      case "MultiPoint":
        A = e.getFlatCoordinates(), l = this.appendFlatPointCoordinates(A, a), l > o && (this.instructions.push([
          Ft.CUSTOM,
          o,
          l,
          e,
          r,
          Qo
        ]), this.hitDetectionInstructions.push([
          Ft.CUSTOM,
          o,
          l,
          e,
          n || r,
          Qo
        ]));
        break;
      case "Point":
        A = e.getFlatCoordinates(), this.coordinates.push(A[0], A[1]), l = this.coordinates.length, this.instructions.push([
          Ft.CUSTOM,
          o,
          l,
          e,
          r
        ]), this.hitDetectionInstructions.push([
          Ft.CUSTOM,
          o,
          l,
          e,
          n || r
        ]);
        break;
    }
    this.endGeometry(t);
  }
  /**
   * @protected
   * @param {import("../../geom/Geometry").default|import("../Feature.js").default} geometry The geometry.
   * @param {import("../../Feature.js").FeatureLike} feature Feature.
   */
  beginGeometry(e, t) {
    this.beginGeometryInstruction1_ = [
      Ft.BEGIN_GEOMETRY,
      t,
      0,
      e
    ], this.instructions.push(this.beginGeometryInstruction1_), this.beginGeometryInstruction2_ = [
      Ft.BEGIN_GEOMETRY,
      t,
      0,
      e
    ], this.hitDetectionInstructions.push(this.beginGeometryInstruction2_);
  }
  /**
   * @return {import("../canvas.js").SerializableInstructions} the serializable instructions.
   */
  finish() {
    return {
      instructions: this.instructions,
      hitDetectionInstructions: this.hitDetectionInstructions,
      coordinates: this.coordinates
    };
  }
  /**
   * Reverse the hit detection instructions.
   */
  reverseHitDetectionInstructions() {
    const e = this.hitDetectionInstructions;
    e.reverse();
    let t;
    const r = e.length;
    let n, s, a = -1;
    for (t = 0; t < r; ++t)
      n = e[t], s = /** @type {import("./Instruction.js").default} */
      n[0], s == Ft.END_GEOMETRY ? a = t : s == Ft.BEGIN_GEOMETRY && (n[2] = t, CQ(this.hitDetectionInstructions, a, t), a = -1);
  }
  /**
   * @param {import("../../style/Fill.js").default} fillStyle Fill style.
   * @param {import("../../style/Stroke.js").default} strokeStyle Stroke style.
   */
  setFillStrokeStyle(e, t) {
    const r = this.state;
    if (e) {
      const n = e.getColor();
      r.fillStyle = Ga(
        n || Go
      );
    } else
      r.fillStyle = void 0;
    if (t) {
      const n = t.getColor();
      r.strokeStyle = Ga(
        n || Nd
      );
      const s = t.getLineCap();
      r.lineCap = s !== void 0 ? s : xm;
      const a = t.getLineDash();
      r.lineDash = a ? a.slice() : Id;
      const o = t.getLineDashOffset();
      r.lineDashOffset = o || Rd;
      const A = t.getLineJoin();
      r.lineJoin = A !== void 0 ? A : mu;
      const l = t.getWidth();
      r.lineWidth = l !== void 0 ? l : Od;
      const h = t.getMiterLimit();
      r.miterLimit = h !== void 0 ? h : Md, r.lineWidth > this.maxLineWidth && (this.maxLineWidth = r.lineWidth, this.bufferedMaxExtent_ = null);
    } else
      r.strokeStyle = void 0, r.lineCap = void 0, r.lineDash = null, r.lineDashOffset = void 0, r.lineJoin = void 0, r.lineWidth = void 0, r.miterLimit = void 0;
  }
  /**
   * @param {import("../canvas.js").FillStrokeState} state State.
   * @return {Array<*>} Fill instruction.
   */
  createFill(e) {
    const t = e.fillStyle, r = [Ft.SET_FILL_STYLE, t];
    return typeof t != "string" && r.push(!0), r;
  }
  /**
   * @param {import("../canvas.js").FillStrokeState} state State.
   */
  applyStroke(e) {
    this.instructions.push(this.createStroke(e));
  }
  /**
   * @param {import("../canvas.js").FillStrokeState} state State.
   * @return {Array<*>} Stroke instruction.
   */
  createStroke(e) {
    return [
      Ft.SET_STROKE_STYLE,
      e.strokeStyle,
      e.lineWidth * this.pixelRatio,
      e.lineCap,
      e.lineJoin,
      e.miterLimit,
      this.applyPixelRatio(e.lineDash),
      e.lineDashOffset * this.pixelRatio
    ];
  }
  /**
   * @param {import("../canvas.js").FillStrokeState} state State.
   * @param {function(this:CanvasBuilder, import("../canvas.js").FillStrokeState):Array<*>} createFill Create fill.
   */
  updateFillStyle(e, t) {
    const r = e.fillStyle;
    (typeof r != "string" || e.currentFillStyle != r) && (r !== void 0 && this.instructions.push(t.call(this, e)), e.currentFillStyle = r);
  }
  /**
   * @param {import("../canvas.js").FillStrokeState} state State.
   * @param {function(this:CanvasBuilder, import("../canvas.js").FillStrokeState): void} applyStroke Apply stroke.
   */
  updateStrokeStyle(e, t) {
    const r = e.strokeStyle, n = e.lineCap, s = e.lineDash, a = e.lineDashOffset, o = e.lineJoin, A = e.lineWidth, l = e.miterLimit;
    (e.currentStrokeStyle != r || e.currentLineCap != n || s != e.currentLineDash && !Za(e.currentLineDash, s) || e.currentLineDashOffset != a || e.currentLineJoin != o || e.currentLineWidth != A || e.currentMiterLimit != l) && (r !== void 0 && t.call(this, e), e.currentStrokeStyle = r, e.currentLineCap = n, e.currentLineDash = s, e.currentLineDashOffset = a, e.currentLineJoin = o, e.currentLineWidth = A, e.currentMiterLimit = l);
  }
  /**
   * @param {import("../../Feature.js").FeatureLike} feature Feature.
   */
  endGeometry(e) {
    this.beginGeometryInstruction1_[2] = this.instructions.length, this.beginGeometryInstruction1_ = null, this.beginGeometryInstruction2_[2] = this.hitDetectionInstructions.length, this.beginGeometryInstruction2_ = null;
    const t = [Ft.END_GEOMETRY, e];
    this.instructions.push(t), this.hitDetectionInstructions.push(t);
  }
  /**
   * Get the buffered rendering extent.  Rendering will be clipped to the extent
   * provided to the constructor.  To account for symbolizers that may intersect
   * this extent, we calculate a buffered extent (e.g. based on stroke width).
   * @return {import("../../extent.js").Extent} The buffered rendering extent.
   * @protected
   */
  getBufferedMaxExtent() {
    if (!this.bufferedMaxExtent_ && (this.bufferedMaxExtent_ = sE(this.maxExtent), this.maxLineWidth > 0)) {
      const e = this.resolution * (this.maxLineWidth + 1) / 2;
      zn(this.bufferedMaxExtent_, e, this.bufferedMaxExtent_);
    }
    return this.bufferedMaxExtent_;
  }
}
const Bg = Y9;
class q9 extends Bg {
  /**
   * @param {number} tolerance Tolerance.
   * @param {import("../../extent.js").Extent} maxExtent Maximum extent.
   * @param {number} resolution Resolution.
   * @param {number} pixelRatio Pixel ratio.
   */
  constructor(e, t, r, n) {
    super(e, t, r, n), this.hitDetectionImage_ = null, this.image_ = null, this.imagePixelRatio_ = void 0, this.anchorX_ = void 0, this.anchorY_ = void 0, this.height_ = void 0, this.opacity_ = void 0, this.originX_ = void 0, this.originY_ = void 0, this.rotateWithView_ = void 0, this.rotation_ = void 0, this.scale_ = void 0, this.width_ = void 0, this.declutterMode_ = void 0, this.declutterImageWithText_ = void 0;
  }
  /**
   * @param {import("../../geom/Point.js").default|import("../Feature.js").default} pointGeometry Point geometry.
   * @param {import("../../Feature.js").FeatureLike} feature Feature.
   */
  drawPoint(e, t) {
    if (!this.image_)
      return;
    this.beginGeometry(e, t);
    const r = e.getFlatCoordinates(), n = e.getStride(), s = this.coordinates.length, a = this.appendFlatPointCoordinates(r, n);
    this.instructions.push([
      Ft.DRAW_IMAGE,
      s,
      a,
      this.image_,
      // Remaining arguments to DRAW_IMAGE are in alphabetical order
      this.anchorX_ * this.imagePixelRatio_,
      this.anchorY_ * this.imagePixelRatio_,
      Math.ceil(this.height_ * this.imagePixelRatio_),
      this.opacity_,
      this.originX_ * this.imagePixelRatio_,
      this.originY_ * this.imagePixelRatio_,
      this.rotateWithView_,
      this.rotation_,
      [
        this.scale_[0] * this.pixelRatio / this.imagePixelRatio_,
        this.scale_[1] * this.pixelRatio / this.imagePixelRatio_
      ],
      Math.ceil(this.width_ * this.imagePixelRatio_),
      this.declutterMode_,
      this.declutterImageWithText_
    ]), this.hitDetectionInstructions.push([
      Ft.DRAW_IMAGE,
      s,
      a,
      this.hitDetectionImage_,
      // Remaining arguments to DRAW_IMAGE are in alphabetical order
      this.anchorX_,
      this.anchorY_,
      this.height_,
      this.opacity_,
      this.originX_,
      this.originY_,
      this.rotateWithView_,
      this.rotation_,
      this.scale_,
      this.width_,
      this.declutterMode_,
      this.declutterImageWithText_
    ]), this.endGeometry(t);
  }
  /**
   * @param {import("../../geom/MultiPoint.js").default|import("../Feature.js").default} multiPointGeometry MultiPoint geometry.
   * @param {import("../../Feature.js").FeatureLike} feature Feature.
   */
  drawMultiPoint(e, t) {
    if (!this.image_)
      return;
    this.beginGeometry(e, t);
    const r = e.getFlatCoordinates(), n = e.getStride(), s = this.coordinates.length, a = this.appendFlatPointCoordinates(r, n);
    this.instructions.push([
      Ft.DRAW_IMAGE,
      s,
      a,
      this.image_,
      // Remaining arguments to DRAW_IMAGE are in alphabetical order
      this.anchorX_ * this.imagePixelRatio_,
      this.anchorY_ * this.imagePixelRatio_,
      Math.ceil(this.height_ * this.imagePixelRatio_),
      this.opacity_,
      this.originX_ * this.imagePixelRatio_,
      this.originY_ * this.imagePixelRatio_,
      this.rotateWithView_,
      this.rotation_,
      [
        this.scale_[0] * this.pixelRatio / this.imagePixelRatio_,
        this.scale_[1] * this.pixelRatio / this.imagePixelRatio_
      ],
      Math.ceil(this.width_ * this.imagePixelRatio_),
      this.declutterMode_,
      this.declutterImageWithText_
    ]), this.hitDetectionInstructions.push([
      Ft.DRAW_IMAGE,
      s,
      a,
      this.hitDetectionImage_,
      // Remaining arguments to DRAW_IMAGE are in alphabetical order
      this.anchorX_,
      this.anchorY_,
      this.height_,
      this.opacity_,
      this.originX_,
      this.originY_,
      this.rotateWithView_,
      this.rotation_,
      this.scale_,
      this.width_,
      this.declutterMode_,
      this.declutterImageWithText_
    ]), this.endGeometry(t);
  }
  /**
   * @return {import("../canvas.js").SerializableInstructions} the serializable instructions.
   */
  finish() {
    return this.reverseHitDetectionInstructions(), this.anchorX_ = void 0, this.anchorY_ = void 0, this.hitDetectionImage_ = null, this.image_ = null, this.imagePixelRatio_ = void 0, this.height_ = void 0, this.scale_ = void 0, this.opacity_ = void 0, this.originX_ = void 0, this.originY_ = void 0, this.rotateWithView_ = void 0, this.rotation_ = void 0, this.width_ = void 0, super.finish();
  }
  /**
   * @param {import("../../style/Image.js").default} imageStyle Image style.
   * @param {Object} [sharedData] Shared data.
   */
  setImageStyle(e, t) {
    const r = e.getAnchor(), n = e.getSize(), s = e.getOrigin();
    this.imagePixelRatio_ = e.getPixelRatio(this.pixelRatio), this.anchorX_ = r[0], this.anchorY_ = r[1], this.hitDetectionImage_ = e.getHitDetectionImage(), this.image_ = e.getImage(this.pixelRatio), this.height_ = n[1], this.opacity_ = e.getOpacity(), this.originX_ = s[0], this.originY_ = s[1], this.rotateWithView_ = e.getRotateWithView(), this.rotation_ = e.getRotation(), this.scale_ = e.getScaleArray(), this.width_ = n[0], this.declutterMode_ = e.getDeclutterMode(), this.declutterImageWithText_ = t;
  }
}
const Z9 = q9;
class J9 extends Bg {
  /**
   * @param {number} tolerance Tolerance.
   * @param {import("../../extent.js").Extent} maxExtent Maximum extent.
   * @param {number} resolution Resolution.
   * @param {number} pixelRatio Pixel ratio.
   */
  constructor(e, t, r, n) {
    super(e, t, r, n);
  }
  /**
   * @param {Array<number>} flatCoordinates Flat coordinates.
   * @param {number} offset Offset.
   * @param {number} end End.
   * @param {number} stride Stride.
   * @private
   * @return {number} end.
   */
  drawFlatCoordinates_(e, t, r, n) {
    const s = this.coordinates.length, a = this.appendFlatLineCoordinates(
      e,
      t,
      r,
      n,
      !1,
      !1
    ), o = [
      Ft.MOVE_TO_LINE_TO,
      s,
      a
    ];
    return this.instructions.push(o), this.hitDetectionInstructions.push(o), r;
  }
  /**
   * @param {import("../../geom/LineString.js").default|import("../Feature.js").default} lineStringGeometry Line string geometry.
   * @param {import("../../Feature.js").FeatureLike} feature Feature.
   */
  drawLineString(e, t) {
    const r = this.state, n = r.strokeStyle, s = r.lineWidth;
    if (n === void 0 || s === void 0)
      return;
    this.updateStrokeStyle(r, this.applyStroke), this.beginGeometry(e, t), this.hitDetectionInstructions.push(
      [
        Ft.SET_STROKE_STYLE,
        r.strokeStyle,
        r.lineWidth,
        r.lineCap,
        r.lineJoin,
        r.miterLimit,
        Id,
        Rd
      ],
      Xl
    );
    const a = e.getFlatCoordinates(), o = e.getStride();
    this.drawFlatCoordinates_(
      a,
      0,
      a.length,
      o
    ), this.hitDetectionInstructions.push(XA), this.endGeometry(t);
  }
  /**
   * @param {import("../../geom/MultiLineString.js").default|import("../Feature.js").default} multiLineStringGeometry MultiLineString geometry.
   * @param {import("../../Feature.js").FeatureLike} feature Feature.
   */
  drawMultiLineString(e, t) {
    const r = this.state, n = r.strokeStyle, s = r.lineWidth;
    if (n === void 0 || s === void 0)
      return;
    this.updateStrokeStyle(r, this.applyStroke), this.beginGeometry(e, t), this.hitDetectionInstructions.push(
      [
        Ft.SET_STROKE_STYLE,
        r.strokeStyle,
        r.lineWidth,
        r.lineCap,
        r.lineJoin,
        r.miterLimit,
        r.lineDash,
        r.lineDashOffset
      ],
      Xl
    );
    const a = e.getEnds(), o = e.getFlatCoordinates(), A = e.getStride();
    let l = 0;
    for (let h = 0, c = a.length; h < c; ++h)
      l = this.drawFlatCoordinates_(
        o,
        l,
        /** @type {number} */
        a[h],
        A
      );
    this.hitDetectionInstructions.push(XA), this.endGeometry(t);
  }
  /**
   * @return {import("../canvas.js").SerializableInstructions} the serializable instructions.
   */
  finish() {
    const e = this.state;
    return e.lastStroke != null && e.lastStroke != this.coordinates.length && this.instructions.push(XA), this.reverseHitDetectionInstructions(), this.state = null, super.finish();
  }
  /**
   * @param {import("../canvas.js").FillStrokeState} state State.
   */
  applyStroke(e) {
    e.lastStroke != null && e.lastStroke != this.coordinates.length && (this.instructions.push(XA), e.lastStroke = this.coordinates.length), e.lastStroke = 0, super.applyStroke(e), this.instructions.push(Xl);
  }
}
const eV = J9;
class tV extends Bg {
  /**
   * @param {number} tolerance Tolerance.
   * @param {import("../../extent.js").Extent} maxExtent Maximum extent.
   * @param {number} resolution Resolution.
   * @param {number} pixelRatio Pixel ratio.
   */
  constructor(e, t, r, n) {
    super(e, t, r, n);
  }
  /**
   * @param {Array<number>} flatCoordinates Flat coordinates.
   * @param {number} offset Offset.
   * @param {Array<number>} ends Ends.
   * @param {number} stride Stride.
   * @private
   * @return {number} End.
   */
  drawFlatCoordinatess_(e, t, r, n) {
    const s = this.state, a = s.fillStyle !== void 0, o = s.strokeStyle !== void 0, A = r.length;
    this.instructions.push(Xl), this.hitDetectionInstructions.push(Xl);
    for (let l = 0; l < A; ++l) {
      const h = r[l], c = this.coordinates.length, u = this.appendFlatLineCoordinates(
        e,
        t,
        h,
        n,
        !0,
        !o
      ), f = [
        Ft.MOVE_TO_LINE_TO,
        c,
        u
      ];
      this.instructions.push(f), this.hitDetectionInstructions.push(f), o && (this.instructions.push(w5), this.hitDetectionInstructions.push(w5)), t = h;
    }
    return a && (this.instructions.push(Pp), this.hitDetectionInstructions.push(Pp)), o && (this.instructions.push(XA), this.hitDetectionInstructions.push(XA)), t;
  }
  /**
   * @param {import("../../geom/Circle.js").default} circleGeometry Circle geometry.
   * @param {import("../../Feature.js").default} feature Feature.
   */
  drawCircle(e, t) {
    const r = this.state, n = r.fillStyle, s = r.strokeStyle;
    if (n === void 0 && s === void 0)
      return;
    this.setFillStrokeStyles_(), this.beginGeometry(e, t), r.fillStyle !== void 0 && this.hitDetectionInstructions.push([
      Ft.SET_FILL_STYLE,
      Go
    ]), r.strokeStyle !== void 0 && this.hitDetectionInstructions.push([
      Ft.SET_STROKE_STYLE,
      r.strokeStyle,
      r.lineWidth,
      r.lineCap,
      r.lineJoin,
      r.miterLimit,
      r.lineDash,
      r.lineDashOffset
    ]);
    const a = e.getFlatCoordinates(), o = e.getStride(), A = this.coordinates.length;
    this.appendFlatLineCoordinates(
      a,
      0,
      a.length,
      o,
      !1,
      !1
    );
    const l = [Ft.CIRCLE, A];
    this.instructions.push(Xl, l), this.hitDetectionInstructions.push(Xl, l), r.fillStyle !== void 0 && (this.instructions.push(Pp), this.hitDetectionInstructions.push(Pp)), r.strokeStyle !== void 0 && (this.instructions.push(XA), this.hitDetectionInstructions.push(XA)), this.endGeometry(t);
  }
  /**
   * @param {import("../../geom/Polygon.js").default|import("../Feature.js").default} polygonGeometry Polygon geometry.
   * @param {import("../../Feature.js").FeatureLike} feature Feature.
   */
  drawPolygon(e, t) {
    const r = this.state, n = r.fillStyle, s = r.strokeStyle;
    if (n === void 0 && s === void 0)
      return;
    this.setFillStrokeStyles_(), this.beginGeometry(e, t), r.fillStyle !== void 0 && this.hitDetectionInstructions.push([
      Ft.SET_FILL_STYLE,
      Go
    ]), r.strokeStyle !== void 0 && this.hitDetectionInstructions.push([
      Ft.SET_STROKE_STYLE,
      r.strokeStyle,
      r.lineWidth,
      r.lineCap,
      r.lineJoin,
      r.miterLimit,
      r.lineDash,
      r.lineDashOffset
    ]);
    const a = e.getEnds(), o = e.getOrientedFlatCoordinates(), A = e.getStride();
    this.drawFlatCoordinatess_(
      o,
      0,
      /** @type {Array<number>} */
      a,
      A
    ), this.endGeometry(t);
  }
  /**
   * @param {import("../../geom/MultiPolygon.js").default} multiPolygonGeometry MultiPolygon geometry.
   * @param {import("../../Feature.js").FeatureLike} feature Feature.
   */
  drawMultiPolygon(e, t) {
    const r = this.state, n = r.fillStyle, s = r.strokeStyle;
    if (n === void 0 && s === void 0)
      return;
    this.setFillStrokeStyles_(), this.beginGeometry(e, t), r.fillStyle !== void 0 && this.hitDetectionInstructions.push([
      Ft.SET_FILL_STYLE,
      Go
    ]), r.strokeStyle !== void 0 && this.hitDetectionInstructions.push([
      Ft.SET_STROKE_STYLE,
      r.strokeStyle,
      r.lineWidth,
      r.lineCap,
      r.lineJoin,
      r.miterLimit,
      r.lineDash,
      r.lineDashOffset
    ]);
    const a = e.getEndss(), o = e.getOrientedFlatCoordinates(), A = e.getStride();
    let l = 0;
    for (let h = 0, c = a.length; h < c; ++h)
      l = this.drawFlatCoordinatess_(
        o,
        l,
        a[h],
        A
      );
    this.endGeometry(t);
  }
  /**
   * @return {import("../canvas.js").SerializableInstructions} the serializable instructions.
   */
  finish() {
    this.reverseHitDetectionInstructions(), this.state = null;
    const e = this.tolerance;
    if (e !== 0) {
      const t = this.coordinates;
      for (let r = 0, n = t.length; r < n; ++r)
        t[r] = kl(t[r], e);
    }
    return super.finish();
  }
  /**
   * @private
   */
  setFillStrokeStyles_() {
    const e = this.state;
    e.fillStyle !== void 0 && this.updateFillStyle(e, this.createFill), e.strokeStyle !== void 0 && this.updateStrokeStyle(e, this.applyStroke);
  }
}
const x5 = tV;
function rV(i, e, t, r, n) {
  const s = [];
  let a = t, o = 0, A = e.slice(t, 2);
  for (; o < i && a + n < r; ) {
    const [l, h] = A.slice(-2), c = e[a + n], u = e[a + n + 1], f = Math.sqrt(
      (c - l) * (c - l) + (u - h) * (u - h)
    );
    if (o += f, o >= i) {
      const g = (i - o + f) / f, p = Ms(l, c, g), y = Ms(h, u, g);
      A.push(p, y), s.push(A), A = [p, y], o == i && (a += n), o = 0;
    } else if (o < i)
      A.push(
        e[a + n],
        e[a + n + 1]
      ), a += n;
    else {
      const g = f - o, p = Ms(l, c, g / f), y = Ms(h, u, g / f);
      A.push(p, y), s.push(A), A = [p, y], o = 0, a += n;
    }
  }
  return o > 0 && s.push(A), s;
}
function iV(i, e, t, r, n) {
  let s = t, a = t, o = 0, A = 0, l = t, h, c, u, f, g, p, y, v, w, C;
  for (c = t; c < r; c += n) {
    const E = e[c], S = e[c + 1];
    g !== void 0 && (w = E - g, C = S - p, f = Math.sqrt(w * w + C * C), y !== void 0 && (A += u, h = Math.acos((y * w + v * C) / (u * f)), h > i && (A > o && (o = A, s = l, a = c), A = 0, l = c - n)), u = f, y = w, v = C), g = E, p = S;
  }
  return A += f, A > o ? [l, c] : [s, a];
}
const fd = {
  left: 0,
  end: 0,
  center: 0.5,
  right: 1,
  start: 1,
  top: 0,
  middle: 0.5,
  hanging: 0.2,
  alphabetic: 0.8,
  ideographic: 0.8,
  bottom: 1
};
class nV extends Bg {
  /**
   * @param {number} tolerance Tolerance.
   * @param {import("../../extent.js").Extent} maxExtent Maximum extent.
   * @param {number} resolution Resolution.
   * @param {number} pixelRatio Pixel ratio.
   */
  constructor(e, t, r, n) {
    super(e, t, r, n), this.labels_ = null, this.text_ = "", this.textOffsetX_ = 0, this.textOffsetY_ = 0, this.textRotateWithView_ = void 0, this.textRotation_ = 0, this.textFillState_ = null, this.fillStates = {}, this.textStrokeState_ = null, this.strokeStates = {}, this.textState_ = /** @type {import("../canvas.js").TextState} */
    {}, this.textStates = {}, this.textKey_ = "", this.fillKey_ = "", this.strokeKey_ = "", this.declutterImageWithText_ = void 0;
  }
  /**
   * @return {import("../canvas.js").SerializableInstructions} the serializable instructions.
   */
  finish() {
    const e = super.finish();
    return e.textStates = this.textStates, e.fillStates = this.fillStates, e.strokeStates = this.strokeStates, e;
  }
  /**
   * @param {import("../../geom/SimpleGeometry.js").default|import("../Feature.js").default} geometry Geometry.
   * @param {import("../../Feature.js").FeatureLike} feature Feature.
   */
  drawText(e, t) {
    const r = this.textFillState_, n = this.textStrokeState_, s = this.textState_;
    if (this.text_ === "" || !s || !r && !n)
      return;
    const a = this.coordinates;
    let o = a.length;
    const A = e.getType();
    let l = null, h = e.getStride();
    if (s.placement === "line" && (A == "LineString" || A == "MultiLineString" || A == "Polygon" || A == "MultiPolygon")) {
      if (!ci(this.getBufferedMaxExtent(), e.getExtent()))
        return;
      let c;
      if (l = e.getFlatCoordinates(), A == "LineString")
        c = [l.length];
      else if (A == "MultiLineString")
        c = /** @type {import("../../geom/MultiLineString.js").default} */
        e.getEnds();
      else if (A == "Polygon")
        c = /** @type {import("../../geom/Polygon.js").default} */
        e.getEnds().slice(0, 1);
      else if (A == "MultiPolygon") {
        const p = (
          /** @type {import("../../geom/MultiPolygon.js").default} */
          e.getEndss()
        );
        c = [];
        for (let y = 0, v = p.length; y < v; ++y)
          c.push(p[y][0]);
      }
      this.beginGeometry(e, t);
      const u = s.repeat, f = u ? void 0 : s.textAlign;
      let g = 0;
      for (let p = 0, y = c.length; p < y; ++p) {
        let v;
        u ? v = rV(
          u * this.resolution,
          l,
          g,
          c[p],
          h
        ) : v = [l.slice(g, c[p])];
        for (let w = 0, C = v.length; w < C; ++w) {
          const E = v[w];
          let S = 0, M = E.length;
          if (f == null) {
            const F = iV(
              s.maxAngle,
              E,
              0,
              E.length,
              2
            );
            S = F[0], M = F[1];
          }
          for (let F = S; F < M; F += h)
            a.push(E[F], E[F + 1]);
          const T = a.length;
          g = c[p], this.drawChars_(o, T), o = T;
        }
      }
      this.endGeometry(t);
    } else {
      let c = s.overflow ? null : [];
      switch (A) {
        case "Point":
        case "MultiPoint":
          l = /** @type {import("../../geom/MultiPoint.js").default} */
          e.getFlatCoordinates();
          break;
        case "LineString":
          l = /** @type {import("../../geom/LineString.js").default} */
          e.getFlatMidpoint();
          break;
        case "Circle":
          l = /** @type {import("../../geom/Circle.js").default} */
          e.getCenter();
          break;
        case "MultiLineString":
          l = /** @type {import("../../geom/MultiLineString.js").default} */
          e.getFlatMidpoints(), h = 2;
          break;
        case "Polygon":
          l = /** @type {import("../../geom/Polygon.js").default} */
          e.getFlatInteriorPoint(), s.overflow || c.push(l[2] / this.resolution), h = 3;
          break;
        case "MultiPolygon":
          const y = (
            /** @type {import("../../geom/MultiPolygon.js").default} */
            e.getFlatInteriorPoints()
          );
          l = [];
          for (let v = 0, w = y.length; v < w; v += 3)
            s.overflow || c.push(y[v + 2] / this.resolution), l.push(y[v], y[v + 1]);
          if (l.length === 0)
            return;
          h = 2;
          break;
      }
      const u = this.appendFlatPointCoordinates(l, h);
      if (u === o)
        return;
      if (c && (u - o) / 2 !== l.length / h) {
        let y = o / 2;
        c = c.filter((v, w) => {
          const C = a[(y + w) * 2] === l[w * h] && a[(y + w) * 2 + 1] === l[w * h + 1];
          return C || --y, C;
        });
      }
      this.saveTextStates_(), (s.backgroundFill || s.backgroundStroke) && (this.setFillStrokeStyle(
        s.backgroundFill,
        s.backgroundStroke
      ), s.backgroundFill && (this.updateFillStyle(this.state, this.createFill), this.hitDetectionInstructions.push(this.createFill(this.state))), s.backgroundStroke && (this.updateStrokeStyle(this.state, this.applyStroke), this.hitDetectionInstructions.push(this.createStroke(this.state)))), this.beginGeometry(e, t);
      let f = s.padding;
      if (f != zl && (s.scale[0] < 0 || s.scale[1] < 0)) {
        let y = s.padding[0], v = s.padding[1], w = s.padding[2], C = s.padding[3];
        s.scale[0] < 0 && (v = -v, C = -C), s.scale[1] < 0 && (y = -y, w = -w), f = [y, v, w, C];
      }
      const g = this.pixelRatio;
      this.instructions.push([
        Ft.DRAW_IMAGE,
        o,
        u,
        null,
        NaN,
        NaN,
        NaN,
        1,
        0,
        0,
        this.textRotateWithView_,
        this.textRotation_,
        [1, 1],
        NaN,
        void 0,
        this.declutterImageWithText_,
        f == zl ? zl : f.map(function(y) {
          return y * g;
        }),
        !!s.backgroundFill,
        !!s.backgroundStroke,
        this.text_,
        this.textKey_,
        this.strokeKey_,
        this.fillKey_,
        this.textOffsetX_,
        this.textOffsetY_,
        c
      ]);
      const p = 1 / g;
      this.hitDetectionInstructions.push([
        Ft.DRAW_IMAGE,
        o,
        u,
        null,
        NaN,
        NaN,
        NaN,
        1,
        0,
        0,
        this.textRotateWithView_,
        this.textRotation_,
        [p, p],
        NaN,
        void 0,
        this.declutterImageWithText_,
        f,
        !!s.backgroundFill,
        !!s.backgroundStroke,
        this.text_,
        this.textKey_,
        this.strokeKey_,
        this.fillKey_,
        this.textOffsetX_,
        this.textOffsetY_,
        c
      ]), this.endGeometry(t);
    }
  }
  /**
   * @private
   */
  saveTextStates_() {
    const e = this.textStrokeState_, t = this.textState_, r = this.textFillState_, n = this.strokeKey_;
    e && (n in this.strokeStates || (this.strokeStates[n] = {
      strokeStyle: e.strokeStyle,
      lineCap: e.lineCap,
      lineDashOffset: e.lineDashOffset,
      lineWidth: e.lineWidth,
      lineJoin: e.lineJoin,
      miterLimit: e.miterLimit,
      lineDash: e.lineDash
    }));
    const s = this.textKey_;
    s in this.textStates || (this.textStates[s] = {
      font: t.font,
      textAlign: t.textAlign || Pd,
      justify: t.justify,
      textBaseline: t.textBaseline || Cm,
      scale: t.scale
    });
    const a = this.fillKey_;
    r && (a in this.fillStates || (this.fillStates[a] = {
      fillStyle: r.fillStyle
    }));
  }
  /**
   * @private
   * @param {number} begin Begin.
   * @param {number} end End.
   */
  drawChars_(e, t) {
    const r = this.textStrokeState_, n = this.textState_, s = this.strokeKey_, a = this.textKey_, o = this.fillKey_;
    this.saveTextStates_();
    const A = this.pixelRatio, l = fd[n.textBaseline], h = this.textOffsetY_ * A, c = this.text_, u = r ? r.lineWidth * Math.abs(n.scale[0]) / 2 : 0;
    this.instructions.push([
      Ft.DRAW_CHARS,
      e,
      t,
      l,
      n.overflow,
      o,
      n.maxAngle,
      A,
      h,
      s,
      u * A,
      c,
      a,
      1
    ]), this.hitDetectionInstructions.push([
      Ft.DRAW_CHARS,
      e,
      t,
      l,
      n.overflow,
      o,
      n.maxAngle,
      1,
      h,
      s,
      u,
      c,
      a,
      1 / A
    ]);
  }
  /**
   * @param {import("../../style/Text.js").default} textStyle Text style.
   * @param {Object} [sharedData] Shared data.
   */
  setTextStyle(e, t) {
    let r, n, s;
    if (!e)
      this.text_ = "";
    else {
      const a = e.getFill();
      a ? (n = this.textFillState_, n || (n = /** @type {import("../canvas.js").FillState} */
      {}, this.textFillState_ = n), n.fillStyle = Ga(
        a.getColor() || Go
      )) : (n = null, this.textFillState_ = n);
      const o = e.getStroke();
      if (!o)
        s = null, this.textStrokeState_ = s;
      else {
        s = this.textStrokeState_, s || (s = /** @type {import("../canvas.js").StrokeState} */
        {}, this.textStrokeState_ = s);
        const g = o.getLineDash(), p = o.getLineDashOffset(), y = o.getWidth(), v = o.getMiterLimit();
        s.lineCap = o.getLineCap() || xm, s.lineDash = g ? g.slice() : Id, s.lineDashOffset = p === void 0 ? Rd : p, s.lineJoin = o.getLineJoin() || mu, s.lineWidth = y === void 0 ? Od : y, s.miterLimit = v === void 0 ? Md : v, s.strokeStyle = Ga(
          o.getColor() || Nd
        );
      }
      r = this.textState_;
      const A = e.getFont() || eM;
      f6(A);
      const l = e.getScaleArray();
      r.overflow = e.getOverflow(), r.font = A, r.maxAngle = e.getMaxAngle(), r.placement = e.getPlacement(), r.textAlign = e.getTextAlign(), r.repeat = e.getRepeat(), r.justify = e.getJustify(), r.textBaseline = e.getTextBaseline() || Cm, r.backgroundFill = e.getBackgroundFill(), r.backgroundStroke = e.getBackgroundStroke(), r.padding = e.getPadding() || zl, r.scale = l === void 0 ? [1, 1] : l;
      const h = e.getOffsetX(), c = e.getOffsetY(), u = e.getRotateWithView(), f = e.getRotation();
      this.text_ = e.getText() || "", this.textOffsetX_ = h === void 0 ? 0 : h, this.textOffsetY_ = c === void 0 ? 0 : c, this.textRotateWithView_ = u === void 0 ? !1 : u, this.textRotation_ = f === void 0 ? 0 : f, this.strokeKey_ = s ? (typeof s.strokeStyle == "string" ? s.strokeStyle : st(s.strokeStyle)) + s.lineCap + s.lineDashOffset + "|" + s.lineWidth + s.lineJoin + s.miterLimit + "[" + s.lineDash.join() + "]" : "", this.textKey_ = r.font + r.scale + (r.textAlign || "?") + (r.repeat || "?") + (r.justify || "?") + (r.textBaseline || "?"), this.fillKey_ = n ? typeof n.fillStyle == "string" ? n.fillStyle : "|" + st(n.fillStyle) : "";
    }
    this.declutterImageWithText_ = t;
  }
}
const sV = {
  Circle: x5,
  Default: Bg,
  Image: Z9,
  LineString: eV,
  Polygon: x5,
  Text: nV
};
class aV {
  /**
   * @param {number} tolerance Tolerance.
   * @param {import("../../extent.js").Extent} maxExtent Max extent.
   * @param {number} resolution Resolution.
   * @param {number} pixelRatio Pixel ratio.
   */
  constructor(e, t, r, n) {
    this.tolerance_ = e, this.maxExtent_ = t, this.pixelRatio_ = n, this.resolution_ = r, this.buildersByZIndex_ = {};
  }
  /**
   * @return {!Object<string, !Object<import("../canvas.js").BuilderType, import("./Builder.js").SerializableInstructions>>} The serializable instructions
   */
  finish() {
    const e = {};
    for (const t in this.buildersByZIndex_) {
      e[t] = e[t] || {};
      const r = this.buildersByZIndex_[t];
      for (const n in r) {
        const s = r[n].finish();
        e[t][n] = s;
      }
    }
    return e;
  }
  /**
   * @param {number|undefined} zIndex Z index.
   * @param {import("../canvas.js").BuilderType} builderType Replay type.
   * @return {import("../VectorContext.js").default} Replay.
   */
  getBuilder(e, t) {
    const r = e !== void 0 ? e.toString() : "0";
    let n = this.buildersByZIndex_[r];
    n === void 0 && (n = {}, this.buildersByZIndex_[r] = n);
    let s = n[t];
    if (s === void 0) {
      const a = sV[t];
      s = new a(
        this.tolerance_,
        this.maxExtent_,
        this.resolution_,
        this.pixelRatio_
      ), n[t] = s;
    }
    return s;
  }
}
const Qm = aV;
function oV(i, e, t, r, n, s, a, o, A, l, h, c) {
  let u = i[e], f = i[e + 1], g = 0, p = 0, y = 0, v = 0;
  function w() {
    g = u, p = f, e += r, u = i[e], f = i[e + 1], v += y, y = Math.sqrt((u - g) * (u - g) + (f - p) * (f - p));
  }
  do
    w();
  while (e < t - r && v + y < s);
  let C = y === 0 ? 0 : (s - v) / y;
  const E = Ms(g, u, C), S = Ms(p, f, C), M = e - r, T = v, F = s + o * A(l, n, h);
  for (; e < t - r && v + y < F; )
    w();
  C = y === 0 ? 0 : (F - v) / y;
  const k = Ms(g, u, C), $ = Ms(p, f, C);
  let I;
  if (c) {
    const W = [E, S, k, $];
    wE(W, 0, 4, 2, c, W, W), I = W[0] > W[2];
  } else
    I = E > k;
  const L = Math.PI, P = [], Q = M + r === e;
  e = M, y = 0, v = T, u = i[e], f = i[e + 1];
  let X;
  if (Q) {
    w(), X = Math.atan2(f - p, u - g), I && (X += X > 0 ? -L : L);
    const W = (k + E) / 2, q = ($ + S) / 2;
    return P[0] = [W, q, (F - s) / 2, X, n], P;
  }
  n = n.replace(/\n/g, " ");
  for (let W = 0, q = n.length; W < q; ) {
    w();
    let Z = Math.atan2(f - p, u - g);
    if (I && (Z += Z > 0 ? -L : L), X !== void 0) {
      let V = Z - X;
      if (V += V > L ? -2 * L : V < -L ? 2 * L : 0, Math.abs(V) > a)
        return null;
    }
    X = Z;
    const oe = W;
    let ne = 0;
    for (; W < q; ++W) {
      const V = I ? q - W - 1 : W, j = o * A(l, n[V], h);
      if (e + r < t && v + y < s + ne + j / 2)
        break;
      ne += j;
    }
    if (W === oe)
      continue;
    const me = I ? n.substring(q - oe, q - W) : n.substring(oe, W);
    C = y === 0 ? 0 : (s + ne / 2 - v) / y;
    const b = Ms(g, u, C), H = Ms(p, f, C);
    P.push([b, H, ne / 2, Z, me]), s += ne;
  }
  return P;
}
function p4(i, e, t, r) {
  let n = i[e], s = i[e + 1], a = 0;
  for (let o = e + r; o < t; o += r) {
    const A = i[o], l = i[o + 1];
    a += Math.sqrt((A - n) * (A - n) + (l - s) * (l - s)), n = A, s = l;
  }
  return a;
}
const ac = Ji(), TA = [], Eo = [], Bo = [], FA = [];
function C5(i) {
  return i[3].declutterBox;
}
const AV = new RegExp(
  /* eslint-disable prettier/prettier */
  "[" + String.fromCharCode(1425) + "-" + String.fromCharCode(2303) + String.fromCharCode(64285) + "-" + String.fromCharCode(65023) + String.fromCharCode(65136) + "-" + String.fromCharCode(65276) + String.fromCharCode(67584) + "-" + String.fromCharCode(69631) + String.fromCharCode(124928) + "-" + String.fromCharCode(126975) + "]"
  /* eslint-enable prettier/prettier */
);
function E5(i, e) {
  return (e === "start" || e === "end") && !AV.test(i) && (e = e === "start" ? "left" : "right"), fd[e];
}
function lV(i, e, t) {
  return t > 0 && i.push(`
`, ""), i.push(e, ""), i;
}
class hV {
  /**
   * @param {number} resolution Resolution.
   * @param {number} pixelRatio Pixel ratio.
   * @param {boolean} overlaps The replay can have overlapping geometries.
   * @param {import("../canvas.js").SerializableInstructions} instructions The serializable instructions
   */
  constructor(e, t, r, n) {
    this.overlaps = r, this.pixelRatio = t, this.resolution = e, this.alignFill_, this.instructions = n.instructions, this.coordinates = n.coordinates, this.coordinateCache_ = {}, this.renderedTransform_ = qi(), this.hitDetectionInstructions = n.hitDetectionInstructions, this.pixelCoordinates_ = null, this.viewRotation_ = 0, this.fillStates = n.fillStates || {}, this.strokeStates = n.strokeStates || {}, this.textStates = n.textStates || {}, this.widths_ = {}, this.labels_ = {};
  }
  /**
   * @param {string|Array<string>} text Text.
   * @param {string} textKey Text style key.
   * @param {string} fillKey Fill style key.
   * @param {string} strokeKey Stroke style key.
   * @return {import("../canvas.js").Label} Label.
   */
  createLabel(e, t, r, n) {
    const s = e + t + r + n;
    if (this.labels_[s])
      return this.labels_[s];
    const a = n ? this.strokeStates[n] : null, o = r ? this.fillStates[r] : null, A = this.textStates[t], l = this.pixelRatio, h = [
      A.scale[0] * l,
      A.scale[1] * l
    ], c = Array.isArray(e), u = A.justify ? fd[A.justify] : E5(
      Array.isArray(e) ? e[0] : e,
      A.textAlign || Pd
    ), f = n && a.lineWidth ? a.lineWidth : 0, g = c ? e : e.split(`
`).reduce(lV, []), { width: p, height: y, widths: v, heights: w, lineWidths: C } = g6(
      A,
      g
    ), E = p + f, S = [], M = (E + 2) * h[0], T = (y + f) * h[1], F = {
      width: M < 0 ? Math.floor(M) : Math.ceil(M),
      height: T < 0 ? Math.floor(T) : Math.ceil(T),
      contextInstructions: S
    };
    (h[0] != 1 || h[1] != 1) && S.push("scale", h), n && (S.push("strokeStyle", a.strokeStyle), S.push("lineWidth", f), S.push("lineCap", a.lineCap), S.push("lineJoin", a.lineJoin), S.push("miterLimit", a.miterLimit), S.push("setLineDash", [a.lineDash]), S.push("lineDashOffset", a.lineDashOffset)), r && S.push("fillStyle", o.fillStyle), S.push("textBaseline", "middle"), S.push("textAlign", "center");
    const k = 0.5 - u;
    let $ = u * E + k * f;
    const I = [], L = [];
    let P = 0, Q = 0, X = 0, W = 0, q;
    for (let Z = 0, oe = g.length; Z < oe; Z += 2) {
      const ne = g[Z];
      if (ne === `
`) {
        Q += P, P = 0, $ = u * E + k * f, ++W;
        continue;
      }
      const me = g[Z + 1] || A.font;
      me !== q && (n && I.push("font", me), r && L.push("font", me), q = me), P = Math.max(P, w[X]);
      const b = [
        ne,
        $ + k * v[X] + u * (v[X] - C[W]),
        0.5 * (f + P) + Q
      ];
      $ += v[X], n && I.push("strokeText", b), r && L.push("fillText", b), ++X;
    }
    return Array.prototype.push.apply(S, I), Array.prototype.push.apply(S, L), this.labels_[s] = F, F;
  }
  /**
   * @param {CanvasRenderingContext2D} context Context.
   * @param {import("../../coordinate.js").Coordinate} p1 1st point of the background box.
   * @param {import("../../coordinate.js").Coordinate} p2 2nd point of the background box.
   * @param {import("../../coordinate.js").Coordinate} p3 3rd point of the background box.
   * @param {import("../../coordinate.js").Coordinate} p4 4th point of the background box.
   * @param {Array<*>} fillInstruction Fill instruction.
   * @param {Array<*>} strokeInstruction Stroke instruction.
   */
  replayTextBackground_(e, t, r, n, s, a, o) {
    e.beginPath(), e.moveTo.apply(e, t), e.lineTo.apply(e, r), e.lineTo.apply(e, n), e.lineTo.apply(e, s), e.lineTo.apply(e, t), a && (this.alignFill_ = /** @type {boolean} */
    a[2], this.fill_(e)), o && (this.setStrokeStyle_(
      e,
      /** @type {Array<*>} */
      o
    ), e.stroke());
  }
  /**
   * @private
   * @param {number} sheetWidth Width of the sprite sheet.
   * @param {number} sheetHeight Height of the sprite sheet.
   * @param {number} centerX X.
   * @param {number} centerY Y.
   * @param {number} width Width.
   * @param {number} height Height.
   * @param {number} anchorX Anchor X.
   * @param {number} anchorY Anchor Y.
   * @param {number} originX Origin X.
   * @param {number} originY Origin Y.
   * @param {number} rotation Rotation.
   * @param {import("../../size.js").Size} scale Scale.
   * @param {boolean} snapToPixel Snap to pixel.
   * @param {Array<number>} padding Padding.
   * @param {boolean} fillStroke Background fill or stroke.
   * @param {import("../../Feature.js").FeatureLike} feature Feature.
   * @return {ImageOrLabelDimensions} Dimensions for positioning and decluttering the image or label.
   */
  calculateImageOrLabelDimensions_(e, t, r, n, s, a, o, A, l, h, c, u, f, g, p, y) {
    o *= u[0], A *= u[1];
    let v = r - o, w = n - A;
    const C = s + l > e ? e - l : s, E = a + h > t ? t - h : a, S = g[3] + C * u[0] + g[1], M = g[0] + E * u[1] + g[2], T = v - g[3], F = w - g[0];
    (p || c !== 0) && (TA[0] = T, FA[0] = T, TA[1] = F, Eo[1] = F, Eo[0] = T + S, Bo[0] = Eo[0], Bo[1] = F + M, FA[1] = Bo[1]);
    let k;
    return c !== 0 ? (k = Qs(
      qi(),
      r,
      n,
      1,
      1,
      c,
      -r,
      -n
    ), vi(k, TA), vi(k, Eo), vi(k, Bo), vi(k, FA), ms(
      Math.min(TA[0], Eo[0], Bo[0], FA[0]),
      Math.min(TA[1], Eo[1], Bo[1], FA[1]),
      Math.max(TA[0], Eo[0], Bo[0], FA[0]),
      Math.max(TA[1], Eo[1], Bo[1], FA[1]),
      ac
    )) : ms(
      Math.min(T, T + S),
      Math.min(F, F + M),
      Math.max(T, T + S),
      Math.max(F, F + M),
      ac
    ), f && (v = Math.round(v), w = Math.round(w)), {
      drawImageX: v,
      drawImageY: w,
      drawImageW: C,
      drawImageH: E,
      originX: l,
      originY: h,
      declutterBox: {
        minX: ac[0],
        minY: ac[1],
        maxX: ac[2],
        maxY: ac[3],
        value: y
      },
      canvasTransform: k,
      scale: u
    };
  }
  /**
   * @private
   * @param {CanvasRenderingContext2D} context Context.
   * @param {number} contextScale Scale of the context.
   * @param {import("../canvas.js").Label|HTMLImageElement|HTMLCanvasElement|HTMLVideoElement} imageOrLabel Image.
   * @param {ImageOrLabelDimensions} dimensions Dimensions.
   * @param {number} opacity Opacity.
   * @param {Array<*>} fillInstruction Fill instruction.
   * @param {Array<*>} strokeInstruction Stroke instruction.
   * @return {boolean} The image or label was rendered.
   */
  replayImageOrLabel_(e, t, r, n, s, a, o) {
    const A = !!(a || o), l = n.declutterBox, h = e.canvas, c = o ? o[2] * n.scale[0] / 2 : 0;
    return l.minX - c <= h.width / t && l.maxX + c >= 0 && l.minY - c <= h.height / t && l.maxY + c >= 0 && (A && this.replayTextBackground_(
      e,
      TA,
      Eo,
      Bo,
      FA,
      /** @type {Array<*>} */
      a,
      /** @type {Array<*>} */
      o
    ), p6(
      e,
      n.canvasTransform,
      s,
      r,
      n.originX,
      n.originY,
      n.drawImageW,
      n.drawImageH,
      n.drawImageX,
      n.drawImageY,
      n.scale
    )), !0;
  }
  /**
   * @private
   * @param {CanvasRenderingContext2D} context Context.
   */
  fill_(e) {
    if (this.alignFill_) {
      const t = vi(this.renderedTransform_, [0, 0]), r = 512 * this.pixelRatio;
      e.save(), e.translate(t[0] % r, t[1] % r), e.rotate(this.viewRotation_);
    }
    e.fill(), this.alignFill_ && e.restore();
  }
  /**
   * @private
   * @param {CanvasRenderingContext2D} context Context.
   * @param {Array<*>} instruction Instruction.
   */
  setStrokeStyle_(e, t) {
    e.strokeStyle = /** @type {import("../../colorlike.js").ColorLike} */
    t[1], e.lineWidth = /** @type {number} */
    t[2], e.lineCap = /** @type {CanvasLineCap} */
    t[3], e.lineJoin = /** @type {CanvasLineJoin} */
    t[4], e.miterLimit = /** @type {number} */
    t[5], e.lineDashOffset = /** @type {number} */
    t[7], e.setLineDash(
      /** @type {Array<number>} */
      t[6]
    );
  }
  /**
   * @private
   * @param {string|Array<string>} text The text to draw.
   * @param {string} textKey The key of the text state.
   * @param {string} strokeKey The key for the stroke state.
   * @param {string} fillKey The key for the fill state.
   * @return {{label: import("../canvas.js").Label, anchorX: number, anchorY: number}} The text image and its anchor.
   */
  drawLabelWithPointPlacement_(e, t, r, n) {
    const s = this.textStates[t], a = this.createLabel(e, t, n, r), o = this.strokeStates[r], A = this.pixelRatio, l = E5(
      Array.isArray(e) ? e[0] : e,
      s.textAlign || Pd
    ), h = fd[s.textBaseline || Cm], c = o && o.lineWidth ? o.lineWidth : 0, u = a.width / A - 2 * s.scale[0], f = l * u + 2 * (0.5 - l) * c, g = h * a.height / A + 2 * (0.5 - h) * c;
    return {
      label: a,
      anchorX: f,
      anchorY: g
    };
  }
  /**
   * @private
   * @param {CanvasRenderingContext2D} context Context.
   * @param {number} contextScale Scale of the context.
   * @param {import("../../transform.js").Transform} transform Transform.
   * @param {Array<*>} instructions Instructions array.
   * @param {boolean} snapToPixel Snap point symbols and text to integer pixels.
   * @param {FeatureCallback<T>} [featureCallback] Feature callback.
   * @param {import("../../extent.js").Extent} [hitExtent] Only check
   *     features that intersect this extent.
   * @param {import("rbush").default} [declutterTree] Declutter tree.
   * @return {T|undefined} Callback result.
   * @template T
   */
  execute_(e, t, r, n, s, a, o, A) {
    let l;
    this.pixelCoordinates_ && Za(r, this.renderedTransform_) ? l = this.pixelCoordinates_ : (this.pixelCoordinates_ || (this.pixelCoordinates_ = []), l = il(
      this.coordinates,
      0,
      this.coordinates.length,
      2,
      r,
      this.pixelCoordinates_
    ), QQ(this.renderedTransform_, r));
    let h = 0;
    const c = n.length;
    let u = 0, f, g, p, y, v, w, C, E, S, M, T, F, k = 0, $ = 0, I = null, L = null;
    const P = this.coordinateCache_, Q = this.viewRotation_, X = Math.round(Math.atan2(-r[1], r[0]) * 1e12) / 1e12, W = (
      /** @type {import("../../render.js").State} */
      {
        context: e,
        pixelRatio: this.pixelRatio,
        resolution: this.resolution,
        rotation: Q
      }
    ), q = this.instructions != n || this.overlaps ? 0 : 200;
    let Z, oe, ne, me;
    for (; h < c; ) {
      const b = n[h];
      switch (
        /** @type {import("./Instruction.js").default} */
        b[0]
      ) {
        case Ft.BEGIN_GEOMETRY:
          Z = /** @type {import("../../Feature.js").FeatureLike} */
          b[1], me = b[3], Z.getGeometry() ? o !== void 0 && !ci(o, me.getExtent()) ? h = /** @type {number} */
          b[2] + 1 : ++h : h = /** @type {number} */
          b[2];
          break;
        case Ft.BEGIN_PATH:
          k > q && (this.fill_(e), k = 0), $ > q && (e.stroke(), $ = 0), !k && !$ && (e.beginPath(), y = NaN, v = NaN), ++h;
          break;
        case Ft.CIRCLE:
          u = /** @type {number} */
          b[1];
          const V = l[u], j = l[u + 1], ie = l[u + 2], ue = l[u + 3], fe = ie - V, ee = ue - j, xe = Math.sqrt(fe * fe + ee * ee);
          e.moveTo(V + xe, j), e.arc(V, j, xe, 0, 2 * Math.PI, !0), ++h;
          break;
        case Ft.CLOSE_PATH:
          e.closePath(), ++h;
          break;
        case Ft.CUSTOM:
          u = /** @type {number} */
          b[1], f = b[2];
          const Ee = (
            /** @type {import("../../geom/SimpleGeometry.js").default} */
            b[3]
          ), Ue = b[4], ke = b.length == 6 ? b[5] : void 0;
          W.geometry = Ee, W.feature = Z, h in P || (P[h] = []);
          const We = P[h];
          ke ? ke(l, u, f, 2, We) : (We[0] = l[u], We[1] = l[u + 1], We.length = 2), Ue(We, W), ++h;
          break;
        case Ft.DRAW_IMAGE:
          u = /** @type {number} */
          b[1], f = /** @type {number} */
          b[2], E = /** @type {HTMLCanvasElement|HTMLVideoElement|HTMLImageElement} */
          b[3], g = /** @type {number} */
          b[4], p = /** @type {number} */
          b[5];
          let ve = (
            /** @type {number} */
            b[6]
          );
          const Y = (
            /** @type {number} */
            b[7]
          ), mt = (
            /** @type {number} */
            b[8]
          ), Ze = (
            /** @type {number} */
            b[9]
          ), Fe = (
            /** @type {boolean} */
            b[10]
          );
          let Re = (
            /** @type {number} */
            b[11]
          );
          const De = (
            /** @type {import("../../size.js").Size} */
            b[12]
          );
          let Le = (
            /** @type {number} */
            b[13]
          );
          const Ge = (
            /** @type {"declutter"|"obstacle"|"none"|undefined} */
            b[14]
          ), ze = (
            /** @type {import("../canvas.js").DeclutterImageWithText} */
            b[15]
          );
          if (!E && b.length >= 20) {
            S = /** @type {string} */
            b[19], M = /** @type {string} */
            b[20], T = /** @type {string} */
            b[21], F = /** @type {string} */
            b[22];
            const Ot = this.drawLabelWithPointPlacement_(
              S,
              M,
              T,
              F
            );
            E = Ot.label, b[3] = E;
            const li = (
              /** @type {number} */
              b[23]
            );
            g = (Ot.anchorX - li) * this.pixelRatio, b[4] = g;
            const _r = (
              /** @type {number} */
              b[24]
            );
            p = (Ot.anchorY - _r) * this.pixelRatio, b[5] = p, ve = E.height, b[6] = ve, Le = E.width, b[13] = Le;
          }
          let ft;
          b.length > 25 && (ft = /** @type {number} */
          b[25]);
          let Et, Mt, Ut;
          b.length > 17 ? (Et = /** @type {Array<number>} */
          b[16], Mt = /** @type {boolean} */
          b[17], Ut = /** @type {boolean} */
          b[18]) : (Et = zl, Mt = !1, Ut = !1), Fe && X ? Re += Q : !Fe && !X && (Re -= Q);
          let At = 0;
          for (; u < f; u += 2) {
            if (ft && ft[At++] < Le / this.pixelRatio)
              continue;
            const Ot = this.calculateImageOrLabelDimensions_(
              E.width,
              E.height,
              l[u],
              l[u + 1],
              Le,
              ve,
              g,
              p,
              mt,
              Ze,
              Re,
              De,
              s,
              Et,
              Mt || Ut,
              Z
            ), li = [
              e,
              t,
              E,
              Ot,
              Y,
              Mt ? (
                /** @type {Array<*>} */
                I
              ) : null,
              Ut ? (
                /** @type {Array<*>} */
                L
              ) : null
            ];
            if (A) {
              if (Ge === "none")
                continue;
              if (Ge === "obstacle") {
                A.insert(Ot.declutterBox);
                continue;
              } else {
                let _r, di;
                if (ze) {
                  const zr = f - u;
                  if (!ze[zr]) {
                    ze[zr] = li;
                    continue;
                  }
                  if (_r = ze[zr], delete ze[zr], di = C5(_r), A.collides(di))
                    continue;
                }
                if (A.collides(Ot.declutterBox))
                  continue;
                _r && (A.insert(di), this.replayImageOrLabel_.apply(this, _r)), A.insert(Ot.declutterBox);
              }
            }
            this.replayImageOrLabel_.apply(this, li);
          }
          ++h;
          break;
        case Ft.DRAW_CHARS:
          const vt = (
            /** @type {number} */
            b[1]
          ), Ne = (
            /** @type {number} */
            b[2]
          ), Qr = (
            /** @type {number} */
            b[3]
          ), kt = (
            /** @type {number} */
            b[4]
          );
          F = /** @type {string} */
          b[5];
          const fn = (
            /** @type {number} */
            b[6]
          ), Ar = (
            /** @type {number} */
            b[7]
          ), Zt = (
            /** @type {number} */
            b[8]
          );
          T = /** @type {string} */
          b[9];
          const ii = (
            /** @type {number} */
            b[10]
          );
          S = /** @type {string} */
          b[11], M = /** @type {string} */
          b[12];
          const Jt = [
            /** @type {number} */
            b[13],
            /** @type {number} */
            b[13]
          ], rn = this.textStates[M], ar = rn.font, Ai = [
            rn.scale[0] * Ar,
            rn.scale[1] * Ar
          ];
          let yr;
          ar in this.widths_ ? yr = this.widths_[ar] : (yr = {}, this.widths_[ar] = yr);
          const Lr = p4(l, vt, Ne, 2), bt = Math.abs(Ai[0]) * DS(ar, S, yr);
          if (kt || bt <= Lr) {
            const Ot = this.textStates[M].textAlign, li = (Lr - bt) * fd[Ot], _r = oV(
              l,
              vt,
              Ne,
              2,
              S,
              li,
              fn,
              Math.abs(Ai[0]),
              DS,
              ar,
              yr,
              X ? 0 : this.viewRotation_
            );
            e:
              if (_r) {
                const di = [];
                let zr, gt, Ci, fr, Ir;
                if (T)
                  for (zr = 0, gt = _r.length; zr < gt; ++zr) {
                    Ir = _r[zr], Ci = /** @type {string} */
                    Ir[4], fr = this.createLabel(Ci, M, "", T), g = /** @type {number} */
                    Ir[2] + (Ai[0] < 0 ? -ii : ii), p = Qr * fr.height + (0.5 - Qr) * 2 * ii * Ai[1] / Ai[0] - Zt;
                    const Cr = this.calculateImageOrLabelDimensions_(
                      fr.width,
                      fr.height,
                      Ir[0],
                      Ir[1],
                      fr.width,
                      fr.height,
                      g,
                      p,
                      0,
                      0,
                      Ir[3],
                      Jt,
                      !1,
                      zl,
                      !1,
                      Z
                    );
                    if (A && A.collides(Cr.declutterBox))
                      break e;
                    di.push([
                      e,
                      t,
                      fr,
                      Cr,
                      1,
                      null,
                      null
                    ]);
                  }
                if (F)
                  for (zr = 0, gt = _r.length; zr < gt; ++zr) {
                    Ir = _r[zr], Ci = /** @type {string} */
                    Ir[4], fr = this.createLabel(Ci, M, F, ""), g = /** @type {number} */
                    Ir[2], p = Qr * fr.height - Zt;
                    const Cr = this.calculateImageOrLabelDimensions_(
                      fr.width,
                      fr.height,
                      Ir[0],
                      Ir[1],
                      fr.width,
                      fr.height,
                      g,
                      p,
                      0,
                      0,
                      Ir[3],
                      Jt,
                      !1,
                      zl,
                      !1,
                      Z
                    );
                    if (A && A.collides(Cr.declutterBox))
                      break e;
                    di.push([
                      e,
                      t,
                      fr,
                      Cr,
                      1,
                      null,
                      null
                    ]);
                  }
                A && A.load(di.map(C5));
                for (let Cr = 0, ni = di.length; Cr < ni; ++Cr)
                  this.replayImageOrLabel_.apply(this, di[Cr]);
              }
          }
          ++h;
          break;
        case Ft.END_GEOMETRY:
          if (a !== void 0) {
            Z = /** @type {import("../../Feature.js").FeatureLike} */
            b[1];
            const Ot = a(Z, me);
            if (Ot)
              return Ot;
          }
          ++h;
          break;
        case Ft.FILL:
          q ? k++ : this.fill_(e), ++h;
          break;
        case Ft.MOVE_TO_LINE_TO:
          for (u = /** @type {number} */
          b[1], f = /** @type {number} */
          b[2], oe = l[u], ne = l[u + 1], w = oe + 0.5 | 0, C = ne + 0.5 | 0, (w !== y || C !== v) && (e.moveTo(oe, ne), y = w, v = C), u += 2; u < f; u += 2)
            oe = l[u], ne = l[u + 1], w = oe + 0.5 | 0, C = ne + 0.5 | 0, (u == f - 2 || w !== y || C !== v) && (e.lineTo(oe, ne), y = w, v = C);
          ++h;
          break;
        case Ft.SET_FILL_STYLE:
          I = b, this.alignFill_ = b[2], k && (this.fill_(e), k = 0, $ && (e.stroke(), $ = 0)), e.fillStyle = /** @type {import("../../colorlike.js").ColorLike} */
          b[1], ++h;
          break;
        case Ft.SET_STROKE_STYLE:
          L = b, $ && (e.stroke(), $ = 0), this.setStrokeStyle_(
            e,
            /** @type {Array<*>} */
            b
          ), ++h;
          break;
        case Ft.STROKE:
          q ? $++ : e.stroke(), ++h;
          break;
        default:
          ++h;
          break;
      }
    }
    k && this.fill_(e), $ && e.stroke();
  }
  /**
   * @param {CanvasRenderingContext2D} context Context.
   * @param {number} contextScale Scale of the context.
   * @param {import("../../transform.js").Transform} transform Transform.
   * @param {number} viewRotation View rotation.
   * @param {boolean} snapToPixel Snap point symbols and text to integer pixels.
   * @param {import("rbush").default} [declutterTree] Declutter tree.
   */
  execute(e, t, r, n, s, a) {
    this.viewRotation_ = n, this.execute_(
      e,
      t,
      r,
      this.instructions,
      s,
      void 0,
      void 0,
      a
    );
  }
  /**
   * @param {CanvasRenderingContext2D} context Context.
   * @param {import("../../transform.js").Transform} transform Transform.
   * @param {number} viewRotation View rotation.
   * @param {FeatureCallback<T>} [featureCallback] Feature callback.
   * @param {import("../../extent.js").Extent} [hitExtent] Only check
   *     features that intersect this extent.
   * @return {T|undefined} Callback result.
   * @template T
   */
  executeHitDetection(e, t, r, n, s) {
    return this.viewRotation_ = r, this.execute_(
      e,
      1,
      t,
      this.hitDetectionInstructions,
      !0,
      n,
      s
    );
  }
}
const cV = hV, K1 = ["Polygon", "Circle", "LineString", "Image", "Text", "Default"];
class uV {
  /**
   * @param {import("../../extent.js").Extent} maxExtent Max extent for clipping. When a
   * `maxExtent` was set on the Builder for this executor group, the same `maxExtent`
   * should be set here, unless the target context does not exceed that extent (which
   * can be the case when rendering to tiles).
   * @param {number} resolution Resolution.
   * @param {number} pixelRatio Pixel ratio.
   * @param {boolean} overlaps The executor group can have overlapping geometries.
   * @param {!Object<string, !Object<import("../canvas.js").BuilderType, import("../canvas.js").SerializableInstructions>>} allInstructions
   * The serializable instructions.
   * @param {number} [renderBuffer] Optional rendering buffer.
   */
  constructor(e, t, r, n, s, a) {
    this.maxExtent_ = e, this.overlaps_ = n, this.pixelRatio_ = r, this.resolution_ = t, this.renderBuffer_ = a, this.executorsByZIndex_ = {}, this.hitDetectionContext_ = null, this.hitDetectionTransform_ = qi(), this.createExecutors_(s);
  }
  /**
   * @param {CanvasRenderingContext2D} context Context.
   * @param {import("../../transform.js").Transform} transform Transform.
   */
  clip(e, t) {
    const r = this.getClipCoords(t);
    e.beginPath(), e.moveTo(r[0], r[1]), e.lineTo(r[2], r[3]), e.lineTo(r[4], r[5]), e.lineTo(r[6], r[7]), e.clip();
  }
  /**
   * Create executors and populate them using the provided instructions.
   * @private
   * @param {!Object<string, !Object<import("../canvas.js").BuilderType, import("../canvas.js").SerializableInstructions>>} allInstructions The serializable instructions
   */
  createExecutors_(e) {
    for (const t in e) {
      let r = this.executorsByZIndex_[t];
      r === void 0 && (r = {}, this.executorsByZIndex_[t] = r);
      const n = e[t];
      for (const s in n) {
        const a = n[s];
        r[s] = new cV(
          this.resolution_,
          this.pixelRatio_,
          this.overlaps_,
          a
        );
      }
    }
  }
  /**
   * @param {Array<import("../canvas.js").BuilderType>} executors Executors.
   * @return {boolean} Has executors of the provided types.
   */
  hasExecutors(e) {
    for (const t in this.executorsByZIndex_) {
      const r = this.executorsByZIndex_[t];
      for (let n = 0, s = e.length; n < s; ++n)
        if (e[n] in r)
          return !0;
    }
    return !1;
  }
  /**
   * @param {import("../../coordinate.js").Coordinate} coordinate Coordinate.
   * @param {number} resolution Resolution.
   * @param {number} rotation Rotation.
   * @param {number} hitTolerance Hit tolerance in pixels.
   * @param {function(import("../../Feature.js").FeatureLike, import("../../geom/SimpleGeometry.js").default, number): T} callback Feature callback.
   * @param {Array<import("../../Feature.js").FeatureLike>} declutteredFeatures Decluttered features.
   * @return {T|undefined} Callback result.
   * @template T
   */
  forEachFeatureAtCoordinate(e, t, r, n, s, a) {
    n = Math.round(n);
    const o = n * 2 + 1, A = Qs(
      this.hitDetectionTransform_,
      n + 0.5,
      n + 0.5,
      1 / t,
      -1 / t,
      -r,
      -e[0],
      -e[1]
    ), l = !this.hitDetectionContext_;
    l && (this.hitDetectionContext_ = Ii(
      o,
      o,
      void 0,
      { willReadFrequently: !0 }
    ));
    const h = this.hitDetectionContext_;
    h.canvas.width !== o || h.canvas.height !== o ? (h.canvas.width = o, h.canvas.height = o) : l || h.clearRect(0, 0, o, o);
    let c;
    this.renderBuffer_ !== void 0 && (c = Ji(), eh(c, e), zn(
      c,
      t * (this.renderBuffer_ + n),
      c
    ));
    const u = fV(n);
    let f;
    function g(S, M) {
      const T = h.getImageData(
        0,
        0,
        o,
        o
      ).data;
      for (let F = 0, k = u.length; F < k; F++)
        if (T[u[F]] > 0) {
          if (!a || f !== "Image" && f !== "Text" || a.includes(S)) {
            const $ = (u[F] - 3) / 4, I = n - $ % o, L = n - ($ / o | 0), P = s(S, M, I * I + L * L);
            if (P)
              return P;
          }
          h.clearRect(0, 0, o, o);
          break;
        }
    }
    const p = Object.keys(this.executorsByZIndex_).map(Number);
    p.sort(Al);
    let y, v, w, C, E;
    for (y = p.length - 1; y >= 0; --y) {
      const S = p[y].toString();
      for (w = this.executorsByZIndex_[S], v = K1.length - 1; v >= 0; --v)
        if (f = K1[v], C = w[f], C !== void 0 && (E = C.executeHitDetection(
          h,
          A,
          r,
          g,
          c
        ), E))
          return E;
    }
  }
  /**
   * @param {import("../../transform.js").Transform} transform Transform.
   * @return {Array<number>|null} Clip coordinates.
   */
  getClipCoords(e) {
    const t = this.maxExtent_;
    if (!t)
      return null;
    const r = t[0], n = t[1], s = t[2], a = t[3], o = [r, n, r, a, s, a, s, n];
    return il(o, 0, 8, 2, e, o), o;
  }
  /**
   * @return {boolean} Is empty.
   */
  isEmpty() {
    return dh(this.executorsByZIndex_);
  }
  /**
   * @param {CanvasRenderingContext2D} context Context.
   * @param {number} contextScale Scale of the context.
   * @param {import("../../transform.js").Transform} transform Transform.
   * @param {number} viewRotation View rotation.
   * @param {boolean} snapToPixel Snap point symbols and test to integer pixel.
   * @param {Array<import("../canvas.js").BuilderType>} [builderTypes] Ordered replay types to replay.
   *     Default is {@link module:ol/render/replay~ORDER}
   * @param {import("rbush").default} [declutterTree] Declutter tree.
   */
  execute(e, t, r, n, s, a, o) {
    const A = Object.keys(this.executorsByZIndex_).map(Number);
    A.sort(Al), this.maxExtent_ && (e.save(), this.clip(e, r)), a = a || K1;
    let l, h, c, u, f, g;
    for (o && A.reverse(), l = 0, h = A.length; l < h; ++l) {
      const p = A[l].toString();
      for (f = this.executorsByZIndex_[p], c = 0, u = a.length; c < u; ++c) {
        const y = a[c];
        g = f[y], g !== void 0 && g.execute(
          e,
          t,
          r,
          n,
          s,
          o
        );
      }
    }
    this.maxExtent_ && e.restore();
  }
}
const j1 = {};
function fV(i) {
  if (j1[i] !== void 0)
    return j1[i];
  const e = i * 2 + 1, t = i * i, r = new Array(t + 1);
  for (let s = 0; s <= i; ++s)
    for (let a = 0; a <= i; ++a) {
      const o = s * s + a * a;
      if (o > t)
        break;
      let A = r[o];
      A || (A = [], r[o] = A), A.push(((i + s) * e + (i + a)) * 4 + 3), s > 0 && A.push(((i - s) * e + (i + a)) * 4 + 3), a > 0 && (A.push(((i + s) * e + (i - a)) * 4 + 3), s > 0 && A.push(((i - s) * e + (i - a)) * 4 + 3));
    }
  const n = [];
  for (let s = 0, a = r.length; s < a; ++s)
    r[s] && n.push(...r[s]);
  return j1[i] = n, n;
}
const Dm = uV;
class dV extends g4 {
  /**
   * @param {CanvasRenderingContext2D} context Context.
   * @param {number} pixelRatio Pixel ratio.
   * @param {import("../../extent.js").Extent} extent Extent.
   * @param {import("../../transform.js").Transform} transform Transform.
   * @param {number} viewRotation View rotation.
   * @param {number} [squaredTolerance] Optional squared tolerance for simplification.
   * @param {import("../../proj.js").TransformFunction} [userTransform] Transform from user to view projection.
   */
  constructor(e, t, r, n, s, a, o) {
    super(), this.context_ = e, this.pixelRatio_ = t, this.extent_ = r, this.transform_ = n, this.transformRotation_ = n ? cg(Math.atan2(n[1], n[0]), 10) : 0, this.viewRotation_ = s, this.squaredTolerance_ = a, this.userTransform_ = o, this.contextFillState_ = null, this.contextStrokeState_ = null, this.contextTextState_ = null, this.fillState_ = null, this.strokeState_ = null, this.image_ = null, this.imageAnchorX_ = 0, this.imageAnchorY_ = 0, this.imageHeight_ = 0, this.imageOpacity_ = 0, this.imageOriginX_ = 0, this.imageOriginY_ = 0, this.imageRotateWithView_ = !1, this.imageRotation_ = 0, this.imageScale_ = [0, 0], this.imageWidth_ = 0, this.text_ = "", this.textOffsetX_ = 0, this.textOffsetY_ = 0, this.textRotateWithView_ = !1, this.textRotation_ = 0, this.textScale_ = [0, 0], this.textFillState_ = null, this.textStrokeState_ = null, this.textState_ = null, this.pixelCoordinates_ = [], this.tmpLocalTransform_ = qi();
  }
  /**
   * @param {Array<number>} flatCoordinates Flat coordinates.
   * @param {number} offset Offset.
   * @param {number} end End.
   * @param {number} stride Stride.
   * @private
   */
  drawImages_(e, t, r, n) {
    if (!this.image_)
      return;
    const s = il(
      e,
      t,
      r,
      n,
      this.transform_,
      this.pixelCoordinates_
    ), a = this.context_, o = this.tmpLocalTransform_, A = a.globalAlpha;
    this.imageOpacity_ != 1 && (a.globalAlpha = A * this.imageOpacity_);
    let l = this.imageRotation_;
    this.transformRotation_ === 0 && (l -= this.viewRotation_), this.imageRotateWithView_ && (l += this.viewRotation_);
    for (let h = 0, c = s.length; h < c; h += 2) {
      const u = s[h] - this.imageAnchorX_, f = s[h + 1] - this.imageAnchorY_;
      if (l !== 0 || this.imageScale_[0] != 1 || this.imageScale_[1] != 1) {
        const g = u + this.imageAnchorX_, p = f + this.imageAnchorY_;
        Qs(
          o,
          g,
          p,
          1,
          1,
          l,
          -g,
          -p
        ), a.setTransform.apply(a, o), a.translate(g, p), a.scale(this.imageScale_[0], this.imageScale_[1]), a.drawImage(
          this.image_,
          this.imageOriginX_,
          this.imageOriginY_,
          this.imageWidth_,
          this.imageHeight_,
          -this.imageAnchorX_,
          -this.imageAnchorY_,
          this.imageWidth_,
          this.imageHeight_
        ), a.setTransform(1, 0, 0, 1, 0, 0);
      } else
        a.drawImage(
          this.image_,
          this.imageOriginX_,
          this.imageOriginY_,
          this.imageWidth_,
          this.imageHeight_,
          u,
          f,
          this.imageWidth_,
          this.imageHeight_
        );
    }
    this.imageOpacity_ != 1 && (a.globalAlpha = A);
  }
  /**
   * @param {Array<number>} flatCoordinates Flat coordinates.
   * @param {number} offset Offset.
   * @param {number} end End.
   * @param {number} stride Stride.
   * @private
   */
  drawText_(e, t, r, n) {
    if (!this.textState_ || this.text_ === "")
      return;
    this.textFillState_ && this.setContextFillState_(this.textFillState_), this.textStrokeState_ && this.setContextStrokeState_(this.textStrokeState_), this.setContextTextState_(this.textState_);
    const s = il(
      e,
      t,
      r,
      n,
      this.transform_,
      this.pixelCoordinates_
    ), a = this.context_;
    let o = this.textRotation_;
    for (this.transformRotation_ === 0 && (o -= this.viewRotation_), this.textRotateWithView_ && (o += this.viewRotation_); t < r; t += n) {
      const A = s[t] + this.textOffsetX_, l = s[t + 1] + this.textOffsetY_;
      o !== 0 || this.textScale_[0] != 1 || this.textScale_[1] != 1 ? (a.translate(A - this.textOffsetX_, l - this.textOffsetY_), a.rotate(o), a.translate(this.textOffsetX_, this.textOffsetY_), a.scale(this.textScale_[0], this.textScale_[1]), this.textStrokeState_ && a.strokeText(this.text_, 0, 0), this.textFillState_ && a.fillText(this.text_, 0, 0), a.setTransform(1, 0, 0, 1, 0, 0)) : (this.textStrokeState_ && a.strokeText(this.text_, A, l), this.textFillState_ && a.fillText(this.text_, A, l));
    }
  }
  /**
   * @param {Array<number>} flatCoordinates Flat coordinates.
   * @param {number} offset Offset.
   * @param {number} end End.
   * @param {number} stride Stride.
   * @param {boolean} close Close.
   * @private
   * @return {number} end End.
   */
  moveToLineTo_(e, t, r, n, s) {
    const a = this.context_, o = il(
      e,
      t,
      r,
      n,
      this.transform_,
      this.pixelCoordinates_
    );
    a.moveTo(o[0], o[1]);
    let A = o.length;
    s && (A -= 2);
    for (let l = 2; l < A; l += 2)
      a.lineTo(o[l], o[l + 1]);
    return s && a.closePath(), r;
  }
  /**
   * @param {Array<number>} flatCoordinates Flat coordinates.
   * @param {number} offset Offset.
   * @param {Array<number>} ends Ends.
   * @param {number} stride Stride.
   * @private
   * @return {number} End.
   */
  drawRings_(e, t, r, n) {
    for (let s = 0, a = r.length; s < a; ++s)
      t = this.moveToLineTo_(
        e,
        t,
        r[s],
        n,
        !0
      );
    return t;
  }
  /**
   * Render a circle geometry into the canvas.  Rendering is immediate and uses
   * the current fill and stroke styles.
   *
   * @param {import("../../geom/Circle.js").default} geometry Circle geometry.
   * @api
   */
  drawCircle(e) {
    if (ci(this.extent_, e.getExtent())) {
      if (this.fillState_ || this.strokeState_) {
        this.fillState_ && this.setContextFillState_(this.fillState_), this.strokeState_ && this.setContextStrokeState_(this.strokeState_);
        const t = MD(
          e,
          this.transform_,
          this.pixelCoordinates_
        ), r = t[2] - t[0], n = t[3] - t[1], s = Math.sqrt(r * r + n * n), a = this.context_;
        a.beginPath(), a.arc(
          t[0],
          t[1],
          s,
          0,
          2 * Math.PI
        ), this.fillState_ && a.fill(), this.strokeState_ && a.stroke();
      }
      this.text_ !== "" && this.drawText_(e.getCenter(), 0, 2, 2);
    }
  }
  /**
   * Set the rendering style.  Note that since this is an immediate rendering API,
   * any `zIndex` on the provided style will be ignored.
   *
   * @param {import("../../style/Style.js").default} style The rendering style.
   * @api
   */
  setStyle(e) {
    this.setFillStrokeStyle(e.getFill(), e.getStroke()), this.setImageStyle(e.getImage()), this.setTextStyle(e.getText());
  }
  /**
   * @param {import("../../transform.js").Transform} transform Transform.
   */
  setTransform(e) {
    this.transform_ = e;
  }
  /**
   * Render a geometry into the canvas.  Call
   * {@link module:ol/render/canvas/Immediate~CanvasImmediateRenderer#setStyle renderer.setStyle()} first to set the rendering style.
   *
   * @param {import("../../geom/Geometry.js").default|import("../Feature.js").default} geometry The geometry to render.
   * @api
   */
  drawGeometry(e) {
    switch (e.getType()) {
      case "Point":
        this.drawPoint(
          /** @type {import("../../geom/Point.js").default} */
          e
        );
        break;
      case "LineString":
        this.drawLineString(
          /** @type {import("../../geom/LineString.js").default} */
          e
        );
        break;
      case "Polygon":
        this.drawPolygon(
          /** @type {import("../../geom/Polygon.js").default} */
          e
        );
        break;
      case "MultiPoint":
        this.drawMultiPoint(
          /** @type {import("../../geom/MultiPoint.js").default} */
          e
        );
        break;
      case "MultiLineString":
        this.drawMultiLineString(
          /** @type {import("../../geom/MultiLineString.js").default} */
          e
        );
        break;
      case "MultiPolygon":
        this.drawMultiPolygon(
          /** @type {import("../../geom/MultiPolygon.js").default} */
          e
        );
        break;
      case "GeometryCollection":
        this.drawGeometryCollection(
          /** @type {import("../../geom/GeometryCollection.js").default} */
          e
        );
        break;
      case "Circle":
        this.drawCircle(
          /** @type {import("../../geom/Circle.js").default} */
          e
        );
        break;
    }
  }
  /**
   * Render a feature into the canvas.  Note that any `zIndex` on the provided
   * style will be ignored - features are rendered immediately in the order that
   * this method is called.  If you need `zIndex` support, you should be using an
   * {@link module:ol/layer/Vector~VectorLayer} instead.
   *
   * @param {import("../../Feature.js").default} feature Feature.
   * @param {import("../../style/Style.js").default} style Style.
   * @api
   */
  drawFeature(e, t) {
    const r = t.getGeometryFunction()(e);
    !r || !ci(this.extent_, r.getExtent()) || (this.setStyle(t), this.drawGeometry(r));
  }
  /**
   * Render a GeometryCollection to the canvas.  Rendering is immediate and
   * uses the current styles appropriate for each geometry in the collection.
   *
   * @param {import("../../geom/GeometryCollection.js").default} geometry Geometry collection.
   */
  drawGeometryCollection(e) {
    const t = e.getGeometriesArray();
    for (let r = 0, n = t.length; r < n; ++r)
      this.drawGeometry(t[r]);
  }
  /**
   * Render a Point geometry into the canvas.  Rendering is immediate and uses
   * the current style.
   *
   * @param {import("../../geom/Point.js").default|import("../Feature.js").default} geometry Point geometry.
   */
  drawPoint(e) {
    this.squaredTolerance_ && (e = /** @type {import("../../geom/Point.js").default} */
    e.simplifyTransformed(
      this.squaredTolerance_,
      this.userTransform_
    ));
    const t = e.getFlatCoordinates(), r = e.getStride();
    this.image_ && this.drawImages_(t, 0, t.length, r), this.text_ !== "" && this.drawText_(t, 0, t.length, r);
  }
  /**
   * Render a MultiPoint geometry  into the canvas.  Rendering is immediate and
   * uses the current style.
   *
   * @param {import("../../geom/MultiPoint.js").default|import("../Feature.js").default} geometry MultiPoint geometry.
   */
  drawMultiPoint(e) {
    this.squaredTolerance_ && (e = /** @type {import("../../geom/MultiPoint.js").default} */
    e.simplifyTransformed(
      this.squaredTolerance_,
      this.userTransform_
    ));
    const t = e.getFlatCoordinates(), r = e.getStride();
    this.image_ && this.drawImages_(t, 0, t.length, r), this.text_ !== "" && this.drawText_(t, 0, t.length, r);
  }
  /**
   * Render a LineString into the canvas.  Rendering is immediate and uses
   * the current style.
   *
   * @param {import("../../geom/LineString.js").default|import("../Feature.js").default} geometry LineString geometry.
   */
  drawLineString(e) {
    if (this.squaredTolerance_ && (e = /** @type {import("../../geom/LineString.js").default} */
    e.simplifyTransformed(
      this.squaredTolerance_,
      this.userTransform_
    )), !!ci(this.extent_, e.getExtent())) {
      if (this.strokeState_) {
        this.setContextStrokeState_(this.strokeState_);
        const t = this.context_, r = e.getFlatCoordinates();
        t.beginPath(), this.moveToLineTo_(
          r,
          0,
          r.length,
          e.getStride(),
          !1
        ), t.stroke();
      }
      if (this.text_ !== "") {
        const t = e.getFlatMidpoint();
        this.drawText_(t, 0, 2, 2);
      }
    }
  }
  /**
   * Render a MultiLineString geometry into the canvas.  Rendering is immediate
   * and uses the current style.
   *
   * @param {import("../../geom/MultiLineString.js").default|import("../Feature.js").default} geometry MultiLineString geometry.
   */
  drawMultiLineString(e) {
    this.squaredTolerance_ && (e = /** @type {import("../../geom/MultiLineString.js").default} */
    e.simplifyTransformed(
      this.squaredTolerance_,
      this.userTransform_
    ));
    const t = e.getExtent();
    if (ci(this.extent_, t)) {
      if (this.strokeState_) {
        this.setContextStrokeState_(this.strokeState_);
        const r = this.context_, n = e.getFlatCoordinates();
        let s = 0;
        const a = (
          /** @type {Array<number>} */
          e.getEnds()
        ), o = e.getStride();
        r.beginPath();
        for (let A = 0, l = a.length; A < l; ++A)
          s = this.moveToLineTo_(
            n,
            s,
            a[A],
            o,
            !1
          );
        r.stroke();
      }
      if (this.text_ !== "") {
        const r = e.getFlatMidpoints();
        this.drawText_(r, 0, r.length, 2);
      }
    }
  }
  /**
   * Render a Polygon geometry into the canvas.  Rendering is immediate and uses
   * the current style.
   *
   * @param {import("../../geom/Polygon.js").default|import("../Feature.js").default} geometry Polygon geometry.
   */
  drawPolygon(e) {
    if (this.squaredTolerance_ && (e = /** @type {import("../../geom/Polygon.js").default} */
    e.simplifyTransformed(
      this.squaredTolerance_,
      this.userTransform_
    )), !!ci(this.extent_, e.getExtent())) {
      if (this.strokeState_ || this.fillState_) {
        this.fillState_ && this.setContextFillState_(this.fillState_), this.strokeState_ && this.setContextStrokeState_(this.strokeState_);
        const t = this.context_;
        t.beginPath(), this.drawRings_(
          e.getOrientedFlatCoordinates(),
          0,
          /** @type {Array<number>} */
          e.getEnds(),
          e.getStride()
        ), this.fillState_ && t.fill(), this.strokeState_ && t.stroke();
      }
      if (this.text_ !== "") {
        const t = e.getFlatInteriorPoint();
        this.drawText_(t, 0, 2, 2);
      }
    }
  }
  /**
   * Render MultiPolygon geometry into the canvas.  Rendering is immediate and
   * uses the current style.
   * @param {import("../../geom/MultiPolygon.js").default} geometry MultiPolygon geometry.
   */
  drawMultiPolygon(e) {
    if (this.squaredTolerance_ && (e = /** @type {import("../../geom/MultiPolygon.js").default} */
    e.simplifyTransformed(
      this.squaredTolerance_,
      this.userTransform_
    )), !!ci(this.extent_, e.getExtent())) {
      if (this.strokeState_ || this.fillState_) {
        this.fillState_ && this.setContextFillState_(this.fillState_), this.strokeState_ && this.setContextStrokeState_(this.strokeState_);
        const t = this.context_, r = e.getOrientedFlatCoordinates();
        let n = 0;
        const s = e.getEndss(), a = e.getStride();
        t.beginPath();
        for (let o = 0, A = s.length; o < A; ++o) {
          const l = s[o];
          n = this.drawRings_(r, n, l, a);
        }
        this.fillState_ && t.fill(), this.strokeState_ && t.stroke();
      }
      if (this.text_ !== "") {
        const t = e.getFlatInteriorPoints();
        this.drawText_(t, 0, t.length, 2);
      }
    }
  }
  /**
   * @param {import("../canvas.js").FillState} fillState Fill state.
   * @private
   */
  setContextFillState_(e) {
    const t = this.context_, r = this.contextFillState_;
    r ? r.fillStyle != e.fillStyle && (r.fillStyle = e.fillStyle, t.fillStyle = e.fillStyle) : (t.fillStyle = e.fillStyle, this.contextFillState_ = {
      fillStyle: e.fillStyle
    });
  }
  /**
   * @param {import("../canvas.js").StrokeState} strokeState Stroke state.
   * @private
   */
  setContextStrokeState_(e) {
    const t = this.context_, r = this.contextStrokeState_;
    r ? (r.lineCap != e.lineCap && (r.lineCap = e.lineCap, t.lineCap = e.lineCap), Za(r.lineDash, e.lineDash) || t.setLineDash(
      r.lineDash = e.lineDash
    ), r.lineDashOffset != e.lineDashOffset && (r.lineDashOffset = e.lineDashOffset, t.lineDashOffset = e.lineDashOffset), r.lineJoin != e.lineJoin && (r.lineJoin = e.lineJoin, t.lineJoin = e.lineJoin), r.lineWidth != e.lineWidth && (r.lineWidth = e.lineWidth, t.lineWidth = e.lineWidth), r.miterLimit != e.miterLimit && (r.miterLimit = e.miterLimit, t.miterLimit = e.miterLimit), r.strokeStyle != e.strokeStyle && (r.strokeStyle = e.strokeStyle, t.strokeStyle = e.strokeStyle)) : (t.lineCap = e.lineCap, t.setLineDash(e.lineDash), t.lineDashOffset = e.lineDashOffset, t.lineJoin = e.lineJoin, t.lineWidth = e.lineWidth, t.miterLimit = e.miterLimit, t.strokeStyle = e.strokeStyle, this.contextStrokeState_ = {
      lineCap: e.lineCap,
      lineDash: e.lineDash,
      lineDashOffset: e.lineDashOffset,
      lineJoin: e.lineJoin,
      lineWidth: e.lineWidth,
      miterLimit: e.miterLimit,
      strokeStyle: e.strokeStyle
    });
  }
  /**
   * @param {import("../canvas.js").TextState} textState Text state.
   * @private
   */
  setContextTextState_(e) {
    const t = this.context_, r = this.contextTextState_, n = e.textAlign ? e.textAlign : Pd;
    r ? (r.font != e.font && (r.font = e.font, t.font = e.font), r.textAlign != n && (r.textAlign = n, t.textAlign = n), r.textBaseline != e.textBaseline && (r.textBaseline = e.textBaseline, t.textBaseline = e.textBaseline)) : (t.font = e.font, t.textAlign = n, t.textBaseline = e.textBaseline, this.contextTextState_ = {
      font: e.font,
      textAlign: n,
      textBaseline: e.textBaseline
    });
  }
  /**
   * Set the fill and stroke style for subsequent draw operations.  To clear
   * either fill or stroke styles, pass null for the appropriate parameter.
   *
   * @param {import("../../style/Fill.js").default} fillStyle Fill style.
   * @param {import("../../style/Stroke.js").default} strokeStyle Stroke style.
   */
  setFillStrokeStyle(e, t) {
    if (!e)
      this.fillState_ = null;
    else {
      const r = e.getColor();
      this.fillState_ = {
        fillStyle: Ga(
          r || Go
        )
      };
    }
    if (!t)
      this.strokeState_ = null;
    else {
      const r = t.getColor(), n = t.getLineCap(), s = t.getLineDash(), a = t.getLineDashOffset(), o = t.getLineJoin(), A = t.getWidth(), l = t.getMiterLimit(), h = s || Id;
      this.strokeState_ = {
        lineCap: n !== void 0 ? n : xm,
        lineDash: this.pixelRatio_ === 1 ? h : h.map((c) => c * this.pixelRatio_),
        lineDashOffset: (a || Rd) * this.pixelRatio_,
        lineJoin: o !== void 0 ? o : mu,
        lineWidth: (A !== void 0 ? A : Od) * this.pixelRatio_,
        miterLimit: l !== void 0 ? l : Md,
        strokeStyle: Ga(
          r || Nd
        )
      };
    }
  }
  /**
   * Set the image style for subsequent draw operations.  Pass null to remove
   * the image style.
   *
   * @param {import("../../style/Image.js").default} imageStyle Image style.
   */
  setImageStyle(e) {
    let t;
    if (!e || !(t = e.getSize())) {
      this.image_ = null;
      return;
    }
    const r = e.getPixelRatio(this.pixelRatio_), n = e.getAnchor(), s = e.getOrigin();
    this.image_ = e.getImage(this.pixelRatio_), this.imageAnchorX_ = n[0] * r, this.imageAnchorY_ = n[1] * r, this.imageHeight_ = t[1] * r, this.imageOpacity_ = e.getOpacity(), this.imageOriginX_ = s[0], this.imageOriginY_ = s[1], this.imageRotateWithView_ = e.getRotateWithView(), this.imageRotation_ = e.getRotation();
    const a = e.getScaleArray();
    this.imageScale_ = [
      a[0] * this.pixelRatio_ / r,
      a[1] * this.pixelRatio_ / r
    ], this.imageWidth_ = t[0] * r;
  }
  /**
   * Set the text style for subsequent draw operations.  Pass null to
   * remove the text style.
   *
   * @param {import("../../style/Text.js").default} textStyle Text style.
   */
  setTextStyle(e) {
    if (!e)
      this.text_ = "";
    else {
      const t = e.getFill();
      if (!t)
        this.textFillState_ = null;
      else {
        const f = t.getColor();
        this.textFillState_ = {
          fillStyle: Ga(
            f || Go
          )
        };
      }
      const r = e.getStroke();
      if (!r)
        this.textStrokeState_ = null;
      else {
        const f = r.getColor(), g = r.getLineCap(), p = r.getLineDash(), y = r.getLineDashOffset(), v = r.getLineJoin(), w = r.getWidth(), C = r.getMiterLimit();
        this.textStrokeState_ = {
          lineCap: g !== void 0 ? g : xm,
          lineDash: p || Id,
          lineDashOffset: y || Rd,
          lineJoin: v !== void 0 ? v : mu,
          lineWidth: w !== void 0 ? w : Od,
          miterLimit: C !== void 0 ? C : Md,
          strokeStyle: Ga(
            f || Nd
          )
        };
      }
      const n = e.getFont(), s = e.getOffsetX(), a = e.getOffsetY(), o = e.getRotateWithView(), A = e.getRotation(), l = e.getScaleArray(), h = e.getText(), c = e.getTextAlign(), u = e.getTextBaseline();
      this.textState_ = {
        font: n !== void 0 ? n : eM,
        textAlign: c !== void 0 ? c : Pd,
        textBaseline: u !== void 0 ? u : Cm
      }, this.text_ = h !== void 0 ? Array.isArray(h) ? h.reduce((f, g, p) => f += p % 2 ? " " : g, "") : h : "", this.textOffsetX_ = s !== void 0 ? this.pixelRatio_ * s : 0, this.textOffsetY_ = a !== void 0 ? this.pixelRatio_ * a : 0, this.textRotateWithView_ = o !== void 0 ? o : !1, this.textRotation_ = A !== void 0 ? A : 0, this.textScale_ = [
        this.pixelRatio_ * l[0],
        this.pixelRatio_ * l[1]
      ];
    }
  }
}
const m4 = dV, Ns = 0.5;
function v4(i, e, t, r, n, s, a) {
  const o = i[0] * Ns, A = i[1] * Ns, l = Ii(o, A);
  l.imageSmoothingEnabled = !1;
  const h = l.canvas, c = new m4(
    l,
    Ns,
    n,
    null,
    a
  ), u = t.length, f = Math.floor((256 * 256 * 256 - 1) / u), g = {};
  for (let y = 1; y <= u; ++y) {
    const v = t[y - 1], w = v.getStyleFunction() || r;
    if (!r)
      continue;
    let C = w(v, s);
    if (!C)
      continue;
    Array.isArray(C) || (C = [C]);
    const S = (y * f).toString(16).padStart(7, "#00000");
    for (let M = 0, T = C.length; M < T; ++M) {
      const F = C[M], k = F.getGeometryFunction()(v);
      if (!k || !ci(n, k.getExtent()))
        continue;
      const $ = F.clone(), I = $.getFill();
      I && I.setColor(S);
      const L = $.getStroke();
      L && (L.setColor(S), L.setLineDash(null)), $.setText(void 0);
      const P = F.getImage();
      if (P && P.getOpacity() !== 0) {
        const q = P.getImageSize();
        if (!q)
          continue;
        const Z = Ii(
          q[0],
          q[1],
          void 0,
          { alpha: !1 }
        ), oe = Z.canvas;
        Z.fillStyle = S, Z.fillRect(0, 0, oe.width, oe.height), $.setImage(
          new Mu({
            img: oe,
            imgSize: q,
            anchor: P.getAnchor(),
            anchorXUnits: "pixels",
            anchorYUnits: "pixels",
            offset: P.getOrigin(),
            opacity: 1,
            size: P.getSize(),
            scale: P.getScale(),
            rotation: P.getRotation(),
            rotateWithView: P.getRotateWithView()
          })
        );
      }
      const Q = $.getZIndex() || 0;
      let X = g[Q];
      X || (X = {}, g[Q] = X, X.Polygon = [], X.Circle = [], X.LineString = [], X.Point = []);
      const W = k.getType();
      if (W === "GeometryCollection") {
        const q = (
          /** @type {import("../../geom/GeometryCollection.js").default} */
          k.getGeometriesArrayRecursive()
        );
        for (let Z = 0, oe = q.length; Z < oe; ++Z) {
          const ne = q[Z];
          X[ne.getType().replace("Multi", "")].push(
            ne,
            $
          );
        }
      } else
        X[W.replace("Multi", "")].push(k, $);
    }
  }
  const p = Object.keys(g).map(Number).sort(Al);
  for (let y = 0, v = p.length; y < v; ++y) {
    const w = g[p[y]];
    for (const C in w) {
      const E = w[C];
      for (let S = 0, M = E.length; S < M; S += 2) {
        c.setStyle(E[S + 1]);
        for (let T = 0, F = e.length; T < F; ++T)
          c.setTransform(e[T]), c.drawGeometry(E[S]);
      }
    }
  }
  return l.getImageData(0, 0, h.width, h.height);
}
function y4(i, e, t) {
  const r = [];
  if (t) {
    const n = Math.floor(Math.round(i[0]) * Ns), s = Math.floor(Math.round(i[1]) * Ns), a = (jr(n, 0, t.width - 1) + jr(s, 0, t.height - 1) * t.width) * 4, o = t.data[a], A = t.data[a + 1], h = t.data[a + 2] + 256 * (A + 256 * o), c = Math.floor((256 * 256 * 256 - 1) / e.length);
    h && h % c === 0 && r.push(e[h / c - 1]);
  }
  return r;
}
const gV = 0.5, _4 = {
  Point: CV,
  LineString: _V,
  Polygon: BV,
  MultiPoint: EV,
  MultiLineString: wV,
  MultiPolygon: xV,
  GeometryCollection: yV,
  Circle: mV
};
function pV(i, e) {
  return parseInt(st(i), 10) - parseInt(st(e), 10);
}
function w4(i, e) {
  const t = a2(i, e);
  return t * t;
}
function a2(i, e) {
  return gV * i / e;
}
function mV(i, e, t, r, n) {
  const s = t.getFill(), a = t.getStroke();
  if (s || a) {
    const A = i.getBuilder(t.getZIndex(), "Circle");
    A.setFillStrokeStyle(s, a), A.drawCircle(e, r);
  }
  const o = t.getText();
  if (o && o.getText()) {
    const A = (n || i).getBuilder(
      t.getZIndex(),
      "Text"
    );
    A.setTextStyle(o), A.drawText(e, r);
  }
}
function km(i, e, t, r, n, s, a) {
  let o = !1;
  const A = t.getImage();
  if (A) {
    const l = A.getImageState();
    l == Pt.LOADED || l == Pt.ERROR ? A.unlistenImageChange(n) : (l == Pt.IDLE && A.load(), A.listenImageChange(n), o = !0);
  }
  return vV(
    i,
    e,
    t,
    r,
    s,
    a
  ), o;
}
function vV(i, e, t, r, n, s) {
  const a = t.getGeometryFunction()(e);
  if (!a)
    return;
  const o = a.simplifyTransformed(
    r,
    n
  );
  if (t.getRenderer())
    x4(i, o, t, e);
  else {
    const l = _4[o.getType()];
    l(
      i,
      o,
      t,
      e,
      s
    );
  }
}
function x4(i, e, t, r) {
  if (e.getType() == "GeometryCollection") {
    const s = (
      /** @type {import("../geom/GeometryCollection.js").default} */
      e.getGeometries()
    );
    for (let a = 0, o = s.length; a < o; ++a)
      x4(i, s[a], t, r);
    return;
  }
  i.getBuilder(t.getZIndex(), "Default").drawCustom(
    /** @type {import("../geom/SimpleGeometry.js").default} */
    e,
    r,
    t.getRenderer(),
    t.getHitDetectionRenderer()
  );
}
function yV(i, e, t, r, n) {
  const s = e.getGeometriesArray();
  let a, o;
  for (a = 0, o = s.length; a < o; ++a) {
    const A = _4[s[a].getType()];
    A(
      i,
      s[a],
      t,
      r,
      n
    );
  }
}
function _V(i, e, t, r, n) {
  const s = t.getStroke();
  if (s) {
    const o = i.getBuilder(
      t.getZIndex(),
      "LineString"
    );
    o.setFillStrokeStyle(null, s), o.drawLineString(e, r);
  }
  const a = t.getText();
  if (a && a.getText()) {
    const o = (n || i).getBuilder(
      t.getZIndex(),
      "Text"
    );
    o.setTextStyle(a), o.drawText(e, r);
  }
}
function wV(i, e, t, r, n) {
  const s = t.getStroke();
  if (s) {
    const o = i.getBuilder(
      t.getZIndex(),
      "LineString"
    );
    o.setFillStrokeStyle(null, s), o.drawMultiLineString(e, r);
  }
  const a = t.getText();
  if (a && a.getText()) {
    const o = (n || i).getBuilder(
      t.getZIndex(),
      "Text"
    );
    o.setTextStyle(a), o.drawText(e, r);
  }
}
function xV(i, e, t, r, n) {
  const s = t.getFill(), a = t.getStroke();
  if (a || s) {
    const A = i.getBuilder(t.getZIndex(), "Polygon");
    A.setFillStrokeStyle(s, a), A.drawMultiPolygon(e, r);
  }
  const o = t.getText();
  if (o && o.getText()) {
    const A = (n || i).getBuilder(
      t.getZIndex(),
      "Text"
    );
    A.setTextStyle(o), A.drawText(e, r);
  }
}
function CV(i, e, t, r, n) {
  const s = t.getImage(), a = t.getText();
  let o;
  if (s) {
    if (s.getImageState() != Pt.LOADED)
      return;
    let A = i;
    if (n) {
      const h = s.getDeclutterMode();
      if (h !== "none")
        if (A = n, h === "obstacle") {
          const c = i.getBuilder(
            t.getZIndex(),
            "Image"
          );
          c.setImageStyle(s, o), c.drawPoint(e, r);
        } else
          a && a.getText() && (o = {});
    }
    const l = A.getBuilder(
      t.getZIndex(),
      "Image"
    );
    l.setImageStyle(s, o), l.drawPoint(e, r);
  }
  if (a && a.getText()) {
    let A = i;
    n && (A = n);
    const l = A.getBuilder(t.getZIndex(), "Text");
    l.setTextStyle(a, o), l.drawText(e, r);
  }
}
function EV(i, e, t, r, n) {
  const s = t.getImage(), a = t.getText();
  let o;
  if (s) {
    if (s.getImageState() != Pt.LOADED)
      return;
    let A = i;
    if (n) {
      const h = s.getDeclutterMode();
      if (h !== "none")
        if (A = n, h === "obstacle") {
          const c = i.getBuilder(
            t.getZIndex(),
            "Image"
          );
          c.setImageStyle(s, o), c.drawMultiPoint(e, r);
        } else
          a && a.getText() && (o = {});
    }
    const l = A.getBuilder(
      t.getZIndex(),
      "Image"
    );
    l.setImageStyle(s, o), l.drawMultiPoint(e, r);
  }
  if (a && a.getText()) {
    let A = i;
    n && (A = n);
    const l = A.getBuilder(t.getZIndex(), "Text");
    l.setTextStyle(a, o), l.drawText(e, r);
  }
}
function BV(i, e, t, r, n) {
  const s = t.getFill(), a = t.getStroke();
  if (s || a) {
    const A = i.getBuilder(t.getZIndex(), "Polygon");
    A.setFillStrokeStyle(s, a), A.drawPolygon(e, r);
  }
  const o = t.getText();
  if (o && o.getText()) {
    const A = (n || i).getBuilder(
      t.getZIndex(),
      "Text"
    );
    A.setTextStyle(o), A.drawText(e, r);
  }
}
class bV extends $E {
  /**
   * @param {import("../../layer/BaseVector.js").default} vectorLayer Vector layer.
   */
  constructor(e) {
    super(e), this.boundHandleStyleImageChange_ = this.handleStyleImageChange_.bind(this), this.animatingOrInteracting_, this.hitDetectionImageData_ = null, this.renderedFeatures_ = null, this.renderedRevision_ = -1, this.renderedResolution_ = NaN, this.renderedExtent_ = Ji(), this.wrappedRenderedExtent_ = Ji(), this.renderedRotation_, this.renderedCenter_ = null, this.renderedProjection_ = null, this.renderedRenderOrder_ = null, this.replayGroup_ = null, this.replayGroupChanged = !0, this.declutterExecutorGroup = null, this.clipping = !0, this.compositionContext_ = null, this.opacity_ = 1;
  }
  /**
   * @param {ExecutorGroup} executorGroup Executor group.
   * @param {import("../../Map.js").FrameState} frameState Frame state.
   * @param {import("rbush").default} [declutterTree] Declutter tree.
   */
  renderWorlds(e, t, r) {
    const n = t.extent, s = t.viewState, a = s.center, o = s.resolution, A = s.projection, l = s.rotation, h = A.getExtent(), c = this.getLayer().getSource(), u = t.pixelRatio, f = t.viewHints, g = !(f[ei.ANIMATING] || f[ei.INTERACTING]), p = this.compositionContext_, y = Math.round(t.size[0] * u), v = Math.round(t.size[1] * u), w = c.getWrapX() && A.canWrapX(), C = w ? ir(h) : null, E = w ? Math.ceil((n[2] - h[2]) / C) + 1 : 1;
    let S = w ? Math.floor((n[0] - h[0]) / C) : 0;
    do {
      const M = this.getRenderTransform(
        a,
        o,
        l,
        u,
        y,
        v,
        S * C
      );
      e.execute(
        p,
        1,
        M,
        l,
        g,
        void 0,
        r
      );
    } while (++S < E);
  }
  setupCompositionContext_() {
    if (this.opacity_ !== 1) {
      const e = Ii(
        this.context.canvas.width,
        this.context.canvas.height,
        a5
      );
      this.compositionContext_ = e;
    } else
      this.compositionContext_ = this.context;
  }
  releaseCompositionContext_() {
    if (this.opacity_ !== 1) {
      const e = this.context.globalAlpha;
      this.context.globalAlpha = this.opacity_, this.context.drawImage(this.compositionContext_.canvas, 0, 0), this.context.globalAlpha = e, gu(this.compositionContext_), a5.push(this.compositionContext_.canvas), this.compositionContext_ = null;
    }
  }
  /**
   * Render declutter items for this layer
   * @param {import("../../Map.js").FrameState} frameState Frame state.
   */
  renderDeclutter(e) {
    this.declutterExecutorGroup && (this.setupCompositionContext_(), this.renderWorlds(
      this.declutterExecutorGroup,
      e,
      e.declutterTree
    ), this.releaseCompositionContext_());
  }
  /**
   * Render the layer.
   * @param {import("../../Map.js").FrameState} frameState Frame state.
   * @param {HTMLElement} target Target that may be used to render content to.
   * @return {HTMLElement} The rendered element.
   */
  renderFrame(e, t) {
    const r = e.pixelRatio, n = e.layerStatesArray[e.layerIndex];
    DQ(this.pixelTransform, 1 / r, 1 / r), Ag(this.inversePixelTransform, this.pixelTransform);
    const s = nE(this.pixelTransform);
    this.useContainer(t, s, this.getBackground(e));
    const a = this.context, o = a.canvas, A = this.replayGroup_, l = this.declutterExecutorGroup;
    if ((!A || A.isEmpty()) && (!l || l.isEmpty()))
      return null;
    const h = Math.round(e.size[0] * r), c = Math.round(e.size[1] * r);
    o.width != h || o.height != c ? (o.width = h, o.height = c, o.style.transform !== s && (o.style.transform = s)) : this.containerReused || a.clearRect(0, 0, h, c), this.preRender(a, e);
    const u = e.viewState;
    u.projection, this.opacity_ = n.opacity, this.setupCompositionContext_();
    let f = !1, g = !0;
    if (n.extent && this.clipping) {
      const p = Os(n.extent);
      g = ci(p, e.extent), f = g && !Ps(p, e.extent), f && this.clipUnrotated(this.compositionContext_, e, p);
    }
    return g && this.renderWorlds(A, e), f && this.compositionContext_.restore(), this.releaseCompositionContext_(), this.postRender(a, e), this.renderedRotation_ !== u.rotation && (this.renderedRotation_ = u.rotation, this.hitDetectionImageData_ = null), this.container;
  }
  /**
   * Asynchronous layer level hit detection.
   * @param {import("../../pixel.js").Pixel} pixel Pixel.
   * @return {Promise<Array<import("../../Feature").default>>} Promise
   * that resolves with an array of features.
   */
  getFeatures(e) {
    return new Promise((t) => {
      if (!this.hitDetectionImageData_ && !this.animatingOrInteracting_) {
        const r = [this.context.canvas.width, this.context.canvas.height];
        vi(this.pixelTransform, r);
        const n = this.renderedCenter_, s = this.renderedResolution_, a = this.renderedRotation_, o = this.renderedProjection_, A = this.wrappedRenderedExtent_, l = this.getLayer(), h = [], c = r[0] * Ns, u = r[1] * Ns;
        h.push(
          this.getRenderTransform(
            n,
            s,
            a,
            Ns,
            c,
            u,
            0
          ).slice()
        );
        const f = l.getSource(), g = o.getExtent();
        if (f.getWrapX() && o.canWrapX() && !Ps(g, A)) {
          let p = A[0];
          const y = ir(g);
          let v = 0, w;
          for (; p < g[0]; )
            --v, w = y * v, h.push(
              this.getRenderTransform(
                n,
                s,
                a,
                Ns,
                c,
                u,
                w
              ).slice()
            ), p += y;
          for (v = 0, p = A[2]; p > g[2]; )
            ++v, w = y * v, h.push(
              this.getRenderTransform(
                n,
                s,
                a,
                Ns,
                c,
                u,
                w
              ).slice()
            ), p -= y;
        }
        this.hitDetectionImageData_ = v4(
          r,
          h,
          this.renderedFeatures_,
          l.getStyleFunction(),
          A,
          s,
          a
        );
      }
      t(
        y4(e, this.renderedFeatures_, this.hitDetectionImageData_)
      );
    });
  }
  /**
   * @param {import("../../coordinate.js").Coordinate} coordinate Coordinate.
   * @param {import("../../Map.js").FrameState} frameState Frame state.
   * @param {number} hitTolerance Hit tolerance in pixels.
   * @param {import("../vector.js").FeatureCallback<T>} callback Feature callback.
   * @param {Array<import("../Map.js").HitMatch<T>>} matches The hit detected matches with tolerance.
   * @return {T|undefined} Callback result.
   * @template T
   */
  forEachFeatureAtCoordinate(e, t, r, n, s) {
    if (!this.replayGroup_)
      return;
    const a = t.viewState.resolution, o = t.viewState.rotation, A = this.getLayer(), l = {}, h = function(f, g, p) {
      const y = st(f), v = l[y];
      if (v) {
        if (v !== !0 && p < v.distanceSq) {
          if (p === 0)
            return l[y] = !0, s.splice(s.lastIndexOf(v), 1), n(f, A, g);
          v.geometry = g, v.distanceSq = p;
        }
      } else {
        if (p === 0)
          return l[y] = !0, n(f, A, g);
        s.push(
          l[y] = {
            feature: f,
            layer: A,
            geometry: g,
            distanceSq: p,
            callback: n
          }
        );
      }
    };
    let c;
    const u = [this.replayGroup_];
    return this.declutterExecutorGroup && u.push(this.declutterExecutorGroup), u.some((f) => c = f.forEachFeatureAtCoordinate(
      e,
      a,
      o,
      r,
      h,
      f === this.declutterExecutorGroup && t.declutterTree ? t.declutterTree.all().map((g) => g.value) : null
    )), c;
  }
  /**
   * Perform action necessary to get the layer rendered after new fonts have loaded
   */
  handleFontsChanged() {
    const e = this.getLayer();
    e.getVisible() && this.replayGroup_ && e.changed();
  }
  /**
   * Handle changes in image style state.
   * @param {import("../../events/Event.js").default} event Image style change event.
   * @private
   */
  handleStyleImageChange_(e) {
    this.renderIfReadyAndVisible();
  }
  /**
   * Determine whether render should be called.
   * @param {import("../../Map.js").FrameState} frameState Frame state.
   * @return {boolean} Layer is ready to be rendered.
   */
  prepareFrame(e) {
    const t = this.getLayer(), r = t.getSource();
    if (!r)
      return !1;
    const n = e.viewHints[ei.ANIMATING], s = e.viewHints[ei.INTERACTING], a = t.getUpdateWhileAnimating(), o = t.getUpdateWhileInteracting();
    if (this.ready && !a && n || !o && s)
      return this.animatingOrInteracting_ = !0, !0;
    this.animatingOrInteracting_ = !1;
    const A = e.extent, l = e.viewState, h = l.projection, c = l.resolution, u = e.pixelRatio, f = t.getRevision(), g = t.getRenderBuffer();
    let p = t.getRenderOrder();
    p === void 0 && (p = pV);
    const y = l.center.slice(), v = zn(
      A,
      g * c
    ), w = v.slice(), C = [v.slice()], E = h.getExtent();
    if (r.getWrapX() && h.canWrapX() && !Ps(E, e.extent)) {
      const X = ir(E), W = Math.max(ir(v) / 2, X);
      v[0] = E[0] - W, v[2] = E[2] + W, Nv(y, h);
      const q = lE(C[0], h);
      q[0] < E[0] && q[2] < E[2] ? C.push([
        q[0] + X,
        q[1],
        q[2] + X,
        q[3]
      ]) : q[0] > E[0] && q[2] > E[2] && C.push([
        q[0] - X,
        q[1],
        q[2] - X,
        q[3]
      ]);
    }
    if (this.ready && this.renderedResolution_ == c && this.renderedRevision_ == f && this.renderedRenderOrder_ == p && Ps(this.wrappedRenderedExtent_, v))
      return Za(this.renderedExtent_, w) || (this.hitDetectionImageData_ = null, this.renderedExtent_ = w), this.renderedCenter_ = y, this.replayGroupChanged = !1, !0;
    this.replayGroup_ = null;
    const S = new Qm(
      a2(c, u),
      v,
      c,
      u
    );
    let M;
    this.getLayer().getDeclutter() && (M = new Qm(
      a2(c, u),
      v,
      c,
      u
    ));
    let T;
    for (let X = 0, W = C.length; X < W; ++X)
      r.loadFeatures(C[X], c, h);
    const F = w4(c, u);
    let k = !0;
    const $ = (
      /**
       * @param {import("../../Feature.js").default} feature Feature.
       */
      (X) => {
        let W;
        const q = X.getStyleFunction() || t.getStyleFunction();
        if (q && (W = q(X, c)), W) {
          const Z = this.renderFeature(
            X,
            F,
            W,
            S,
            T,
            M
          );
          k = k && !Z;
        }
      }
    ), I = fg(v), L = r.getFeaturesInExtent(I);
    p && L.sort(p);
    for (let X = 0, W = L.length; X < W; ++X)
      $(L[X]);
    this.renderedFeatures_ = L, this.ready = k;
    const P = S.finish(), Q = new Dm(
      v,
      c,
      u,
      r.getOverlaps(),
      P,
      t.getRenderBuffer()
    );
    return M && (this.declutterExecutorGroup = new Dm(
      v,
      c,
      u,
      r.getOverlaps(),
      M.finish(),
      t.getRenderBuffer()
    )), this.renderedResolution_ = c, this.renderedRevision_ = f, this.renderedRenderOrder_ = p, this.renderedExtent_ = w, this.wrappedRenderedExtent_ = v, this.renderedCenter_ = y, this.renderedProjection_ = h, this.replayGroup_ = Q, this.hitDetectionImageData_ = null, this.replayGroupChanged = !0, !0;
  }
  /**
   * @param {import("../../Feature.js").default} feature Feature.
   * @param {number} squaredTolerance Squared render tolerance.
   * @param {import("../../style/Style.js").default|Array<import("../../style/Style.js").default>} styles The style or array of styles.
   * @param {import("../../render/canvas/BuilderGroup.js").default} builderGroup Builder group.
   * @param {import("../../proj.js").TransformFunction} [transform] Transform from user to view projection.
   * @param {import("../../render/canvas/BuilderGroup.js").default} [declutterBuilderGroup] Builder for decluttering.
   * @return {boolean} `true` if an image is loading.
   */
  renderFeature(e, t, r, n, s, a) {
    if (!r)
      return !1;
    let o = !1;
    if (Array.isArray(r))
      for (let A = 0, l = r.length; A < l; ++A)
        o = km(
          n,
          e,
          r[A],
          t,
          this.boundHandleStyleImageChange_,
          s,
          a
        ) || o;
    else
      o = km(
        n,
        e,
        r,
        t,
        this.boundHandleStyleImageChange_,
        s,
        a
      );
    return o;
  }
}
const SV = bV;
let TV = class extends zv {
  /**
   * @param {import("./BaseVector.js").Options<VectorSourceType>} [options] Options.
   */
  constructor(e) {
    super(e);
  }
  createRenderer() {
    return new SV(this);
  }
};
const nA = TV, FV = {
  extends: Th,
  name: "ol-vector-layer",
  setup(i) {
    const e = _t("map"), { properties: t } = sr(i), r = cr(() => new nA(t));
    return at(t, () => {
      r.value.setProperties(t);
    }), tr(() => {
      e.addLayer(r.value);
    }), nr(() => {
      e.removeLayer(r.value);
    }), Ur("vectorLayer", r), Ur("stylable", r), {
      vectorLayer: r
    };
  },
  props: {
    renderBuffer: {
      type: Number,
      default: 100
    },
    updateWhileAnimating: {
      type: Boolean,
      default: !1
    },
    style: {
      type: Function
    },
    updateWhileInteracting: {
      type: Boolean,
      default: !1
    }
  }
};
function LV(i, e, t, r, n, s) {
  return xn(), Cn("div", null, [
    mr(i.$slots, "default")
  ]);
}
const o2 = /* @__PURE__ */ qe(FV, [["render", LV]]);
class IV extends $M {
  clear() {
    for (; this.getCount() > 0; )
      this.pop().release();
    super.clear();
  }
  /**
   * @param {!Object<string, boolean>} usedTiles Used tiles.
   */
  expireCache(e) {
    for (; this.canExpireCache() && !(this.peekLast().getKey() in e); )
      this.pop().release();
  }
  /**
   * Prune all tiles from the cache that don't have the same z as the newest tile.
   */
  pruneExceptNewestZ() {
    if (this.getCount() === 0)
      return;
    const e = this.peekFirstKey(), r = o9(e)[0];
    this.forEach((n) => {
      n.tileCoord[0] !== r && (this.remove(Vd(n.tileCoord)), n.release());
    });
  }
}
const C4 = IV, z1 = {
  /**
   * Triggered when a tile starts loading.
   * @event module:ol/source/Tile.TileSourceEvent#tileloadstart
   * @api
   */
  TILELOADSTART: "tileloadstart",
  /**
   * Triggered when a tile finishes loading, either when its data is loaded,
   * or when loading was aborted because the tile is no longer needed.
   * @event module:ol/source/Tile.TileSourceEvent#tileloadend
   * @api
   */
  TILELOADEND: "tileloadend",
  /**
   * Triggered if tile loading results in an error. Note that this is not the
   * right place to re-fetch tiles. See {@link module:ol/ImageTile~ImageTile#load}
   * for details.
   * @event module:ol/source/Tile.TileSourceEvent#tileloaderror
   * @api
   */
  TILELOADERROR: "tileloaderror"
};
class RV extends ws {
  /**
   * @param {Options} options Source options.
   */
  constructor(e) {
    super(), this.projection = Ct(e.projection), this.attributions_ = B5(e.attributions), this.attributionsCollapsible_ = e.attributionsCollapsible !== void 0 ? e.attributionsCollapsible : !0, this.loading = !1, this.state_ = e.state !== void 0 ? e.state : "ready", this.wrapX_ = e.wrapX !== void 0 ? e.wrapX : !1, this.interpolate_ = !!e.interpolate, this.viewResolver = null, this.viewRejector = null;
    const t = this;
    this.viewPromise_ = new Promise(function(r, n) {
      t.viewResolver = r, t.viewRejector = n;
    });
  }
  /**
   * Get the attribution function for the source.
   * @return {?Attribution} Attribution function.
   * @api
   */
  getAttributions() {
    return this.attributions_;
  }
  /**
   * @return {boolean} Attributions are collapsible.
   * @api
   */
  getAttributionsCollapsible() {
    return this.attributionsCollapsible_;
  }
  /**
   * Get the projection of the source.
   * @return {import("../proj/Projection.js").default|null} Projection.
   * @api
   */
  getProjection() {
    return this.projection;
  }
  /**
   * @param {import("../proj/Projection").default} [projection] Projection.
   * @return {Array<number>|null} Resolutions.
   */
  getResolutions(e) {
    return null;
  }
  /**
   * @return {Promise<import("../View.js").ViewOptions>} A promise for view-related properties.
   */
  getView() {
    return this.viewPromise_;
  }
  /**
   * Get the state of the source, see {@link import("./Source.js").State} for possible states.
   * @return {import("./Source.js").State} State.
   * @api
   */
  getState() {
    return this.state_;
  }
  /**
   * @return {boolean|undefined} Wrap X.
   */
  getWrapX() {
    return this.wrapX_;
  }
  /**
   * @return {boolean} Use linear interpolation when resampling.
   */
  getInterpolate() {
    return this.interpolate_;
  }
  /**
   * Refreshes the source. The source will be cleared, and data from the server will be reloaded.
   * @api
   */
  refresh() {
    this.changed();
  }
  /**
   * Set the attributions of the source.
   * @param {AttributionLike|undefined} attributions Attributions.
   *     Can be passed as `string`, `Array<string>`, {@link module:ol/source/Source~Attribution},
   *     or `undefined`.
   * @api
   */
  setAttributions(e) {
    this.attributions_ = B5(e), this.changed();
  }
  /**
   * Set the state of the source.
   * @param {import("./Source.js").State} state State.
   */
  setState(e) {
    this.state_ = e, this.changed();
  }
}
function B5(i) {
  return i ? Array.isArray(i) ? function(e) {
    return i;
  } : typeof i == "function" ? i : function(e) {
    return [i];
  } : null;
}
const Xv = RV, oc = [0, 0, 0], LA = 5;
class MV {
  /**
   * @param {Options} options Tile grid options.
   */
  constructor(e) {
    this.minZoom = e.minZoom !== void 0 ? e.minZoom : 0, this.resolutions_ = e.resolutions, lt(
      EQ(
        this.resolutions_,
        function(n, s) {
          return s - n;
        },
        !0
      ),
      17
    );
    let t;
    if (!e.origins) {
      for (let n = 0, s = this.resolutions_.length - 1; n < s; ++n)
        if (!t)
          t = this.resolutions_[n] / this.resolutions_[n + 1];
        else if (this.resolutions_[n] / this.resolutions_[n + 1] !== t) {
          t = void 0;
          break;
        }
    }
    this.zoomFactor_ = t, this.maxZoom = this.resolutions_.length - 1, this.origin_ = e.origin !== void 0 ? e.origin : null, this.origins_ = null, e.origins !== void 0 && (this.origins_ = e.origins, lt(this.origins_.length == this.resolutions_.length, 20));
    const r = e.extent;
    r !== void 0 && !this.origin_ && !this.origins_ && (this.origin_ = Sa(r)), lt(
      !this.origin_ && this.origins_ || this.origin_ && !this.origins_,
      18
    ), this.tileSizes_ = null, e.tileSizes !== void 0 && (this.tileSizes_ = e.tileSizes, lt(this.tileSizes_.length == this.resolutions_.length, 19)), this.tileSize_ = e.tileSize !== void 0 ? e.tileSize : this.tileSizes_ ? null : cE, lt(
      !this.tileSize_ && this.tileSizes_ || this.tileSize_ && !this.tileSizes_,
      22
    ), this.extent_ = r !== void 0 ? r : null, this.fullTileRanges_ = null, this.tmpSize_ = [0, 0], this.tmpExtent_ = [0, 0, 0, 0], e.sizes !== void 0 ? this.fullTileRanges_ = e.sizes.map(function(n, s) {
      const a = new WE(
        Math.min(0, n[0]),
        Math.max(n[0] - 1, -1),
        Math.min(0, n[1]),
        Math.max(n[1] - 1, -1)
      );
      if (r) {
        const o = this.getTileRangeForExtentAndZ(r, s);
        a.minX = Math.max(o.minX, a.minX), a.maxX = Math.min(o.maxX, a.maxX), a.minY = Math.max(o.minY, a.minY), a.maxY = Math.min(o.maxY, a.maxY);
      }
      return a;
    }, this) : r && this.calculateTileRanges_(r);
  }
  /**
   * Call a function with each tile coordinate for a given extent and zoom level.
   *
   * @param {import("../extent.js").Extent} extent Extent.
   * @param {number} zoom Integer zoom level.
   * @param {function(import("../tilecoord.js").TileCoord): void} callback Function called with each tile coordinate.
   * @api
   */
  forEachTileCoord(e, t, r) {
    const n = this.getTileRangeForExtentAndZ(e, t);
    for (let s = n.minX, a = n.maxX; s <= a; ++s)
      for (let o = n.minY, A = n.maxY; o <= A; ++o)
        r([t, s, o]);
  }
  /**
   * @param {import("../tilecoord.js").TileCoord} tileCoord Tile coordinate.
   * @param {function(number, import("../TileRange.js").default): boolean} callback Callback.
   * @param {import("../TileRange.js").default} [tempTileRange] Temporary import("../TileRange.js").default object.
   * @param {import("../extent.js").Extent} [tempExtent] Temporary import("../extent.js").Extent object.
   * @return {boolean} Callback succeeded.
   */
  forEachTileCoordParentTileRange(e, t, r, n) {
    let s, a, o, A = null, l = e[0] - 1;
    for (this.zoomFactor_ === 2 ? (a = e[1], o = e[2]) : A = this.getTileCoordExtent(e, n); l >= this.minZoom; ) {
      if (this.zoomFactor_ === 2 ? (a = Math.floor(a / 2), o = Math.floor(o / 2), s = nc(a, a, o, o, r)) : s = this.getTileRangeForExtentAndZ(
        A,
        l,
        r
      ), t(l, s))
        return !0;
      --l;
    }
    return !1;
  }
  /**
   * Get the extent for this tile grid, if it was configured.
   * @return {import("../extent.js").Extent} Extent.
   * @api
   */
  getExtent() {
    return this.extent_;
  }
  /**
   * Get the maximum zoom level for the grid.
   * @return {number} Max zoom.
   * @api
   */
  getMaxZoom() {
    return this.maxZoom;
  }
  /**
   * Get the minimum zoom level for the grid.
   * @return {number} Min zoom.
   * @api
   */
  getMinZoom() {
    return this.minZoom;
  }
  /**
   * Get the origin for the grid at the given zoom level.
   * @param {number} z Integer zoom level.
   * @return {import("../coordinate.js").Coordinate} Origin.
   * @api
   */
  getOrigin(e) {
    return this.origin_ ? this.origin_ : this.origins_[e];
  }
  /**
   * Get the resolution for the given zoom level.
   * @param {number} z Integer zoom level.
   * @return {number} Resolution.
   * @api
   */
  getResolution(e) {
    return this.resolutions_[e];
  }
  /**
   * Get the list of resolutions for the tile grid.
   * @return {Array<number>} Resolutions.
   * @api
   */
  getResolutions() {
    return this.resolutions_;
  }
  /**
   * @param {import("../tilecoord.js").TileCoord} tileCoord Tile coordinate.
   * @param {import("../TileRange.js").default} [tempTileRange] Temporary import("../TileRange.js").default object.
   * @param {import("../extent.js").Extent} [tempExtent] Temporary import("../extent.js").Extent object.
   * @return {import("../TileRange.js").default|null} Tile range.
   */
  getTileCoordChildTileRange(e, t, r) {
    if (e[0] < this.maxZoom) {
      if (this.zoomFactor_ === 2) {
        const s = e[1] * 2, a = e[2] * 2;
        return nc(
          s,
          s + 1,
          a,
          a + 1,
          t
        );
      }
      const n = this.getTileCoordExtent(
        e,
        r || this.tmpExtent_
      );
      return this.getTileRangeForExtentAndZ(
        n,
        e[0] + 1,
        t
      );
    }
    return null;
  }
  /**
   * @param {import("../tilecoord.js").TileCoord} tileCoord Tile coordinate.
   * @param {number} z Integer zoom level.
   * @param {import("../TileRange.js").default} [tempTileRange] Temporary import("../TileRange.js").default object.
   * @return {import("../TileRange.js").default|null} Tile range.
   */
  getTileRangeForTileCoordAndZ(e, t, r) {
    if (t > this.maxZoom || t < this.minZoom)
      return null;
    const n = e[0], s = e[1], a = e[2];
    if (t === n)
      return nc(
        s,
        a,
        s,
        a,
        r
      );
    if (this.zoomFactor_) {
      const A = Math.pow(this.zoomFactor_, t - n), l = Math.floor(s * A), h = Math.floor(a * A);
      if (t < n)
        return nc(l, l, h, h, r);
      const c = Math.floor(A * (s + 1)) - 1, u = Math.floor(A * (a + 1)) - 1;
      return nc(l, c, h, u, r);
    }
    const o = this.getTileCoordExtent(e, this.tmpExtent_);
    return this.getTileRangeForExtentAndZ(o, t, r);
  }
  /**
   * Get the extent for a tile range.
   * @param {number} z Integer zoom level.
   * @param {import("../TileRange.js").default} tileRange Tile range.
   * @param {import("../extent.js").Extent} [tempExtent] Temporary import("../extent.js").Extent object.
   * @return {import("../extent.js").Extent} Extent.
   */
  getTileRangeExtent(e, t, r) {
    const n = this.getOrigin(e), s = this.getResolution(e), a = An(this.getTileSize(e), this.tmpSize_), o = n[0] + t.minX * a[0] * s, A = n[0] + (t.maxX + 1) * a[0] * s, l = n[1] + t.minY * a[1] * s, h = n[1] + (t.maxY + 1) * a[1] * s;
    return ms(o, l, A, h, r);
  }
  /**
   * Get a tile range for the given extent and integer zoom level.
   * @param {import("../extent.js").Extent} extent Extent.
   * @param {number} z Integer zoom level.
   * @param {import("../TileRange.js").default} [tempTileRange] Temporary tile range object.
   * @return {import("../TileRange.js").default} Tile range.
   */
  getTileRangeForExtentAndZ(e, t, r) {
    this.getTileCoordForXYAndZ_(e[0], e[3], t, !1, oc);
    const n = oc[1], s = oc[2];
    this.getTileCoordForXYAndZ_(e[2], e[1], t, !0, oc);
    const a = oc[1], o = oc[2];
    return nc(n, a, s, o, r);
  }
  /**
   * @param {import("../tilecoord.js").TileCoord} tileCoord Tile coordinate.
   * @return {import("../coordinate.js").Coordinate} Tile center.
   */
  getTileCoordCenter(e) {
    const t = this.getOrigin(e[0]), r = this.getResolution(e[0]), n = An(this.getTileSize(e[0]), this.tmpSize_);
    return [
      t[0] + (e[1] + 0.5) * n[0] * r,
      t[1] - (e[2] + 0.5) * n[1] * r
    ];
  }
  /**
   * Get the extent of a tile coordinate.
   *
   * @param {import("../tilecoord.js").TileCoord} tileCoord Tile coordinate.
   * @param {import("../extent.js").Extent} [tempExtent] Temporary extent object.
   * @return {import("../extent.js").Extent} Extent.
   * @api
   */
  getTileCoordExtent(e, t) {
    const r = this.getOrigin(e[0]), n = this.getResolution(e[0]), s = An(this.getTileSize(e[0]), this.tmpSize_), a = r[0] + e[1] * s[0] * n, o = r[1] - (e[2] + 1) * s[1] * n, A = a + s[0] * n, l = o + s[1] * n;
    return ms(a, o, A, l, t);
  }
  /**
   * Get the tile coordinate for the given map coordinate and resolution.  This
   * method considers that coordinates that intersect tile boundaries should be
   * assigned the higher tile coordinate.
   *
   * @param {import("../coordinate.js").Coordinate} coordinate Coordinate.
   * @param {number} resolution Resolution.
   * @param {import("../tilecoord.js").TileCoord} [opt_tileCoord] Destination import("../tilecoord.js").TileCoord object.
   * @return {import("../tilecoord.js").TileCoord} Tile coordinate.
   * @api
   */
  getTileCoordForCoordAndResolution(e, t, r) {
    return this.getTileCoordForXYAndResolution_(
      e[0],
      e[1],
      t,
      !1,
      r
    );
  }
  /**
   * Note that this method should not be called for resolutions that correspond
   * to an integer zoom level.  Instead call the `getTileCoordForXYAndZ_` method.
   * @param {number} x X.
   * @param {number} y Y.
   * @param {number} resolution Resolution (for a non-integer zoom level).
   * @param {boolean} reverseIntersectionPolicy Instead of letting edge
   *     intersections go to the higher tile coordinate, let edge intersections
   *     go to the lower tile coordinate.
   * @param {import("../tilecoord.js").TileCoord} [opt_tileCoord] Temporary import("../tilecoord.js").TileCoord object.
   * @return {import("../tilecoord.js").TileCoord} Tile coordinate.
   * @private
   */
  getTileCoordForXYAndResolution_(e, t, r, n, s) {
    const a = this.getZForResolution(r), o = r / this.getResolution(a), A = this.getOrigin(a), l = An(this.getTileSize(a), this.tmpSize_);
    let h = o * (e - A[0]) / r / l[0], c = o * (A[1] - t) / r / l[1];
    return n ? (h = KA(h, LA) - 1, c = KA(c, LA) - 1) : (h = Nc(h, LA), c = Nc(c, LA)), $d(a, h, c, s);
  }
  /**
   * Although there is repetition between this method and `getTileCoordForXYAndResolution_`,
   * they should have separate implementations.  This method is for integer zoom
   * levels.  The other method should only be called for resolutions corresponding
   * to non-integer zoom levels.
   * @param {number} x Map x coordinate.
   * @param {number} y Map y coordinate.
   * @param {number} z Integer zoom level.
   * @param {boolean} reverseIntersectionPolicy Instead of letting edge
   *     intersections go to the higher tile coordinate, let edge intersections
   *     go to the lower tile coordinate.
   * @param {import("../tilecoord.js").TileCoord} [opt_tileCoord] Temporary import("../tilecoord.js").TileCoord object.
   * @return {import("../tilecoord.js").TileCoord} Tile coordinate.
   * @private
   */
  getTileCoordForXYAndZ_(e, t, r, n, s) {
    const a = this.getOrigin(r), o = this.getResolution(r), A = An(this.getTileSize(r), this.tmpSize_);
    let l = (e - a[0]) / o / A[0], h = (a[1] - t) / o / A[1];
    return n ? (l = KA(l, LA) - 1, h = KA(h, LA) - 1) : (l = Nc(l, LA), h = Nc(h, LA)), $d(r, l, h, s);
  }
  /**
   * Get a tile coordinate given a map coordinate and zoom level.
   * @param {import("../coordinate.js").Coordinate} coordinate Coordinate.
   * @param {number} z Zoom level.
   * @param {import("../tilecoord.js").TileCoord} [opt_tileCoord] Destination import("../tilecoord.js").TileCoord object.
   * @return {import("../tilecoord.js").TileCoord} Tile coordinate.
   * @api
   */
  getTileCoordForCoordAndZ(e, t, r) {
    return this.getTileCoordForXYAndZ_(
      e[0],
      e[1],
      t,
      !1,
      r
    );
  }
  /**
   * @param {import("../tilecoord.js").TileCoord} tileCoord Tile coordinate.
   * @return {number} Tile resolution.
   */
  getTileCoordResolution(e) {
    return this.resolutions_[e[0]];
  }
  /**
   * Get the tile size for a zoom level. The type of the return value matches the
   * `tileSize` or `tileSizes` that the tile grid was configured with. To always
   * get an {@link import("../size.js").Size}, run the result through {@link module:ol/size.toSize}.
   * @param {number} z Z.
   * @return {number|import("../size.js").Size} Tile size.
   * @api
   */
  getTileSize(e) {
    return this.tileSize_ ? this.tileSize_ : this.tileSizes_[e];
  }
  /**
   * @param {number} z Zoom level.
   * @return {import("../TileRange.js").default} Extent tile range for the specified zoom level.
   */
  getFullTileRange(e) {
    return this.fullTileRanges_ ? this.fullTileRanges_[e] : this.extent_ ? this.getTileRangeForExtentAndZ(this.extent_, e) : null;
  }
  /**
   * @param {number} resolution Resolution.
   * @param {number|import("../array.js").NearestDirectionFunction} [opt_direction]
   *     If 0, the nearest resolution will be used.
   *     If 1, the nearest higher resolution (lower Z) will be used. If -1, the
   *     nearest lower resolution (higher Z) will be used. Default is 0.
   *     Use a {@link module:ol/array~NearestDirectionFunction} for more precise control.
   *
   * For example to change tile Z at the midpoint of zoom levels
   * ```js
   * function(value, high, low) {
   *   return value - low * Math.sqrt(high / low);
   * }
   * ```
   * @return {number} Z.
   * @api
   */
  getZForResolution(e, t) {
    const r = Lv(
      this.resolutions_,
      e,
      t || 0
    );
    return jr(r, this.minZoom, this.maxZoom);
  }
  /**
   * The tile with the provided tile coordinate intersects the given viewport.
   * @param {import('../tilecoord.js').TileCoord} tileCoord Tile coordinate.
   * @param {Array<number>} viewport Viewport as returned from {@link module:ol/extent.getRotatedViewport}.
   * @return {boolean} The tile with the provided tile coordinate intersects the given viewport.
   */
  tileCoordIntersectsViewport(e, t) {
    return WR(
      t,
      0,
      t.length,
      2,
      this.getTileCoordExtent(e)
    );
  }
  /**
   * @param {!import("../extent.js").Extent} extent Extent for this tile grid.
   * @private
   */
  calculateTileRanges_(e) {
    const t = this.resolutions_.length, r = new Array(t);
    for (let n = this.minZoom; n < t; ++n)
      r[n] = this.getTileRangeForExtentAndZ(e, n);
    this.fullTileRanges_ = r;
  }
}
const sB = MV;
function E4(i) {
  let e = i.getDefaultTileGrid();
  return e || (e = OV(i), i.setDefaultTileGrid(e)), e;
}
function NV(i, e, t) {
  const r = e[0], n = i.getTileCoordCenter(e), s = Wv(t);
  if (!Wo(s, n)) {
    const a = ir(s), o = Math.ceil(
      (s[0] - n[0]) / a
    );
    return n[0] += a * o, i.getTileCoordForCoordAndZ(n, r);
  }
  return e;
}
function PV(i, e, t, r) {
  r = r !== void 0 ? r : "top-left";
  const n = b4(i, e, t);
  return new sB({
    extent: i,
    origin: xR(i, r),
    resolutions: n,
    tileSize: t
  });
}
function B4(i) {
  const e = i || {}, t = e.extent || Ct("EPSG:3857").getExtent(), r = {
    extent: t,
    minZoom: e.minZoom,
    tileSize: e.tileSize,
    resolutions: b4(
      t,
      e.maxZoom,
      e.tileSize,
      e.maxResolution
    )
  };
  return new sB(r);
}
function b4(i, e, t, r) {
  e = e !== void 0 ? e : rD, t = An(t !== void 0 ? t : cE);
  const n = _i(i), s = ir(i);
  r = r > 0 ? r : Math.max(s / t[0], n / t[1]);
  const a = e + 1, o = new Array(a);
  for (let A = 0; A < a; ++A)
    o[A] = r / Math.pow(2, A);
  return o;
}
function OV(i, e, t, r) {
  const n = Wv(i);
  return PV(n, e, t, r);
}
function Wv(i) {
  i = Ct(i);
  let e = i.getExtent();
  if (!e) {
    const t = 180 * cu.degrees / i.getMetersPerUnit();
    e = ms(-t, -t, t, t);
  }
  return e;
}
class UV extends Xv {
  /**
   * @param {Options} options SourceTile source options.
   */
  constructor(e) {
    super({
      attributions: e.attributions,
      attributionsCollapsible: e.attributionsCollapsible,
      projection: e.projection,
      state: e.state,
      wrapX: e.wrapX,
      interpolate: e.interpolate
    }), this.on, this.once, this.un, this.opaque_ = e.opaque !== void 0 ? e.opaque : !1, this.tilePixelRatio_ = e.tilePixelRatio !== void 0 ? e.tilePixelRatio : 1, this.tileGrid = e.tileGrid !== void 0 ? e.tileGrid : null;
    const t = [256, 256];
    this.tileGrid && An(this.tileGrid.getTileSize(this.tileGrid.getMinZoom()), t), this.tileCache = new C4(e.cacheSize || 0), this.tmpSize = [0, 0], this.key_ = e.key || "", this.tileOptions = {
      transition: e.transition,
      interpolate: e.interpolate
    }, this.zDirection = e.zDirection ? e.zDirection : 0;
  }
  /**
   * @return {boolean} Can expire cache.
   */
  canExpireCache() {
    return this.tileCache.canExpireCache();
  }
  /**
   * @param {import("../proj/Projection.js").default} projection Projection.
   * @param {!Object<string, boolean>} usedTiles Used tiles.
   */
  expireCache(e, t) {
    const r = this.getTileCacheForProjection(e);
    r && r.expireCache(t);
  }
  /**
   * @param {import("../proj/Projection.js").default} projection Projection.
   * @param {number} z Zoom level.
   * @param {import("../TileRange.js").default} tileRange Tile range.
   * @param {function(import("../Tile.js").default):(boolean|void)} callback Called with each
   *     loaded tile.  If the callback returns `false`, the tile will not be
   *     considered loaded.
   * @return {boolean} The tile range is fully covered with loaded tiles.
   */
  forEachLoadedTile(e, t, r, n) {
    const s = this.getTileCacheForProjection(e);
    if (!s)
      return !1;
    let a = !0, o, A, l;
    for (let h = r.minX; h <= r.maxX; ++h)
      for (let c = r.minY; c <= r.maxY; ++c)
        A = Vv(t, h, c), l = !1, s.containsKey(A) && (o = /** @type {!import("../Tile.js").default} */
        s.get(A), l = o.getState() === He.LOADED, l && (l = n(o) !== !1)), l || (a = !1);
    return a;
  }
  /**
   * @param {import("../proj/Projection.js").default} projection Projection.
   * @return {number} Gutter.
   */
  getGutterForProjection(e) {
    return 0;
  }
  /**
   * Return the key to be used for all tiles in the source.
   * @return {string} The key for all tiles.
   */
  getKey() {
    return this.key_;
  }
  /**
   * Set the value to be used as the key for all tiles in the source.
   * @param {string} key The key for tiles.
   * @protected
   */
  setKey(e) {
    this.key_ !== e && (this.key_ = e, this.changed());
  }
  /**
   * @param {import("../proj/Projection.js").default} projection Projection.
   * @return {boolean} Opaque.
   */
  getOpaque(e) {
    return this.opaque_;
  }
  /**
   * @param {import("../proj/Projection").default} [projection] Projection.
   * @return {Array<number>|null} Resolutions.
   */
  getResolutions(e) {
    const t = e ? this.getTileGridForProjection(e) : this.tileGrid;
    return t ? t.getResolutions() : null;
  }
  /**
   * @abstract
   * @param {number} z Tile coordinate z.
   * @param {number} x Tile coordinate x.
   * @param {number} y Tile coordinate y.
   * @param {number} pixelRatio Pixel ratio.
   * @param {import("../proj/Projection.js").default} projection Projection.
   * @return {!import("../Tile.js").default} Tile.
   */
  getTile(e, t, r, n, s) {
    return pt();
  }
  /**
   * Return the tile grid of the tile source.
   * @return {import("../tilegrid/TileGrid.js").default|null} Tile grid.
   * @api
   */
  getTileGrid() {
    return this.tileGrid;
  }
  /**
   * @param {import("../proj/Projection.js").default} projection Projection.
   * @return {!import("../tilegrid/TileGrid.js").default} Tile grid.
   */
  getTileGridForProjection(e) {
    return this.tileGrid ? this.tileGrid : E4(e);
  }
  /**
   * @param {import("../proj/Projection.js").default} projection Projection.
   * @return {import("../TileCache.js").default} Tile cache.
   * @protected
   */
  getTileCacheForProjection(e) {
    const t = this.getProjection();
    return lt(
      t === null || Da(t, e),
      68
      // A VectorTile source can only be rendered if it has a projection compatible with the view projection.
    ), this.tileCache;
  }
  /**
   * Get the tile pixel ratio for this source. Subclasses may override this
   * method, which is meant to return a supported pixel ratio that matches the
   * provided `pixelRatio` as close as possible.
   * @param {number} pixelRatio Pixel ratio.
   * @return {number} Tile pixel ratio.
   */
  getTilePixelRatio(e) {
    return this.tilePixelRatio_;
  }
  /**
   * @param {number} z Z.
   * @param {number} pixelRatio Pixel ratio.
   * @param {import("../proj/Projection.js").default} projection Projection.
   * @return {import("../size.js").Size} Tile size.
   */
  getTilePixelSize(e, t, r) {
    const n = this.getTileGridForProjection(r), s = this.getTilePixelRatio(t), a = An(n.getTileSize(e), this.tmpSize);
    return s == 1 ? a : AM(a, s, this.tmpSize);
  }
  /**
   * Returns a tile coordinate wrapped around the x-axis. When the tile coordinate
   * is outside the resolution and extent range of the tile grid, `null` will be
   * returned.
   * @param {import("../tilecoord.js").TileCoord} tileCoord Tile coordinate.
   * @param {import("../proj/Projection.js").default} [projection] Projection.
   * @return {import("../tilecoord.js").TileCoord} Tile coordinate to be passed to the tileUrlFunction or
   *     null if no tile URL should be created for the passed `tileCoord`.
   */
  getTileCoordForTileUrlFunction(e, t) {
    t = t !== void 0 ? t : this.getProjection();
    const r = this.getTileGridForProjection(t);
    return this.getWrapX() && t.isGlobal() && (e = NV(r, e, t)), A9(e, r) ? e : null;
  }
  /**
   * Remove all cached tiles from the source. The next render cycle will fetch new tiles.
   * @api
   */
  clear() {
    this.tileCache.clear();
  }
  refresh() {
    this.clear(), super.refresh();
  }
  /**
   * Increases the cache size if needed
   * @param {number} tileCount Minimum number of tiles needed.
   * @param {import("../proj/Projection.js").default} projection Projection.
   */
  updateCacheSize(e, t) {
    const r = this.getTileCacheForProjection(t);
    e > r.highWaterMark && (r.highWaterMark = e);
  }
  /**
   * Marks a tile coord as being used, without triggering a load.
   * @abstract
   * @param {number} z Tile coordinate z.
   * @param {number} x Tile coordinate x.
   * @param {number} y Tile coordinate y.
   * @param {import("../proj/Projection.js").default} projection Projection.
   */
  useTile(e, t, r, n) {
  }
}
class QV extends _s {
  /**
   * @param {string} type Type.
   * @param {import("../Tile.js").default} tile The tile.
   */
  constructor(e, t) {
    super(e), this.tile = t;
  }
}
const S4 = UV;
function DV(i, e) {
  const t = /\{z\}/g, r = /\{x\}/g, n = /\{y\}/g, s = /\{-y\}/g;
  return (
    /**
     * @param {import("./tilecoord.js").TileCoord} tileCoord Tile Coordinate.
     * @param {number} pixelRatio Pixel ratio.
     * @param {import("./proj/Projection.js").default} projection Projection.
     * @return {string|undefined} Tile URL.
     */
    function(a, o, A) {
      if (a)
        return i.replace(t, a[0].toString()).replace(r, a[1].toString()).replace(n, a[2].toString()).replace(s, function() {
          const l = a[0], h = e.getFullTileRange(l);
          return lt(h, 55), (h.getHeight() - a[2] - 1).toString();
        });
    }
  );
}
function kV(i, e) {
  const t = i.length, r = new Array(t);
  for (let n = 0; n < t; ++n)
    r[n] = DV(i[n], e);
  return Hm(r);
}
function Hm(i) {
  return i.length === 1 ? i[0] : (
    /**
     * @param {import("./tilecoord.js").TileCoord} tileCoord Tile Coordinate.
     * @param {number} pixelRatio Pixel ratio.
     * @param {import("./proj/Projection.js").default} projection Projection.
     * @return {string|undefined} Tile URL.
     */
    function(e, t, r) {
      if (!e)
        return;
      const n = qM(e), s = tl(n, i.length);
      return i[s](e, t, r);
    }
  );
}
function T4(i) {
  const e = [];
  let t = /\{([a-z])-([a-z])\}/.exec(i);
  if (t) {
    const r = t[1].charCodeAt(0), n = t[2].charCodeAt(0);
    let s;
    for (s = r; s <= n; ++s)
      e.push(i.replace(t[0], String.fromCharCode(s)));
    return e;
  }
  if (t = /\{(\d+)-(\d+)\}/.exec(i), t) {
    const r = parseInt(t[2], 10);
    for (let n = parseInt(t[1], 10); n <= r; n++)
      e.push(i.replace(t[0], n.toString()));
    return e;
  }
  return e.push(i), e;
}
class aB extends S4 {
  /**
   * @param {Options} options Image tile options.
   */
  constructor(e) {
    super({
      attributions: e.attributions,
      cacheSize: e.cacheSize,
      opaque: e.opaque,
      projection: e.projection,
      state: e.state,
      tileGrid: e.tileGrid,
      tilePixelRatio: e.tilePixelRatio,
      wrapX: e.wrapX,
      transition: e.transition,
      interpolate: e.interpolate,
      key: e.key,
      attributionsCollapsible: e.attributionsCollapsible,
      zDirection: e.zDirection
    }), this.generateTileUrlFunction_ = this.tileUrlFunction === aB.prototype.tileUrlFunction, this.tileLoadFunction = e.tileLoadFunction, e.tileUrlFunction && (this.tileUrlFunction = e.tileUrlFunction), this.urls = null, e.urls ? this.setUrls(e.urls) : e.url && this.setUrl(e.url), this.tileLoadingKeys_ = {};
  }
  /**
   * Return the tile load function of the source.
   * @return {import("../Tile.js").LoadFunction} TileLoadFunction
   * @api
   */
  getTileLoadFunction() {
    return this.tileLoadFunction;
  }
  /**
   * Return the tile URL function of the source.
   * @return {import("../Tile.js").UrlFunction} TileUrlFunction
   * @api
   */
  getTileUrlFunction() {
    return Object.getPrototypeOf(this).tileUrlFunction === this.tileUrlFunction ? this.tileUrlFunction.bind(this) : this.tileUrlFunction;
  }
  /**
   * Return the URLs used for this source.
   * When a tileUrlFunction is used instead of url or urls,
   * null will be returned.
   * @return {!Array<string>|null} URLs.
   * @api
   */
  getUrls() {
    return this.urls;
  }
  /**
   * Handle tile change events.
   * @param {import("../events/Event.js").default} event Event.
   * @protected
   */
  handleTileChange(e) {
    const t = (
      /** @type {import("../Tile.js").default} */
      e.target
    ), r = st(t), n = t.getState();
    let s;
    n == He.LOADING ? (this.tileLoadingKeys_[r] = !0, s = z1.TILELOADSTART) : r in this.tileLoadingKeys_ && (delete this.tileLoadingKeys_[r], s = n == He.ERROR ? z1.TILELOADERROR : n == He.LOADED ? z1.TILELOADEND : void 0), s != null && this.dispatchEvent(new QV(s, t));
  }
  /**
   * Set the tile load function of the source.
   * @param {import("../Tile.js").LoadFunction} tileLoadFunction Tile load function.
   * @api
   */
  setTileLoadFunction(e) {
    this.tileCache.clear(), this.tileLoadFunction = e, this.changed();
  }
  /**
   * Set the tile URL function of the source.
   * @param {import("../Tile.js").UrlFunction} tileUrlFunction Tile URL function.
   * @param {string} [key] Optional new tile key for the source.
   * @api
   */
  setTileUrlFunction(e, t) {
    this.tileUrlFunction = e, this.tileCache.pruneExceptNewestZ(), typeof t < "u" ? this.setKey(t) : this.changed();
  }
  /**
   * Set the URL to use for requests.
   * @param {string} url URL.
   * @api
   */
  setUrl(e) {
    const t = T4(e);
    this.urls = t, this.setUrls(t);
  }
  /**
   * Set the URLs to use for requests.
   * @param {Array<string>} urls URLs.
   * @api
   */
  setUrls(e) {
    this.urls = e;
    const t = e.join(`
`);
    this.generateTileUrlFunction_ ? this.setTileUrlFunction(kV(e, this.tileGrid), t) : this.setKey(t);
  }
  /**
   * @param {import("../tilecoord.js").TileCoord} tileCoord Tile coordinate.
   * @param {number} pixelRatio Pixel ratio.
   * @param {import("../proj/Projection.js").default} projection Projection.
   * @return {string|undefined} Tile URL.
   */
  tileUrlFunction(e, t, r) {
  }
  /**
   * Marks a tile coord as being used, without triggering a load.
   * @param {number} z Tile coordinate z.
   * @param {number} x Tile coordinate x.
   * @param {number} y Tile coordinate y.
   */
  useTile(e, t, r) {
    const n = Vv(e, t, r);
    this.tileCache.containsKey(n) && this.tileCache.get(n);
  }
}
const HV = aB;
class GV extends HV {
  /**
   * @param {!Options} options Image tile options.
   */
  constructor(e) {
    super({
      attributions: e.attributions,
      cacheSize: e.cacheSize,
      opaque: e.opaque,
      projection: e.projection,
      state: e.state,
      tileGrid: e.tileGrid,
      tileLoadFunction: e.tileLoadFunction ? e.tileLoadFunction : $V,
      tilePixelRatio: e.tilePixelRatio,
      tileUrlFunction: e.tileUrlFunction,
      url: e.url,
      urls: e.urls,
      wrapX: e.wrapX,
      transition: e.transition,
      interpolate: e.interpolate !== void 0 ? e.interpolate : !0,
      key: e.key,
      attributionsCollapsible: e.attributionsCollapsible,
      zDirection: e.zDirection
    }), this.crossOrigin = e.crossOrigin !== void 0 ? e.crossOrigin : null, this.tileClass = e.tileClass !== void 0 ? e.tileClass : Nm, this.tileCacheForProjection = {}, this.tileGridForProjection = {}, this.reprojectionErrorThreshold_ = e.reprojectionErrorThreshold, this.renderReprojectionEdges_ = !1;
  }
  /**
   * @return {boolean} Can expire cache.
   */
  canExpireCache() {
    if (this.tileCache.canExpireCache())
      return !0;
    for (const e in this.tileCacheForProjection)
      if (this.tileCacheForProjection[e].canExpireCache())
        return !0;
    return !1;
  }
  /**
   * @param {import("../proj/Projection.js").default} projection Projection.
   * @param {!Object<string, boolean>} usedTiles Used tiles.
   */
  expireCache(e, t) {
    const r = this.getTileCacheForProjection(e);
    this.tileCache.expireCache(
      this.tileCache == r ? t : {}
    );
    for (const n in this.tileCacheForProjection) {
      const s = this.tileCacheForProjection[n];
      s.expireCache(s == r ? t : {});
    }
  }
  /**
   * @param {import("../proj/Projection.js").default} projection Projection.
   * @return {number} Gutter.
   */
  getGutterForProjection(e) {
    return this.getProjection() && e && !Da(this.getProjection(), e) ? 0 : this.getGutter();
  }
  /**
   * @return {number} Gutter.
   */
  getGutter() {
    return 0;
  }
  /**
   * Return the key to be used for all tiles in the source.
   * @return {string} The key for all tiles.
   */
  getKey() {
    let e = super.getKey();
    return this.getInterpolate() || (e += ":disable-interpolation"), e;
  }
  /**
   * @param {import("../proj/Projection.js").default} projection Projection.
   * @return {boolean} Opaque.
   */
  getOpaque(e) {
    return this.getProjection() && e && !Da(this.getProjection(), e) ? !1 : super.getOpaque(e);
  }
  /**
   * @param {import("../proj/Projection.js").default} projection Projection.
   * @return {!import("../tilegrid/TileGrid.js").default} Tile grid.
   */
  getTileGridForProjection(e) {
    const t = this.getProjection();
    if (this.tileGrid && (!t || Da(t, e)))
      return this.tileGrid;
    const r = st(e);
    return r in this.tileGridForProjection || (this.tileGridForProjection[r] = E4(e)), this.tileGridForProjection[r];
  }
  /**
   * @param {import("../proj/Projection.js").default} projection Projection.
   * @return {import("../TileCache.js").default} Tile cache.
   */
  getTileCacheForProjection(e) {
    const t = this.getProjection();
    if (!t || Da(t, e))
      return this.tileCache;
    const r = st(e);
    return r in this.tileCacheForProjection || (this.tileCacheForProjection[r] = new C4(
      this.tileCache.highWaterMark
    )), this.tileCacheForProjection[r];
  }
  /**
   * @param {number} z Tile coordinate z.
   * @param {number} x Tile coordinate x.
   * @param {number} y Tile coordinate y.
   * @param {number} pixelRatio Pixel ratio.
   * @param {import("../proj/Projection.js").default} projection Projection.
   * @param {string} key The key set on the tile.
   * @return {!ImageTile} Tile.
   * @private
   */
  createTile_(e, t, r, n, s, a) {
    const o = [e, t, r], A = this.getTileCoordForTileUrlFunction(
      o,
      s
    ), l = A ? this.tileUrlFunction(A, n, s) : void 0, h = new this.tileClass(
      o,
      l !== void 0 ? He.IDLE : He.EMPTY,
      l !== void 0 ? l : "",
      this.crossOrigin,
      this.tileLoadFunction,
      this.tileOptions
    );
    return h.key = a, h.addEventListener(ut.CHANGE, this.handleTileChange.bind(this)), h;
  }
  /**
   * @param {number} z Tile coordinate z.
   * @param {number} x Tile coordinate x.
   * @param {number} y Tile coordinate y.
   * @param {number} pixelRatio Pixel ratio.
   * @param {import("../proj/Projection.js").default} projection Projection.
   * @return {!(ImageTile|ReprojTile)} Tile.
   */
  getTile(e, t, r, n, s) {
    const a = this.getProjection();
    if (!a || !s || Da(a, s))
      return this.getTileInternal(
        e,
        t,
        r,
        n,
        a || s
      );
    const o = this.getTileCacheForProjection(s), A = [e, t, r];
    let l;
    const h = Vd(A);
    o.containsKey(h) && (l = o.get(h));
    const c = this.getKey();
    if (l && l.key == c)
      return l;
    const u = this.getTileGridForProjection(a), f = this.getTileGridForProjection(s), g = this.getTileCoordForTileUrlFunction(
      A,
      s
    ), p = new _u(
      a,
      u,
      s,
      f,
      A,
      g,
      this.getTilePixelRatio(n),
      this.getGutter(),
      (y, v, w, C) => this.getTileInternal(y, v, w, C, a),
      this.reprojectionErrorThreshold_,
      this.renderReprojectionEdges_,
      this.getInterpolate()
    );
    return p.key = c, l ? (p.interimTile = l, p.refreshInterimChain(), o.replace(h, p)) : o.set(h, p), p;
  }
  /**
   * @param {number} z Tile coordinate z.
   * @param {number} x Tile coordinate x.
   * @param {number} y Tile coordinate y.
   * @param {number} pixelRatio Pixel ratio.
   * @param {!import("../proj/Projection.js").default} projection Projection.
   * @return {!ImageTile} Tile.
   * @protected
   */
  getTileInternal(e, t, r, n, s) {
    let a = null;
    const o = Vv(e, t, r), A = this.getKey();
    if (!this.tileCache.containsKey(o))
      a = this.createTile_(e, t, r, n, s, A), this.tileCache.set(o, a);
    else if (a = this.tileCache.get(o), a.key != A) {
      const l = a;
      a = this.createTile_(e, t, r, n, s, A), l.getState() == He.IDLE ? a.interimTile = l.interimTile : a.interimTile = l, a.refreshInterimChain(), this.tileCache.replace(o, a);
    }
    return a;
  }
  /**
   * Sets whether to render reprojection edges or not (usually for debugging).
   * @param {boolean} render Render the edges.
   * @api
   */
  setRenderReprojectionEdges(e) {
    if (this.renderReprojectionEdges_ != e) {
      this.renderReprojectionEdges_ = e;
      for (const t in this.tileCacheForProjection)
        this.tileCacheForProjection[t].clear();
      this.changed();
    }
  }
  /**
   * Sets the tile grid to use when reprojecting the tiles to the given
   * projection instead of the default tile grid for the projection.
   *
   * This can be useful when the default tile grid cannot be created
   * (e.g. projection has no extent defined) or
   * for optimization reasons (custom tile size, resolutions, ...).
   *
   * @param {import("../proj.js").ProjectionLike} projection Projection.
   * @param {import("../tilegrid/TileGrid.js").default} tilegrid Tile grid to use for the projection.
   * @api
   */
  setTileGridForProjection(e, t) {
    const r = Ct(e);
    if (r) {
      const n = st(r);
      n in this.tileGridForProjection || (this.tileGridForProjection[n] = t);
    }
  }
  clear() {
    super.clear();
    for (const e in this.tileCacheForProjection)
      this.tileCacheForProjection[e].clear();
  }
}
function $V(i, e) {
  i.getImage().src = e;
}
const Yv = GV;
function VV(i) {
  const e = i[0], t = new Array(e);
  let r = 1 << e - 1, n, s;
  for (n = 0; n < e; ++n)
    s = 48, i[1] & r && (s += 1), i[2] & r && (s += 2), t[n] = String.fromCharCode(s), r >>= 1;
  return t.join("");
}
const KV = '<a class="ol-attribution-bing-tos" href="https://www.microsoft.com/maps/product/terms.html" target="_blank">Terms of Use</a>';
class jV extends Yv {
  /**
   * @param {Options} options Bing Maps options.
   */
  constructor(e) {
    const t = e.hidpi !== void 0 ? e.hidpi : !1;
    super({
      cacheSize: e.cacheSize,
      crossOrigin: "anonymous",
      interpolate: e.interpolate,
      opaque: !0,
      projection: Ct("EPSG:3857"),
      reprojectionErrorThreshold: e.reprojectionErrorThreshold,
      state: "loading",
      tileLoadFunction: e.tileLoadFunction,
      tilePixelRatio: t ? 2 : 1,
      wrapX: e.wrapX !== void 0 ? e.wrapX : !0,
      transition: e.transition,
      zDirection: e.zDirection
    }), this.hidpi_ = t, this.culture_ = e.culture !== void 0 ? e.culture : "en-us", this.maxZoom_ = e.maxZoom !== void 0 ? e.maxZoom : -1, this.apiKey_ = e.key, this.imagerySet_ = e.imagerySet;
    const r = "https://dev.virtualearth.net/REST/v1/Imagery/Metadata/" + this.imagerySet_ + "?uriScheme=https&include=ImageryProviders&key=" + this.apiKey_ + "&c=" + this.culture_;
    fetch(r).then((n) => n.json()).then((n) => this.handleImageryMetadataResponse(n));
  }
  /**
   * Get the api key used for this source.
   *
   * @return {string} The api key.
   * @api
   */
  getApiKey() {
    return this.apiKey_;
  }
  /**
   * Get the imagery set associated with this source.
   *
   * @return {string} The imagery set.
   * @api
   */
  getImagerySet() {
    return this.imagerySet_;
  }
  /**
   * @param {BingMapsImageryMetadataResponse} response Response.
   */
  handleImageryMetadataResponse(e) {
    if (e.statusCode != 200 || e.statusDescription != "OK" || e.authenticationResultCode != "ValidCredentials" || e.resourceSets.length != 1 || e.resourceSets[0].resources.length != 1) {
      this.setState("error");
      return;
    }
    const t = e.resourceSets[0].resources[0], r = this.maxZoom_ == -1 ? t.zoomMax : this.maxZoom_, n = this.getProjection(), s = Wv(n), a = this.hidpi_ ? 2 : 1, o = t.imageWidth == t.imageHeight ? t.imageWidth / a : [t.imageWidth / a, t.imageHeight / a], A = B4({
      extent: s,
      minZoom: t.zoomMin,
      maxZoom: r,
      tileSize: o
    });
    this.tileGrid = A;
    const l = this.culture_, h = this.hidpi_;
    if (this.tileUrlFunction = Hm(
      t.imageUrlSubdomains.map(function(c) {
        const u = [0, 0, 0], f = t.imageUrl.replace("{subdomain}", c).replace("{culture}", l);
        return (
          /**
           * @param {import("../tilecoord.js").TileCoord} tileCoord Tile coordinate.
           * @param {number} pixelRatio Pixel ratio.
           * @param {import("../proj/Projection.js").default} projection Projection.
           * @return {string|undefined} Tile URL.
           */
          function(g, p, y) {
            if (!g)
              return;
            $d(
              g[0],
              g[1],
              g[2],
              u
            );
            let v = f;
            return h && (v += "&dpi=d1&device=mobile"), v.replace("{quadkey}", VV(u));
          }
        );
      })
    ), t.imageryProviders) {
      const c = Fu(
        Ct("EPSG:4326"),
        this.getProjection()
      );
      this.setAttributions((u) => {
        const f = [], g = u.viewState, p = this.getTileGrid(), y = p.getZForResolution(
          g.resolution,
          this.zDirection
        ), w = p.getTileCoordForCoordAndZ(
          g.center,
          y
        )[0];
        return t.imageryProviders.map(function(C) {
          let E = !1;
          const S = C.coverageAreas;
          for (let M = 0, T = S.length; M < T; ++M) {
            const F = S[M];
            if (w >= F.zoomMin && w <= F.zoomMax) {
              const k = F.bbox, $ = [k[1], k[0], k[3], k[2]], I = AE($, c);
              if (ci(I, u.extent)) {
                E = !0;
                break;
              }
            }
          }
          E && f.push(C.attribution);
        }), f.push(KV), f;
      });
    }
    this.setState("ready");
  }
}
const zV = jV;
class XV extends Yv {
  /**
   * @param {Options} [options] XYZ options.
   */
  constructor(e) {
    e = e || {};
    const t = e.projection !== void 0 ? e.projection : "EPSG:3857", r = e.tileGrid !== void 0 ? e.tileGrid : B4({
      extent: Wv(t),
      maxResolution: e.maxResolution,
      maxZoom: e.maxZoom,
      minZoom: e.minZoom,
      tileSize: e.tileSize
    });
    super({
      attributions: e.attributions,
      cacheSize: e.cacheSize,
      crossOrigin: e.crossOrigin,
      interpolate: e.interpolate,
      opaque: e.opaque,
      projection: t,
      reprojectionErrorThreshold: e.reprojectionErrorThreshold,
      tileGrid: r,
      tileLoadFunction: e.tileLoadFunction,
      tilePixelRatio: e.tilePixelRatio,
      tileUrlFunction: e.tileUrlFunction,
      url: e.url,
      urls: e.urls,
      wrapX: e.wrapX !== void 0 ? e.wrapX : !0,
      transition: e.transition,
      attributionsCollapsible: e.attributionsCollapsible,
      zDirection: e.zDirection
    }), this.gutter_ = e.gutter !== void 0 ? e.gutter : 0;
  }
  /**
   * @return {number} Gutter.
   */
  getGutter() {
    return this.gutter_;
  }
}
const F4 = XV;
class WV {
  /**
   * @param {number} [maxEntries] Max entries.
   */
  constructor(e) {
    this.rbush_ = new A4(e), this.items_ = {};
  }
  /**
   * Insert a value into the RBush.
   * @param {import("../extent.js").Extent} extent Extent.
   * @param {T} value Value.
   */
  insert(e, t) {
    const r = {
      minX: e[0],
      minY: e[1],
      maxX: e[2],
      maxY: e[3],
      value: t
    };
    this.rbush_.insert(r), this.items_[st(t)] = r;
  }
  /**
   * Bulk-insert values into the RBush.
   * @param {Array<import("../extent.js").Extent>} extents Extents.
   * @param {Array<T>} values Values.
   */
  load(e, t) {
    const r = new Array(t.length);
    for (let n = 0, s = t.length; n < s; n++) {
      const a = e[n], o = t[n], A = {
        minX: a[0],
        minY: a[1],
        maxX: a[2],
        maxY: a[3],
        value: o
      };
      r[n] = A, this.items_[st(o)] = A;
    }
    this.rbush_.load(r);
  }
  /**
   * Remove a value from the RBush.
   * @param {T} value Value.
   * @return {boolean} Removed.
   */
  remove(e) {
    const t = st(e), r = this.items_[t];
    return delete this.items_[t], this.rbush_.remove(r) !== null;
  }
  /**
   * Update the extent of a value in the RBush.
   * @param {import("../extent.js").Extent} extent Extent.
   * @param {T} value Value.
   */
  update(e, t) {
    const r = this.items_[st(t)], n = [r.minX, r.minY, r.maxX, r.maxY];
    Xa(n, e) || (this.remove(t), this.insert(e, t));
  }
  /**
   * Return all values in the RBush.
   * @return {Array<T>} All.
   */
  getAll() {
    return this.rbush_.all().map(function(t) {
      return t.value;
    });
  }
  /**
   * Return all values in the given extent.
   * @param {import("../extent.js").Extent} extent Extent.
   * @return {Array<T>} All in extent.
   */
  getInExtent(e) {
    const t = {
      minX: e[0],
      minY: e[1],
      maxX: e[2],
      maxY: e[3]
    };
    return this.rbush_.search(t).map(function(n) {
      return n.value;
    });
  }
  /**
   * Calls a callback function with each value in the tree.
   * If the callback returns a truthy value, this value is returned without
   * checking the rest of the tree.
   * @param {function(T): *} callback Callback.
   * @return {*} Callback return value.
   */
  forEach(e) {
    return this.forEach_(this.getAll(), e);
  }
  /**
   * Calls a callback function with each value in the provided extent.
   * @param {import("../extent.js").Extent} extent Extent.
   * @param {function(T): *} callback Callback.
   * @return {*} Callback return value.
   */
  forEachInExtent(e, t) {
    return this.forEach_(this.getInExtent(e), t);
  }
  /**
   * @param {Array<T>} values Values.
   * @param {function(T): *} callback Callback.
   * @private
   * @return {*} Callback return value.
   */
  forEach_(e, t) {
    let r;
    for (let n = 0, s = e.length; n < s; n++)
      if (r = t(e[n]), r)
        return r;
    return r;
  }
  /**
   * @return {boolean} Is empty.
   */
  isEmpty() {
    return dh(this.items_);
  }
  /**
   * Remove all values from the RBush.
   */
  clear() {
    this.rbush_.clear(), this.items_ = {};
  }
  /**
   * @param {import("../extent.js").Extent} [extent] Extent.
   * @return {import("../extent.js").Extent} Extent.
   */
  getExtent(e) {
    const t = this.rbush_.toJSON();
    return ms(t.minX, t.minY, t.maxX, t.maxY, e);
  }
  /**
   * @param {RBush} rbush R-Tree.
   */
  concat(e) {
    this.rbush_.load(e.rbush_.all());
    for (const t in e.items_)
      this.items_[t] = e.items_[t];
  }
}
const Gm = WV, an = {
  /**
   * Triggered when a feature is added to the source.
   * @event module:ol/source/Vector.VectorSourceEvent#addfeature
   * @api
   */
  ADDFEATURE: "addfeature",
  /**
   * Triggered when a feature is updated.
   * @event module:ol/source/Vector.VectorSourceEvent#changefeature
   * @api
   */
  CHANGEFEATURE: "changefeature",
  /**
   * Triggered when the clear method is called on the source.
   * @event module:ol/source/Vector.VectorSourceEvent#clear
   * @api
   */
  CLEAR: "clear",
  /**
   * Triggered when a feature is removed from the source.
   * See {@link module:ol/source/Vector~VectorSource#clear source.clear()} for exceptions.
   * @event module:ol/source/Vector.VectorSourceEvent#removefeature
   * @api
   */
  REMOVEFEATURE: "removefeature",
  /**
   * Triggered when features starts loading.
   * @event module:ol/source/Vector.VectorSourceEvent#featuresloadstart
   * @api
   */
  FEATURESLOADSTART: "featuresloadstart",
  /**
   * Triggered when features finishes loading.
   * @event module:ol/source/Vector.VectorSourceEvent#featuresloadend
   * @api
   */
  FEATURESLOADEND: "featuresloadend",
  /**
   * Triggered if feature loading results in an error.
   * @event module:ol/source/Vector.VectorSourceEvent#featuresloaderror
   * @api
   */
  FEATURESLOADERROR: "featuresloaderror"
};
function L4(i, e) {
  return [[-1 / 0, -1 / 0, 1 / 0, 1 / 0]];
}
function YV(i, e) {
  return [i];
}
function qV(i) {
  return (
    /**
     * @param {import("./extent.js").Extent} extent Extent.
     * @param {number} resolution Resolution.
     * @param {import("./proj.js").Projection} projection Projection.
     * @return {Array<import("./extent.js").Extent>} Extents.
     */
    function(e, t, r) {
      const n = i.getZForResolution(
        _D(t)
      ), s = i.getTileRangeForExtentAndZ(
        Os(e),
        n
      ), a = [], o = [n, 0, 0];
      for (o[1] = s.minX; o[1] <= s.maxX; ++o[1])
        for (o[2] = s.minY; o[2] <= s.maxY; ++o[2])
          a.push(
            fg(i.getTileCoordExtent(o))
          );
      return a;
    }
  );
}
const ZV = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  all: L4,
  bbox: YV,
  tile: qV
}, Symbol.toStringTag, { value: "Module" }));
let JV = !1;
function eK(i, e, t, r, n, s, a) {
  const o = new XMLHttpRequest();
  o.open(
    "GET",
    typeof i == "function" ? i(t, r, n) : i,
    !0
  ), e.getType() == "arraybuffer" && (o.responseType = "arraybuffer"), o.withCredentials = JV, o.onload = function(A) {
    if (!o.status || o.status >= 200 && o.status < 300) {
      const l = e.getType();
      let h;
      l == "json" || l == "text" ? h = o.responseText : l == "xml" ? (h = o.responseXML, h || (h = new DOMParser().parseFromString(
        o.responseText,
        "application/xml"
      ))) : l == "arraybuffer" && (h = /** @type {ArrayBuffer} */
      o.response), h ? s(
        /** @type {Array<import("./Feature.js").default>} */
        e.readFeatures(h, {
          extent: t,
          featureProjection: n
        }),
        e.readProjection(h)
      ) : a();
    } else
      a();
  }, o.onerror = a, o.send();
}
function b5(i, e) {
  return function(t, r, n, s, a) {
    const o = (
      /** @type {import("./source/Vector").default} */
      this
    );
    eK(
      i,
      e,
      t,
      r,
      n,
      /**
       * @param {Array<import("./Feature.js").default>} features The loaded features.
       * @param {import("./proj/Projection.js").default} dataProjection Data
       * projection.
       */
      function(A, l) {
        o.addFeatures(A), s !== void 0 && s(A);
      },
      /* FIXME handle error */
      a || hu
    );
  };
}
class IA extends _s {
  /**
   * @param {string} type Type.
   * @param {import("../Feature.js").default<Geometry>} [feature] Feature.
   * @param {Array<import("../Feature.js").default<Geometry>>} [features] Features.
   */
  constructor(e, t, r) {
    super(e), this.feature = t, this.features = r;
  }
}
class tK extends Xv {
  /**
   * @param {Options<Geometry>} [options] Vector source options.
   */
  constructor(e) {
    e = e || {}, super({
      attributions: e.attributions,
      interpolate: !0,
      projection: void 0,
      state: "ready",
      wrapX: e.wrapX !== void 0 ? e.wrapX : !0
    }), this.on, this.once, this.un, this.loader_ = hu, this.format_ = e.format, this.overlaps_ = e.overlaps === void 0 ? !0 : e.overlaps, this.url_ = e.url, e.loader !== void 0 ? this.loader_ = e.loader : this.url_ !== void 0 && (lt(this.format_, 7), this.loader_ = b5(
      this.url_,
      /** @type {import("../format/Feature.js").default} */
      this.format_
    )), this.strategy_ = e.strategy !== void 0 ? e.strategy : L4;
    const t = e.useSpatialIndex !== void 0 ? e.useSpatialIndex : !0;
    this.featuresRtree_ = t ? new Gm() : null, this.loadedExtentsRtree_ = new Gm(), this.loadingExtentsCount_ = 0, this.nullGeometryFeatures_ = {}, this.idIndex_ = {}, this.uidIndex_ = {}, this.featureChangeKeys_ = {}, this.featuresCollection_ = null;
    let r, n;
    Array.isArray(e.features) ? n = e.features : e.features && (r = e.features, n = r.getArray()), !t && r === void 0 && (r = new Yi(n)), n !== void 0 && this.addFeaturesInternal(n), r !== void 0 && this.bindFeaturesCollection_(r);
  }
  /**
   * Add a single feature to the source.  If you want to add a batch of features
   * at once, call {@link module:ol/source/Vector~VectorSource#addFeatures #addFeatures()}
   * instead. A feature will not be added to the source if feature with
   * the same id is already there. The reason for this behavior is to avoid
   * feature duplication when using bbox or tile loading strategies.
   * Note: this also applies if an {@link module:ol/Collection~Collection} is used for features,
   * meaning that if a feature with a duplicate id is added in the collection, it will
   * be removed from it right away.
   * @param {import("../Feature.js").default<Geometry>} feature Feature to add.
   * @api
   */
  addFeature(e) {
    this.addFeatureInternal(e), this.changed();
  }
  /**
   * Add a feature without firing a `change` event.
   * @param {import("../Feature.js").default<Geometry>} feature Feature.
   * @protected
   */
  addFeatureInternal(e) {
    const t = st(e);
    if (!this.addToIndex_(t, e)) {
      this.featuresCollection_ && this.featuresCollection_.remove(e);
      return;
    }
    this.setupChangeEvents_(t, e);
    const r = e.getGeometry();
    if (r) {
      const n = r.getExtent();
      this.featuresRtree_ && this.featuresRtree_.insert(n, e);
    } else
      this.nullGeometryFeatures_[t] = e;
    this.dispatchEvent(
      new IA(an.ADDFEATURE, e)
    );
  }
  /**
   * @param {string} featureKey Unique identifier for the feature.
   * @param {import("../Feature.js").default<Geometry>} feature The feature.
   * @private
   */
  setupChangeEvents_(e, t) {
    this.featureChangeKeys_[e] = [
      St(t, ut.CHANGE, this.handleFeatureChange_, this),
      St(
        t,
        fh.PROPERTYCHANGE,
        this.handleFeatureChange_,
        this
      )
    ];
  }
  /**
   * @param {string} featureKey Unique identifier for the feature.
   * @param {import("../Feature.js").default<Geometry>} feature The feature.
   * @return {boolean} The feature is "valid", in the sense that it is also a
   *     candidate for insertion into the Rtree.
   * @private
   */
  addToIndex_(e, t) {
    let r = !0;
    const n = t.getId();
    return n !== void 0 && (n.toString() in this.idIndex_ ? r = !1 : this.idIndex_[n.toString()] = t), r && (lt(!(e in this.uidIndex_), 30), this.uidIndex_[e] = t), r;
  }
  /**
   * Add a batch of features to the source.
   * @param {Array<import("../Feature.js").default<Geometry>>} features Features to add.
   * @api
   */
  addFeatures(e) {
    this.addFeaturesInternal(e), this.changed();
  }
  /**
   * Add features without firing a `change` event.
   * @param {Array<import("../Feature.js").default<Geometry>>} features Features.
   * @protected
   */
  addFeaturesInternal(e) {
    const t = [], r = [], n = [];
    for (let s = 0, a = e.length; s < a; s++) {
      const o = e[s], A = st(o);
      this.addToIndex_(A, o) && r.push(o);
    }
    for (let s = 0, a = r.length; s < a; s++) {
      const o = r[s], A = st(o);
      this.setupChangeEvents_(A, o);
      const l = o.getGeometry();
      if (l) {
        const h = l.getExtent();
        t.push(h), n.push(o);
      } else
        this.nullGeometryFeatures_[A] = o;
    }
    if (this.featuresRtree_ && this.featuresRtree_.load(t, n), this.hasListener(an.ADDFEATURE))
      for (let s = 0, a = r.length; s < a; s++)
        this.dispatchEvent(
          new IA(an.ADDFEATURE, r[s])
        );
  }
  /**
   * @param {!Collection<import("../Feature.js").default<Geometry>>} collection Collection.
   * @private
   */
  bindFeaturesCollection_(e) {
    let t = !1;
    this.addEventListener(
      an.ADDFEATURE,
      /**
       * @param {VectorSourceEvent<Geometry>} evt The vector source event
       */
      function(r) {
        t || (t = !0, e.push(r.feature), t = !1);
      }
    ), this.addEventListener(
      an.REMOVEFEATURE,
      /**
       * @param {VectorSourceEvent<Geometry>} evt The vector source event
       */
      function(r) {
        t || (t = !0, e.remove(r.feature), t = !1);
      }
    ), e.addEventListener(
      Si.ADD,
      /**
       * @param {import("../Collection.js").CollectionEvent<import("../Feature.js").default<Geometry>>} evt The collection event
       */
      (r) => {
        t || (t = !0, this.addFeature(r.element), t = !1);
      }
    ), e.addEventListener(
      Si.REMOVE,
      /**
       * @param {import("../Collection.js").CollectionEvent<import("../Feature.js").default<Geometry>>} evt The collection event
       */
      (r) => {
        t || (t = !0, this.removeFeature(r.element), t = !1);
      }
    ), this.featuresCollection_ = e;
  }
  /**
   * Remove all features from the source.
   * @param {boolean} [fast] Skip dispatching of {@link module:ol/source/Vector.VectorSourceEvent#event:removefeature} events.
   * @api
   */
  clear(e) {
    if (e) {
      for (const r in this.featureChangeKeys_)
        this.featureChangeKeys_[r].forEach(pr);
      this.featuresCollection_ || (this.featureChangeKeys_ = {}, this.idIndex_ = {}, this.uidIndex_ = {});
    } else if (this.featuresRtree_) {
      const r = (n) => {
        this.removeFeatureInternal(n);
      };
      this.featuresRtree_.forEach(r);
      for (const n in this.nullGeometryFeatures_)
        this.removeFeatureInternal(this.nullGeometryFeatures_[n]);
    }
    this.featuresCollection_ && this.featuresCollection_.clear(), this.featuresRtree_ && this.featuresRtree_.clear(), this.nullGeometryFeatures_ = {};
    const t = new IA(an.CLEAR);
    this.dispatchEvent(t), this.changed();
  }
  /**
   * Iterate through all features on the source, calling the provided callback
   * with each one.  If the callback returns any "truthy" value, iteration will
   * stop and the function will return the same value.
   * Note: this function only iterate through the feature that have a defined geometry.
   *
   * @param {function(import("../Feature.js").default<Geometry>): T} callback Called with each feature
   *     on the source.  Return a truthy value to stop iteration.
   * @return {T|undefined} The return value from the last call to the callback.
   * @template T
   * @api
   */
  forEachFeature(e) {
    if (this.featuresRtree_)
      return this.featuresRtree_.forEach(e);
    this.featuresCollection_ && this.featuresCollection_.forEach(e);
  }
  /**
   * Iterate through all features whose geometries contain the provided
   * coordinate, calling the callback with each feature.  If the callback returns
   * a "truthy" value, iteration will stop and the function will return the same
   * value.
   *
   * @param {import("../coordinate.js").Coordinate} coordinate Coordinate.
   * @param {function(import("../Feature.js").default<Geometry>): T} callback Called with each feature
   *     whose goemetry contains the provided coordinate.
   * @return {T|undefined} The return value from the last call to the callback.
   * @template T
   */
  forEachFeatureAtCoordinateDirect(e, t) {
    const r = [e[0], e[1], e[0], e[1]];
    return this.forEachFeatureInExtent(r, function(n) {
      if (n.getGeometry().intersectsCoordinate(e))
        return t(n);
    });
  }
  /**
   * Iterate through all features whose bounding box intersects the provided
   * extent (note that the feature's geometry may not intersect the extent),
   * calling the callback with each feature.  If the callback returns a "truthy"
   * value, iteration will stop and the function will return the same value.
   *
   * If you are interested in features whose geometry intersects an extent, call
   * the {@link module:ol/source/Vector~VectorSource#forEachFeatureIntersectingExtent #forEachFeatureIntersectingExtent()} method instead.
   *
   * When `useSpatialIndex` is set to false, this method will loop through all
   * features, equivalent to {@link module:ol/source/Vector~VectorSource#forEachFeature #forEachFeature()}.
   *
   * @param {import("../extent.js").Extent} extent Extent.
   * @param {function(import("../Feature.js").default<Geometry>): T} callback Called with each feature
   *     whose bounding box intersects the provided extent.
   * @return {T|undefined} The return value from the last call to the callback.
   * @template T
   * @api
   */
  forEachFeatureInExtent(e, t) {
    if (this.featuresRtree_)
      return this.featuresRtree_.forEachInExtent(e, t);
    this.featuresCollection_ && this.featuresCollection_.forEach(t);
  }
  /**
   * Iterate through all features whose geometry intersects the provided extent,
   * calling the callback with each feature.  If the callback returns a "truthy"
   * value, iteration will stop and the function will return the same value.
   *
   * If you only want to test for bounding box intersection, call the
   * {@link module:ol/source/Vector~VectorSource#forEachFeatureInExtent #forEachFeatureInExtent()} method instead.
   *
   * @param {import("../extent.js").Extent} extent Extent.
   * @param {function(import("../Feature.js").default<Geometry>): T} callback Called with each feature
   *     whose geometry intersects the provided extent.
   * @return {T|undefined} The return value from the last call to the callback.
   * @template T
   * @api
   */
  forEachFeatureIntersectingExtent(e, t) {
    return this.forEachFeatureInExtent(
      e,
      /**
       * @param {import("../Feature.js").default<Geometry>} feature Feature.
       * @return {T|undefined} The return value from the last call to the callback.
       */
      function(r) {
        if (r.getGeometry().intersectsExtent(e)) {
          const s = t(r);
          if (s)
            return s;
        }
      }
    );
  }
  /**
   * Get the features collection associated with this source. Will be `null`
   * unless the source was configured with `useSpatialIndex` set to `false`, or
   * with an {@link module:ol/Collection~Collection} as `features`.
   * @return {Collection<import("../Feature.js").default<Geometry>>|null} The collection of features.
   * @api
   */
  getFeaturesCollection() {
    return this.featuresCollection_;
  }
  /**
   * Get a snapshot of the features currently on the source in random order. The returned array
   * is a copy, the features are references to the features in the source.
   * @return {Array<import("../Feature.js").default<Geometry>>} Features.
   * @api
   */
  getFeatures() {
    let e;
    return this.featuresCollection_ ? e = this.featuresCollection_.getArray().slice(0) : this.featuresRtree_ && (e = this.featuresRtree_.getAll(), dh(this.nullGeometryFeatures_) || Er(e, Object.values(this.nullGeometryFeatures_))), /** @type {Array<import("../Feature.js").default<Geometry>>} */
    e;
  }
  /**
   * Get all features whose geometry intersects the provided coordinate.
   * @param {import("../coordinate.js").Coordinate} coordinate Coordinate.
   * @return {Array<import("../Feature.js").default<Geometry>>} Features.
   * @api
   */
  getFeaturesAtCoordinate(e) {
    const t = [];
    return this.forEachFeatureAtCoordinateDirect(e, function(r) {
      t.push(r);
    }), t;
  }
  /**
   * Get all features whose bounding box intersects the provided extent.  Note that this returns an array of
   * all features intersecting the given extent in random order (so it may include
   * features whose geometries do not intersect the extent).
   *
   * When `useSpatialIndex` is set to false, this method will return all
   * features.
   *
   * @param {import("../extent.js").Extent} extent Extent.
   * @param {import("../proj/Projection.js").default} [projection] Include features
   * where `extent` exceeds the x-axis bounds of `projection` and wraps around the world.
   * @return {Array<import("../Feature.js").default<Geometry>>} Features.
   * @api
   */
  getFeaturesInExtent(e, t) {
    if (this.featuresRtree_) {
      if (!(t && t.canWrapX() && this.getWrapX()))
        return this.featuresRtree_.getInExtent(e);
      const n = bR(e, t);
      return [].concat(
        ...n.map((s) => this.featuresRtree_.getInExtent(s))
      );
    } else if (this.featuresCollection_)
      return this.featuresCollection_.getArray().slice(0);
    return [];
  }
  /**
   * Get the closest feature to the provided coordinate.
   *
   * This method is not available when the source is configured with
   * `useSpatialIndex` set to `false`.
   * @param {import("../coordinate.js").Coordinate} coordinate Coordinate.
   * @param {function(import("../Feature.js").default<Geometry>):boolean} [filter] Feature filter function.
   *     The filter function will receive one argument, the {@link module:ol/Feature~Feature feature}
   *     and it should return a boolean value. By default, no filtering is made.
   * @return {import("../Feature.js").default<Geometry>} Closest feature.
   * @api
   */
  getClosestFeatureToCoordinate(e, t) {
    const r = e[0], n = e[1];
    let s = null;
    const a = [NaN, NaN];
    let o = 1 / 0;
    const A = [-1 / 0, -1 / 0, 1 / 0, 1 / 0];
    return t = t || Xo, this.featuresRtree_.forEachInExtent(
      A,
      /**
       * @param {import("../Feature.js").default<Geometry>} feature Feature.
       */
      function(l) {
        if (t(l)) {
          const h = l.getGeometry(), c = o;
          if (o = h.closestPointXY(
            r,
            n,
            a,
            o
          ), o < c) {
            s = l;
            const u = Math.sqrt(o);
            A[0] = r - u, A[1] = n - u, A[2] = r + u, A[3] = n + u;
          }
        }
      }
    ), s;
  }
  /**
   * Get the extent of the features currently in the source.
   *
   * This method is not available when the source is configured with
   * `useSpatialIndex` set to `false`.
   * @param {import("../extent.js").Extent} [extent] Destination extent. If provided, no new extent
   *     will be created. Instead, that extent's coordinates will be overwritten.
   * @return {import("../extent.js").Extent} Extent.
   * @api
   */
  getExtent(e) {
    return this.featuresRtree_.getExtent(e);
  }
  /**
   * Get a feature by its identifier (the value returned by feature.getId()).
   * Note that the index treats string and numeric identifiers as the same.  So
   * `source.getFeatureById(2)` will return a feature with id `'2'` or `2`.
   *
   * @param {string|number} id Feature identifier.
   * @return {import("../Feature.js").default<Geometry>|null} The feature (or `null` if not found).
   * @api
   */
  getFeatureById(e) {
    const t = this.idIndex_[e.toString()];
    return t !== void 0 ? t : null;
  }
  /**
   * Get a feature by its internal unique identifier (using `getUid`).
   *
   * @param {string} uid Feature identifier.
   * @return {import("../Feature.js").default<Geometry>|null} The feature (or `null` if not found).
   */
  getFeatureByUid(e) {
    const t = this.uidIndex_[e];
    return t !== void 0 ? t : null;
  }
  /**
   * Get the format associated with this source.
   *
   * @return {import("../format/Feature.js").default|undefined} The feature format.
   * @api
   */
  getFormat() {
    return this.format_;
  }
  /**
   * @return {boolean} The source can have overlapping geometries.
   */
  getOverlaps() {
    return this.overlaps_;
  }
  /**
   * Get the url associated with this source.
   *
   * @return {string|import("../featureloader.js").FeatureUrlFunction|undefined} The url.
   * @api
   */
  getUrl() {
    return this.url_;
  }
  /**
   * @param {Event} event Event.
   * @private
   */
  handleFeatureChange_(e) {
    const t = (
      /** @type {import("../Feature.js").default<Geometry>} */
      e.target
    ), r = st(t), n = t.getGeometry();
    if (!n)
      r in this.nullGeometryFeatures_ || (this.featuresRtree_ && this.featuresRtree_.remove(t), this.nullGeometryFeatures_[r] = t);
    else {
      const a = n.getExtent();
      r in this.nullGeometryFeatures_ ? (delete this.nullGeometryFeatures_[r], this.featuresRtree_ && this.featuresRtree_.insert(a, t)) : this.featuresRtree_ && this.featuresRtree_.update(a, t);
    }
    const s = t.getId();
    if (s !== void 0) {
      const a = s.toString();
      this.idIndex_[a] !== t && (this.removeFromIdIndex_(t), this.idIndex_[a] = t);
    } else
      this.removeFromIdIndex_(t), this.uidIndex_[r] = t;
    this.changed(), this.dispatchEvent(
      new IA(an.CHANGEFEATURE, t)
    );
  }
  /**
   * Returns true if the feature is contained within the source.
   * @param {import("../Feature.js").default<Geometry>} feature Feature.
   * @return {boolean} Has feature.
   * @api
   */
  hasFeature(e) {
    const t = e.getId();
    return t !== void 0 ? t in this.idIndex_ : st(e) in this.uidIndex_;
  }
  /**
   * @return {boolean} Is empty.
   */
  isEmpty() {
    return this.featuresRtree_ ? this.featuresRtree_.isEmpty() && dh(this.nullGeometryFeatures_) : this.featuresCollection_ ? this.featuresCollection_.getLength() === 0 : !0;
  }
  /**
   * @param {import("../extent.js").Extent} extent Extent.
   * @param {number} resolution Resolution.
   * @param {import("../proj/Projection.js").default} projection Projection.
   */
  loadFeatures(e, t, r) {
    const n = this.loadedExtentsRtree_, s = this.strategy_(e, t, r);
    for (let a = 0, o = s.length; a < o; ++a) {
      const A = s[a];
      n.forEachInExtent(
        A,
        /**
         * @param {{extent: import("../extent.js").Extent}} object Object.
         * @return {boolean} Contains.
         */
        function(h) {
          return Ps(h.extent, A);
        }
      ) || (++this.loadingExtentsCount_, this.dispatchEvent(
        new IA(an.FEATURESLOADSTART)
      ), this.loader_.call(
        this,
        A,
        t,
        r,
        (h) => {
          --this.loadingExtentsCount_, this.dispatchEvent(
            new IA(
              an.FEATURESLOADEND,
              void 0,
              h
            )
          );
        },
        () => {
          --this.loadingExtentsCount_, this.dispatchEvent(
            new IA(an.FEATURESLOADERROR)
          );
        }
      ), n.insert(A, { extent: A.slice() }));
    }
    this.loading = this.loader_.length < 4 ? !1 : this.loadingExtentsCount_ > 0;
  }
  refresh() {
    this.clear(!0), this.loadedExtentsRtree_.clear(), super.refresh();
  }
  /**
   * Remove an extent from the list of loaded extents.
   * @param {import("../extent.js").Extent} extent Extent.
   * @api
   */
  removeLoadedExtent(e) {
    const t = this.loadedExtentsRtree_;
    let r;
    t.forEachInExtent(e, function(n) {
      if (Xa(n.extent, e))
        return r = n, !0;
    }), r && t.remove(r);
  }
  /**
   * Remove a single feature from the source.  If you want to remove all features
   * at once, use the {@link module:ol/source/Vector~VectorSource#clear #clear()} method
   * instead.
   * @param {import("../Feature.js").default<Geometry>} feature Feature to remove.
   * @api
   */
  removeFeature(e) {
    if (!e)
      return;
    const t = st(e);
    t in this.nullGeometryFeatures_ ? delete this.nullGeometryFeatures_[t] : this.featuresRtree_ && this.featuresRtree_.remove(e), this.removeFeatureInternal(e) && this.changed();
  }
  /**
   * Remove feature without firing a `change` event.
   * @param {import("../Feature.js").default<Geometry>} feature Feature.
   * @return {import("../Feature.js").default<Geometry>|undefined} The removed feature
   *     (or undefined if the feature was not found).
   * @protected
   */
  removeFeatureInternal(e) {
    const t = st(e), r = this.featureChangeKeys_[t];
    if (!r)
      return;
    r.forEach(pr), delete this.featureChangeKeys_[t];
    const n = e.getId();
    return n !== void 0 && delete this.idIndex_[n.toString()], delete this.uidIndex_[t], this.dispatchEvent(
      new IA(an.REMOVEFEATURE, e)
    ), e;
  }
  /**
   * Remove a feature from the id index.  Called internally when the feature id
   * may have changed.
   * @param {import("../Feature.js").default<Geometry>} feature The feature.
   * @return {boolean} Removed the feature from the index.
   * @private
   */
  removeFromIdIndex_(e) {
    let t = !1;
    for (const r in this.idIndex_)
      if (this.idIndex_[r] === e) {
        delete this.idIndex_[r], t = !0;
        break;
      }
    return t;
  }
  /**
   * Set the new loader of the source. The next render cycle will use the
   * new loader.
   * @param {import("../featureloader.js").FeatureLoader} loader The loader to set.
   * @api
   */
  setLoader(e) {
    this.loader_ = e;
  }
  /**
   * Points the source to a new url. The next render cycle will use the new url.
   * @param {string|import("../featureloader.js").FeatureUrlFunction} url Url.
   * @api
   */
  setUrl(e) {
    lt(this.format_, 7), this.url_ = e, this.setLoader(b5(e, this.format_));
  }
}
const sA = tK;
class rK extends sA {
  /**
   * @param {Options} options Cluster options.
   */
  constructor(e) {
    super({
      attributions: e.attributions,
      wrapX: e.wrapX
    }), this.resolution = void 0, this.distance = e.distance !== void 0 ? e.distance : 20, this.minDistance = e.minDistance || 0, this.interpolationRatio = 0, this.features = [], this.geometryFunction = e.geometryFunction || function(t) {
      const r = (
        /** @type {Point} */
        t.getGeometry()
      );
      return lt(r.getType() == "Point", 10), r;
    }, this.createCustomCluster_ = e.createCluster, this.source = null, this.boundRefresh_ = this.refresh.bind(this), this.updateDistance(this.distance, this.minDistance), this.setSource(e.source || null);
  }
  /**
   * Remove all features from the source.
   * @param {boolean} [fast] Skip dispatching of {@link module:ol/source/VectorEventType~VectorEventType#removefeature} events.
   * @api
   */
  clear(e) {
    this.features.length = 0, super.clear(e);
  }
  /**
   * Get the distance in pixels between clusters.
   * @return {number} Distance.
   * @api
   */
  getDistance() {
    return this.distance;
  }
  /**
   * Get a reference to the wrapped source.
   * @return {VectorSource|null} Source.
   * @api
   */
  getSource() {
    return this.source;
  }
  /**
   * @param {import("../extent.js").Extent} extent Extent.
   * @param {number} resolution Resolution.
   * @param {import("../proj/Projection.js").default} projection Projection.
   */
  loadFeatures(e, t, r) {
    this.source.loadFeatures(e, t, r), t !== this.resolution && (this.resolution = t, this.refresh());
  }
  /**
   * Set the distance within which features will be clusterd together.
   * @param {number} distance The distance in pixels.
   * @api
   */
  setDistance(e) {
    this.updateDistance(e, this.minDistance);
  }
  /**
   * Set the minimum distance between clusters. Will be capped at the
   * configured distance.
   * @param {number} minDistance The minimum distance in pixels.
   * @api
   */
  setMinDistance(e) {
    this.updateDistance(this.distance, e);
  }
  /**
   * The configured minimum distance between clusters.
   * @return {number} The minimum distance in pixels.
   * @api
   */
  getMinDistance() {
    return this.minDistance;
  }
  /**
   * Replace the wrapped source.
   * @param {VectorSource|null} source The new source for this instance.
   * @api
   */
  setSource(e) {
    this.source && this.source.removeEventListener(ut.CHANGE, this.boundRefresh_), this.source = e, e && e.addEventListener(ut.CHANGE, this.boundRefresh_), this.refresh();
  }
  /**
   * Handle the source changing.
   */
  refresh() {
    this.clear(), this.cluster(), this.addFeatures(this.features);
  }
  /**
   * Update the distances and refresh the source if necessary.
   * @param {number} distance The new distance.
   * @param {number} minDistance The new minimum distance.
   */
  updateDistance(e, t) {
    const r = e === 0 ? 0 : Math.min(t, e) / e, n = e !== this.distance || this.interpolationRatio !== r;
    this.distance = e, this.minDistance = t, this.interpolationRatio = r, n && this.refresh();
  }
  /**
   * @protected
   */
  cluster() {
    if (this.resolution === void 0 || !this.source)
      return;
    const e = Ji(), t = this.distance * this.resolution, r = this.source.getFeatures(), n = {};
    for (let s = 0, a = r.length; s < a; s++) {
      const o = r[s];
      if (!(st(o) in n)) {
        const A = this.geometryFunction(o);
        if (A) {
          const l = A.getCoordinates();
          Zl(l, e), zn(e, t, e);
          const h = this.source.getFeaturesInExtent(e).filter(function(c) {
            const u = st(c);
            return u in n ? !1 : (n[u] = !0, !0);
          });
          this.features.push(this.createCluster(h, e));
        }
      }
    }
  }
  /**
   * @param {Array<Feature>} features Features
   * @param {import("../extent.js").Extent} extent The searched extent for these features.
   * @return {Feature} The cluster feature.
   * @protected
   */
  createCluster(e, t) {
    const r = [0, 0];
    for (let o = e.length - 1; o >= 0; --o) {
      const A = this.geometryFunction(e[o]);
      A ? NR(r, A.getCoordinates()) : e.splice(o, 1);
    }
    PR(r, 1 / e.length);
    const n = Xn(t), s = this.interpolationRatio, a = new gr([
      r[0] * (1 - s) + n[0] * s,
      r[1] * (1 - s) + n[1] * s
    ]);
    return this.createCustomCluster_ ? this.createCustomCluster_(a, e) : new qt({
      geometry: a,
      features: e
    });
  }
}
const I4 = rK;
var Uo = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
const es = {
  VERSION1: "version1",
  VERSION2: "version2",
  VERSION3: "version3"
}, yh = {};
yh[es.VERSION1] = {
  level0: {
    supports: [],
    formats: [],
    qualities: ["native"]
  },
  level1: {
    supports: ["regionByPx", "sizeByW", "sizeByH", "sizeByPct"],
    formats: ["jpg"],
    qualities: ["native"]
  },
  level2: {
    supports: [
      "regionByPx",
      "regionByPct",
      "sizeByW",
      "sizeByH",
      "sizeByPct",
      "sizeByConfinedWh",
      "sizeByWh"
    ],
    formats: ["jpg", "png"],
    qualities: ["native", "color", "grey", "bitonal"]
  }
};
yh[es.VERSION2] = {
  level0: {
    supports: [],
    formats: ["jpg"],
    qualities: ["default"]
  },
  level1: {
    supports: ["regionByPx", "sizeByW", "sizeByH", "sizeByPct"],
    formats: ["jpg"],
    qualities: ["default"]
  },
  level2: {
    supports: [
      "regionByPx",
      "regionByPct",
      "sizeByW",
      "sizeByH",
      "sizeByPct",
      "sizeByConfinedWh",
      "sizeByDistortedWh",
      "sizeByWh"
    ],
    formats: ["jpg", "png"],
    qualities: ["default", "bitonal"]
  }
};
yh[es.VERSION3] = {
  level0: {
    supports: [],
    formats: ["jpg"],
    qualities: ["default"]
  },
  level1: {
    supports: ["regionByPx", "regionSquare", "sizeByW", "sizeByH", "sizeByWh"],
    formats: ["jpg"],
    qualities: ["default"]
  },
  level2: {
    supports: [
      "regionByPx",
      "regionSquare",
      "regionByPct",
      "sizeByW",
      "sizeByH",
      "sizeByPct",
      "sizeByConfinedWh",
      "sizeByWh"
    ],
    formats: ["jpg", "png"],
    qualities: ["default"]
  }
};
yh.none = {
  none: {
    supports: [],
    formats: [],
    qualities: []
  }
};
const iK = /^https?:\/\/library\.stanford\.edu\/iiif\/image-api\/(?:1\.1\/)?compliance\.html#level[0-2]$/, S5 = /^https?:\/\/iiif\.io\/api\/image\/2\/level[0-2](?:\.json)?$/, nK = /(^https?:\/\/iiif\.io\/api\/image\/3\/level[0-2](?:\.json)?$)|(^level[0-2]$)/;
function sK(i) {
  let e = i.getComplianceLevelSupportedFeatures();
  return e === void 0 && (e = yh[es.VERSION1].level0), {
    url: i.imageInfo["@id"] === void 0 ? void 0 : i.imageInfo["@id"].replace(/\/?(?:info\.json)?$/g, ""),
    supports: e.supports,
    formats: [
      ...e.formats,
      i.imageInfo.formats === void 0 ? [] : i.imageInfo.formats
    ],
    qualities: [
      ...e.qualities,
      i.imageInfo.qualities === void 0 ? [] : i.imageInfo.qualities
    ],
    resolutions: i.imageInfo.scale_factors,
    tileSize: i.imageInfo.tile_width !== void 0 ? i.imageInfo.tile_height !== void 0 ? [i.imageInfo.tile_width, i.imageInfo.tile_height] : [i.imageInfo.tile_width, i.imageInfo.tile_width] : i.imageInfo.tile_height != null ? [i.imageInfo.tile_height, i.imageInfo.tile_height] : void 0
  };
}
function aK(i) {
  const e = i.getComplianceLevelSupportedFeatures(), t = Array.isArray(i.imageInfo.profile) && i.imageInfo.profile.length > 1, r = t && i.imageInfo.profile[1].supports ? i.imageInfo.profile[1].supports : [], n = t && i.imageInfo.profile[1].formats ? i.imageInfo.profile[1].formats : [], s = t && i.imageInfo.profile[1].qualities ? i.imageInfo.profile[1].qualities : [];
  return {
    url: i.imageInfo["@id"].replace(/\/?(?:info\.json)?$/g, ""),
    sizes: i.imageInfo.sizes === void 0 ? void 0 : i.imageInfo.sizes.map(function(a) {
      return [a.width, a.height];
    }),
    tileSize: i.imageInfo.tiles === void 0 ? void 0 : [
      i.imageInfo.tiles.map(function(a) {
        return a.width;
      })[0],
      i.imageInfo.tiles.map(function(a) {
        return a.height === void 0 ? a.width : a.height;
      })[0]
    ],
    resolutions: i.imageInfo.tiles === void 0 ? void 0 : i.imageInfo.tiles.map(function(a) {
      return a.scaleFactors;
    })[0],
    supports: [...e.supports, ...r],
    formats: [...e.formats, ...n],
    qualities: [...e.qualities, ...s]
  };
}
function oK(i) {
  const e = i.getComplianceLevelSupportedFeatures(), t = i.imageInfo.extraFormats === void 0 ? e.formats : [...e.formats, ...i.imageInfo.extraFormats], r = i.imageInfo.preferredFormats !== void 0 && Array.isArray(i.imageInfo.preferredFormats) && i.imageInfo.preferredFormats.length > 0 ? i.imageInfo.preferredFormats.filter(function(n) {
    return ["jpg", "png", "gif"].includes(n);
  }).reduce(function(n, s) {
    return n === void 0 && t.includes(s) ? s : n;
  }, void 0) : void 0;
  return {
    url: i.imageInfo.id,
    sizes: i.imageInfo.sizes === void 0 ? void 0 : i.imageInfo.sizes.map(function(n) {
      return [n.width, n.height];
    }),
    tileSize: i.imageInfo.tiles === void 0 ? void 0 : [
      i.imageInfo.tiles.map(function(n) {
        return n.width;
      })[0],
      i.imageInfo.tiles.map(function(n) {
        return n.height;
      })[0]
    ],
    resolutions: i.imageInfo.tiles === void 0 ? void 0 : i.imageInfo.tiles.map(function(n) {
      return n.scaleFactors;
    })[0],
    supports: i.imageInfo.extraFeatures === void 0 ? e.supports : [...e.supports, ...i.imageInfo.extraFeatures],
    formats: t,
    qualities: i.imageInfo.extraQualities === void 0 ? e.qualities : [...e.qualities, ...i.imageInfo.extraQualities],
    preferredFormat: r
  };
}
const qv = {};
qv[es.VERSION1] = sK;
qv[es.VERSION2] = aK;
qv[es.VERSION3] = oK;
class AK {
  /**
   * @param {string|ImageInformationResponse} imageInfo
   * Deserialized image information JSON response object or JSON response as string
   */
  constructor(e) {
    this.setImageInfo(e);
  }
  /**
   * @param {string|ImageInformationResponse} imageInfo
   * Deserialized image information JSON response object or JSON response as string
   * @api
   */
  setImageInfo(e) {
    typeof e == "string" ? this.imageInfo = JSON.parse(e) : this.imageInfo = e;
  }
  /**
   * @return {Versions} Major IIIF version.
   * @api
   */
  getImageApiVersion() {
    if (this.imageInfo === void 0)
      return;
    let e = this.imageInfo["@context"] || "ol-no-context";
    typeof e == "string" && (e = [e]);
    for (let t = 0; t < e.length; t++)
      switch (e[t]) {
        case "http://library.stanford.edu/iiif/image-api/1.1/context.json":
        case "http://iiif.io/api/image/1/context.json":
          return es.VERSION1;
        case "http://iiif.io/api/image/2/context.json":
          return es.VERSION2;
        case "http://iiif.io/api/image/3/context.json":
          return es.VERSION3;
        case "ol-no-context":
          if (this.getComplianceLevelEntryFromProfile(es.VERSION1) && this.imageInfo.identifier)
            return es.VERSION1;
          break;
      }
    lt(!1, 61);
  }
  /**
   * @param {Versions} version Optional IIIF image API version
   * @return {string} Compliance level as it appears in the IIIF image information
   * response.
   */
  getComplianceLevelEntryFromProfile(e) {
    if (!(this.imageInfo === void 0 || this.imageInfo.profile === void 0))
      switch (e === void 0 && (e = this.getImageApiVersion()), e) {
        case es.VERSION1:
          if (iK.test(this.imageInfo.profile))
            return this.imageInfo.profile;
          break;
        case es.VERSION3:
          if (nK.test(this.imageInfo.profile))
            return this.imageInfo.profile;
          break;
        case es.VERSION2:
          if (typeof this.imageInfo.profile == "string" && S5.test(this.imageInfo.profile))
            return this.imageInfo.profile;
          if (Array.isArray(this.imageInfo.profile) && this.imageInfo.profile.length > 0 && typeof this.imageInfo.profile[0] == "string" && S5.test(this.imageInfo.profile[0]))
            return this.imageInfo.profile[0];
          break;
      }
  }
  /**
   * @param {Versions} version Optional IIIF image API version
   * @return {string} Compliance level, on of 'level0', 'level1' or 'level2' or undefined
   */
  getComplianceLevelFromProfile(e) {
    const t = this.getComplianceLevelEntryFromProfile(e);
    if (t === void 0)
      return;
    const r = t.match(/level[0-2](?:\.json)?$/g);
    return Array.isArray(r) ? r[0].replace(".json", "") : void 0;
  }
  /**
   * @return {SupportedFeatures} Image formats, qualities and region / size calculation
   * methods that are supported by the IIIF service.
   */
  getComplianceLevelSupportedFeatures() {
    if (this.imageInfo === void 0)
      return;
    const e = this.getImageApiVersion(), t = this.getComplianceLevelFromProfile(e);
    return t === void 0 ? yh.none.none : yh[e][t];
  }
  /**
   * @param {PreferredOptions} [preferredOptions] Optional options for preferred format and quality.
   * @return {import("../source/IIIF.js").Options} IIIF tile source ready constructor options.
   * @api
   */
  getTileSourceOptions(e) {
    const t = e || {}, r = this.getImageApiVersion();
    if (r === void 0)
      return;
    const n = r === void 0 ? void 0 : qv[r](this);
    if (n !== void 0)
      return {
        url: n.url,
        version: r,
        size: [this.imageInfo.width, this.imageInfo.height],
        sizes: n.sizes,
        format: t.format !== void 0 && n.formats.includes(t.format) ? t.format : n.preferredFormat !== void 0 ? n.preferredFormat : "jpg",
        supports: n.supports,
        quality: t.quality && n.qualities.includes(t.quality) ? t.quality : n.qualities.includes("native") ? "native" : "default",
        resolutions: Array.isArray(n.resolutions) ? n.resolutions.sort(function(s, a) {
          return a - s;
        }) : void 0,
        tileSize: n.tileSize
      };
  }
}
const lK = AK;
class hK extends QM {
  /**
   * @param {import("../proj/Projection.js").default} sourceProj Source projection (of the data).
   * @param {import("../proj/Projection.js").default} targetProj Target projection.
   * @param {import("../extent.js").Extent} targetExtent Target extent.
   * @param {number} targetResolution Target resolution.
   * @param {number} pixelRatio Pixel ratio.
   * @param {FunctionType} getImageFunction
   *     Function returning source images (extent, resolution, pixelRatio).
   * @param {boolean} interpolate Use linear interpolation when resampling.
   */
  constructor(e, t, r, n, s, a, o) {
    const A = e.getExtent(), l = t.getExtent(), h = l ? jn(r, l) : r, c = Xn(h), u = Hd(
      e,
      t,
      c,
      n
    ), f = jE, g = new zE(
      e,
      t,
      h,
      A,
      u * f,
      n
    ), p = g.calculateSourceExtent(), y = a(
      p,
      u,
      s
    ), v = y ? Pt.IDLE : Pt.EMPTY, w = y ? y.getPixelRatio() : 1;
    super(r, n, w, v), this.targetProj_ = t, this.maxSourceExtent_ = A, this.triangulation_ = g, this.targetResolution_ = n, this.targetExtent_ = r, this.sourceImage_ = y, this.sourcePixelRatio_ = w, this.interpolate_ = o, this.canvas_ = null, this.sourceListenerKey_ = null;
  }
  /**
   * Clean up.
   */
  disposeInternal() {
    this.state == Pt.LOADING && this.unlistenSource_(), super.disposeInternal();
  }
  /**
   * @return {HTMLCanvasElement} Image.
   */
  getImage() {
    return this.canvas_;
  }
  /**
   * @return {import("../proj/Projection.js").default} Projection.
   */
  getProjection() {
    return this.targetProj_;
  }
  /**
   * @private
   */
  reproject_() {
    const e = this.sourceImage_.getState();
    if (e == Pt.LOADED) {
      const t = ir(this.targetExtent_) / this.targetResolution_, r = _i(this.targetExtent_) / this.targetResolution_;
      this.canvas_ = XE(
        t,
        r,
        this.sourcePixelRatio_,
        this.sourceImage_.getResolution(),
        this.maxSourceExtent_,
        this.targetResolution_,
        this.targetExtent_,
        this.triangulation_,
        [
          {
            extent: this.sourceImage_.getExtent(),
            image: this.sourceImage_.getImage()
          }
        ],
        0,
        void 0,
        this.interpolate_
      );
    }
    this.state = e, this.changed();
  }
  /**
   * Load not yet loaded URI.
   */
  load() {
    if (this.state == Pt.IDLE) {
      this.state = Pt.LOADING, this.changed();
      const e = this.sourceImage_.getState();
      e == Pt.LOADED || e == Pt.ERROR ? this.reproject_() : (this.sourceListenerKey_ = St(
        this.sourceImage_,
        ut.CHANGE,
        function(t) {
          const r = this.sourceImage_.getState();
          (r == Pt.LOADED || r == Pt.ERROR) && (this.unlistenSource_(), this.reproject_());
        },
        this
      ), this.sourceImage_.load());
    }
  }
  /**
   * @private
   */
  unlistenSource_() {
    pr(
      /** @type {!import("../events.js").EventsKey} */
      this.sourceListenerKey_
    ), this.sourceListenerKey_ = null;
  }
}
const cK = hK, X1 = {
  /**
   * Triggered when an image starts loading.
   * @event module:ol/source/Image.ImageSourceEvent#imageloadstart
   * @api
   */
  IMAGELOADSTART: "imageloadstart",
  /**
   * Triggered when an image finishes loading.
   * @event module:ol/source/Image.ImageSourceEvent#imageloadend
   * @api
   */
  IMAGELOADEND: "imageloadend",
  /**
   * Triggered if image loading results in an error.
   * @event module:ol/source/Image.ImageSourceEvent#imageloaderror
   * @api
   */
  IMAGELOADERROR: "imageloaderror"
};
class uK extends _s {
  /**
   * @param {string} type Type.
   * @param {import("../Image.js").default} image The image.
   */
  constructor(e, t) {
    super(e), this.image = t;
  }
}
class fK extends Xv {
  /**
   * @param {Options} options Single image source options.
   */
  constructor(e) {
    super({
      attributions: e.attributions,
      projection: e.projection,
      state: e.state,
      interpolate: e.interpolate !== void 0 ? e.interpolate : !0
    }), this.on, this.once, this.un, this.resolutions_ = e.resolutions !== void 0 ? e.resolutions : null, this.reprojectedImage_ = null, this.reprojectedRevision_ = 0;
  }
  /**
   * @return {Array<number>|null} Resolutions.
   */
  getResolutions() {
    return this.resolutions_;
  }
  /**
   * @param {Array<number>|null} resolutions Resolutions.
   */
  setResolutions(e) {
    this.resolutions_ = e;
  }
  /**
   * @protected
   * @param {number} resolution Resolution.
   * @return {number} Resolution.
   */
  findNearestResolution(e) {
    const t = this.getResolutions();
    if (t) {
      const r = Lv(t, e, 0);
      e = t[r];
    }
    return e;
  }
  /**
   * @param {import("../extent.js").Extent} extent Extent.
   * @param {number} resolution Resolution.
   * @param {number} pixelRatio Pixel ratio.
   * @param {import("../proj/Projection.js").default} projection Projection.
   * @return {import("../ImageBase.js").default} Single image.
   */
  getImage(e, t, r, n) {
    const s = this.getProjection();
    if (!s || !n || Da(s, n))
      return s && (n = s), this.getImageInternal(e, t, r, n);
    if (this.reprojectedImage_) {
      if (this.reprojectedRevision_ == this.getRevision() && Da(this.reprojectedImage_.getProjection(), n) && this.reprojectedImage_.getResolution() == t && Xa(this.reprojectedImage_.getExtent(), e))
        return this.reprojectedImage_;
      this.reprojectedImage_.dispose(), this.reprojectedImage_ = null;
    }
    return this.reprojectedImage_ = new cK(
      s,
      n,
      e,
      t,
      r,
      (a, o, A) => this.getImageInternal(a, o, A, s),
      this.getInterpolate()
    ), this.reprojectedRevision_ = this.getRevision(), this.reprojectedImage_;
  }
  /**
   * @abstract
   * @param {import("../extent.js").Extent} extent Extent.
   * @param {number} resolution Resolution.
   * @param {number} pixelRatio Pixel ratio.
   * @param {import("../proj/Projection.js").default} projection Projection.
   * @return {import("../ImageBase.js").default} Single image.
   * @protected
   */
  getImageInternal(e, t, r, n) {
    return pt();
  }
  /**
   * Handle image change events.
   * @param {import("../events/Event.js").default} event Event.
   * @protected
   */
  handleImageChange(e) {
    const t = (
      /** @type {import("../Image.js").default} */
      e.target
    );
    let r;
    switch (t.getState()) {
      case Pt.LOADING:
        this.loading = !0, r = X1.IMAGELOADSTART;
        break;
      case Pt.LOADED:
        this.loading = !1, r = X1.IMAGELOADEND;
        break;
      case Pt.ERROR:
        this.loading = !1, r = X1.IMAGELOADERROR;
        break;
      default:
        return;
    }
    this.hasListener(r) && this.dispatchEvent(new uK(r, t));
  }
}
function R4(i, e) {
  i.getImage().src = e;
}
const M4 = fK;
function wu(i, e) {
  const t = [];
  Object.keys(e).forEach(function(n) {
    e[n] !== null && e[n] !== void 0 && t.push(n + "=" + encodeURIComponent(e[n]));
  });
  const r = t.join("&");
  return i = i.replace(/[?&]$/, ""), i += i.includes("?") ? "&" : "?", i + r;
}
class dK extends M4 {
  /**
   * @param {Options} options ImageStatic options.
   */
  constructor(e) {
    const t = e.crossOrigin !== void 0 ? e.crossOrigin : null, r = e.imageLoadFunction !== void 0 ? e.imageLoadFunction : R4;
    super({
      attributions: e.attributions,
      interpolate: e.interpolate,
      projection: Ct(e.projection)
    }), this.url_ = e.url, this.imageExtent_ = e.imageExtent, this.image_ = new DM(
      this.imageExtent_,
      void 0,
      1,
      this.url_,
      t,
      r,
      Ii(1, 1)
    ), this.imageSize_ = e.imageSize ? e.imageSize : null, this.image_.addEventListener(
      ut.CHANGE,
      this.handleImageChange.bind(this)
    );
  }
  /**
   * Returns the image extent
   * @return {import("../extent.js").Extent} image extent.
   * @api
   */
  getImageExtent() {
    return this.imageExtent_;
  }
  /**
   * @param {import("../extent.js").Extent} extent Extent.
   * @param {number} resolution Resolution.
   * @param {number} pixelRatio Pixel ratio.
   * @param {import("../proj/Projection.js").default} projection Projection.
   * @return {import("../Image.js").default} Single image.
   */
  getImageInternal(e, t, r, n) {
    return ci(e, this.image_.getExtent()) ? this.image_ : null;
  }
  /**
   * Return the URL used for this image source.
   * @return {string} URL.
   * @api
   */
  getUrl() {
    return this.url_;
  }
  /**
   * @param {import("../events/Event.js").default} evt Event.
   */
  handleImageChange(e) {
    if (this.image_.getState() == Pt.LOADED) {
      const t = this.image_.getExtent(), r = this.image_.getImage();
      let n, s;
      this.imageSize_ ? (n = this.imageSize_[0], s = this.imageSize_[1]) : (n = r.width, s = r.height);
      const a = ir(t), o = _i(t), A = a / n, l = o / s;
      let h = n, c = s;
      if (A > l ? h = Math.round(a / l) : c = Math.round(o / A), h !== n || c !== s) {
        const u = Ii(h, c);
        this.getInterpolate() || (u.imageSmoothingEnabled = !1);
        const f = u.canvas;
        u.drawImage(
          r,
          0,
          0,
          n,
          s,
          0,
          0,
          f.width,
          f.height
        ), this.image_.setImage(f);
      }
    }
    super.handleImageChange(e);
  }
}
const gK = dK, WA = "1.3.0", RA = 4, T5 = [101, 101];
class pK extends M4 {
  /**
   * @param {Options} [options] ImageWMS options.
   */
  constructor(e) {
    e = e || {}, super({
      attributions: e.attributions,
      interpolate: e.interpolate,
      projection: e.projection,
      resolutions: e.resolutions
    }), this.context_ = Ii(1, 1), this.crossOrigin_ = e.crossOrigin !== void 0 ? e.crossOrigin : null, this.url_ = e.url, this.imageLoadFunction_ = e.imageLoadFunction !== void 0 ? e.imageLoadFunction : R4, this.params_ = Object.assign({}, e.params), this.v13_ = !0, this.updateV13_(), this.serverType_ = e.serverType, this.hidpi_ = e.hidpi !== void 0 ? e.hidpi : !0, this.image_ = null, this.imageSize_ = [0, 0], this.renderedRevision_ = 0, this.ratio_ = e.ratio !== void 0 ? e.ratio : 1.5;
  }
  /**
   * Return the GetFeatureInfo URL for the passed coordinate, resolution, and
   * projection. Return `undefined` if the GetFeatureInfo URL cannot be
   * constructed.
   * @param {import("../coordinate.js").Coordinate} coordinate Coordinate.
   * @param {number} resolution Resolution.
   * @param {import("../proj.js").ProjectionLike} projection Projection.
   * @param {!Object} params GetFeatureInfo params. `INFO_FORMAT` at least should
   *     be provided. If `QUERY_LAYERS` is not provided then the layers specified
   *     in the `LAYERS` parameter will be used. `VERSION` should not be
   *     specified here.
   * @return {string|undefined} GetFeatureInfo URL.
   * @api
   */
  getFeatureInfoUrl(e, t, r, n) {
    if (this.url_ === void 0)
      return;
    const s = Ct(r), a = this.getProjection();
    a && a !== s && (t = Hd(
      a,
      s,
      e,
      t
    ), e = cl(e, s, a));
    const o = th(
      e,
      t,
      0,
      T5
    ), A = {
      SERVICE: "WMS",
      VERSION: WA,
      REQUEST: "GetFeatureInfo",
      FORMAT: "image/png",
      TRANSPARENT: !0,
      QUERY_LAYERS: this.params_.LAYERS
    };
    Object.assign(A, this.params_, n);
    const l = Nc((e[0] - o[0]) / t, RA), h = Nc((o[3] - e[1]) / t, RA);
    return A[this.v13_ ? "I" : "X"] = l, A[this.v13_ ? "J" : "Y"] = h, this.getRequestUrl_(
      o,
      T5,
      1,
      a || s,
      A
    );
  }
  /**
   * Return the GetLegendGraphic URL, optionally optimized for the passed
   * resolution and possibly including any passed specific parameters. Returns
   * `undefined` if the GetLegendGraphic URL cannot be constructed.
   *
   * @param {number} [resolution] Resolution. If set to undefined, `SCALE`
   *     will not be calculated and included in URL.
   * @param {Object} [params] GetLegendGraphic params. If `LAYER` is set, the
   *     request is generated for this wms layer, else it will try to use the
   *     configured wms layer. Default `FORMAT` is `image/png`.
   *     `VERSION` should not be specified here.
   * @return {string|undefined} GetLegendGraphic URL.
   * @api
   */
  getLegendUrl(e, t) {
    if (this.url_ === void 0)
      return;
    const r = {
      SERVICE: "WMS",
      VERSION: WA,
      REQUEST: "GetLegendGraphic",
      FORMAT: "image/png"
    };
    if (t === void 0 || t.LAYER === void 0) {
      const n = this.params_.LAYERS;
      if (!(!Array.isArray(n) || n.length === 1))
        return;
      r.LAYER = n;
    }
    if (e !== void 0) {
      const n = this.getProjection() ? this.getProjection().getMetersPerUnit() : 1, s = 28e-5;
      r.SCALE = e * n / s;
    }
    return Object.assign(r, t), wu(
      /** @type {string} */
      this.url_,
      r
    );
  }
  /**
   * Get the user-provided params, i.e. those passed to the constructor through
   * the "params" option, and possibly updated using the updateParams method.
   * @return {Object} Params.
   * @api
   */
  getParams() {
    return this.params_;
  }
  /**
   * @param {import("../extent.js").Extent} extent Extent.
   * @param {number} resolution Resolution.
   * @param {number} pixelRatio Pixel ratio.
   * @param {import("../proj/Projection.js").default} projection Projection.
   * @return {import("../Image.js").default} Single image.
   */
  getImageInternal(e, t, r, n) {
    if (this.url_ === void 0)
      return null;
    t = this.findNearestResolution(t), r != 1 && (!this.hidpi_ || this.serverType_ === void 0) && (r = 1);
    const s = t / r, a = Xn(e), o = KA(ir(e) / s, RA), A = KA(_i(e) / s, RA), l = th(a, s, 0, [
      o,
      A
    ]), h = KA(
      this.ratio_ * ir(e) / s,
      RA
    ), c = KA(
      this.ratio_ * _i(e) / s,
      RA
    ), u = th(a, s, 0, [
      h,
      c
    ]), f = this.image_;
    if (f && this.renderedRevision_ == this.getRevision() && f.getResolution() == t && f.getPixelRatio() == r && Ps(f.getExtent(), l))
      return f;
    const g = {
      SERVICE: "WMS",
      VERSION: WA,
      REQUEST: "GetMap",
      FORMAT: "image/png",
      TRANSPARENT: !0
    };
    Object.assign(g, this.params_), this.imageSize_[0] = CS(
      ir(u) / s,
      RA
    ), this.imageSize_[1] = CS(
      _i(u) / s,
      RA
    );
    const p = this.getRequestUrl_(
      u,
      this.imageSize_,
      r,
      n,
      g
    );
    return this.image_ = new DM(
      u,
      t,
      r,
      p,
      this.crossOrigin_,
      this.imageLoadFunction_,
      this.context_
    ), this.renderedRevision_ = this.getRevision(), this.image_.addEventListener(
      ut.CHANGE,
      this.handleImageChange.bind(this)
    ), this.image_;
  }
  /**
   * Return the image load function of the source.
   * @return {import("../Image.js").LoadFunction} The image load function.
   * @api
   */
  getImageLoadFunction() {
    return this.imageLoadFunction_;
  }
  /**
   * @param {import("../extent.js").Extent} extent Extent.
   * @param {import("../size.js").Size} size Size.
   * @param {number} pixelRatio Pixel ratio.
   * @param {import("../proj/Projection.js").default} projection Projection.
   * @param {Object} params Params.
   * @return {string} Request URL.
   * @private
   */
  getRequestUrl_(e, t, r, n, s) {
    if (lt(this.url_ !== void 0, 9), s[this.v13_ ? "CRS" : "SRS"] = n.getCode(), "STYLES" in this.params_ || (s.STYLES = ""), r != 1)
      switch (this.serverType_) {
        case "geoserver":
          const A = 90 * r + 0.5 | 0;
          "FORMAT_OPTIONS" in s ? s.FORMAT_OPTIONS += ";dpi:" + A : s.FORMAT_OPTIONS = "dpi:" + A;
          break;
        case "mapserver":
          s.MAP_RESOLUTION = 90 * r;
          break;
        case "carmentaserver":
        case "qgis":
          s.DPI = 90 * r;
          break;
        default:
          lt(!1, 8);
          break;
      }
    s.WIDTH = t[0], s.HEIGHT = t[1];
    const a = n.getAxisOrientation();
    let o;
    return this.v13_ && a.substr(0, 2) == "ne" ? o = [e[1], e[0], e[3], e[2]] : o = e, s.BBOX = o.join(","), wu(
      /** @type {string} */
      this.url_,
      s
    );
  }
  /**
   * Return the URL used for this WMS source.
   * @return {string|undefined} URL.
   * @api
   */
  getUrl() {
    return this.url_;
  }
  /**
   * Set the image load function of the source.
   * @param {import("../Image.js").LoadFunction} imageLoadFunction Image load function.
   * @api
   */
  setImageLoadFunction(e) {
    this.image_ = null, this.imageLoadFunction_ = e, this.changed();
  }
  /**
   * Set the URL to use for requests.
   * @param {string|undefined} url URL.
   * @api
   */
  setUrl(e) {
    e != this.url_ && (this.url_ = e, this.image_ = null, this.changed());
  }
  /**
   * Update the user-provided params.
   * @param {Object} params Params.
   * @api
   */
  updateParams(e) {
    Object.assign(this.params_, e), this.updateV13_(), this.image_ = null, this.changed();
  }
  /**
   * @private
   */
  updateV13_() {
    const e = this.params_.VERSION || WA;
    this.v13_ = MR(e, "1.3") >= 0;
  }
}
const mK = pK, vK = '&#169; <a href="https://www.openstreetmap.org/copyright" target="_blank">OpenStreetMap</a> contributors.';
class yK extends F4 {
  /**
   * @param {Options} [options] Open Street Map options.
   */
  constructor(e) {
    e = e || {};
    let t;
    e.attributions !== void 0 ? t = e.attributions : t = [vK];
    const r = e.crossOrigin !== void 0 ? e.crossOrigin : "anonymous", n = e.url !== void 0 ? e.url : "https://tile.openstreetmap.org/{z}/{x}/{y}.png";
    super({
      attributions: t,
      attributionsCollapsible: !1,
      cacheSize: e.cacheSize,
      crossOrigin: r,
      interpolate: e.interpolate,
      maxZoom: e.maxZoom !== void 0 ? e.maxZoom : 19,
      opaque: e.opaque !== void 0 ? e.opaque : !0,
      reprojectionErrorThreshold: e.reprojectionErrorThreshold,
      tileLoadFunction: e.tileLoadFunction,
      transition: e.transition,
      url: n,
      wrapX: e.wrapX,
      zDirection: e.zDirection
    });
  }
}
const _K = yK;
class wK extends Yv {
  /**
   * @param {Options} [options] Tile WMS options.
   */
  constructor(e) {
    e = e || /** @type {Options} */
    {};
    const t = Object.assign({}, e.params), r = "TRANSPARENT" in t ? t.TRANSPARENT : !0;
    super({
      attributions: e.attributions,
      attributionsCollapsible: e.attributionsCollapsible,
      cacheSize: e.cacheSize,
      crossOrigin: e.crossOrigin,
      interpolate: e.interpolate,
      opaque: !r,
      projection: e.projection,
      reprojectionErrorThreshold: e.reprojectionErrorThreshold,
      tileClass: e.tileClass,
      tileGrid: e.tileGrid,
      tileLoadFunction: e.tileLoadFunction,
      url: e.url,
      urls: e.urls,
      wrapX: e.wrapX !== void 0 ? e.wrapX : !0,
      transition: e.transition,
      zDirection: e.zDirection
    }), this.gutter_ = e.gutter !== void 0 ? e.gutter : 0, this.params_ = t, this.v13_ = !0, this.serverType_ = e.serverType, this.hidpi_ = e.hidpi !== void 0 ? e.hidpi : !0, this.tmpExtent_ = Ji(), this.updateV13_(), this.setKey(this.getKeyForParams_());
  }
  /**
   * Return the GetFeatureInfo URL for the passed coordinate, resolution, and
   * projection. Return `undefined` if the GetFeatureInfo URL cannot be
   * constructed.
   * @param {import("../coordinate.js").Coordinate} coordinate Coordinate.
   * @param {number} resolution Resolution.
   * @param {import("../proj.js").ProjectionLike} projection Projection.
   * @param {!Object} params GetFeatureInfo params. `INFO_FORMAT` at least should
   *     be provided. If `QUERY_LAYERS` is not provided then the layers specified
   *     in the `LAYERS` parameter will be used. `VERSION` should not be
   *     specified here.
   * @return {string|undefined} GetFeatureInfo URL.
   * @api
   */
  getFeatureInfoUrl(e, t, r, n) {
    const s = Ct(r), a = this.getProjection();
    let o = this.getTileGrid();
    o || (o = this.getTileGridForProjection(s));
    const A = o.getZForResolution(t, this.zDirection), l = o.getTileCoordForCoordAndZ(e, A);
    if (o.getResolutions().length <= l[0])
      return;
    let h = o.getResolution(l[0]), c = o.getTileCoordExtent(l, this.tmpExtent_), u = An(o.getTileSize(l[0]), this.tmpSize);
    const f = this.gutter_;
    f !== 0 && (u = kS(u, f, this.tmpSize), c = zn(c, h * f, c)), a && a !== s && (h = Hd(
      a,
      s,
      e,
      h
    ), c = mm(
      c,
      s,
      a
    ), e = cl(e, s, a));
    const g = {
      SERVICE: "WMS",
      VERSION: WA,
      REQUEST: "GetFeatureInfo",
      FORMAT: "image/png",
      TRANSPARENT: !0,
      QUERY_LAYERS: this.params_.LAYERS
    };
    Object.assign(g, this.params_, n);
    const p = Math.floor((e[0] - c[0]) / h), y = Math.floor((c[3] - e[1]) / h);
    return g[this.v13_ ? "I" : "X"] = p, g[this.v13_ ? "J" : "Y"] = y, this.getRequestUrl_(
      l,
      u,
      c,
      1,
      a || s,
      g
    );
  }
  /**
   * Return the GetLegendGraphic URL, optionally optimized for the passed
   * resolution and possibly including any passed specific parameters. Returns
   * `undefined` if the GetLegendGraphic URL cannot be constructed.
   *
   * @param {number} [resolution] Resolution. If set to undefined, `SCALE`
   *     will not be calculated and included in URL.
   * @param {Object} [params] GetLegendGraphic params. If `LAYER` is set, the
   *     request is generated for this wms layer, else it will try to use the
   *     configured wms layer. Default `FORMAT` is `image/png`.
   *     `VERSION` should not be specified here.
   * @return {string|undefined} GetLegendGraphic URL.
   * @api
   */
  getLegendUrl(e, t) {
    if (this.urls[0] === void 0)
      return;
    const r = {
      SERVICE: "WMS",
      VERSION: WA,
      REQUEST: "GetLegendGraphic",
      FORMAT: "image/png"
    };
    if (t === void 0 || t.LAYER === void 0) {
      const n = this.params_.LAYERS;
      if (!(!Array.isArray(n) || n.length === 1))
        return;
      r.LAYER = n;
    }
    if (e !== void 0) {
      const n = this.getProjection() ? this.getProjection().getMetersPerUnit() : 1, s = 28e-5;
      r.SCALE = e * n / s;
    }
    return Object.assign(r, t), wu(
      /** @type {string} */
      this.urls[0],
      r
    );
  }
  /**
   * @return {number} Gutter.
   */
  getGutter() {
    return this.gutter_;
  }
  /**
   * Get the user-provided params, i.e. those passed to the constructor through
   * the "params" option, and possibly updated using the updateParams method.
   * @return {Object} Params.
   * @api
   */
  getParams() {
    return this.params_;
  }
  /**
   * @param {import("../tilecoord.js").TileCoord} tileCoord Tile coordinate.
   * @param {import("../size.js").Size} tileSize Tile size.
   * @param {import("../extent.js").Extent} tileExtent Tile extent.
   * @param {number} pixelRatio Pixel ratio.
   * @param {import("../proj/Projection.js").default} projection Projection.
   * @param {Object} params Params.
   * @return {string|undefined} Request URL.
   * @private
   */
  getRequestUrl_(e, t, r, n, s, a) {
    const o = this.urls;
    if (!o)
      return;
    if (a.WIDTH = t[0], a.HEIGHT = t[1], a[this.v13_ ? "CRS" : "SRS"] = s.getCode(), "STYLES" in this.params_ || (a.STYLES = ""), n != 1)
      switch (this.serverType_) {
        case "geoserver":
          const c = 90 * n + 0.5 | 0;
          "FORMAT_OPTIONS" in a ? a.FORMAT_OPTIONS += ";dpi:" + c : a.FORMAT_OPTIONS = "dpi:" + c;
          break;
        case "mapserver":
          a.MAP_RESOLUTION = 90 * n;
          break;
        case "carmentaserver":
        case "qgis":
          a.DPI = 90 * n;
          break;
        default:
          lt(!1, 52);
          break;
      }
    const A = s.getAxisOrientation(), l = r;
    if (this.v13_ && A.substr(0, 2) == "ne") {
      let c;
      c = r[0], l[0] = r[1], l[1] = c, c = r[2], l[2] = r[3], l[3] = c;
    }
    a.BBOX = l.join(",");
    let h;
    if (o.length == 1)
      h = o[0];
    else {
      const c = tl(qM(e), o.length);
      h = o[c];
    }
    return wu(h, a);
  }
  /**
   * Get the tile pixel ratio for this source.
   * @param {number} pixelRatio Pixel ratio.
   * @return {number} Tile pixel ratio.
   */
  getTilePixelRatio(e) {
    return !this.hidpi_ || this.serverType_ === void 0 ? 1 : e;
  }
  /**
   * @private
   * @return {string} The key for the current params.
   */
  getKeyForParams_() {
    let e = 0;
    const t = [];
    for (const r in this.params_)
      t[e++] = r + "-" + this.params_[r];
    return t.join("/");
  }
  /**
   * Update the user-provided params.
   * @param {Object} params Params.
   * @api
   */
  updateParams(e) {
    Object.assign(this.params_, e), this.updateV13_(), this.setKey(this.getKeyForParams_());
  }
  /**
   * @private
   */
  updateV13_() {
    const e = this.params_.VERSION || WA;
    this.v13_ = MR(e, "1.3") >= 0;
  }
  /**
   * @param {import("../tilecoord.js").TileCoord} tileCoord The tile coordinate
   * @param {number} pixelRatio The pixel ratio
   * @param {import("../proj/Projection.js").default} projection The projection
   * @return {string|undefined} The tile URL
   * @override
   */
  tileUrlFunction(e, t, r) {
    let n = this.getTileGrid();
    if (n || (n = this.getTileGridForProjection(r)), n.getResolutions().length <= e[0])
      return;
    t != 1 && (!this.hidpi_ || this.serverType_ === void 0) && (t = 1);
    const s = n.getResolution(e[0]);
    let a = n.getTileCoordExtent(e, this.tmpExtent_), o = An(n.getTileSize(e[0]), this.tmpSize);
    const A = this.gutter_;
    A !== 0 && (o = kS(o, A, this.tmpSize), a = zn(a, s * A, a)), t != 1 && (o = AM(o, t, this.tmpSize));
    const l = {
      SERVICE: "WMS",
      VERSION: WA,
      REQUEST: "GetMap",
      FORMAT: "image/png",
      TRANSPARENT: !0
    };
    return Object.assign(l, this.params_), this.getRequestUrl_(
      e,
      o,
      a,
      t,
      r,
      l
    );
  }
}
const N4 = wK;
class xK extends sB {
  /**
   * @param {Options} options WMTS options.
   */
  constructor(e) {
    super({
      extent: e.extent,
      origin: e.origin,
      origins: e.origins,
      resolutions: e.resolutions,
      tileSize: e.tileSize,
      tileSizes: e.tileSizes,
      sizes: e.sizes
    }), this.matrixIds_ = e.matrixIds;
  }
  /**
   * @param {number} z Z.
   * @return {string} MatrixId..
   */
  getMatrixId(e) {
    return this.matrixIds_[e];
  }
  /**
   * Get the list of matrix identifiers.
   * @return {Array<string>} MatrixIds.
   * @api
   */
  getMatrixIds() {
    return this.matrixIds_;
  }
}
const A2 = xK;
class CK extends Yv {
  /**
   * @param {Options} options WMTS options.
   */
  constructor(e) {
    const t = e.requestEncoding !== void 0 ? e.requestEncoding : "KVP", r = e.tileGrid;
    let n = e.urls;
    n === void 0 && e.url !== void 0 && (n = T4(e.url)), super({
      attributions: e.attributions,
      attributionsCollapsible: e.attributionsCollapsible,
      cacheSize: e.cacheSize,
      crossOrigin: e.crossOrigin,
      interpolate: e.interpolate,
      projection: e.projection,
      reprojectionErrorThreshold: e.reprojectionErrorThreshold,
      tileClass: e.tileClass,
      tileGrid: r,
      tileLoadFunction: e.tileLoadFunction,
      tilePixelRatio: e.tilePixelRatio,
      urls: n,
      wrapX: e.wrapX !== void 0 ? e.wrapX : !1,
      transition: e.transition,
      zDirection: e.zDirection
    }), this.version_ = e.version !== void 0 ? e.version : "1.0.0", this.format_ = e.format !== void 0 ? e.format : "image/jpeg", this.dimensions_ = e.dimensions !== void 0 ? e.dimensions : {}, this.layer_ = e.layer, this.matrixSet_ = e.matrixSet, this.style_ = e.style, this.requestEncoding_ = t, this.setKey(this.getKeyForDimensions_()), n && n.length > 0 && (this.tileUrlFunction = Hm(
      n.map(this.createFromWMTSTemplate.bind(this))
    ));
  }
  /**
   * Set the URLs to use for requests.
   * URLs may contain OGC conform URL Template Variables: {TileMatrix}, {TileRow}, {TileCol}.
   * @param {Array<string>} urls URLs.
   */
  setUrls(e) {
    this.urls = e;
    const t = e.join(`
`);
    this.setTileUrlFunction(
      Hm(
        e.map(this.createFromWMTSTemplate.bind(this))
      ),
      t
    );
  }
  /**
   * Get the dimensions, i.e. those passed to the constructor through the
   * "dimensions" option, and possibly updated using the updateDimensions
   * method.
   * @return {!Object} Dimensions.
   * @api
   */
  getDimensions() {
    return this.dimensions_;
  }
  /**
   * Return the image format of the WMTS source.
   * @return {string} Format.
   * @api
   */
  getFormat() {
    return this.format_;
  }
  /**
   * Return the layer of the WMTS source.
   * @return {string} Layer.
   * @api
   */
  getLayer() {
    return this.layer_;
  }
  /**
   * Return the matrix set of the WMTS source.
   * @return {string} MatrixSet.
   * @api
   */
  getMatrixSet() {
    return this.matrixSet_;
  }
  /**
   * Return the request encoding, either "KVP" or "REST".
   * @return {RequestEncoding} Request encoding.
   * @api
   */
  getRequestEncoding() {
    return this.requestEncoding_;
  }
  /**
   * Return the style of the WMTS source.
   * @return {string} Style.
   * @api
   */
  getStyle() {
    return this.style_;
  }
  /**
   * Return the version of the WMTS source.
   * @return {string} Version.
   * @api
   */
  getVersion() {
    return this.version_;
  }
  /**
   * @private
   * @return {string} The key for the current dimensions.
   */
  getKeyForDimensions_() {
    const e = this.urls ? this.urls.slice(0) : [];
    for (const t in this.dimensions_)
      e.push(t + "-" + this.dimensions_[t]);
    return e.join("/");
  }
  /**
   * Update the dimensions.
   * @param {Object} dimensions Dimensions.
   * @api
   */
  updateDimensions(e) {
    Object.assign(this.dimensions_, e), this.setKey(this.getKeyForDimensions_());
  }
  /**
   * @param {string} template Template.
   * @return {import("../Tile.js").UrlFunction} Tile URL function.
   */
  createFromWMTSTemplate(e) {
    const t = this.requestEncoding_, r = {
      layer: this.layer_,
      style: this.style_,
      tilematrixset: this.matrixSet_
    };
    t == "KVP" && Object.assign(r, {
      Service: "WMTS",
      Request: "GetTile",
      Version: this.version_,
      Format: this.format_
    }), e = t == "KVP" ? wu(e, r) : e.replace(/\{(\w+?)\}/g, function(a, o) {
      return o.toLowerCase() in r ? r[o.toLowerCase()] : a;
    });
    const n = (
      /** @type {import("../tilegrid/WMTS.js").default} */
      this.tileGrid
    ), s = this.dimensions_;
    return (
      /**
       * @param {import("../tilecoord.js").TileCoord} tileCoord Tile coordinate.
       * @param {number} pixelRatio Pixel ratio.
       * @param {import("../proj/Projection.js").default} projection Projection.
       * @return {string|undefined} Tile URL.
       */
      function(a, o, A) {
        if (!a)
          return;
        const l = {
          TileMatrix: n.getMatrixId(a[0]),
          TileCol: a[1],
          TileRow: a[2]
        };
        Object.assign(l, s);
        let h = e;
        return t == "KVP" ? h = wu(h, l) : h = h.replace(/\{(\w+?)\}/g, function(c, u) {
          return l[u];
        }), h;
      }
    );
  }
}
const P4 = CK;
function Zv(i) {
  const e = i.frameState, t = gh(i.inversePixelTransform.slice(), e.coordinateToPixelTransform);
  return new m4(
    i.context,
    e.pixelRatio,
    e.extent,
    t,
    e.viewState.rotation
  );
}
window.ol && (ol.util ? ol.util.VERSION || (ol.util.VERSION = ol.VERSION || "6.1.0") : ol.util = {
  VERSION: ol.VERSION || "5.3.0"
});
var j0 = TQ.split(".");
j0 = parseInt(j0[0]) * 100 + parseInt(j0[1]);
var l2 = function(i, e) {
  var t = i.frameState.pixelRatio;
  if (j0 > 605 && t !== 1 && e.getImage() instanceof Mu) {
    e = e.clone();
    var r = e.getImage();
    r.setScale(r.getScale() * t);
    var n = r.getAnchor();
    if (r.setDisplacement) {
      var s = r.getDisplacement();
      s && (s[0] -= n[0] / t, s[1] += n[1] / t, r.setAnchor([0, 0]));
    } else
      n && (n[0] /= t, n[1] /= t);
  }
  return e;
}, EK = class extends nA {
  constructor(e) {
    var t = e || {};
    super(t), this.oldcluster = new sA(), this.clusters = [], this.animation = { start: !1 }, this.set("animationDuration", typeof t.animationDuration == "number" ? t.animationDuration : 700), this.set("animationMethod", t.animationMethod || ea), this.getSource().on("change", this.saveCluster.bind(this)), this.on(["precompose", "prerender"], this.animate.bind(this)), this.on(["postcompose", "postrender"], this.postanimate.bind(this));
  }
  /** save cluster features before change
   * @private
   */
  saveCluster() {
    if (this.oldcluster) {
      if (this.oldcluster.clear(), !this.get("animationDuration"))
        return;
      var e = this.getSource().getFeatures();
      e.length && e[0].get("features") && (this.oldcluster.addFeatures(this.clusters), this.clusters = e.slice(0), this.sourceChanged = !0);
    }
  }
  /**
   * Get the cluster that contains a feature
   * @private
  */
  getClusterForFeature(e, t) {
    for (var r = 0, n; n = t[r]; r++) {
      var s = n.get("features");
      if (s && s.length) {
        for (var a = 0, o; o = s[a]; a++)
          if (e === o)
            return n;
      }
    }
    return !1;
  }
  /**
   * Stop animation
   * @private
   */
  stopAnimation() {
    this.animation.start = !1, this.animation.cA = [], this.animation.cB = [];
  }
  /**
   * animate the cluster
   * @private
   */
  animate(e) {
    var t = this.get("animationDuration");
    if (t) {
      var r = e.frameState.viewState.resolution, n, s, a = this.animation, o = e.frameState.time;
      if (a.resolution != r && this.sourceChanged) {
        var A = e.frameState.extent;
        for (a.resolution < r ? (A = zn(A, 100 * r), a.cA = this.oldcluster.getFeaturesInExtent(A), a.cB = this.getSource().getFeaturesInExtent(A), a.revers = !1) : (A = zn(A, 100 * r), a.cA = this.getSource().getFeaturesInExtent(A), a.cB = this.oldcluster.getFeaturesInExtent(A), a.revers = !0), a.clusters = [], n = 0, s; s = a.cA[n]; n++) {
          var l = s.get("features");
          if (l && l.length) {
            var h = this.getClusterForFeature(l[0], a.cB);
            h && a.clusters.push({ f: s, pt: h.getGeometry().getCoordinates() });
          }
        }
        if (a.resolution = r, this.sourceChanged = !1, !a.clusters.length || a.clusters.length > 1e3) {
          this.stopAnimation();
          return;
        }
        o = a.start = (/* @__PURE__ */ new Date()).getTime();
      }
      if (a.start) {
        var c = e.vectorContext || Zv(e), u = (o - a.start) / t;
        u > 1 && (this.stopAnimation(), u = 1), u = this.get("animationMethod")(u);
        var f = this.getStyle(), g = typeof f == "function" ? f : f.length ? function() {
          return f;
        } : function() {
          return [f];
        };
        for (e.context.save(), e.context.globalAlpha = this.getOpacity(), n = 0, h; h = a.clusters[n]; n++) {
          var p = h.f.getGeometry().getCoordinates(), y = p[0] - h.pt[0], v = p[1] - h.pt[1];
          a.revers ? (p[0] = h.pt[0] + u * y, p[1] = h.pt[1] + u * v) : (p[0] = p[0] - u * y, p[1] = p[1] - u * v);
          var w = g(h.f, r, !0);
          if (w.length || (w = [w]), h.f.get("features").length === 1 && !y && !v)
            l = h.f.get("features")[0];
          else {
            var C = new gr(p);
            l = new qt(C);
          }
          for (var E = 0, S; S = w[E]; E++)
            if (S.getText() && /\n/.test(S.getText().getText())) {
              var M = S.getText().getOffsetX(), T = S.getText().getOffsetY(), F = S.getText().getRotation() || 0, k = Number((S.getText().getFont() || "10px").match(/\d+/)) * 1.2, $ = S.getText().getText().split(`
`), I, L = $.length - 1, P = S.clone();
              $.forEach(function(Q, X) {
                switch (X == 1 && (P.setImage(), P.setFill(), P.setStroke()), S.getText().getTextBaseline()) {
                  case "alphabetic":
                  case "ideographic":
                  case "bottom": {
                    I = L;
                    break;
                  }
                  case "hanging":
                  case "top": {
                    I = 0;
                    break;
                  }
                  default: {
                    I = L / 2;
                    break;
                  }
                }
                P.getText().setOffsetX(M - Math.sin(F) * k * (X - I)), P.getText().setOffsetY(T + Math.cos(F) * k * (X - I)), P.getText().setText(Q), c.drawFeature(l, l2(e, P));
              });
            } else
              c.drawFeature(l, l2(e, S));
        }
        e.context.restore(), e.frameState.animate = !0, e.context.save(), e.context.beginPath(), e.context.rect(0, 0, 0, 0), e.context.clip(), this.clip_ = !0;
      }
    }
  }
  /**
   * remove clipping after the layer is drawn
   * @private
   */
  postanimate(e) {
    this.clip_ && (e.context.restore(), this.clip_ = !1);
  }
};
const BK = {
  extends: Th,
  name: "ol-animated-clusterlayer",
  setup(i) {
    const e = _t("map"), { properties: t } = sr(i), r = cr(() => new EK({
      ...t,
      source: new I4({
        distance: t.distance,
        geometryFunction: (a) => a.getGeometry()
      })
    })), n = cr(() => r.value.getSource());
    return at(t, () => {
      r.value.setProperties(t), r.value.changed();
    }), tr(() => {
      e.addLayer(r.value), r.value.changed(), e.changed();
    }), nr(() => {
      e.removeLayer(r.value);
    }), Ur("vectorLayer", n), Ur("stylable", r), {
      vectorLayer: r,
      map: e
    };
  },
  props: {
    animationDuration: {
      type: Number,
      default: 700
    },
    distance: {
      type: Number,
      default: 20
    },
    animationMethod: {
      type: Function,
      default: ea
    },
    updateWhileAnimating: {
      type: Boolean,
      default: !1
    },
    updateWhileInteracting: {
      type: Boolean,
      default: !1
    }
  }
};
function bK(i, e, t, r, n, s) {
  return xn(), Cn("div", null, [
    mr(i.$slots, "default")
  ]);
}
const h2 = /* @__PURE__ */ qe(BK, [["render", bK]]), Na = new Uint8Array(4);
class SK {
  /**
   * @param {import("./Helper.js").default} helper WebGL helper; mandatory.
   * @param {Array<number>} [size] Expected size of the render target texture; note: this can be changed later on.
   */
  constructor(e, t) {
    this.helper_ = e;
    const r = e.getGL();
    this.texture_ = r.createTexture(), this.framebuffer_ = r.createFramebuffer(), this.size_ = t || [1, 1], this.data_ = new Uint8Array(0), this.dataCacheDirty_ = !0, this.updateSize_();
  }
  /**
   * Changes the size of the render target texture. Note: will do nothing if the size
   * is already the same.
   * @param {Array<number>} size Expected size of the render target texture
   * @api
   */
  setSize(e) {
    Za(e, this.size_) || (this.size_[0] = e[0], this.size_[1] = e[1], this.updateSize_());
  }
  /**
   * Returns the size of the render target texture
   * @return {Array<number>} Size of the render target texture
   * @api
   */
  getSize() {
    return this.size_;
  }
  /**
   * This will cause following calls to `#readAll` or `#readPixel` to download the content of the
   * render target into memory, which is an expensive operation.
   * This content will be kept in cache but should be cleared after each new render.
   * @api
   */
  clearCachedData() {
    this.dataCacheDirty_ = !0;
  }
  /**
   * Returns the full content of the frame buffer as a series of r, g, b, a components
   * in the 0-255 range (unsigned byte).
   * @return {Uint8Array} Integer array of color values
   * @api
   */
  readAll() {
    if (this.dataCacheDirty_) {
      const e = this.size_, t = this.helper_.getGL();
      t.bindFramebuffer(t.FRAMEBUFFER, this.framebuffer_), t.readPixels(
        0,
        0,
        e[0],
        e[1],
        t.RGBA,
        t.UNSIGNED_BYTE,
        this.data_
      ), this.dataCacheDirty_ = !1;
    }
    return this.data_;
  }
  /**
   * Reads one pixel of the frame buffer as an array of r, g, b, a components
   * in the 0-255 range (unsigned byte).
   * If x and/or y are outside of existing data, an array filled with 0 is returned.
   * @param {number} x Pixel coordinate
   * @param {number} y Pixel coordinate
   * @return {Uint8Array} Integer array with one color value (4 components)
   * @api
   */
  readPixel(e, t) {
    if (e < 0 || t < 0 || e > this.size_[0] || t >= this.size_[1])
      return Na[0] = 0, Na[1] = 0, Na[2] = 0, Na[3] = 0, Na;
    this.readAll();
    const r = Math.floor(e) + (this.size_[1] - Math.floor(t) - 1) * this.size_[0];
    return Na[0] = this.data_[r * 4], Na[1] = this.data_[r * 4 + 1], Na[2] = this.data_[r * 4 + 2], Na[3] = this.data_[r * 4 + 3], Na;
  }
  /**
   * @return {WebGLTexture} Texture to render to
   */
  getTexture() {
    return this.texture_;
  }
  /**
   * @return {WebGLFramebuffer} Frame buffer of the render target
   */
  getFramebuffer() {
    return this.framebuffer_;
  }
  /**
   * @private
   */
  updateSize_() {
    const e = this.size_, t = this.helper_.getGL();
    this.texture_ = this.helper_.createTexture(e, null, this.texture_), t.bindFramebuffer(t.FRAMEBUFFER, this.framebuffer_), t.viewport(0, 0, e[0], e[1]), t.framebufferTexture2D(
      t.FRAMEBUFFER,
      t.COLOR_ATTACHMENT0,
      t.TEXTURE_2D,
      this.texture_,
      0
    ), this.data_ = new Uint8Array(e[0] * e[1] * 4);
  }
}
const TK = SK, W1 = {
  GENERATE_POLYGON_BUFFERS: "GENERATE_POLYGON_BUFFERS",
  GENERATE_POINT_BUFFERS: "GENERATE_POINT_BUFFERS",
  GENERATE_LINE_STRING_BUFFERS: "GENERATE_LINE_STRING_BUFFERS"
};
var c2 = {}, FK = {
  get exports() {
    return c2;
  },
  set exports(i) {
    c2 = i;
  }
};
FK.exports = Jv;
c2.default = Jv;
function Jv(i, e, t) {
  t = t || 2;
  var r = e && e.length, n = r ? e[0] * t : i.length, s = O4(i, 0, n, t, !0), a = [];
  if (!s || s.next === s.prev)
    return a;
  var o, A, l, h, c, u, f;
  if (r && (s = NK(i, e, s, t)), i.length > 80 * t) {
    o = l = i[0], A = h = i[1];
    for (var g = t; g < n; g += t)
      c = i[g], u = i[g + 1], c < o && (o = c), u < A && (A = u), c > l && (l = c), u > h && (h = u);
    f = Math.max(l - o, h - A), f = f !== 0 ? 32767 / f : 0;
  }
  return zd(s, a, t, o, A, f, 0), a;
}
function O4(i, e, t, r, n) {
  var s, a;
  if (n === d2(i, e, t, r) > 0)
    for (s = e; s < t; s += r)
      a = F5(s, i[s], i[s + 1], a);
  else
    for (s = t - r; s >= e; s -= r)
      a = F5(s, i[s], i[s + 1], a);
  return a && ey(a, a.next) && (Wd(a), a = a.next), a;
}
function _h(i, e) {
  if (!i)
    return i;
  e || (e = i);
  var t = i, r;
  do
    if (r = !1, !t.steiner && (ey(t, t.next) || yi(t.prev, t, t.next) === 0)) {
      if (Wd(t), t = e = t.prev, t === t.next)
        break;
      r = !0;
    } else
      t = t.next;
  while (r || t !== e);
  return e;
}
function zd(i, e, t, r, n, s, a) {
  if (i) {
    !a && s && DK(i, r, n, s);
    for (var o = i, A, l; i.prev !== i.next; ) {
      if (A = i.prev, l = i.next, s ? IK(i, r, n, s) : LK(i)) {
        e.push(A.i / t | 0), e.push(i.i / t | 0), e.push(l.i / t | 0), Wd(i), i = l.next, o = l.next;
        continue;
      }
      if (i = l, i === o) {
        a ? a === 1 ? (i = RK(_h(i), e, t), zd(i, e, t, r, n, s, 2)) : a === 2 && MK(i, e, t, r, n, s) : zd(_h(i), e, t, r, n, s, 1);
        break;
      }
    }
  }
}
function LK(i) {
  var e = i.prev, t = i, r = i.next;
  if (yi(e, t, r) >= 0)
    return !1;
  for (var n = e.x, s = t.x, a = r.x, o = e.y, A = t.y, l = r.y, h = n < s ? n < a ? n : a : s < a ? s : a, c = o < A ? o < l ? o : l : A < l ? A : l, u = n > s ? n > a ? n : a : s > a ? s : a, f = o > A ? o > l ? o : l : A > l ? A : l, g = r.next; g !== e; ) {
    if (g.x >= h && g.x <= u && g.y >= c && g.y <= f && Hc(n, o, s, A, a, l, g.x, g.y) && yi(g.prev, g, g.next) >= 0)
      return !1;
    g = g.next;
  }
  return !0;
}
function IK(i, e, t, r) {
  var n = i.prev, s = i, a = i.next;
  if (yi(n, s, a) >= 0)
    return !1;
  for (var o = n.x, A = s.x, l = a.x, h = n.y, c = s.y, u = a.y, f = o < A ? o < l ? o : l : A < l ? A : l, g = h < c ? h < u ? h : u : c < u ? c : u, p = o > A ? o > l ? o : l : A > l ? A : l, y = h > c ? h > u ? h : u : c > u ? c : u, v = u2(f, g, e, t, r), w = u2(p, y, e, t, r), C = i.prevZ, E = i.nextZ; C && C.z >= v && E && E.z <= w; ) {
    if (C.x >= f && C.x <= p && C.y >= g && C.y <= y && C !== n && C !== a && Hc(o, h, A, c, l, u, C.x, C.y) && yi(C.prev, C, C.next) >= 0 || (C = C.prevZ, E.x >= f && E.x <= p && E.y >= g && E.y <= y && E !== n && E !== a && Hc(o, h, A, c, l, u, E.x, E.y) && yi(E.prev, E, E.next) >= 0))
      return !1;
    E = E.nextZ;
  }
  for (; C && C.z >= v; ) {
    if (C.x >= f && C.x <= p && C.y >= g && C.y <= y && C !== n && C !== a && Hc(o, h, A, c, l, u, C.x, C.y) && yi(C.prev, C, C.next) >= 0)
      return !1;
    C = C.prevZ;
  }
  for (; E && E.z <= w; ) {
    if (E.x >= f && E.x <= p && E.y >= g && E.y <= y && E !== n && E !== a && Hc(o, h, A, c, l, u, E.x, E.y) && yi(E.prev, E, E.next) >= 0)
      return !1;
    E = E.nextZ;
  }
  return !0;
}
function RK(i, e, t) {
  var r = i;
  do {
    var n = r.prev, s = r.next.next;
    !ey(n, s) && U4(n, r, r.next, s) && Xd(n, s) && Xd(s, n) && (e.push(n.i / t | 0), e.push(r.i / t | 0), e.push(s.i / t | 0), Wd(r), Wd(r.next), r = i = s), r = r.next;
  } while (r !== i);
  return _h(r);
}
function MK(i, e, t, r, n, s) {
  var a = i;
  do {
    for (var o = a.next.next; o !== a.prev; ) {
      if (a.i !== o.i && GK(a, o)) {
        var A = Q4(a, o);
        a = _h(a, a.next), A = _h(A, A.next), zd(a, e, t, r, n, s, 0), zd(A, e, t, r, n, s, 0);
        return;
      }
      o = o.next;
    }
    a = a.next;
  } while (a !== i);
}
function NK(i, e, t, r) {
  var n = [], s, a, o, A, l;
  for (s = 0, a = e.length; s < a; s++)
    o = e[s] * r, A = s < a - 1 ? e[s + 1] * r : i.length, l = O4(i, o, A, r, !1), l === l.next && (l.steiner = !0), n.push(HK(l));
  for (n.sort(PK), s = 0; s < n.length; s++)
    t = OK(n[s], t);
  return t;
}
function PK(i, e) {
  return i.x - e.x;
}
function OK(i, e) {
  var t = UK(i, e);
  if (!t)
    return e;
  var r = Q4(t, i);
  return _h(r, r.next), _h(t, t.next);
}
function UK(i, e) {
  var t = e, r = i.x, n = i.y, s = -1 / 0, a;
  do {
    if (n <= t.y && n >= t.next.y && t.next.y !== t.y) {
      var o = t.x + (n - t.y) * (t.next.x - t.x) / (t.next.y - t.y);
      if (o <= r && o > s && (s = o, a = t.x < t.next.x ? t : t.next, o === r))
        return a;
    }
    t = t.next;
  } while (t !== e);
  if (!a)
    return null;
  var A = a, l = a.x, h = a.y, c = 1 / 0, u;
  t = a;
  do
    r >= t.x && t.x >= l && r !== t.x && Hc(n < h ? r : s, n, l, h, n < h ? s : r, n, t.x, t.y) && (u = Math.abs(n - t.y) / (r - t.x), Xd(t, i) && (u < c || u === c && (t.x > a.x || t.x === a.x && QK(a, t))) && (a = t, c = u)), t = t.next;
  while (t !== A);
  return a;
}
function QK(i, e) {
  return yi(i.prev, i, e.prev) < 0 && yi(e.next, i, i.next) < 0;
}
function DK(i, e, t, r) {
  var n = i;
  do
    n.z === 0 && (n.z = u2(n.x, n.y, e, t, r)), n.prevZ = n.prev, n.nextZ = n.next, n = n.next;
  while (n !== i);
  n.prevZ.nextZ = null, n.prevZ = null, kK(n);
}
function kK(i) {
  var e, t, r, n, s, a, o, A, l = 1;
  do {
    for (t = i, i = null, s = null, a = 0; t; ) {
      for (a++, r = t, o = 0, e = 0; e < l && (o++, r = r.nextZ, !!r); e++)
        ;
      for (A = l; o > 0 || A > 0 && r; )
        o !== 0 && (A === 0 || !r || t.z <= r.z) ? (n = t, t = t.nextZ, o--) : (n = r, r = r.nextZ, A--), s ? s.nextZ = n : i = n, n.prevZ = s, s = n;
      t = r;
    }
    s.nextZ = null, l *= 2;
  } while (a > 1);
  return i;
}
function u2(i, e, t, r, n) {
  return i = (i - t) * n | 0, e = (e - r) * n | 0, i = (i | i << 8) & 16711935, i = (i | i << 4) & 252645135, i = (i | i << 2) & 858993459, i = (i | i << 1) & 1431655765, e = (e | e << 8) & 16711935, e = (e | e << 4) & 252645135, e = (e | e << 2) & 858993459, e = (e | e << 1) & 1431655765, i | e << 1;
}
function HK(i) {
  var e = i, t = i;
  do
    (e.x < t.x || e.x === t.x && e.y < t.y) && (t = e), e = e.next;
  while (e !== i);
  return t;
}
function Hc(i, e, t, r, n, s, a, o) {
  return (n - a) * (e - o) >= (i - a) * (s - o) && (i - a) * (r - o) >= (t - a) * (e - o) && (t - a) * (s - o) >= (n - a) * (r - o);
}
function GK(i, e) {
  return i.next.i !== e.i && i.prev.i !== e.i && !$K(i, e) && // dones't intersect other edges
  (Xd(i, e) && Xd(e, i) && VK(i, e) && // locally visible
  (yi(i.prev, i, e.prev) || yi(i, e.prev, e)) || // does not create opposite-facing sectors
  ey(i, e) && yi(i.prev, i, i.next) > 0 && yi(e.prev, e, e.next) > 0);
}
function yi(i, e, t) {
  return (e.y - i.y) * (t.x - e.x) - (e.x - i.x) * (t.y - e.y);
}
function ey(i, e) {
  return i.x === e.x && i.y === e.y;
}
function U4(i, e, t, r) {
  var n = Up(yi(i, e, t)), s = Up(yi(i, e, r)), a = Up(yi(t, r, i)), o = Up(yi(t, r, e));
  return !!(n !== s && a !== o || n === 0 && Op(i, t, e) || s === 0 && Op(i, r, e) || a === 0 && Op(t, i, r) || o === 0 && Op(t, e, r));
}
function Op(i, e, t) {
  return e.x <= Math.max(i.x, t.x) && e.x >= Math.min(i.x, t.x) && e.y <= Math.max(i.y, t.y) && e.y >= Math.min(i.y, t.y);
}
function Up(i) {
  return i > 0 ? 1 : i < 0 ? -1 : 0;
}
function $K(i, e) {
  var t = i;
  do {
    if (t.i !== i.i && t.next.i !== i.i && t.i !== e.i && t.next.i !== e.i && U4(t, t.next, i, e))
      return !0;
    t = t.next;
  } while (t !== i);
  return !1;
}
function Xd(i, e) {
  return yi(i.prev, i, i.next) < 0 ? yi(i, e, i.next) >= 0 && yi(i, i.prev, e) >= 0 : yi(i, e, i.prev) < 0 || yi(i, i.next, e) < 0;
}
function VK(i, e) {
  var t = i, r = !1, n = (i.x + e.x) / 2, s = (i.y + e.y) / 2;
  do
    t.y > s != t.next.y > s && t.next.y !== t.y && n < (t.next.x - t.x) * (s - t.y) / (t.next.y - t.y) + t.x && (r = !r), t = t.next;
  while (t !== i);
  return r;
}
function Q4(i, e) {
  var t = new f2(i.i, i.x, i.y), r = new f2(e.i, e.x, e.y), n = i.next, s = e.prev;
  return i.next = e, e.prev = i, t.next = n, n.prev = t, r.next = t, t.prev = r, s.next = r, r.prev = s, r;
}
function F5(i, e, t, r) {
  var n = new f2(i, e, t);
  return r ? (n.next = r.next, n.prev = r, r.next.prev = n, r.next = n) : (n.prev = n, n.next = n), n;
}
function Wd(i) {
  i.next.prev = i.prev, i.prev.next = i.next, i.prevZ && (i.prevZ.nextZ = i.nextZ), i.nextZ && (i.nextZ.prevZ = i.prevZ);
}
function f2(i, e, t) {
  this.i = i, this.x = e, this.y = t, this.prev = null, this.next = null, this.z = 0, this.prevZ = null, this.nextZ = null, this.steiner = !1;
}
Jv.deviation = function(i, e, t, r) {
  var n = e && e.length, s = n ? e[0] * t : i.length, a = Math.abs(d2(i, 0, s, t));
  if (n)
    for (var o = 0, A = e.length; o < A; o++) {
      var l = e[o] * t, h = o < A - 1 ? e[o + 1] * t : i.length;
      a -= Math.abs(d2(i, l, h, t));
    }
  var c = 0;
  for (o = 0; o < r.length; o += 3) {
    var u = r[o] * t, f = r[o + 1] * t, g = r[o + 2] * t;
    c += Math.abs(
      (i[u] - i[g]) * (i[f + 1] - i[u + 1]) - (i[u] - i[f]) * (i[g + 1] - i[u + 1])
    );
  }
  return a === 0 && c === 0 ? 0 : Math.abs((c - a) / a);
};
function d2(i, e, t, r) {
  for (var n = 0, s = e, a = t - r; s < t; s += r)
    n += (i[a] - i[s]) * (i[s + 1] + i[a + 1]), a = s;
  return n;
}
Jv.flatten = function(i) {
  for (var e = i[0][0].length, t = { vertices: [], holes: [], dimensions: e }, r = 0, n = 0; n < i.length; n++) {
    for (var s = 0; s < i[n].length; s++)
      for (var a = 0; a < e; a++)
        t.vertices.push(i[n][s][a]);
    n > 0 && (r += i[n - 1].length, t.holes.push(r));
  }
  return t;
};
function KK(i, e) {
  e = e || [];
  const t = 256, r = t - 1;
  return e[0] = Math.floor(i / t / t / t) / r, e[1] = Math.floor(i / t / t) % t / r, e[2] = Math.floor(i / t) % t / r, e[3] = i % t / r, e;
}
function jK(i) {
  let e = 0;
  const t = 256, r = t - 1;
  return e += Math.round(i[0] * t * t * t * r), e += Math.round(i[1] * t * t * r), e += Math.round(i[2] * t * r), e += Math.round(i[3] * r), e;
}
function zK() {
  const i = 'const e="GENERATE_POLYGON_BUFFERS",t="GENERATE_POINT_BUFFERS",n="GENERATE_LINE_STRING_BUFFERS",r={1:"The view center is not defined",2:"The view resolution is not defined",3:"The view rotation is not defined",4:"`image` and `src` cannot be provided at the same time",5:"`imgSize` must be set when `image` is provided",7:"`format` must be set when `url` is set",8:"Unknown `serverType` configured",9:"`url` must be configured or set using `#setUrl()`",10:"The default `geometryFunction` can only handle `Point` geometries",11:"`options.featureTypes` must be an Array",12:"`options.geometryName` must also be provided when `options.bbox` is set",13:"Invalid corner",14:"Invalid color",15:"Tried to get a value for a key that does not exist in the cache",16:"Tried to set a value for a key that is used already",17:"`resolutions` must be sorted in descending order",18:"Either `origin` or `origins` must be configured, never both",19:"Number of `tileSizes` and `resolutions` must be equal",20:"Number of `origins` and `resolutions` must be equal",22:"Either `tileSize` or `tileSizes` must be configured, never both",24:"Invalid extent or geometry provided as `geometry`",25:"Cannot fit empty extent provided as `geometry`",26:"Features must have an id set",27:"Features must have an id set",28:\'`renderMode` must be `"hybrid"` or `"vector"`\',30:"The passed `feature` was already added to the source",31:"Tried to enqueue an `element` that was already added to the queue",32:"Transformation matrix cannot be inverted",33:"Invalid units",34:"Invalid geometry layout",36:"Unknown SRS type",37:"Unknown geometry type found",38:"`styleMapValue` has an unknown type",39:"Unknown geometry type",40:"Expected `feature` to have a geometry",41:"Expected an `ol/style/Style` or an array of `ol/style/Style.js`",42:"Question unknown, the answer is 42",43:"Expected `layers` to be an array or a `Collection`",47:"Expected `controls` to be an array or an `ol/Collection`",48:"Expected `interactions` to be an array or an `ol/Collection`",49:"Expected `overlays` to be an array or an `ol/Collection`",50:"`options.featureTypes` should be an Array",51:"Either `url` or `tileJSON` options must be provided",52:"Unknown `serverType` configured",53:"Unknown `tierSizeCalculation` configured",55:"The {-y} placeholder requires a tile grid with extent",56:"mapBrowserEvent must originate from a pointer event",57:"At least 2 conditions are required",59:"Invalid command found in the PBF",60:"Missing or invalid `size`",61:"Cannot determine IIIF Image API version from provided image information JSON",62:"A `WebGLArrayBuffer` must either be of type `ELEMENT_ARRAY_BUFFER` or `ARRAY_BUFFER`",64:"Layer opacity must be a number",66:"`forEachFeatureAtCoordinate` cannot be used on a WebGL layer if the hit detection logic has not been enabled. This is done by providing adequate shaders using the `hitVertexShader` and `hitFragmentShader` properties of `WebGLPointsLayerRenderer`",67:"A layer can only be added to the map once. Use either `layer.setMap()` or `map.addLayer()`, not both",68:"A VectorTile source can only be rendered if it has a projection compatible with the view projection",69:"`width` or `height` cannot be provided together with `scale`"};class o extends Error{constructor(e){const t=r[e];super(t),this.code=e,this.name="AssertionError",this.message=t}}var i=o;function a(e,t){const n=t[0],r=t[1];return t[0]=e[0]*n+e[2]*r+e[4],t[1]=e[1]*n+e[3]*r+e[5],t}function s(e,t){const n=(r=t)[0]*r[3]-r[1]*r[2];var r;!function(e,t){if(!e)throw new i(t)}(0!==n,32);const o=t[0],a=t[1],s=t[2],u=t[3],f=t[4],x=t[5];return e[0]=u/n,e[1]=-a/n,e[2]=-s/n,e[3]=o/n,e[4]=(s*x-u*f)/n,e[5]=-(o*x-a*f)/n,e}new Array(6);var u={};function f(e,t,n){n=n||2;var r,o,i,a,s,u,f,l=t&&t.length,c=l?t[0]*n:e.length,v=x(e,0,c,n,!0),d=[];if(!v||v.next===v.prev)return d;if(l&&(v=function(e,t,n,r){var o,i,a,s=[];for(o=0,i=t.length;o<i;o++)(a=x(e,t[o]*r,o<i-1?t[o+1]*r:e.length,r,!1))===a.next&&(a.steiner=!0),s.push(w(a));for(s.sort(p),o=0;o<s.length;o++)n=b(s[o],n);return n}(e,t,v,n)),e.length>80*n){r=i=e[0],o=a=e[1];for(var y=n;y<c;y+=n)(s=e[y])<r&&(r=s),(u=e[y+1])<o&&(o=u),s>i&&(i=s),u>a&&(a=u);f=0!==(f=Math.max(i-r,a-o))?32767/f:0}return h(v,d,n,r,o,f,0),d}function x(e,t,n,r,o){var i,a;if(o===B(e,t,n,r)>0)for(i=t;i<n;i+=r)a=k(i,e[i],e[i+1],a);else for(i=n-r;i>=t;i-=r)a=k(i,e[i],e[i+1],a);return a&&M(a,a.next)&&(z(a),a=a.next),a}function l(e,t){if(!e)return e;t||(t=e);var n,r=e;do{if(n=!1,r.steiner||!M(r,r.next)&&0!==Z(r.prev,r,r.next))r=r.next;else{if(z(r),(r=t=r.prev)===r.next)break;n=!0}}while(n||r!==t);return t}function h(e,t,n,r,o,i,a){if(e){!a&&i&&function(e,t,n,r){var o=e;do{0===o.z&&(o.z=m(o.x,o.y,t,n,r)),o.prevZ=o.prev,o.nextZ=o.next,o=o.next}while(o!==e);o.prevZ.nextZ=null,o.prevZ=null,function(e){var t,n,r,o,i,a,s,u,f=1;do{for(n=e,e=null,i=null,a=0;n;){for(a++,r=n,s=0,t=0;t<f&&(s++,r=r.nextZ);t++);for(u=f;s>0||u>0&&r;)0!==s&&(0===u||!r||n.z<=r.z)?(o=n,n=n.nextZ,s--):(o=r,r=r.nextZ,u--),i?i.nextZ=o:e=o,o.prevZ=i,i=o;n=r}i.nextZ=null,f*=2}while(a>1)}(o)}(e,r,o,i);for(var s,u,f=e;e.prev!==e.next;)if(s=e.prev,u=e.next,i?v(e,r,o,i):c(e))t.push(s.i/n|0),t.push(e.i/n|0),t.push(u.i/n|0),z(e),e=u.next,f=u.next;else if((e=u)===f){a?1===a?h(e=d(l(e),t,n),t,n,r,o,i,2):2===a&&y(e,t,n,r,o,i):h(l(e),t,n,r,o,i,1);break}}}function c(e){var t=e.prev,n=e,r=e.next;if(Z(t,n,r)>=0)return!1;for(var o=t.x,i=n.x,a=r.x,s=t.y,u=n.y,f=r.y,x=o<i?o<a?o:a:i<a?i:a,l=s<u?s<f?s:f:u<f?u:f,h=o>i?o>a?o:a:i>a?i:a,c=s>u?s>f?s:f:u>f?u:f,v=r.next;v!==t;){if(v.x>=x&&v.x<=h&&v.y>=l&&v.y<=c&&A(o,s,i,u,a,f,v.x,v.y)&&Z(v.prev,v,v.next)>=0)return!1;v=v.next}return!0}function v(e,t,n,r){var o=e.prev,i=e,a=e.next;if(Z(o,i,a)>=0)return!1;for(var s=o.x,u=i.x,f=a.x,x=o.y,l=i.y,h=a.y,c=s<u?s<f?s:f:u<f?u:f,v=x<l?x<h?x:h:l<h?l:h,d=s>u?s>f?s:f:u>f?u:f,y=x>l?x>h?x:h:l>h?l:h,p=m(c,v,t,n,r),b=m(d,y,t,n,r),g=e.prevZ,w=e.nextZ;g&&g.z>=p&&w&&w.z<=b;){if(g.x>=c&&g.x<=d&&g.y>=v&&g.y<=y&&g!==o&&g!==a&&A(s,x,u,l,f,h,g.x,g.y)&&Z(g.prev,g,g.next)>=0)return!1;if(g=g.prevZ,w.x>=c&&w.x<=d&&w.y>=v&&w.y<=y&&w!==o&&w!==a&&A(s,x,u,l,f,h,w.x,w.y)&&Z(w.prev,w,w.next)>=0)return!1;w=w.nextZ}for(;g&&g.z>=p;){if(g.x>=c&&g.x<=d&&g.y>=v&&g.y<=y&&g!==o&&g!==a&&A(s,x,u,l,f,h,g.x,g.y)&&Z(g.prev,g,g.next)>=0)return!1;g=g.prevZ}for(;w&&w.z<=b;){if(w.x>=c&&w.x<=d&&w.y>=v&&w.y<=y&&w!==o&&w!==a&&A(s,x,u,l,f,h,w.x,w.y)&&Z(w.prev,w,w.next)>=0)return!1;w=w.nextZ}return!0}function d(e,t,n){var r=e;do{var o=r.prev,i=r.next.next;!M(o,i)&&F(o,r,r.next,i)&&S(o,i)&&S(i,o)&&(t.push(o.i/n|0),t.push(r.i/n|0),t.push(i.i/n|0),z(r),z(r.next),r=e=i),r=r.next}while(r!==e);return l(r)}function y(e,t,n,r,o,i){var a=e;do{for(var s=a.next.next;s!==a.prev;){if(a.i!==s.i&&E(a,s)){var u=U(a,s);return a=l(a,a.next),u=l(u,u.next),h(a,t,n,r,o,i,0),void h(u,t,n,r,o,i,0)}s=s.next}a=a.next}while(a!==e)}function p(e,t){return e.x-t.x}function b(e,t){var n=function(e,t){var n,r=t,o=e.x,i=e.y,a=-1/0;do{if(i<=r.y&&i>=r.next.y&&r.next.y!==r.y){var s=r.x+(i-r.y)*(r.next.x-r.x)/(r.next.y-r.y);if(s<=o&&s>a&&(a=s,n=r.x<r.next.x?r:r.next,s===o))return n}r=r.next}while(r!==t);if(!n)return null;var u,f=n,x=n.x,l=n.y,h=1/0;r=n;do{o>=r.x&&r.x>=x&&o!==r.x&&A(i<l?o:a,i,x,l,i<l?a:o,i,r.x,r.y)&&(u=Math.abs(i-r.y)/(o-r.x),S(r,e)&&(u<h||u===h&&(r.x>n.x||r.x===n.x&&g(n,r)))&&(n=r,h=u)),r=r.next}while(r!==f);return n}(e,t);if(!n)return t;var r=U(n,e);return l(r,r.next),l(n,n.next)}function g(e,t){return Z(e.prev,e,t.prev)<0&&Z(t.next,e,e.next)<0}function m(e,t,n,r,o){return(e=1431655765&((e=858993459&((e=252645135&((e=16711935&((e=(e-n)*o|0)|e<<8))|e<<4))|e<<2))|e<<1))|(t=1431655765&((t=858993459&((t=252645135&((t=16711935&((t=(t-r)*o|0)|t<<8))|t<<4))|t<<2))|t<<1))<<1}function w(e){var t=e,n=e;do{(t.x<n.x||t.x===n.x&&t.y<n.y)&&(n=t),t=t.next}while(t!==e);return n}function A(e,t,n,r,o,i,a,s){return(o-a)*(t-s)>=(e-a)*(i-s)&&(e-a)*(r-s)>=(n-a)*(t-s)&&(n-a)*(i-s)>=(o-a)*(r-s)}function E(e,t){return e.next.i!==t.i&&e.prev.i!==t.i&&!function(e,t){var n=e;do{if(n.i!==e.i&&n.next.i!==e.i&&n.i!==t.i&&n.next.i!==t.i&&F(n,n.next,e,t))return!0;n=n.next}while(n!==e);return!1}(e,t)&&(S(e,t)&&S(t,e)&&function(e,t){var n=e,r=!1,o=(e.x+t.x)/2,i=(e.y+t.y)/2;do{n.y>i!=n.next.y>i&&n.next.y!==n.y&&o<(n.next.x-n.x)*(i-n.y)/(n.next.y-n.y)+n.x&&(r=!r),n=n.next}while(n!==e);return r}(e,t)&&(Z(e.prev,e,t.prev)||Z(e,t.prev,t))||M(e,t)&&Z(e.prev,e,e.next)>0&&Z(t.prev,t,t.next)>0)}function Z(e,t,n){return(t.y-e.y)*(n.x-t.x)-(t.x-e.x)*(n.y-t.y)}function M(e,t){return e.x===t.x&&e.y===t.y}function F(e,t,n,r){var o=I(Z(e,t,n)),i=I(Z(e,t,r)),a=I(Z(n,r,e)),s=I(Z(n,r,t));return o!==i&&a!==s||(!(0!==o||!T(e,n,t))||(!(0!==i||!T(e,r,t))||(!(0!==a||!T(n,e,r))||!(0!==s||!T(n,t,r)))))}function T(e,t,n){return t.x<=Math.max(e.x,n.x)&&t.x>=Math.min(e.x,n.x)&&t.y<=Math.max(e.y,n.y)&&t.y>=Math.min(e.y,n.y)}function I(e){return e>0?1:e<0?-1:0}function S(e,t){return Z(e.prev,e,e.next)<0?Z(e,t,e.next)>=0&&Z(e,e.prev,t)>=0:Z(e,t,e.prev)<0||Z(e,e.next,t)<0}function U(e,t){var n=new R(e.i,e.x,e.y),r=new R(t.i,t.x,t.y),o=e.next,i=t.prev;return e.next=t,t.prev=e,n.next=o,o.prev=n,r.next=n,n.prev=r,i.next=r,r.prev=i,r}function k(e,t,n,r){var o=new R(e,t,n);return r?(o.next=r.next,o.prev=r,r.next.prev=o,r.next=o):(o.prev=o,o.next=o),o}function z(e){e.next.prev=e.prev,e.prev.next=e.next,e.prevZ&&(e.prevZ.nextZ=e.nextZ),e.nextZ&&(e.nextZ.prevZ=e.prevZ)}function R(e,t,n){this.i=e,this.x=t,this.y=n,this.prev=null,this.next=null,this.z=0,this.prevZ=null,this.nextZ=null,this.steiner=!1}function B(e,t,n,r){for(var o=0,i=t,a=n-r;i<n;i+=r)o+=(e[a]-e[i])*(e[i+1]+e[a+1]),a=i;return o}({get exports(){return u},set exports(e){u=e}}).exports=f,u.default=f,f.deviation=function(e,t,n,r){var o=t&&t.length,i=o?t[0]*n:e.length,a=Math.abs(B(e,0,i,n));if(o)for(var s=0,u=t.length;s<u;s++){var f=t[s]*n,x=s<u-1?t[s+1]*n:e.length;a-=Math.abs(B(e,f,x,n))}var l=0;for(s=0;s<r.length;s+=3){var h=r[s]*n,c=r[s+1]*n,v=r[s+2]*n;l+=Math.abs((e[h]-e[v])*(e[c+1]-e[h+1])-(e[h]-e[c])*(e[v+1]-e[h+1]))}return 0===a&&0===l?0:Math.abs((l-a)/a)},f.flatten=function(e){for(var t=e[0][0].length,n={vertices:[],holes:[],dimensions:t},r=0,o=0;o<e.length;o++){for(var i=0;i<e[o].length;i++)for(var a=0;a<t;a++)n.vertices.push(e[o][i][a]);o>0&&(r+=e[o-1].length,n.holes.push(r))}return n};const N=[],P={vertexPosition:0,indexPosition:0};function C(e,t,n,r,o){e[t+0]=n,e[t+1]=r,e[t+2]=o}function _(e,t,n,r,o,i){const a=3+o,s=e[t+0],u=e[t+1],f=N;f.length=o;for(let n=0;n<f.length;n++)f[n]=e[t+2+n];let x=i?i.vertexPosition:0,l=i?i.indexPosition:0;const h=x/a;return C(n,x,s,u,0),f.length&&n.set(f,x+3),x+=a,C(n,x,s,u,1),f.length&&n.set(f,x+3),x+=a,C(n,x,s,u,2),f.length&&n.set(f,x+3),x+=a,C(n,x,s,u,3),f.length&&n.set(f,x+3),x+=a,r[l++]=h,r[l++]=h+1,r[l++]=h+3,r[l++]=h+1,r[l++]=h+2,r[l++]=h+3,P.vertexPosition=x,P.indexPosition=l,P}function q(e,t,n,r,o,i,s,u,f,x){const l=5+u.length,h=i.length/l,c=[e[t+0],e[t+1]],v=[e[n],e[n+1]],d=a(x,[...c]),y=a(x,[...v]);function p(e,t,n){const r=1e4;return Math.round(1500*t)+Math.round(1500*n)*r+e*r*r}function b(e,t,n){const r=Math.sqrt((t[0]-e[0])*(t[0]-e[0])+(t[1]-e[1])*(t[1]-e[1])),o=[(t[0]-e[0])/r,(t[1]-e[1])/r],i=[-o[1],o[0]],a=Math.sqrt((n[0]-e[0])*(n[0]-e[0])+(n[1]-e[1])*(n[1]-e[1])),s=[(n[0]-e[0])/a,(n[1]-e[1])/a],u=0===r||0===a?0:Math.acos((f=s[0]*o[0]+s[1]*o[1],x=-1,l=1,Math.min(Math.max(f,x),l)));var f,x,l;return s[0]*i[0]+s[1]*i[1]>0?u:2*Math.PI-u}const g=null!==o;let m=0,w=0;if(null!==r){m=b(d,y,a(x,[...[e[r],e[r+1]]]))}if(g){w=b(y,d,a(x,[...[e[o],e[o+1]]]))}i.push(c[0],c[1],v[0],v[1],p(0,m,w)),i.push(...u),i.push(c[0],c[1],v[0],v[1],p(1,m,w)),i.push(...u),i.push(c[0],c[1],v[0],v[1],p(2,m,w)),i.push(...u),i.push(c[0],c[1],v[0],v[1],p(3,m,w)),i.push(...u),s.push(h,h+1,h+2,h+1,h+3,h+2)}function L(e,t,n,r,o){const i=2+o;let a=t;const s=e.slice(a,a+o);a+=o;const f=e[a++];let x=0;const l=new Array(f-1);for(let t=0;t<f;t++)x+=e[a++],t<f-1&&(l[t]=x);const h=e.slice(a,a+2*x),c=u(h,l,2);for(let e=0;e<c.length;e++)r.push(c[e]+n.length/i);for(let e=0;e<h.length;e+=2)n.push(h[e],h[e+1],...s);return a+2*x}const G=self;G.onmessage=r=>{const o=r.data;switch(o.type){case t:{const e=3,t=2,n=o.customAttributesCount,r=t+n,i=new Float32Array(o.renderInstructions),a=i.length/r,s=4*a*(n+e),u=new Uint32Array(6*a),f=new Float32Array(s);let x;for(let e=0;e<i.length;e+=r)x=_(i,e,f,u,n,x);const l=Object.assign({vertexBuffer:f.buffer,indexBuffer:u.buffer,renderInstructions:i.buffer},o);G.postMessage(l,[f.buffer,u.buffer,i.buffer]);break}case n:{const e=[],t=[],n=o.customAttributesCount,r=2,i=new Float32Array(o.renderInstructions);let a=0;const u=o.renderInstructionsTransform,f=[1,0,0,1,0,0];let x,l;for(s(f,u);a<i.length;){l=Array.from(i.slice(a,a+n)),a+=n,x=i[a++];for(let n=0;n<x-1;n++)q(i,a+n*r,a+(n+1)*r,n>0?a+(n-1)*r:null,n<x-2?a+(n+2)*r:null,e,t,l,0,f);a+=x*r}const h=Uint32Array.from(t),c=Float32Array.from(e),v=Object.assign({vertexBuffer:c.buffer,indexBuffer:h.buffer,renderInstructions:i.buffer},o);G.postMessage(v,[c.buffer,h.buffer,i.buffer]);break}case e:{const e=[],t=[],n=o.customAttributesCount,r=new Float32Array(o.renderInstructions);let i=0;for(;i<r.length;)i=L(r,i,e,t,n);const a=Uint32Array.from(t),s=Float32Array.from(e),u=Object.assign({vertexBuffer:s.buffer,indexBuffer:a.buffer,renderInstructions:r.buffer},o);G.postMessage(u,[s.buffer,a.buffer,r.buffer]);break}}};';
  return new Worker(typeof Blob > "u" ? "data:application/javascript;base64," + Buffer.from(i, "binary").toString("base64") : URL.createObjectURL(new Blob([i], { type: "application/javascript" })));
}
class XK extends YM {
  /**
   * @param {import("../../layer/Layer.js").default} layer Layer.
   * @param {Options} options Options.
   */
  constructor(e, t) {
    const r = t.uniforms || {}, n = qi();
    r[UA.PROJECTION_MATRIX] = n, super(e, {
      uniforms: r,
      postProcesses: t.postProcesses
    }), this.ready = !1, this.sourceRevision_ = -1, this.verticesBuffer_ = new cd(Gd, $0), this.hitVerticesBuffer_ = new cd(Gd, $0), this.indicesBuffer_ = new cd(
      $v,
      $0
    ), this.vertexShader_ = t.vertexShader, this.fragmentShader_ = t.fragmentShader, this.program_, this.hitDetectionEnabled_ = !!(t.hitFragmentShader && t.hitVertexShader), this.hitVertexShader_ = t.hitVertexShader, this.hitFragmentShader_ = t.hitFragmentShader, this.hitProgram_;
    const s = t.attributes ? t.attributes.map(function(o) {
      return {
        name: "a_" + o.name,
        size: 1,
        type: Xs.FLOAT
      };
    }) : [];
    this.attributes = [
      {
        name: "a_position",
        size: 2,
        type: Xs.FLOAT
      },
      {
        name: "a_index",
        size: 1,
        type: Xs.FLOAT
      }
    ].concat(s), this.hitDetectionAttributes = [
      {
        name: "a_position",
        size: 2,
        type: Xs.FLOAT
      },
      {
        name: "a_index",
        size: 1,
        type: Xs.FLOAT
      },
      {
        name: "a_hitColor",
        size: 4,
        type: Xs.FLOAT
      },
      {
        name: "a_featureUid",
        size: 1,
        type: Xs.FLOAT
      }
    ].concat(s), this.customAttributes = t.attributes ? t.attributes : [], this.previousExtent_ = Ji(), this.currentTransform_ = n, this.renderTransform_ = qi(), this.invertRenderTransform_ = qi(), this.renderInstructions_ = new Float32Array(0), this.hitRenderInstructions_ = new Float32Array(0), this.hitRenderTarget_, this.generateBuffersRun_ = 0, this.worker_ = zK(), this.worker_.addEventListener(
      "message",
      /**
       * @param {*} event Event.
       */
      (o) => {
        const A = o.data;
        if (A.type === W1.GENERATE_POINT_BUFFERS) {
          const l = A.projectionTransform;
          A.hitDetection ? (this.hitVerticesBuffer_.fromArrayBuffer(A.vertexBuffer), this.helper.flushBufferData(this.hitVerticesBuffer_)) : (this.verticesBuffer_.fromArrayBuffer(A.vertexBuffer), this.helper.flushBufferData(this.verticesBuffer_)), this.indicesBuffer_.fromArrayBuffer(A.indexBuffer), this.helper.flushBufferData(this.indicesBuffer_), this.renderTransform_ = l, Ag(
            this.invertRenderTransform_,
            this.renderTransform_
          ), A.hitDetection ? this.hitRenderInstructions_ = new Float32Array(
            o.data.renderInstructions
          ) : (this.renderInstructions_ = new Float32Array(
            o.data.renderInstructions
          ), A.generateBuffersRun === this.generateBuffersRun_ && (this.ready = !0)), this.getLayer().changed();
        }
      }
    ), this.featureCache_ = {}, this.featureCount_ = 0;
    const a = this.getLayer().getSource();
    this.sourceListenKeys_ = [
      St(
        a,
        an.ADDFEATURE,
        this.handleSourceFeatureAdded_,
        this
      ),
      St(
        a,
        an.CHANGEFEATURE,
        this.handleSourceFeatureChanged_,
        this
      ),
      St(
        a,
        an.REMOVEFEATURE,
        this.handleSourceFeatureDelete_,
        this
      ),
      St(
        a,
        an.CLEAR,
        this.handleSourceFeatureClear_,
        this
      )
    ], a.forEachFeature((o) => {
      this.featureCache_[st(o)] = {
        feature: o,
        properties: o.getProperties(),
        geometry: o.getGeometry()
      }, this.featureCount_++;
    });
  }
  afterHelperCreated() {
    this.program_ = this.helper.getProgram(
      this.fragmentShader_,
      this.vertexShader_
    ), this.hitDetectionEnabled_ && (this.hitProgram_ = this.helper.getProgram(
      this.hitFragmentShader_,
      this.hitVertexShader_
    ), this.hitRenderTarget_ = new TK(this.helper));
  }
  /**
   * @param {import("../../source/Vector.js").VectorSourceEvent} event Event.
   * @private
   */
  handleSourceFeatureAdded_(e) {
    const t = e.feature;
    this.featureCache_[st(t)] = {
      feature: t,
      properties: t.getProperties(),
      geometry: t.getGeometry()
    }, this.featureCount_++;
  }
  /**
   * @param {import("../../source/Vector.js").VectorSourceEvent} event Event.
   * @private
   */
  handleSourceFeatureChanged_(e) {
    const t = e.feature;
    this.featureCache_[st(t)] = {
      feature: t,
      properties: t.getProperties(),
      geometry: t.getGeometry()
    };
  }
  /**
   * @param {import("../../source/Vector.js").VectorSourceEvent} event Event.
   * @private
   */
  handleSourceFeatureDelete_(e) {
    const t = e.feature;
    delete this.featureCache_[st(t)], this.featureCount_--;
  }
  /**
   * @private
   */
  handleSourceFeatureClear_() {
    this.featureCache_ = {}, this.featureCount_ = 0;
  }
  /**
   * Render the layer.
   * @param {import("../../Map.js").FrameState} frameState Frame state.
   * @return {HTMLElement} The rendered element.
   */
  renderFrame(e) {
    const t = this.helper.getGL();
    this.preRender(t, e);
    const r = e.viewState.projection, a = this.getLayer().getSource().getWrapX() && r.canWrapX(), o = r.getExtent(), A = e.extent, l = a ? ir(o) : null, h = a ? Math.ceil((A[2] - o[2]) / l) + 1 : 1, c = a ? Math.floor((A[0] - o[0]) / l) : 0;
    let u = c;
    const f = this.indicesBuffer_.getSize();
    do
      this.helper.makeProjectionTransform(e, this.currentTransform_), hm(this.currentTransform_, u * l, 0), gh(this.currentTransform_, this.invertRenderTransform_), this.helper.applyUniforms(e), this.helper.drawElements(0, f);
    while (++u < h);
    this.helper.finalizeDraw(
      e,
      this.dispatchPreComposeEvent,
      this.dispatchPostComposeEvent
    );
    const g = this.helper.getCanvas();
    return this.hitDetectionEnabled_ && (this.renderHitDetection(e, c, h, l), this.hitRenderTarget_.clearCachedData()), this.postRender(t, e), g;
  }
  /**
   * Determine whether renderFrame should be called.
   * @param {import("../../Map.js").FrameState} frameState Frame state.
   * @return {boolean} Layer is ready to be rendered.
   */
  prepareFrameInternal(e) {
    const t = this.getLayer(), r = t.getSource(), n = e.viewState, s = !e.viewHints[ei.ANIMATING] && !e.viewHints[ei.INTERACTING], a = !Xa(this.previousExtent_, e.extent), o = this.sourceRevision_ < r.getRevision();
    if (o && (this.sourceRevision_ = r.getRevision()), s && (a || o)) {
      const A = n.projection, l = n.resolution, h = t instanceof zv ? t.getRenderBuffer() : 0, c = zn(e.extent, h * l);
      r.loadFeatures(c, l, A), this.rebuildBuffers_(e), this.previousExtent_ = e.extent.slice();
    }
    return this.helper.useProgram(this.program_, e), this.helper.prepareDraw(e), this.helper.bindBuffer(this.verticesBuffer_), this.helper.bindBuffer(this.indicesBuffer_), this.helper.enableAttributes(this.attributes), !0;
  }
  /**
   * Rebuild internal webgl buffers based on current view extent; costly, should not be called too much
   * @param {import("../../Map").FrameState} frameState Frame state.
   * @private
   */
  rebuildBuffers_(e) {
    const t = qi();
    this.helper.makeProjectionTransform(e, t);
    const r = (2 + this.customAttributes.length) * this.featureCount_;
    if ((!this.renderInstructions_ || this.renderInstructions_.length !== r) && (this.renderInstructions_ = new Float32Array(r)), this.hitDetectionEnabled_) {
      const u = (7 + this.customAttributes.length) * this.featureCount_;
      (!this.hitRenderInstructions_ || this.hitRenderInstructions_.length !== u) && (this.hitRenderInstructions_ = new Float32Array(
        u
      ));
    }
    let n, s;
    const a = [], o = [];
    let A = 0, l = 0, h;
    for (const u in this.featureCache_) {
      if (n = this.featureCache_[u], s = /** @type {import("../../geom").Point} */
      n.geometry, !s || s.getType() !== "Point")
        continue;
      a[0] = s.getFlatCoordinates()[0], a[1] = s.getFlatCoordinates()[1], vi(t, a), h = KK(l + 6, o), this.renderInstructions_[A++] = a[0], this.renderInstructions_[A++] = a[1], this.hitDetectionEnabled_ && (this.hitRenderInstructions_[l++] = a[0], this.hitRenderInstructions_[l++] = a[1], this.hitRenderInstructions_[l++] = h[0], this.hitRenderInstructions_[l++] = h[1], this.hitRenderInstructions_[l++] = h[2], this.hitRenderInstructions_[l++] = h[3], this.hitRenderInstructions_[l++] = Number(u));
      let f;
      for (let g = 0; g < this.customAttributes.length; g++)
        f = this.customAttributes[g].callback(
          n.feature,
          n.properties
        ), this.renderInstructions_[A++] = f, this.hitDetectionEnabled_ && (this.hitRenderInstructions_[l++] = f);
    }
    const c = {
      id: 0,
      type: W1.GENERATE_POINT_BUFFERS,
      renderInstructions: this.renderInstructions_.buffer,
      customAttributesCount: this.customAttributes.length
    };
    if (c.projectionTransform = t, c.generateBuffersRun = ++this.generateBuffersRun_, this.ready = !1, this.worker_.postMessage(c, [this.renderInstructions_.buffer]), this.renderInstructions_ = null, this.hitDetectionEnabled_) {
      const u = {
        id: 0,
        type: W1.GENERATE_POINT_BUFFERS,
        renderInstructions: this.hitRenderInstructions_.buffer,
        customAttributesCount: 5 + this.customAttributes.length
      };
      u.projectionTransform = t, u.hitDetection = !0, this.worker_.postMessage(u, [
        this.hitRenderInstructions_.buffer
      ]), this.hitRenderInstructions_ = null;
    }
  }
  /**
   * @param {import("../../coordinate.js").Coordinate} coordinate Coordinate.
   * @param {import("../../Map.js").FrameState} frameState Frame state.
   * @param {number} hitTolerance Hit tolerance in pixels.
   * @param {import("../vector.js").FeatureCallback<T>} callback Feature callback.
   * @param {Array<import("../Map.js").HitMatch<T>>} matches The hit detected matches with tolerance.
   * @return {T|undefined} Callback result.
   * @template T
   */
  forEachFeatureAtCoordinate(e, t, r, n, s) {
    if (lt(this.hitDetectionEnabled_, 66), !this.hitRenderInstructions_)
      return;
    const a = vi(
      t.coordinateToPixelTransform,
      e.slice()
    ), o = this.hitRenderTarget_.readPixel(a[0] / 2, a[1] / 2), A = [o[0] / 255, o[1] / 255, o[2] / 255, o[3] / 255], l = jK(A), h = this.hitRenderInstructions_[l], c = Math.floor(h).toString(), f = this.getLayer().getSource().getFeatureByUid(c);
    if (f)
      return n(f, this.getLayer(), null);
  }
  /**
   * Render the hit detection data to the corresponding render target
   * @param {import("../../Map.js").FrameState} frameState current frame state
   * @param {number} startWorld the world to render in the first iteration
   * @param {number} endWorld the last world to render
   * @param {number} worldWidth the width of the worlds being rendered
   */
  renderHitDetection(e, t, r, n) {
    if (!this.hitVerticesBuffer_.getSize())
      return;
    let s = t;
    this.hitRenderTarget_.setSize([
      Math.floor(e.size[0] / 2),
      Math.floor(e.size[1] / 2)
    ]), this.helper.useProgram(this.hitProgram_, e), this.helper.prepareDrawToRenderTarget(
      e,
      this.hitRenderTarget_,
      !0
    ), this.helper.bindBuffer(this.hitVerticesBuffer_), this.helper.bindBuffer(this.indicesBuffer_), this.helper.enableAttributes(this.hitDetectionAttributes);
    do {
      this.helper.makeProjectionTransform(e, this.currentTransform_), hm(this.currentTransform_, s * n, 0), gh(this.currentTransform_, this.invertRenderTransform_), this.helper.applyUniforms(e);
      const a = this.indicesBuffer_.getSize();
      this.helper.drawElements(0, a);
    } while (++s < r);
  }
  /**
   * Clean up.
   */
  disposeInternal() {
    this.worker_.terminate(), this.layer_ = null, this.sourceListenKeys_.forEach(function(e) {
      pr(e);
    }), this.sourceListenKeys_ = null, super.disposeInternal();
  }
}
const D4 = XK;
class WK {
  constructor() {
    this.uniforms = [], this.attributes = [], this.varyings = [], this.sizeExpression = "vec2(1.0)", this.rotationExpression = "0.0", this.offsetExpression = "vec2(0.0)", this.colorExpression = "vec4(1.0)", this.texCoordExpression = "vec4(0.0, 0.0, 1.0, 1.0)", this.discardExpression = "false", this.rotateWithView = !1;
  }
  /**
   * Adds a uniform accessible in both fragment and vertex shaders.
   * The given name should include a type, such as `sampler2D u_texture`.
   * @param {string} name Uniform name
   * @return {ShaderBuilder} the builder object
   */
  addUniform(e) {
    return this.uniforms.push(e), this;
  }
  /**
   * Adds an attribute accessible in the vertex shader, read from the geometry buffer.
   * The given name should include a type, such as `vec2 a_position`.
   * @param {string} name Attribute name
   * @return {ShaderBuilder} the builder object
   */
  addAttribute(e) {
    return this.attributes.push(e), this;
  }
  /**
   * Adds a varying defined in the vertex shader and accessible from the fragment shader.
   * The type and expression of the varying have to be specified separately.
   * @param {string} name Varying name
   * @param {'float'|'vec2'|'vec3'|'vec4'} type Type
   * @param {string} expression Expression used to assign a value to the varying.
   * @return {ShaderBuilder} the builder object
   */
  addVarying(e, t, r) {
    return this.varyings.push({
      name: e,
      type: t,
      expression: r
    }), this;
  }
  /**
   * Sets an expression to compute the size of the shape.
   * This expression can use all the uniforms and attributes available
   * in the vertex shader, and should evaluate to a `vec2` value.
   * @param {string} expression Size expression
   * @return {ShaderBuilder} the builder object
   */
  setSizeExpression(e) {
    return this.sizeExpression = e, this;
  }
  /**
   * Sets an expression to compute the rotation of the shape.
   * This expression can use all the uniforms and attributes available
   * in the vertex shader, and should evaluate to a `float` value in radians.
   * @param {string} expression Size expression
   * @return {ShaderBuilder} the builder object
   */
  setRotationExpression(e) {
    return this.rotationExpression = e, this;
  }
  /**
   * Sets an expression to compute the offset of the symbol from the point center.
   * This expression can use all the uniforms and attributes available
   * in the vertex shader, and should evaluate to a `vec2` value.
   * Note: will only be used for point geometry shaders.
   * @param {string} expression Offset expression
   * @return {ShaderBuilder} the builder object
   */
  setSymbolOffsetExpression(e) {
    return this.offsetExpression = e, this;
  }
  /**
   * Sets an expression to compute the color of the shape.
   * This expression can use all the uniforms, varyings and attributes available
   * in the fragment shader, and should evaluate to a `vec4` value.
   * @param {string} expression Color expression
   * @return {ShaderBuilder} the builder object
   */
  setColorExpression(e) {
    return this.colorExpression = e, this;
  }
  /**
   * Sets an expression to compute the texture coordinates of the vertices.
   * This expression can use all the uniforms and attributes available
   * in the vertex shader, and should evaluate to a `vec4` value.
   * @param {string} expression Texture coordinate expression
   * @return {ShaderBuilder} the builder object
   */
  setTextureCoordinateExpression(e) {
    return this.texCoordExpression = e, this;
  }
  /**
   * Sets an expression to determine whether a fragment (pixel) should be discarded,
   * i.e. not drawn at all.
   * This expression can use all the uniforms, varyings and attributes available
   * in the fragment shader, and should evaluate to a `bool` value (it will be
   * used in an `if` statement)
   * @param {string} expression Fragment discard expression
   * @return {ShaderBuilder} the builder object
   */
  setFragmentDiscardExpression(e) {
    return this.discardExpression = e, this;
  }
  /**
   * Sets whether the symbols should rotate with the view or stay aligned with the map.
   * Note: will only be used for point geometry shaders.
   * @param {boolean} rotateWithView Rotate with view
   * @return {ShaderBuilder} the builder object
   */
  setSymbolRotateWithView(e) {
    return this.rotateWithView = e, this;
  }
  /**
   * @return {string} Previously set size expression
   */
  getSizeExpression() {
    return this.sizeExpression;
  }
  /**
   * @return {string} Previously set symbol offset expression
   */
  getOffsetExpression() {
    return this.offsetExpression;
  }
  /**
   * @return {string} Previously set color expression
   */
  getColorExpression() {
    return this.colorExpression;
  }
  /**
   * @return {string} Previously set texture coordinate expression
   */
  getTextureCoordinateExpression() {
    return this.texCoordExpression;
  }
  /**
   * @return {string} Previously set fragment discard expression
   */
  getFragmentDiscardExpression() {
    return this.discardExpression;
  }
  /**
   * Generates a symbol vertex shader from the builder parameters,
   * intended to be used on point geometries.
   *
   * Four uniforms are hardcoded in all shaders: `u_projectionMatrix`, `u_offsetScaleMatrix`,
   * `u_offsetRotateMatrix`, `u_time`.
   *
   * The following attributes are hardcoded and expected to be present in the vertex buffers:
   * `vec2 a_position`, `float a_index` (being the index of the vertex in the quad, 0 to 3).
   *
   * The following varyings are hardcoded and gives the coordinate of the pixel both in the quad and on the texture:
   * `vec2 v_quadCoord`, `vec2 v_texCoord`
   *
   * @param {boolean} [forHitDetection] If true, the shader will be modified to include hit detection variables
   * (namely, hit color with encoded feature id).
   * @return {string} The full shader as a string.
   */
  getSymbolVertexShader(e) {
    const t = this.rotateWithView ? "u_offsetScaleMatrix * u_offsetRotateMatrix" : "u_offsetScaleMatrix";
    let r = this.attributes, n = this.varyings;
    return e && (r = r.concat("vec4 a_hitColor"), n = n.concat({
      name: "v_hitColor",
      type: "vec4",
      expression: "a_hitColor"
    })), `precision mediump float;
uniform mat4 u_projectionMatrix;
uniform mat4 u_offsetScaleMatrix;
uniform mat4 u_offsetRotateMatrix;
uniform float u_time;
uniform float u_zoom;
uniform float u_resolution;
${this.uniforms.map(function(s) {
      return "uniform " + s + ";";
    }).join(`
`)}
attribute vec2 a_position;
attribute float a_index;
${r.map(function(s) {
      return "attribute " + s + ";";
    }).join(`
`)}
varying vec2 v_texCoord;
varying vec2 v_quadCoord;
${n.map(function(s) {
      return "varying " + s.type + " " + s.name + ";";
    }).join(`
`)}
void main(void) {
  mat4 offsetMatrix = ${t};
  vec2 halfSize = ${this.sizeExpression} * 0.5;
  vec2 offset = ${this.offsetExpression};
  float angle = ${this.rotationExpression};
  float offsetX;
  float offsetY;
  if (a_index == 0.0) {
    offsetX = (offset.x - halfSize.x) * cos(angle) + (offset.y - halfSize.y) * sin(angle);
    offsetY = (offset.y - halfSize.y) * cos(angle) - (offset.x - halfSize.x) * sin(angle);
  } else if (a_index == 1.0) {
    offsetX = (offset.x + halfSize.x) * cos(angle) + (offset.y - halfSize.y) * sin(angle);
    offsetY = (offset.y - halfSize.y) * cos(angle) - (offset.x + halfSize.x) * sin(angle);
  } else if (a_index == 2.0) {
    offsetX = (offset.x + halfSize.x) * cos(angle) + (offset.y + halfSize.y) * sin(angle);
    offsetY = (offset.y + halfSize.y) * cos(angle) - (offset.x + halfSize.x) * sin(angle);
  } else {
    offsetX = (offset.x - halfSize.x) * cos(angle) + (offset.y + halfSize.y) * sin(angle);
    offsetY = (offset.y + halfSize.y) * cos(angle) - (offset.x - halfSize.x) * sin(angle);
  }
  vec4 offsets = offsetMatrix * vec4(offsetX, offsetY, 0.0, 0.0);
  gl_Position = u_projectionMatrix * vec4(a_position, 0.0, 1.0) + offsets;
  vec4 texCoord = ${this.texCoordExpression};
  float u = a_index == 0.0 || a_index == 3.0 ? texCoord.s : texCoord.p;
  float v = a_index == 2.0 || a_index == 3.0 ? texCoord.t : texCoord.q;
  v_texCoord = vec2(u, v);
  u = a_index == 0.0 || a_index == 3.0 ? 0.0 : 1.0;
  v = a_index == 2.0 || a_index == 3.0 ? 0.0 : 1.0;
  v_quadCoord = vec2(u, v);
${n.map(function(s) {
      return "  " + s.name + " = " + s.expression + ";";
    }).join(`
`)}
}`;
  }
  /**
   * Generates a symbol fragment shader from the builder parameters,
   * intended to be used on point geometries.
   *
   * Expects the following varyings to be transmitted by the vertex shader:
   * `vec2 v_quadCoord`, `vec2 v_texCoord`
   *
   * @param {boolean} [forHitDetection] If true, the shader will be modified to include hit detection variables
   * (namely, hit color with encoded feature id).
   * @return {string} The full shader as a string.
   */
  getSymbolFragmentShader(e) {
    const t = e ? "  if (gl_FragColor.a < 0.1) { discard; } gl_FragColor = v_hitColor;" : "";
    let r = this.varyings;
    return e && (r = r.concat({
      name: "v_hitColor",
      type: "vec4",
      expression: "a_hitColor"
    })), `precision mediump float;
uniform float u_time;
uniform float u_zoom;
uniform float u_resolution;
${this.uniforms.map(function(n) {
      return "uniform " + n + ";";
    }).join(`
`)}
varying vec2 v_texCoord;
varying vec2 v_quadCoord;
${r.map(function(n) {
      return "varying " + n.type + " " + n.name + ";";
    }).join(`
`)}
void main(void) {
  if (${this.discardExpression}) { discard; }
  gl_FragColor = ${this.colorExpression};
  gl_FragColor.rgb *= gl_FragColor.a;
${t}
}`;
  }
}
function YK(i) {
  const e = i.symbol, t = e.size !== void 0 ? e.size : 1, r = e.color || "white", n = e.textureCoord || [0, 0, 1, 1], s = e.offset || [0, 0], a = e.opacity !== void 0 ? e.opacity : 1, o = e.rotation !== void 0 ? e.rotation : 0, A = {
    inFragmentShader: !1,
    variables: [],
    attributes: [],
    stringLiteralsMap: {},
    functions: {}
  }, l = rt(
    A,
    t,
    Ve.NUMBER_ARRAY | Ve.NUMBER
  ), h = rt(
    A,
    s,
    Ve.NUMBER_ARRAY
  ), c = rt(
    A,
    n,
    Ve.NUMBER_ARRAY
  ), u = rt(
    A,
    o,
    Ve.NUMBER
  ), f = {
    inFragmentShader: !0,
    variables: A.variables,
    attributes: [],
    stringLiteralsMap: A.stringLiteralsMap,
    functions: {}
  }, g = rt(f, r, Ve.COLOR), p = rt(
    f,
    a,
    Ve.NUMBER
  );
  let y = "1.0";
  const v = `vec2(${rt(
    f,
    t,
    Ve.NUMBER_ARRAY | Ve.NUMBER
  )}).x`;
  switch (e.symbolType) {
    case "square":
      break;
    case "image":
      break;
    case "circle":
      y = `(1.0-smoothstep(1.-4./${v},1.,dot(v_quadCoord-.5,v_quadCoord-.5)*4.))`;
      break;
    case "triangle":
      const E = "(v_quadCoord*2.-1.)", S = `(atan(${E}.x,${E}.y))`;
      y = `(1.0-smoothstep(.5-3./${v},.5,cos(floor(.5+${S}/2.094395102)*2.094395102-${S})*length(${E})))`;
      break;
    default:
      throw new Error("Unexpected symbol type: " + e.symbolType);
  }
  const w = new WK().setSizeExpression(`vec2(${l})`).setRotationExpression(u).setSymbolOffsetExpression(h).setTextureCoordinateExpression(c).setSymbolRotateWithView(!!e.rotateWithView).setColorExpression(
    `vec4(${g}.rgb, ${g}.a * ${p} * ${y})`
  );
  if (i.filter) {
    const E = rt(
      f,
      i.filter,
      Ve.BOOLEAN
    );
    w.setFragmentDiscardExpression(`!${E}`);
  }
  const C = {};
  if (f.variables.forEach(function(E) {
    const S = eB(E);
    w.addUniform(`float ${S}`), C[S] = function() {
      if (!i.variables || i.variables[E] === void 0)
        throw new Error(
          `The following variable is missing from the style: ${E}`
        );
      let M = i.variables[E];
      return typeof M == "string" && (M = Um(A, M)), M !== void 0 ? M : -9999999;
    };
  }), e.symbolType === "image" && e.src) {
    const E = new Image();
    E.crossOrigin = e.crossOrigin === void 0 ? "anonymous" : e.crossOrigin, E.src = e.src, w.addUniform("sampler2D u_texture").setColorExpression(
      w.getColorExpression() + " * texture2D(u_texture, v_texCoord)"
    ), C.u_texture = E;
  }
  return f.attributes.forEach(function(E) {
    A.attributes.includes(E) || A.attributes.push(E), w.addVarying(`v_${E}`, "float", `a_${E}`);
  }), A.attributes.forEach(function(E) {
    w.addAttribute(`float a_${E}`);
  }), {
    builder: w,
    attributes: A.attributes.map(function(E) {
      return {
        name: E,
        callback: function(S, M) {
          let T = M[E];
          return typeof T == "string" && (T = Um(A, T)), T !== void 0 ? T : -9999999;
        }
      };
    }),
    uniforms: C
  };
}
class qK extends bh {
  /**
   * @param {Options<VectorSourceType>} options Options.
   */
  constructor(e) {
    const t = Object.assign({}, e);
    super(t), this.parseResult_ = YK(e.style), this.styleVariables_ = e.style.variables || {}, this.hitDetectionDisabled_ = !!e.disableHitDetection;
  }
  createRenderer() {
    return new D4(this, {
      vertexShader: this.parseResult_.builder.getSymbolVertexShader(),
      fragmentShader: this.parseResult_.builder.getSymbolFragmentShader(),
      hitVertexShader: !this.hitDetectionDisabled_ && this.parseResult_.builder.getSymbolVertexShader(!0),
      hitFragmentShader: !this.hitDetectionDisabled_ && this.parseResult_.builder.getSymbolFragmentShader(!0),
      uniforms: this.parseResult_.uniforms,
      attributes: this.parseResult_.attributes
    });
  }
  /**
   * Update any variables used by the layer style and trigger a re-render.
   * @param {Object<string, number>} variables Variables to update.
   */
  updateStyleVariables(e) {
    Object.assign(this.styleVariables_, e), this.changed();
  }
}
const ZK = qK, JK = {
  extends: Th,
  name: "ol-webglpoints-layer",
  setup(i) {
    const e = _t("map"), { properties: t } = sr(i), r = cr(() => new ZK(t));
    return at(t, () => {
      r.value.setProperties(t);
    }), tr(() => {
      e.addLayer(r.value);
    }), nr(() => {
      e.removeLayer(r.value);
    }), Ur("webglPointsLayer", r), {
      webglPointsLayer: r
    };
  },
  props: {
    disableHitDetection: {
      type: Boolean,
      default: !1
    },
    style: {
      type: Object,
      default: () => ({
        symbol: {
          symbolType: "circle",
          size: 8,
          color: "#33AAFF",
          opacity: 0.9
        }
      })
    }
  }
};
function ej(i, e, t, r, n, s) {
  return xn(), Cn("div", null, [
    mr(i.$slots, "default")
  ]);
}
const g2 = /* @__PURE__ */ qe(JK, [["render", ej]]), fa = {
  BLUR: "blur",
  GRADIENT: "gradient",
  RADIUS: "radius"
}, tj = ["#00f", "#0ff", "#0f0", "#ff0", "#f00"];
class rj extends zv {
  /**
   * @param {Options} [options] Options.
   */
  constructor(e) {
    e = e || {};
    const t = Object.assign({}, e);
    delete t.gradient, delete t.radius, delete t.blur, delete t.weight, super(t), this.gradient_ = null, this.addChangeListener(fa.GRADIENT, this.handleGradientChanged_), this.setGradient(e.gradient ? e.gradient : tj), this.setBlur(e.blur !== void 0 ? e.blur : 15), this.setRadius(e.radius !== void 0 ? e.radius : 8);
    const r = e.weight ? e.weight : "weight";
    typeof r == "string" ? this.weightFunction_ = function(n) {
      return n.get(r);
    } : this.weightFunction_ = r, this.setRenderOrder(null);
  }
  /**
   * Return the blur size in pixels.
   * @return {number} Blur size in pixels.
   * @api
   * @observable
   */
  getBlur() {
    return (
      /** @type {number} */
      this.get(fa.BLUR)
    );
  }
  /**
   * Return the gradient colors as array of strings.
   * @return {Array<string>} Colors.
   * @api
   * @observable
   */
  getGradient() {
    return (
      /** @type {Array<string>} */
      this.get(fa.GRADIENT)
    );
  }
  /**
   * Return the size of the radius in pixels.
   * @return {number} Radius size in pixel.
   * @api
   * @observable
   */
  getRadius() {
    return (
      /** @type {number} */
      this.get(fa.RADIUS)
    );
  }
  /**
   * @private
   */
  handleGradientChanged_() {
    this.gradient_ = ij(this.getGradient());
  }
  /**
   * Set the blur size in pixels.
   * @param {number} blur Blur size in pixels.
   * @api
   * @observable
   */
  setBlur(e) {
    this.set(fa.BLUR, e);
  }
  /**
   * Set the gradient colors as array of strings.
   * @param {Array<string>} colors Gradient.
   * @api
   * @observable
   */
  setGradient(e) {
    this.set(fa.GRADIENT, e);
  }
  /**
   * Set the size of the radius in pixels.
   * @param {number} radius Radius size in pixel.
   * @api
   * @observable
   */
  setRadius(e) {
    this.set(fa.RADIUS, e);
  }
  createRenderer() {
    return new D4(this, {
      className: this.getClassName(),
      attributes: [
        {
          name: "weight",
          callback: (e) => {
            const t = this.weightFunction_(e);
            return t !== void 0 ? jr(t, 0, 1) : 1;
          }
        }
      ],
      vertexShader: `
        precision mediump float;
        uniform mat4 u_projectionMatrix;
        uniform mat4 u_offsetScaleMatrix;
        uniform float u_size;
        attribute vec2 a_position;
        attribute float a_index;
        attribute float a_weight;

        varying vec2 v_texCoord;
        varying float v_weight;

        void main(void) {
          mat4 offsetMatrix = u_offsetScaleMatrix;
          float offsetX = a_index == 0.0 || a_index == 3.0 ? -u_size / 2.0 : u_size / 2.0;
          float offsetY = a_index == 0.0 || a_index == 1.0 ? -u_size / 2.0 : u_size / 2.0;
          vec4 offsets = offsetMatrix * vec4(offsetX, offsetY, 0.0, 0.0);
          gl_Position = u_projectionMatrix * vec4(a_position, 0.0, 1.0) + offsets;
          float u = a_index == 0.0 || a_index == 3.0 ? 0.0 : 1.0;
          float v = a_index == 0.0 || a_index == 1.0 ? 0.0 : 1.0;
          v_texCoord = vec2(u, v);
          v_weight = a_weight;
        }`,
      fragmentShader: `
        precision mediump float;
        uniform float u_blurSlope;

        varying vec2 v_texCoord;
        varying float v_weight;

        void main(void) {
          vec2 texCoord = v_texCoord * 2.0 - vec2(1.0, 1.0);
          float sqRadius = texCoord.x * texCoord.x + texCoord.y * texCoord.y;
          float value = (1.0 - sqrt(sqRadius)) * u_blurSlope;
          float alpha = smoothstep(0.0, 1.0, value) * v_weight;
          gl_FragColor = vec4(alpha, alpha, alpha, alpha);
        }`,
      hitVertexShader: `
        precision mediump float;
        uniform mat4 u_projectionMatrix;
        uniform mat4 u_offsetScaleMatrix;
        uniform float u_size;
        attribute vec2 a_position;
        attribute float a_index;
        attribute float a_weight;
        attribute vec4 a_hitColor;

        varying vec2 v_texCoord;
        varying float v_weight;
        varying vec4 v_hitColor;

        void main(void) {
          mat4 offsetMatrix = u_offsetScaleMatrix;
          float offsetX = a_index == 0.0 || a_index == 3.0 ? -u_size / 2.0 : u_size / 2.0;
          float offsetY = a_index == 0.0 || a_index == 1.0 ? -u_size / 2.0 : u_size / 2.0;
          vec4 offsets = offsetMatrix * vec4(offsetX, offsetY, 0.0, 0.0);
          gl_Position = u_projectionMatrix * vec4(a_position, 0.0, 1.0) + offsets;
          float u = a_index == 0.0 || a_index == 3.0 ? 0.0 : 1.0;
          float v = a_index == 0.0 || a_index == 1.0 ? 0.0 : 1.0;
          v_texCoord = vec2(u, v);
          v_hitColor = a_hitColor;
          v_weight = a_weight;
        }`,
      hitFragmentShader: `
        precision mediump float;
        uniform float u_blurSlope;

        varying vec2 v_texCoord;
        varying float v_weight;
        varying vec4 v_hitColor;

        void main(void) {
          vec2 texCoord = v_texCoord * 2.0 - vec2(1.0, 1.0);
          float sqRadius = texCoord.x * texCoord.x + texCoord.y * texCoord.y;
          float value = (1.0 - sqrt(sqRadius)) * u_blurSlope;
          float alpha = smoothstep(0.0, 1.0, value) * v_weight;
          if (alpha < 0.05) {
            discard;
          }

          gl_FragColor = v_hitColor;
        }`,
      uniforms: {
        u_size: () => (this.get(fa.RADIUS) + this.get(fa.BLUR)) * 2,
        u_blurSlope: () => this.get(fa.RADIUS) / Math.max(1, this.get(fa.BLUR))
      },
      postProcesses: [
        {
          fragmentShader: `
            precision mediump float;

            uniform sampler2D u_image;
            uniform sampler2D u_gradientTexture;
            uniform float u_opacity;

            varying vec2 v_texCoord;

            void main() {
              vec4 color = texture2D(u_image, v_texCoord);
              gl_FragColor.a = color.a * u_opacity;
              gl_FragColor.rgb = texture2D(u_gradientTexture, vec2(0.5, color.a)).rgb;
              gl_FragColor.rgb *= gl_FragColor.a;
            }`,
          uniforms: {
            u_gradientTexture: () => this.gradient_,
            u_opacity: () => this.getOpacity()
          }
        }
      ]
    });
  }
  renderDeclutter() {
  }
}
function ij(i) {
  const r = Ii(1, 256), n = r.createLinearGradient(0, 0, 1, 256), s = 1 / (i.length - 1);
  for (let a = 0, o = i.length; a < o; ++a)
    n.addColorStop(a * s, i[a]);
  return r.fillStyle = n, r.fillRect(0, 0, 1, 256), r.canvas;
}
const k4 = rj, nj = {
  extends: Th,
  name: "ol-heatmap-layer",
  setup(i) {
    const e = _t("map"), { properties: t } = sr(i), r = cr(() => new k4(t));
    return at(t, () => {
      r.value.setProperties(t);
    }), tr(() => {
      e.addLayer(r.value);
    }), nr(() => {
      e.removeLayer(r.value);
    }), Ur("heatmapLayer", r), Ur("stylable", r), {
      heatmapLayer: r
    };
  },
  props: {
    weight: {
      type: Function
    },
    extent: {
      type: Array
    },
    blur: {
      type: Number
    },
    radius: {
      type: Number
    },
    gradient: {
      type: Array
    }
  }
};
function sj(i, e, t, r, n, s) {
  return xn(), Cn("div", null, [
    mr(i.$slots, "default")
  ]);
}
const p2 = /* @__PURE__ */ qe(nj, [["render", sj]]);
function $m(i) {
  $m.installed || ($m.installed = !0, i.component(r2.name, r2), i.component(n2.name, n2), i.component(s2.name, s2), i.component(o2.name, o2), i.component(h2.name, h2), i.component(g2.name, g2), i.component(p2.name, p2));
}
const aj = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  AnimatedClusterLayer: h2,
  HeatmapLayer: p2,
  ImageLayer: s2,
  TileLayer: r2,
  VectorLayer: o2,
  WebGLTileLayer: n2,
  WebglPointsLayer: g2,
  default: $m,
  install: $m
}, Symbol.toStringTag, { value: "Module" })), oj = {
  name: "ol-source-xyz",
  setup(i) {
    const e = _t("tileLayer"), { properties: t } = sr(i), r = cr(() => new F4(t));
    return at(r, () => {
      e.value.setSource(r.value);
    }), at(e, () => {
      e.value.setSource(r.value);
    }), tr(() => {
      e.value.setSource(r.value);
    }), nr(() => {
      e.value.setSource(null);
    }), {
      layer: e,
      source: r
    };
  },
  props: {
    attributions: {
      type: [String, Array]
    },
    url: {
      type: String
    },
    cacheSize: {
      type: Number,
      default: 2048
    },
    crossOrigin: {
      type: String
    },
    maxZoom: {
      type: Number,
      default: 28
    },
    minZoom: {
      type: Number,
      default: 0
    },
    opaque: {
      type: Boolean
    },
    projection: {
      type: String,
      default: "EPSG:3857"
    },
    reprojectionErrorThreshold: {
      type: Number,
      default: 0.5
    },
    tileSize: {
      type: Array,
      default: () => [256, 256]
    },
    tilePixelRatio: {
      type: Number,
      default: 1
    },
    tileKey: {
      type: String
    },
    transition: {
      type: Number
    },
    tileGrid: {
      type: Object
    }
  }
};
function Aj(i, e, t, r, n, s) {
  return ur("", !0);
}
const m2 = /* @__PURE__ */ qe(oj, [["render", Aj]]), lj = {
  name: "ol-source-osm",
  setup(i) {
    const e = _t("tileLayer"), { properties: t } = sr(i), r = cr(() => new _K(t));
    return at(r, () => {
      e.value.setSource(r.value);
    }), at(e, () => {
      e.value.setSource(r.value);
    }), tr(() => {
      e.value.setSource(r.value);
    }), nr(() => {
      e.value.setSource(null);
    }), {
      layer: e,
      source: r
    };
  },
  props: {
    attributions: {
      type: String
    },
    cacheSize: {
      type: Number,
      default: 2048
    },
    crossOrigin: {
      type: String,
      default: "anonymous"
    },
    imageSmoothing: {
      type: Boolean,
      default: !0
    },
    minZoom: {
      type: Number,
      default: 0
    },
    maxZoom: {
      type: Number,
      default: 19
    },
    opaque: {
      type: Boolean,
      default: !0
    },
    reprojectionErrorThreshold: {
      type: Number,
      default: 0.5
    },
    transition: {
      type: Number,
      default: 250
    },
    url: {
      type: String,
      default: "https://{a-c}.tile.openstreetmap.org/{z}/{x}/{y}.png"
    },
    wrapX: {
      type: Boolean,
      default: !0
    }
  }
};
function hj(i, e, t, r, n, s) {
  return ur("", !0);
}
const v2 = /* @__PURE__ */ qe(lj, [["render", hj]]), cj = {
  name: "ol-source-image-static",
  setup(i) {
    const e = _t("imageLayer"), { properties: t } = sr(i), r = () => new gK({
      ...t,
      projection: typeof t.projection == "string" ? t.projection : new Ja({
        ...t.projection
      })
    });
    let n = r();
    return at(t, () => {
      e.setSource(null), n = r(), e.setSource(n);
    }), tr(() => {
      e.setSource(n);
    }), nr(() => {
      e.setSource(null);
    }), {
      layer: e,
      source: n
    };
  },
  props: {
    attributions: {
      type: String
    },
    crossOrigin: {
      type: String
    },
    imageExtent: {
      type: Array
    },
    projection: {
      type: [String, Object]
    },
    imageSmoothing: {
      type: Boolean,
      default: !0
    },
    imageSize: {
      type: Array
    },
    url: {
      type: String
    }
  }
};
function uj(i, e, t, r, n, s) {
  return ur("", !0);
}
const y2 = /* @__PURE__ */ qe(cj, [["render", uj]]), fj = {
  name: "ol-source-wmts",
  setup(i) {
    const e = _t("tileLayer"), { properties: t } = sr(i), r = cr(
      () => Ct(t.projection).getExtent()
    ), n = cr(() => Sa(r.value)), s = cr(() => ir(r.value) / 256), a = cr(() => {
      const A = new Array(t.tileZoomLevel), l = new Array(t.tileZoomLevel);
      for (let h = 0; h < t.tileZoomLevel; ++h)
        A[h] = s.value / Math.pow(2, h), l[h] = h;
      return new A2({
        origin: n.value,
        resolutions: A,
        matrixIds: l
      });
    }), o = cr(
      () => new P4({
        ...t,
        projection: typeof t.projection == "string" ? t.projection : new Ja({
          ...t.projection
        }),
        tileGrid: a.value
      })
    );
    return at(o, () => {
      e.value.setSource(o.value);
    }), at(e, () => {
      e.value.setSource(o.value);
    }), tr(() => {
      e.value.setSource(o.value);
    }), nr(() => {
      e.value.setSource(null);
    }), {
      tileLayer: e,
      source: o
    };
  },
  props: {
    tileZoomLevel: {
      type: Number,
      default: 30
    },
    attributions: {
      type: String
    },
    cacheSize: {
      type: Number
    },
    crossOrigin: {
      type: String
    },
    imageSmoothing: {
      type: Boolean,
      default: !0
    },
    projection: {
      type: [String, Object],
      default: "EPSG:3857"
    },
    reprojectionErrorThreshold: {
      type: Number,
      default: 0.5
    },
    tilePixelRatio: {
      type: Number,
      default: 1
    },
    format: {
      type: String,
      default: "image/jpeg"
    },
    version: {
      type: String,
      default: "1.0.0"
    },
    matrixSet: {
      type: String
    },
    dimensions: {
      type: Object
    },
    requestEncoding: {
      type: String,
      default: "KVP"
    },
    url: {
      type: String
    },
    urls: {
      type: Array
    },
    wrapX: {
      type: Boolean,
      default: !1
    },
    transition: {
      type: Number
    },
    layer: {
      type: String
    },
    style: {
      type: String
    }
  }
};
function dj(i, e, t, r, n, s) {
  return ur("", !0);
}
const _2 = /* @__PURE__ */ qe(fj, [["render", dj]]), gj = {
  name: "ol-source-vector",
  setup(i) {
    const e = _t("vectorLayer") || _t("heatmapLayer"), { properties: t } = sr(i), r = cr(() => new sA(t)), n = () => {
      e.value.setSource(null), e.value.setSource(r.value), e.value.changed();
    };
    return at(t, () => {
      n();
    }), at(e, () => {
      n();
    }), tr(() => {
      e.value.setSource(r.value);
    }), nr(() => {
      e.value.setSource(null);
    }), Ur("vectorSource", r), {
      layer: e,
      source: r
    };
  },
  props: {
    attributions: {
      type: [String, Array]
    },
    features: {
      type: Array,
      default: () => []
    },
    format: {
      type: Object
    },
    loader: {
      type: Function
    },
    overlaps: {
      type: Boolean,
      default: !0
    },
    projection: {
      type: String,
      default: "EPSG:3857"
    },
    strategy: {
      type: Function
    },
    url: {
      type: [String, Function]
    },
    useSpatialIndex: {
      type: Boolean,
      default: !0
    },
    wrapX: {
      type: Boolean,
      default: !0
    }
  }
};
function pj(i, e, t, r, n, s) {
  return xn(), Cn("div", null, [
    mr(i.$slots, "default")
  ]);
}
const w2 = /* @__PURE__ */ qe(gj, [["render", pj]]), mj = {
  name: "ol-source-cluster",
  setup(i) {
    const e = _t("vectorLayer"), { properties: t } = sr(i), r = cr(() => new I4(t)), n = () => {
      e.value.setSource(null), e.value.setSource(r.value), e.value.changed();
    };
    return at(t, () => {
      n();
    }), at(e, () => {
      n();
    }), tr(() => {
      e.value.setSource(r.value), e.value.changed();
    }), nr(() => {
      e.value.setSource(null);
    }), Ur("vectorLayer", r), {
      layer: e,
      source: r
    };
  },
  props: {
    attributions: {
      type: [String, Array]
    },
    distance: {
      type: Number,
      default: 20
    },
    geometryFunction: {
      type: Function,
      default: (i) => i.getGeometry()
    },
    wrapX: {
      type: Boolean,
      default: !0
    }
  }
};
function vj(i, e, t, r, n, s) {
  return xn(), Cn("div", null, [
    mr(i.$slots, "default")
  ]);
}
const x2 = /* @__PURE__ */ qe(mj, [["render", vj]]), yj = {
  name: "ol-source-bingmaps",
  setup(i) {
    const e = _t("tileLayer"), { properties: t } = sr(i), r = cr(
      () => new zV({
        ...t,
        key: t.apiKey
      })
    );
    return at(r, () => {
      e.value.setSource(r.value);
    }), at(e, () => {
      e.value.setSource(r.value);
    }), tr(() => {
      e.value.setSource(r.value);
    }), nr(() => {
      e.value.setSource(null);
    }), {
      layer: e,
      source: r
    };
  },
  props: {
    cacheSize: {
      type: Number
    },
    hidpi: {
      type: Boolean,
      default: !1
    },
    culture: {
      type: String,
      default: "en-us"
    },
    apiKey: {
      type: String
    },
    imagerySet: {
      type: String
    },
    imageSmoothing: {
      type: Boolean,
      default: !0
    },
    maxZoom: {
      type: Number,
      default: 21
    },
    reprojectionErrorThreshold: {
      type: Number,
      default: 0.5
    },
    tileLoadFunction: {
      type: Function,
      default: (i, e) => i.getImage().src = e
    },
    wrapX: {
      type: Boolean,
      default: !0
    },
    transition: {
      type: Number
    }
  }
};
function _j(i, e, t, r, n, s) {
  return ur("", !0);
}
const C2 = /* @__PURE__ */ qe(yj, [["render", _j]]);
class Po extends P4 {
  constructor(e) {
    Po.layerLabelMap = {
      vec: "cva",
      ter: "cta",
      img: "cia"
    }, Po.layerZoomMap = {
      vec: 18,
      ter: 14,
      img: 18
    };
    const t = e || {};
    t.layerType = t.layerType || "vec", t.layerType = t.isLabel ? Po.layerLabelMap[t.layerType] : t.layerType, t.matrixSet = t.projection === "EPSG:4326" || t.projection === "EPSG:4490" ? "c" : "w", !t.url && !t.urls && (t.url = "https://t{0-7}.tianditu.gov.cn/{layer}_{proj}/wmts?"), t.tk && (t.url = `${t.url}tk=${t.tk}`), t.url = t.url.replace("{layer}", t.layerType).replace("{proj}", t.matrixSet);
    const r = t.tileGrid || Po.getTileGrid(t.projection || "EPSG:3857"), n = t.crossOrigin !== void 0 ? t.crossOrigin : "anonymous", s = {
      version: t.version || "1.0.0",
      format: t.format || "tiles",
      dimensions: t.dimensions || {},
      layer: t.layerType,
      matrixSet: t.matrixSet,
      tileGrid: r,
      style: t.style || "default",
      cacheSize: t.cacheSize,
      crossOrigin: n,
      opaque: t.opaque === void 0 ? !0 : t.opaque,
      maxZoom: Po.layerZoomMap[t.layerType],
      reprojectionErrorThreshold: t.reprojectionErrorThreshold,
      url: t.url,
      urls: t.urls,
      projection: t.projection || "EPSG:3857",
      wrapX: t.wrapX
    };
    t.tileProxy && (s.tileLoadFunction = a), super(s), t.tileProxy && (this.tileProxy = t.tileProxy);
    const a = (o, A) => {
      o.getImage().src = this.tileProxy + encodeURIComponent(A);
    };
  }
  static getTileGrid(e) {
    return e === "EPSG:4326" || e === "EPSG:4490" ? Po.default4326TileGrid() : Po.default3857TileGrid();
  }
  static default4326TileGrid() {
    const e = [], t = [];
    for (let n = 1; n < 19; n++)
      e.push(0.703125 * 2 / Math.pow(2, n)), t.push(n);
    return new A2({
      extent: [-180, -90, 180, 90],
      resolutions: e,
      origin: [-180, 90],
      matrixIds: t,
      minZoom: 1
    });
  }
  static default3857TileGrid() {
    const e = [], t = [];
    for (let n = 1; n < 19; n++)
      e.push(78271.51696402031 * 2 / Math.pow(2, n)), t.push(n);
    return new A2({
      extent: [
        -200375083427892e-7,
        -200375083427892e-7,
        200375083427892e-7,
        200375083427892e-7
      ],
      resolutions: e,
      matrixIds: t,
      origin: [-200375083427892e-7, 200375083427892e-7],
      minZoom: 1
    });
  }
}
const wj = {
  name: "ol-source-tianditu",
  setup(i) {
    const e = _t("tileLayer"), { properties: t } = sr(i), r = cr(() => new Po(t));
    return at(r, () => {
      e.value.setSource(r.value);
    }), at(e, () => {
      e.value.setSource(r.value);
    }), tr(() => {
      e.value.setSource(r.value);
    }), nr(() => {
      e.value.setSource(null);
    }), {
      layer: e,
      source: r
    };
  },
  props: {
    layerType: {
      type: String,
      default: "img"
    },
    tk: {
      type: String
    },
    isLabel: {
      type: Boolean,
      default: !1
    },
    cacheSize: {
      type: Number
    },
    crossOrigin: {
      type: String
    },
    projection: {
      Type: String,
      default: "EPSG:3857"
    },
    hidpi: {
      type: Boolean,
      default: !1
    },
    requestEncoding: {
      type: String,
      default: "KVP"
    },
    format: {
      type: String
    },
    version: {
      type: String,
      default: "1.0.0"
    },
    culture: {
      type: String,
      default: "en-us"
    },
    matrixSet: {
      type: String
    },
    dimensions: {
      type: Object,
      default: () => ({})
    },
    imageSmoothing: {
      type: Boolean,
      default: !0
    },
    maxZoom: {
      type: Number,
      default: 21
    },
    reprojectionErrorThreshold: {
      type: Number
    },
    tileLoadFunction: {
      type: Function,
      default: (i, e) => i.getImage().src = e
    },
    wrapX: {
      type: Boolean,
      default: !0
    },
    transition: {
      type: Number
    }
  }
};
function xj(i, e, t, r, n, s) {
  return ur("", !0);
}
const E2 = /* @__PURE__ */ qe(wj, [["render", xj]]), Cj = {
  name: "ol-source-image-wms",
  setup(i) {
    const e = _t("imageLayer"), { properties: t } = sr(i), r = () => new mK({
      ...t,
      params: {
        ...i.params,
        LAYERS: i.layers,
        STYLES: i.styles,
        TIME: i.time
      },
      projection: typeof t.projection == "string" ? t.projection : new Ja({
        ...t.projection
      })
    });
    let n = r();
    return at(t, () => {
      e.setSource(null), n = r(), e.setSource(n);
    }), tr(() => {
      e.setSource(n);
    }), nr(() => {
      e.setSource(null);
    }), {
      layer: e,
      source: n
    };
  },
  props: {
    attributions: {
      type: String
    },
    crossOrigin: {
      type: String
    },
    imageExtent: {
      type: Array
    },
    projection: {
      type: [String, Object],
      default: "EPSG:3857"
    },
    reprojectionErrorThreshold: {
      type: Number,
      default: 0.5
    },
    format: {
      type: String,
      default: "image/png"
    },
    version: {
      type: String,
      default: "1.3.0"
    },
    matrixSet: {
      type: String
    },
    serverType: {
      type: String,
      default: "mapserver"
    },
    imageSmoothing: {
      type: Boolean,
      default: !0
    },
    layers: {
      type: [String, Array],
      required: !0
    },
    styles: {
      type: [String, Array],
      default: ""
    },
    time: {
      type: String
    },
    ratio: {
      type: Number,
      default: 1
    },
    imageSize: {
      type: Array
    },
    url: {
      type: String
    },
    params: {
      type: Object,
      default: () => ({})
    },
    imageLoadFunction: {
      type: Function
    }
  }
};
function Ej(i, e, t, r, n, s) {
  return ur("", !0);
}
const B2 = /* @__PURE__ */ qe(Cj, [["render", Ej]]), Bj = {
  name: "ol-source-tile-wms",
  setup(i) {
    const e = _t("tileLayer"), { properties: t } = sr(i), r = () => new N4({
      ...t,
      params: {
        ...i.params,
        LAYERS: i.layers,
        STYLES: i.styles,
        TILED: !0
      },
      projection: typeof t.projection == "string" ? t.projection : new Ja({
        ...t.projection
      })
    });
    let n = r();
    return at(t, () => {
      e.value.setSource(null), n = r(), e.value.setSource(n);
    }), tr(() => {
      e.value.setSource(n);
    }), nr(() => {
      e.value.setSource(null);
    }), {
      layer: e,
      source: n
    };
  },
  props: {
    attributions: {
      type: String
    },
    cacheSize: {
      type: Number
    },
    crossOrigin: {
      type: String
    },
    interpolate: {
      type: Boolean,
      default: !0
    },
    layers: {
      type: [String, Array],
      required: !0
    },
    styles: {
      type: [String, Array],
      default: ""
    },
    hidpi: {
      type: Boolean,
      default: !1
    },
    projection: {
      type: [String, Object],
      default: "EPSG:3857"
    },
    reprojectionErrorThreshold: {
      type: Number,
      default: 0.5
    },
    tileGrid: {
      type: Object
    },
    serverType: {
      type: String,
      default: "mapserver"
    },
    tileLoadFunction: {
      type: Function,
      default: (i, e) => i.getImage().src = e
    },
    url: {
      type: String
    },
    urls: {
      type: Array
    },
    params: {
      type: Object,
      default: () => ({})
    },
    wrapX: {
      type: Boolean,
      default: !0
    },
    transition: {
      type: Number
    }
  }
};
function bj(i, e, t, r, n, s) {
  return ur("", !0);
}
const b2 = /* @__PURE__ */ qe(Bj, [["render", bj]]), Sj = {
  name: "ol-source-webglpoints",
  setup(i) {
    const e = _t("webglPointsLayer"), { properties: t } = sr(i), r = cr(() => new sA(t)), n = () => {
      e.value.setSource(null), e.value.setSource(r.value), e.value.changed();
    };
    return at(t, () => {
      n();
    }), at(e, () => {
      n();
    }), tr(() => {
      e.value.setSource(r.value);
    }), nr(() => {
      e.value.setSource(null);
    }), Ur("vectorSource", r), {
      layer: e,
      source: r
    };
  },
  props: {
    attributions: {
      type: [String, Array]
    },
    features: {
      type: Array,
      default: () => []
    },
    format: {
      type: Object
    },
    loader: {
      type: Function
    },
    overlaps: {
      type: Boolean,
      default: !0
    },
    projection: {
      type: String,
      default: "EPSG:3857"
    },
    strategy: {
      type: Function
    },
    url: {
      type: [String, Function]
    },
    useSpatialIndex: {
      type: Boolean,
      default: !0
    },
    wrapX: {
      type: Boolean,
      default: !0
    }
  }
};
function Tj(i, e, t, r, n, s) {
  return xn(), Cn("div", null, [
    mr(i.$slots, "default")
  ]);
}
const S2 = /* @__PURE__ */ qe(Sj, [["render", Tj]]);
function Vm(i) {
  Vm.installed || (Vm.installed = !0, i.component(m2.name, m2), i.component(v2.name, v2), i.component(y2.name, y2), i.component(_2.name, _2), i.component(w2.name, w2), i.component(x2.name, x2), i.component(C2.name, C2), i.component(E2.name, E2), i.component(B2.name, B2), i.component(b2.name, b2), i.component(S2.name, S2));
}
const Fj = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  SourceBingMaps: C2,
  SourceCluster: x2,
  SourceImageStatic: y2,
  SourceImageWMS: B2,
  SourceOSM: v2,
  SourceTianDiTu: E2,
  SourceTileWMS: b2,
  SourceVector: w2,
  SourceWMTS: _2,
  SourceWebglPoints: S2,
  SourceXYZ: m2,
  default: Vm,
  install: Vm
}, Symbol.toStringTag, { value: "Module" })), L5 = [
  "fullscreenchange",
  "webkitfullscreenchange",
  "MSFullscreenChange"
], I5 = {
  /**
   * Triggered after the map entered fullscreen.
   * @event FullScreenEventType#enterfullscreen
   * @api
   */
  ENTERFULLSCREEN: "enterfullscreen",
  /**
   * Triggered after the map leave fullscreen.
   * @event FullScreenEventType#leavefullscreen
   * @api
   */
  LEAVEFULLSCREEN: "leavefullscreen"
};
class Lj extends hn {
  /**
   * @param {Options} [options] Options.
   */
  constructor(e) {
    e = e || {}, super({
      element: document.createElement("div"),
      target: e.target
    }), this.on, this.once, this.un, this.keys_ = e.keys !== void 0 ? e.keys : !1, this.source_ = e.source, this.isInFullscreen_ = !1, this.boundHandleMapTargetChange_ = this.handleMapTargetChange_.bind(this), this.cssClassName_ = e.className !== void 0 ? e.className : "ol-full-screen", this.documentListeners_ = [], this.activeClassName_ = e.activeClassName !== void 0 ? e.activeClassName.split(" ") : [this.cssClassName_ + "-true"], this.inactiveClassName_ = e.inactiveClassName !== void 0 ? e.inactiveClassName.split(" ") : [this.cssClassName_ + "-false"];
    const t = e.label !== void 0 ? e.label : "";
    this.labelNode_ = typeof t == "string" ? document.createTextNode(t) : t;
    const r = e.labelActive !== void 0 ? e.labelActive : "";
    this.labelActiveNode_ = typeof r == "string" ? document.createTextNode(r) : r;
    const n = e.tipLabel ? e.tipLabel : "Toggle full-screen";
    this.button_ = document.createElement("button"), this.button_.title = n, this.button_.setAttribute("type", "button"), this.button_.appendChild(this.labelNode_), this.button_.addEventListener(
      ut.CLICK,
      this.handleClick_.bind(this),
      !1
    ), this.setClassName_(this.button_, this.isInFullscreen_), this.element.className = `${this.cssClassName_} ${Wa} ${Sh}`, this.element.appendChild(this.button_);
  }
  /**
   * @param {MouseEvent} event The event to handle
   * @private
   */
  handleClick_(e) {
    e.preventDefault(), this.handleFullScreen_();
  }
  /**
   * @private
   */
  handleFullScreen_() {
    const e = this.getMap();
    if (!e)
      return;
    const t = e.getOwnerDocument();
    if (R5(t))
      if (M5(t))
        Rj(t);
      else {
        let r;
        this.source_ ? r = typeof this.source_ == "string" ? t.getElementById(this.source_) : this.source_ : r = e.getTargetElement(), this.keys_ ? Ij(r) : H4(r);
      }
  }
  /**
   * @private
   */
  handleFullScreenChange_() {
    const e = this.getMap();
    if (!e)
      return;
    const t = this.isInFullscreen_;
    this.isInFullscreen_ = M5(e.getOwnerDocument()), t !== this.isInFullscreen_ && (this.setClassName_(this.button_, this.isInFullscreen_), this.isInFullscreen_ ? (pu(this.labelActiveNode_, this.labelNode_), this.dispatchEvent(I5.ENTERFULLSCREEN)) : (pu(this.labelNode_, this.labelActiveNode_), this.dispatchEvent(I5.LEAVEFULLSCREEN)), e.updateSize());
  }
  /**
   * @param {HTMLElement} element Target element
   * @param {boolean} fullscreen True if fullscreen class name should be active
   * @private
   */
  setClassName_(e, t) {
    t ? (e.classList.remove(...this.inactiveClassName_), e.classList.add(...this.activeClassName_)) : (e.classList.remove(...this.activeClassName_), e.classList.add(...this.inactiveClassName_));
  }
  /**
   * Remove the control from its current map and attach it to the new map.
   * Pass `null` to just remove the control from the current map.
   * Subclasses may set up event handlers to get notified about changes to
   * the map here.
   * @param {import("../Map.js").default|null} map Map.
   * @api
   */
  setMap(e) {
    const t = this.getMap();
    t && t.removeChangeListener(
      Pi.TARGET,
      this.boundHandleMapTargetChange_
    ), super.setMap(e), this.handleMapTargetChange_(), e && e.addChangeListener(
      Pi.TARGET,
      this.boundHandleMapTargetChange_
    );
  }
  /**
   * @private
   */
  handleMapTargetChange_() {
    const e = this.documentListeners_;
    for (let r = 0, n = e.length; r < n; ++r)
      pr(e[r]);
    e.length = 0;
    const t = this.getMap();
    if (t) {
      const r = t.getOwnerDocument();
      R5(r) ? this.element.classList.remove(US) : this.element.classList.add(US);
      for (let n = 0, s = L5.length; n < s; ++n)
        e.push(
          St(r, L5[n], this.handleFullScreenChange_, this)
        );
      this.handleFullScreenChange_();
    }
  }
}
function R5(i) {
  const e = i.body;
  return !!(e.webkitRequestFullscreen || e.requestFullscreen && i.fullscreenEnabled);
}
function M5(i) {
  return !!(i.webkitIsFullScreen || i.fullscreenElement);
}
function H4(i) {
  i.requestFullscreen ? i.requestFullscreen() : i.webkitRequestFullscreen && i.webkitRequestFullscreen();
}
function Ij(i) {
  i.webkitRequestFullscreen ? i.webkitRequestFullscreen() : H4(i);
}
function Rj(i) {
  i.exitFullscreen ? i.exitFullscreen() : i.webkitExitFullscreen && i.webkitExitFullscreen();
}
const Mj = Lj, Y1 = "projection", N5 = "coordinateFormat";
class Nj extends hn {
  /**
   * @param {Options} [options] Mouse position options.
   */
  constructor(e) {
    e = e || {};
    const t = document.createElement("div");
    t.className = e.className !== void 0 ? e.className : "ol-mouse-position", super({
      element: t,
      render: e.render,
      target: e.target
    }), this.on, this.once, this.un, this.addChangeListener(Y1, this.handleProjectionChanged_), e.coordinateFormat && this.setCoordinateFormat(e.coordinateFormat), e.projection && this.setProjection(e.projection), this.renderOnMouseOut_ = e.placeholder !== void 0, this.placeholder_ = this.renderOnMouseOut_ ? e.placeholder : "&#160;", this.renderedHTML_ = t.innerHTML, this.mapProjection_ = null, this.transform_ = null, this.wrapX_ = e.wrapX !== !1;
  }
  /**
   * @private
   */
  handleProjectionChanged_() {
    this.transform_ = null;
  }
  /**
   * Return the coordinate format type used to render the current position or
   * undefined.
   * @return {import("../coordinate.js").CoordinateFormat|undefined} The format to render the current
   *     position in.
   * @observable
   * @api
   */
  getCoordinateFormat() {
    return (
      /** @type {import("../coordinate.js").CoordinateFormat|undefined} */
      this.get(N5)
    );
  }
  /**
   * Return the projection that is used to report the mouse position.
   * @return {import("../proj/Projection.js").default|undefined} The projection to report mouse
   *     position in.
   * @observable
   * @api
   */
  getProjection() {
    return (
      /** @type {import("../proj/Projection.js").default|undefined} */
      this.get(Y1)
    );
  }
  /**
   * @param {MouseEvent} event Browser event.
   * @protected
   */
  handleMouseMove(e) {
    const t = this.getMap();
    this.updateHTML_(t.getEventPixel(e));
  }
  /**
   * @param {Event} event Browser event.
   * @protected
   */
  handleMouseOut(e) {
    this.updateHTML_(null);
  }
  /**
   * Remove the control from its current map and attach it to the new map.
   * Pass `null` to just remove the control from the current map.
   * Subclasses may set up event handlers to get notified about changes to
   * the map here.
   * @param {import("../Map.js").default|null} map Map.
   * @api
   */
  setMap(e) {
    if (super.setMap(e), e) {
      const t = e.getViewport();
      this.listenerKeys.push(
        St(t, ka.POINTERMOVE, this.handleMouseMove, this)
      ), this.renderOnMouseOut_ && this.listenerKeys.push(
        St(t, ka.POINTEROUT, this.handleMouseOut, this)
      ), this.updateHTML_(null);
    }
  }
  /**
   * Set the coordinate format type used to render the current position.
   * @param {import("../coordinate.js").CoordinateFormat} format The format to render the current
   *     position in.
   * @observable
   * @api
   */
  setCoordinateFormat(e) {
    this.set(N5, e);
  }
  /**
   * Set the projection that is used to report the mouse position.
   * @param {import("../proj.js").ProjectionLike} projection The projection to report mouse
   *     position in.
   * @observable
   * @api
   */
  setProjection(e) {
    this.set(Y1, Ct(e));
  }
  /**
   * @param {?import("../pixel.js").Pixel} pixel Pixel.
   * @private
   */
  updateHTML_(e) {
    let t = this.placeholder_;
    if (e && this.mapProjection_) {
      if (!this.transform_) {
        const s = this.getProjection();
        s ? this.transform_ = Fu(
          this.mapProjection_,
          s
        ) : this.transform_ = Pv;
      }
      const n = this.getMap().getCoordinateFromPixelInternal(e);
      if (n) {
        if (this.transform_(n, n), this.wrapX_) {
          const a = this.getProjection() || this.mapProjection_;
          Nv(n, a);
        }
        const s = this.getCoordinateFormat();
        s ? t = s(n) : t = n.toString();
      }
    }
    (!this.renderedHTML_ || t !== this.renderedHTML_) && (this.element.innerHTML = t, this.renderedHTML_ = t);
  }
  /**
   * Update the projection. Rendering of the coordinates is done in
   * `handleMouseMove` and `handleMouseUp`.
   * @param {import("../MapEvent.js").default} mapEvent Map event.
   * @override
   */
  render(e) {
    const t = e.frameState;
    t ? this.mapProjection_ != t.viewState.projection && (this.mapProjection_ = t.viewState.projection, this.transform_ = null) : this.mapProjection_ = null;
  }
}
const Pj = Nj, q1 = 0.75, Qp = 0.1;
class Oj extends hn {
  /**
   * @param {Options} [options] OverviewMap options.
   */
  constructor(e) {
    e = e || {}, super({
      element: document.createElement("div"),
      render: e.render,
      target: e.target
    }), this.boundHandleRotationChanged_ = this.handleRotationChanged_.bind(this), this.collapsed_ = e.collapsed !== void 0 ? e.collapsed : !0, this.collapsible_ = e.collapsible !== void 0 ? e.collapsible : !0, this.collapsible_ || (this.collapsed_ = !1), this.rotateWithView_ = e.rotateWithView !== void 0 ? e.rotateWithView : !1, this.viewExtent_ = void 0;
    const t = e.className !== void 0 ? e.className : "ol-overviewmap", r = e.tipLabel !== void 0 ? e.tipLabel : "Overview map", n = e.collapseLabel !== void 0 ? e.collapseLabel : "";
    typeof n == "string" ? (this.collapseLabel_ = document.createElement("span"), this.collapseLabel_.textContent = n) : this.collapseLabel_ = n;
    const s = e.label !== void 0 ? e.label : "";
    typeof s == "string" ? (this.label_ = document.createElement("span"), this.label_.textContent = s) : this.label_ = s;
    const a = this.collapsible_ && !this.collapsed_ ? this.collapseLabel_ : this.label_, o = document.createElement("button");
    o.setAttribute("type", "button"), o.title = r, o.appendChild(a), o.addEventListener(
      ut.CLICK,
      this.handleClick_.bind(this),
      !1
    ), this.ovmapDiv_ = document.createElement("div"), this.ovmapDiv_.className = "ol-overviewmap-map", this.view_ = e.view;
    const A = new vg({
      view: e.view,
      controls: new Yi(),
      interactions: new Yi()
    });
    this.ovmap_ = A, e.layers && e.layers.forEach(function(w) {
      A.addLayer(w);
    });
    const l = document.createElement("div");
    l.className = "ol-overviewmap-box", l.style.boxSizing = "border-box", this.boxOverlay_ = new uM({
      position: [0, 0],
      positioning: "center-center",
      element: l
    }), this.ovmap_.addOverlay(this.boxOverlay_);
    const h = t + " " + Wa + " " + Sh + (this.collapsed_ && this.collapsible_ ? " " + _m : "") + (this.collapsible_ ? "" : " ol-uncollapsible"), c = this.element;
    c.className = h, c.appendChild(this.ovmapDiv_), c.appendChild(o);
    const u = this, f = this.boxOverlay_, g = this.boxOverlay_.getElement(), p = function(w) {
      return {
        clientX: w.clientX,
        clientY: w.clientY
      };
    }, y = function(w) {
      const C = (
        /** @type {?} */
        p(w)
      ), E = A.getEventCoordinateInternal(
        /** @type {MouseEvent} */
        C
      );
      f.setPosition(E);
    }, v = function(w) {
      const C = A.getEventCoordinateInternal(w);
      u.getMap().getView().setCenterInternal(C), window.removeEventListener("mousemove", y), window.removeEventListener("mouseup", v);
    };
    g.addEventListener("mousedown", function() {
      window.addEventListener("mousemove", y), window.addEventListener("mouseup", v);
    });
  }
  /**
   * Remove the control from its current map and attach it to the new map.
   * Pass `null` to just remove the control from the current map.
   * Subclasses may set up event handlers to get notified about changes to
   * the map here.
   * @param {import("../Map.js").default|null} map Map.
   * @api
   */
  setMap(e) {
    const t = this.getMap();
    if (e !== t) {
      if (t) {
        const r = t.getView();
        r && this.unbindView_(r), this.ovmap_.setTarget(null);
      }
      if (super.setMap(e), e) {
        this.ovmap_.setTarget(this.ovmapDiv_), this.listenerKeys.push(
          St(
            e,
            fh.PROPERTYCHANGE,
            this.handleMapPropertyChange_,
            this
          )
        );
        const r = e.getView();
        r && (this.bindView_(r), r.isDef() && (this.ovmap_.updateSize(), this.resetExtent_())), this.ovmap_.isRendered() || this.updateBoxAfterOvmapIsRendered_();
      }
    }
  }
  /**
   * Handle map property changes.  This only deals with changes to the map's view.
   * @param {import("../Object.js").ObjectEvent} event The propertychange event.
   * @private
   */
  handleMapPropertyChange_(e) {
    if (e.key === Pi.VIEW) {
      const t = (
        /** @type {import("../View.js").default} */
        e.oldValue
      );
      t && this.unbindView_(t);
      const r = this.getMap().getView();
      this.bindView_(r);
    } else
      !this.ovmap_.isRendered() && (e.key === Pi.TARGET || e.key === Pi.SIZE) && this.ovmap_.updateSize();
  }
  /**
   * Register listeners for view property changes.
   * @param {import("../View.js").default} view The view.
   * @private
   */
  bindView_(e) {
    if (!this.view_) {
      const t = new Ys({
        projection: e.getProjection()
      });
      this.ovmap_.setView(t);
    }
    e.addChangeListener(
      Rs.ROTATION,
      this.boundHandleRotationChanged_
    ), this.handleRotationChanged_();
  }
  /**
   * Unregister listeners for view property changes.
   * @param {import("../View.js").default} view The view.
   * @private
   */
  unbindView_(e) {
    e.removeChangeListener(
      Rs.ROTATION,
      this.boundHandleRotationChanged_
    );
  }
  /**
   * Handle rotation changes to the main map.
   * @private
   */
  handleRotationChanged_() {
    this.rotateWithView_ && this.ovmap_.getView().setRotation(this.getMap().getView().getRotation());
  }
  /**
   * Reset the overview map extent if the box size (width or
   * height) is less than the size of the overview map size times minRatio
   * or is greater than the size of the overview size times maxRatio.
   *
   * If the map extent was not reset, the box size can fits in the defined
   * ratio sizes. This method then checks if is contained inside the overview
   * map current extent. If not, recenter the overview map to the current
   * main map center location.
   * @private
   */
  validateExtent_() {
    const e = this.getMap(), t = this.ovmap_;
    if (!e.isRendered() || !t.isRendered())
      return;
    const r = (
      /** @type {import("../size.js").Size} */
      e.getSize()
    ), s = e.getView().calculateExtentInternal(r);
    if (this.viewExtent_ && Xa(s, this.viewExtent_))
      return;
    this.viewExtent_ = s;
    const a = (
      /** @type {import("../size.js").Size} */
      t.getSize()
    ), A = t.getView().calculateExtentInternal(a), l = t.getPixelFromCoordinateInternal(
      Sa(s)
    ), h = t.getPixelFromCoordinateInternal(
      Su(s)
    ), c = Math.abs(l[0] - h[0]), u = Math.abs(l[1] - h[1]), f = a[0], g = a[1];
    c < f * Qp || u < g * Qp || c > f * q1 || u > g * q1 ? this.resetExtent_() : Ps(A, s) || this.recenter_();
  }
  /**
   * Reset the overview map extent to half calculated min and max ratio times
   * the extent of the main map.
   * @private
   */
  resetExtent_() {
    const e = this.getMap(), t = this.ovmap_, r = (
      /** @type {import("../size.js").Size} */
      e.getSize()
    ), s = e.getView().calculateExtentInternal(r), a = t.getView(), o = Math.log(q1 / Qp) / Math.LN2, A = 1 / (Math.pow(2, o / 2) * Qp);
    ER(s, A), a.fitInternal(jA(s));
  }
  /**
   * Set the center of the overview map to the map center without changing its
   * resolution.
   * @private
   */
  recenter_() {
    const e = this.getMap(), t = this.ovmap_, r = e.getView();
    t.getView().setCenterInternal(r.getCenterInternal());
  }
  /**
   * Update the box using the main map extent
   * @private
   */
  updateBox_() {
    const e = this.getMap(), t = this.ovmap_;
    if (!e.isRendered() || !t.isRendered())
      return;
    const r = (
      /** @type {import("../size.js").Size} */
      e.getSize()
    ), n = e.getView(), s = t.getView(), a = this.rotateWithView_ ? 0 : -n.getRotation(), o = this.boxOverlay_, A = this.boxOverlay_.getElement(), l = n.getCenterInternal(), h = n.getResolution(), c = s.getResolution(), u = r[0] * h / c, f = r[1] * h / c;
    if (o.setPosition(l), A) {
      A.style.width = u + "px", A.style.height = f + "px";
      const g = "rotate(" + a + "rad)";
      A.style.transform = g;
    }
  }
  /**
   * @private
   */
  updateBoxAfterOvmapIsRendered_() {
    this.ovmapPostrenderKey_ || (this.ovmapPostrenderKey_ = Sd(
      this.ovmap_,
      Qa.POSTRENDER,
      function(e) {
        delete this.ovmapPostrenderKey_, this.updateBox_();
      },
      this
    ));
  }
  /**
   * @param {MouseEvent} event The event to handle
   * @private
   */
  handleClick_(e) {
    e.preventDefault(), this.handleToggle_();
  }
  /**
   * @private
   */
  handleToggle_() {
    this.element.classList.toggle(_m), this.collapsed_ ? pu(this.collapseLabel_, this.label_) : pu(this.label_, this.collapseLabel_), this.collapsed_ = !this.collapsed_;
    const e = this.ovmap_;
    if (!this.collapsed_) {
      if (e.isRendered()) {
        this.viewExtent_ = void 0, e.render();
        return;
      }
      e.updateSize(), this.resetExtent_(), this.updateBoxAfterOvmapIsRendered_();
    }
  }
  /**
   * Return `true` if the overview map is collapsible, `false` otherwise.
   * @return {boolean} True if the widget is collapsible.
   * @api
   */
  getCollapsible() {
    return this.collapsible_;
  }
  /**
   * Set whether the overview map should be collapsible.
   * @param {boolean} collapsible True if the widget is collapsible.
   * @api
   */
  setCollapsible(e) {
    this.collapsible_ !== e && (this.collapsible_ = e, this.element.classList.toggle("ol-uncollapsible"), !e && this.collapsed_ && this.handleToggle_());
  }
  /**
   * Collapse or expand the overview map according to the passed parameter. Will
   * not do anything if the overview map isn't collapsible or if the current
   * collapsed state is already the one requested.
   * @param {boolean} collapsed True if the widget is collapsed.
   * @api
   */
  setCollapsed(e) {
    !this.collapsible_ || this.collapsed_ === e || this.handleToggle_();
  }
  /**
   * Determine if the overview map is collapsed.
   * @return {boolean} The overview map is collapsed.
   * @api
   */
  getCollapsed() {
    return this.collapsed_;
  }
  /**
   * Return `true` if the overview map view can rotate, `false` otherwise.
   * @return {boolean} True if the control view can rotate.
   * @api
   */
  getRotateWithView() {
    return this.rotateWithView_;
  }
  /**
   * Set whether the overview map view should rotate with the main map view.
   * @param {boolean} rotateWithView True if the control view should rotate.
   * @api
   */
  setRotateWithView(e) {
    this.rotateWithView_ !== e && (this.rotateWithView_ = e, this.getMap().getView().getRotation() !== 0 && (this.rotateWithView_ ? this.handleRotationChanged_() : this.ovmap_.getView().setRotation(0), this.viewExtent_ = void 0, this.validateExtent_(), this.updateBox_()));
  }
  /**
   * Return the overview map.
   * @return {import("../Map.js").default} Overview map.
   * @api
   */
  getOverviewMap() {
    return this.ovmap_;
  }
  /**
   * Update the overview map element.
   * @param {import("../MapEvent.js").default} mapEvent Map event.
   * @override
   */
  render(e) {
    this.validateExtent_(), this.updateBox_();
  }
}
const Uj = Oj, Z1 = "units", Qj = [1, 2, 5], If = 25.4 / 0.28;
class Dj extends hn {
  /**
   * @param {Options} [options] Scale line options.
   */
  constructor(e) {
    e = e || {};
    const t = document.createElement("div");
    t.style.pointerEvents = "none", super({
      element: t,
      render: e.render,
      target: e.target
    }), this.on, this.once, this.un;
    const r = e.className !== void 0 ? e.className : e.bar ? "ol-scale-bar" : "ol-scale-line";
    this.innerElement_ = document.createElement("div"), this.innerElement_.className = r + "-inner", this.element.className = r + " " + Wa, this.element.appendChild(this.innerElement_), this.viewState_ = null, this.minWidth_ = e.minWidth !== void 0 ? e.minWidth : 64, this.maxWidth_ = e.maxWidth, this.renderedVisible_ = !1, this.renderedWidth_ = void 0, this.renderedHTML_ = "", this.addChangeListener(Z1, this.handleUnitsChanged_), this.setUnits(e.units || "metric"), this.scaleBar_ = e.bar || !1, this.scaleBarSteps_ = e.steps || 4, this.scaleBarText_ = e.text || !1, this.dpi_ = e.dpi || void 0;
  }
  /**
   * Return the units to use in the scale line.
   * @return {Units} The units
   * to use in the scale line.
   * @observable
   * @api
   */
  getUnits() {
    return this.get(Z1);
  }
  /**
   * @private
   */
  handleUnitsChanged_() {
    this.updateElement_();
  }
  /**
   * Set the units to use in the scale line.
   * @param {Units} units The units to use in the scale line.
   * @observable
   * @api
   */
  setUnits(e) {
    this.set(Z1, e);
  }
  /**
   * Specify the dpi of output device such as printer.
   * @param {number|undefined} dpi The dpi of output device.
   * @api
   */
  setDpi(e) {
    this.dpi_ = e;
  }
  /**
   * @private
   */
  updateElement_() {
    const e = this.viewState_;
    if (!e) {
      this.renderedVisible_ && (this.element.style.display = "none", this.renderedVisible_ = !1);
      return;
    }
    const t = e.center, r = e.projection, n = this.getUnits(), s = n == "degrees" ? "degrees" : "m";
    let a = pm(
      r,
      e.resolution,
      t,
      s
    );
    const o = this.minWidth_ * (this.dpi_ || If) / If, A = this.maxWidth_ !== void 0 ? this.maxWidth_ * (this.dpi_ || If) / If : void 0;
    let l = o * a, h = "";
    if (n == "degrees") {
      const C = cu.degrees;
      l *= C, l < C / 60 ? (h = "", a *= 3600) : l < C ? (h = "", a *= 60) : h = "";
    } else
      n == "imperial" ? l < 0.9144 ? (h = "in", a /= 0.0254) : l < 1609.344 ? (h = "ft", a /= 0.3048) : (h = "mi", a /= 1609.344) : n == "nautical" ? (a /= 1852, h = "NM") : n == "metric" ? l < 1e-3 ? (h = "m", a *= 1e6) : l < 1 ? (h = "mm", a *= 1e3) : l < 1e3 ? h = "m" : (h = "km", a /= 1e3) : n == "us" ? l < 0.9144 ? (h = "in", a *= 39.37) : l < 1609.344 ? (h = "ft", a /= 0.30480061) : (h = "mi", a /= 1609.3472) : lt(!1, 33);
    let c = 3 * Math.floor(Math.log(o * a) / Math.log(10)), u, f, g, p, y, v;
    for (; ; ) {
      g = Math.floor(c / 3);
      const C = Math.pow(10, g);
      if (u = Qj[(c % 3 + 3) % 3] * C, f = Math.round(u / a), isNaN(f)) {
        this.element.style.display = "none", this.renderedVisible_ = !1;
        return;
      }
      if (A !== void 0 && f >= A) {
        u = p, f = y, g = v;
        break;
      } else if (f >= o)
        break;
      p = u, y = f, v = g, ++c;
    }
    const w = this.scaleBar_ ? this.createScaleBar(f, u, h) : u.toFixed(g < 0 ? -g : 0) + " " + h;
    this.renderedHTML_ != w && (this.innerElement_.innerHTML = w, this.renderedHTML_ = w), this.renderedWidth_ != f && (this.innerElement_.style.width = f + "px", this.renderedWidth_ = f), this.renderedVisible_ || (this.element.style.display = "", this.renderedVisible_ = !0);
  }
  /**
   * @private
   * @param {number} width The current width of the scalebar.
   * @param {number} scale The current scale.
   * @param {string} suffix The suffix to append to the scale text.
   * @return {string} The stringified HTML of the scalebar.
   */
  createScaleBar(e, t, r) {
    const n = this.getScaleForResolution(), s = n < 1 ? Math.round(1 / n).toLocaleString() + " : 1" : "1 : " + Math.round(n).toLocaleString(), a = this.scaleBarSteps_, o = e / a, A = [this.createMarker("absolute")];
    for (let h = 0; h < a; ++h) {
      const c = h % 2 === 0 ? "ol-scale-singlebar-odd" : "ol-scale-singlebar-even";
      A.push(
        `<div><div class="ol-scale-singlebar ${c}" style="width: ${o}px;"></div>` + this.createMarker("relative") + // render text every second step, except when only 2 steps
        (h % 2 === 0 || a === 2 ? this.createStepText(h, e, !1, t, r) : "") + "</div>"
      );
    }
    return A.push(this.createStepText(a, e, !0, t, r)), (this.scaleBarText_ ? `<div class="ol-scale-text" style="width: ${e}px;">` + s + "</div>" : "") + A.join("");
  }
  /**
   * Creates a marker at given position
   * @param {'absolute'|'relative'} position The position, absolute or relative
   * @return {string} The stringified div containing the marker
   */
  createMarker(e) {
    return `<div class="ol-scale-step-marker" style="position: ${e}; top: ${e === "absolute" ? 3 : -10}px;"></div>`;
  }
  /**
   * Creates the label for a marker marker at given position
   * @param {number} i The iterator
   * @param {number} width The width the scalebar will currently use
   * @param {boolean} isLast Flag indicating if we add the last step text
   * @param {number} scale The current scale for the whole scalebar
   * @param {string} suffix The suffix for the scale
   * @return {string} The stringified div containing the step text
   */
  createStepText(e, t, r, n, s) {
    const o = (e === 0 ? 0 : Math.round(n / this.scaleBarSteps_ * e * 100) / 100) + (e === 0 ? "" : " " + s), A = e === 0 ? -3 : t / this.scaleBarSteps_ * -1, l = e === 0 ? 0 : t / this.scaleBarSteps_ * 2;
    return `<div class="ol-scale-step-text" style="margin-left: ${A}px;text-align: ${e === 0 ? "left" : "center"};min-width: ${l}px;left: ${r ? t + "px" : "unset"};">` + o + "</div>";
  }
  /**
   * Returns the appropriate scale for the given resolution and units.
   * @return {number} The appropriate scale.
   */
  getScaleForResolution() {
    const e = pm(
      this.viewState_.projection,
      this.viewState_.resolution,
      this.viewState_.center,
      "m"
    ), t = this.dpi_ || If, r = 1e3 / 25.4;
    return e * r * t;
  }
  /**
   * Update the scale line element.
   * @param {import("../MapEvent.js").default} mapEvent Map event.
   * @override
   */
  render(e) {
    const t = e.frameState;
    t ? this.viewState_ = t.viewState : this.viewState_ = null, this.updateElement_();
  }
}
const kj = Dj, Rf = {
  VERTICAL: 0,
  HORIZONTAL: 1
};
class Hj extends hn {
  /**
   * @param {Options} [options] Zoom slider options.
   */
  constructor(e) {
    e = e || {}, super({
      element: document.createElement("div"),
      render: e.render
    }), this.dragListenerKeys_ = [], this.currentResolution_ = void 0, this.direction_ = Rf.VERTICAL, this.dragging_, this.heightLimit_ = 0, this.widthLimit_ = 0, this.startX_, this.startY_, this.thumbSize_ = null, this.sliderInitialized_ = !1, this.duration_ = e.duration !== void 0 ? e.duration : 200;
    const t = e.className !== void 0 ? e.className : "ol-zoomslider", r = document.createElement("button");
    r.setAttribute("type", "button"), r.className = t + "-thumb " + Wa;
    const n = this.element;
    n.className = t + " " + Wa + " " + Sh, n.appendChild(r), n.addEventListener(
      ka.POINTERDOWN,
      this.handleDraggerStart_.bind(this),
      !1
    ), n.addEventListener(
      ka.POINTERMOVE,
      this.handleDraggerDrag_.bind(this),
      !1
    ), n.addEventListener(
      ka.POINTERUP,
      this.handleDraggerEnd_.bind(this),
      !1
    ), n.addEventListener(
      ut.CLICK,
      this.handleContainerClick_.bind(this),
      !1
    ), r.addEventListener(ut.CLICK, _Q, !1);
  }
  /**
   * Remove the control from its current map and attach it to the new map.
   * Pass `null` to just remove the control from the current map.
   * Subclasses may set up event handlers to get notified about changes to
   * the map here.
   * @param {import("../Map.js").default|null} map Map.
   * @api
   */
  setMap(e) {
    super.setMap(e), e && e.render();
  }
  /**
   * Initializes the slider element. This will determine and set this controls
   * direction_ and also constrain the dragging of the thumb to always be within
   * the bounds of the container.
   *
   * @return {boolean} Initialization successful
   * @private
   */
  initSlider_() {
    const e = this.element;
    let t = e.offsetWidth, r = e.offsetHeight;
    if (t === 0 && r === 0)
      return this.sliderInitialized_ = !1;
    const n = getComputedStyle(e);
    t -= parseFloat(n.paddingRight) + parseFloat(n.paddingLeft), r -= parseFloat(n.paddingTop) + parseFloat(n.paddingBottom);
    const s = (
      /** @type {HTMLElement} */
      e.firstElementChild
    ), a = getComputedStyle(s), o = s.offsetWidth + parseFloat(a.marginRight) + parseFloat(a.marginLeft), A = s.offsetHeight + parseFloat(a.marginTop) + parseFloat(a.marginBottom);
    return this.thumbSize_ = [o, A], t > r ? (this.direction_ = Rf.HORIZONTAL, this.widthLimit_ = t - o) : (this.direction_ = Rf.VERTICAL, this.heightLimit_ = r - A), this.sliderInitialized_ = !0;
  }
  /**
   * @param {PointerEvent} event The browser event to handle.
   * @private
   */
  handleContainerClick_(e) {
    const t = this.getMap().getView(), r = this.getRelativePosition_(
      e.offsetX - this.thumbSize_[0] / 2,
      e.offsetY - this.thumbSize_[1] / 2
    ), n = this.getResolutionForPosition_(r), s = t.getConstrainedZoom(t.getZoomForResolution(n));
    t.animateInternal({
      zoom: s,
      duration: this.duration_,
      easing: ea
    });
  }
  /**
   * Handle dragger start events.
   * @param {PointerEvent} event The drag event.
   * @private
   */
  handleDraggerStart_(e) {
    if (!this.dragging_ && e.target === this.element.firstElementChild) {
      const t = (
        /** @type {HTMLElement} */
        this.element.firstElementChild
      );
      if (this.getMap().getView().beginInteraction(), this.startX_ = e.clientX - parseFloat(t.style.left), this.startY_ = e.clientY - parseFloat(t.style.top), this.dragging_ = !0, this.dragListenerKeys_.length === 0) {
        const r = this.handleDraggerDrag_, n = this.handleDraggerEnd_, s = this.getMap().getOwnerDocument();
        this.dragListenerKeys_.push(
          St(s, ka.POINTERMOVE, r, this),
          St(s, ka.POINTERUP, n, this)
        );
      }
    }
  }
  /**
   * Handle dragger drag events.
   *
   * @param {PointerEvent} event The drag event.
   * @private
   */
  handleDraggerDrag_(e) {
    if (this.dragging_) {
      const t = e.clientX - this.startX_, r = e.clientY - this.startY_, n = this.getRelativePosition_(t, r);
      this.currentResolution_ = this.getResolutionForPosition_(n), this.getMap().getView().setResolution(this.currentResolution_);
    }
  }
  /**
   * Handle dragger end events.
   * @param {PointerEvent} event The drag event.
   * @private
   */
  handleDraggerEnd_(e) {
    this.dragging_ && (this.getMap().getView().endInteraction(), this.dragging_ = !1, this.startX_ = void 0, this.startY_ = void 0, this.dragListenerKeys_.forEach(pr), this.dragListenerKeys_.length = 0);
  }
  /**
   * Positions the thumb inside its container according to the given resolution.
   *
   * @param {number} res The res.
   * @private
   */
  setThumbPosition_(e) {
    const t = this.getPositionForResolution_(e), r = (
      /** @type {HTMLElement} */
      this.element.firstElementChild
    );
    this.direction_ == Rf.HORIZONTAL ? r.style.left = this.widthLimit_ * t + "px" : r.style.top = this.heightLimit_ * t + "px";
  }
  /**
   * Calculates the relative position of the thumb given x and y offsets.  The
   * relative position scales from 0 to 1.  The x and y offsets are assumed to be
   * in pixel units within the dragger limits.
   *
   * @param {number} x Pixel position relative to the left of the slider.
   * @param {number} y Pixel position relative to the top of the slider.
   * @return {number} The relative position of the thumb.
   * @private
   */
  getRelativePosition_(e, t) {
    let r;
    return this.direction_ === Rf.HORIZONTAL ? r = e / this.widthLimit_ : r = t / this.heightLimit_, jr(r, 0, 1);
  }
  /**
   * Calculates the corresponding resolution of the thumb given its relative
   * position (where 0 is the minimum and 1 is the maximum).
   *
   * @param {number} position The relative position of the thumb.
   * @return {number} The corresponding resolution.
   * @private
   */
  getResolutionForPosition_(e) {
    return this.getMap().getView().getResolutionForValueFunction()(1 - e);
  }
  /**
   * Determines the relative position of the slider for the given resolution.  A
   * relative position of 0 corresponds to the minimum view resolution.  A
   * relative position of 1 corresponds to the maximum view resolution.
   *
   * @param {number} res The resolution.
   * @return {number} The relative position value (between 0 and 1).
   * @private
   */
  getPositionForResolution_(e) {
    const t = this.getMap().getView().getValueForResolutionFunction();
    return jr(1 - t(e), 0, 1);
  }
  /**
   * Update the zoomslider element.
   * @param {import("../MapEvent.js").default} mapEvent Map event.
   * @override
   */
  render(e) {
    if (!e.frameState || !this.sliderInitialized_ && !this.initSlider_())
      return;
    const t = e.frameState.viewState.resolution;
    this.currentResolution_ = t, this.setThumbPosition_(t);
  }
}
const Gj = Hj;
class $j extends hn {
  /**
   * @param {Options} [options] Options.
   */
  constructor(e) {
    e = e || {}, super({
      element: document.createElement("div"),
      target: e.target
    }), this.extent = e.extent ? e.extent : null;
    const t = e.className !== void 0 ? e.className : "ol-zoom-extent", r = e.label !== void 0 ? e.label : "E", n = e.tipLabel !== void 0 ? e.tipLabel : "Fit to extent", s = document.createElement("button");
    s.setAttribute("type", "button"), s.title = n, s.appendChild(
      typeof r == "string" ? document.createTextNode(r) : r
    ), s.addEventListener(
      ut.CLICK,
      this.handleClick_.bind(this),
      !1
    );
    const a = t + " " + Wa + " " + Sh, o = this.element;
    o.className = a, o.appendChild(s);
  }
  /**
   * @param {MouseEvent} event The event to handle
   * @private
   */
  handleClick_(e) {
    e.preventDefault(), this.handleZoomToExtent();
  }
  /**
   * @protected
   */
  handleZoomToExtent() {
    const t = this.getMap().getView(), r = this.extent ? this.extent : t.getProjection().getExtent();
    t.fitInternal(jA(r));
  }
}
const Vj = $j;
function cn(i, e, t) {
  const r = _t("map"), n = _t("controlBar", null), s = n != null ? n.value : r, { properties: a } = sr(e), o = cr(
    () => new i({
      ...a
    })
  );
  return o.value.set(
    "order",
    t.attrs.order == null ? 0 : t.attrs.order
  ), at(o, (A, l) => {
    s.removeControl && (s.removeControl(l), s.addControl(A), r.changed());
  }), tr(() => {
    if (s.addControl(o.value), s.controls_ != null) {
      const A = [...s.controls_];
      A.sort((l, h) => l.get("order") - h.get("order")), s.controls_ = [], A.forEach((l) => {
        s.addControl(l);
      }), s.changed();
    }
    r.changed();
  }), nr(() => {
    if (s.removeControl)
      s.removeControl(o.value);
    else {
      const A = s.controls_.findIndex((l) => l == o.value);
      s.controls_.splice(A, 1), o.value.dispose();
    }
    r.changed();
  }), {
    map: r,
    control: o
  };
}
const Kj = {
  name: "ol-fullscreen-control",
  setup(i, e) {
    const { control: t } = cn(Mj, i, e);
    return {
      control: t
    };
  },
  props: {
    className: {
      type: String,
      default: "ol-full-screen"
    },
    label: {
      type: String,
      default: ""
    },
    labelActive: {
      type: String,
      default: ""
    },
    activeClassName: {
      type: String,
      default: "ol-full-screen-true"
    },
    inactiveClassName: {
      type: String,
      default: "ol-full-screen-false"
    },
    tipLabel: {
      type: String,
      default: "Toggle full-screen"
    },
    keys: {
      type: Boolean,
      default: !1
    },
    target: {
      type: Object,
      default: void 0
    },
    source: {
      type: Object,
      default: void 0
    }
  }
};
function jj(i, e, t, r, n, s) {
  return ur("", !0);
}
const T2 = /* @__PURE__ */ qe(Kj, [["render", jj]]), zj = {
  name: "ol-mouseposition-control",
  setup(i, e) {
    const { control: t } = cn(Pj, i, e);
    return {
      control: t
    };
  },
  props: {
    className: {
      type: String,
      default: "ol-mouse-position"
    },
    coordinateFormat: {
      type: [String, Function]
    },
    projection: {
      type: String
    },
    render: {
      type: Function
    },
    target: {
      type: HTMLElement
    },
    undefinedHTML: {
      type: String,
      default: "&#160;"
    }
  }
};
function Xj(i, e, t, r, n, s) {
  return ur("", !0);
}
const F2 = /* @__PURE__ */ qe(zj, [["render", Xj]]), Wj = {
  name: "ol-attribution-control",
  setup(i, e) {
    const { control: t } = cn(rM, i, e);
    return {
      control: t
    };
  },
  props: {
    className: {
      type: String,
      default: "ol-attribution"
    },
    target: {
      type: HTMLElement
    },
    collapsible: {
      type: Boolean
    },
    collapsed: {
      type: Boolean,
      default: !0
    },
    tipLabel: {
      type: String,
      default: "Attributions"
    },
    label: {
      type: String,
      default: "i"
    },
    expandClassName: {
      type: String,
      default: "ol-attribution-expand"
    },
    collapseLabel: {
      type: String,
      default: ""
    },
    collapseClassName: {
      type: String,
      default: "ol-attribution-collapse"
    },
    render: {
      type: Function
    }
  }
};
function Yj(i, e, t, r, n, s) {
  return ur("", !0);
}
const L2 = /* @__PURE__ */ qe(Wj, [["render", Yj]]), qj = {
  name: "ol-overviewmap-control",
  setup(i, e) {
    const t = _t("map"), { control: r } = cn(Uj, i, e);
    return tr(() => {
      r.value.setMap(t);
    }), nr(() => {
      r.value.setMap(null);
    }), Ur("overviewMap", r), {
      control: r
    };
  },
  props: {
    className: {
      type: String,
      default: "ol-overviewmap"
    },
    collapsed: {
      type: Boolean,
      default: !0
    },
    collapseLabel: {
      type: String,
      default: ""
    },
    collapsible: {
      type: Boolean,
      default: !0
    },
    label: {
      type: String,
      default: ""
    },
    render: {
      type: Function
    },
    rotateWithView: {
      type: Boolean,
      default: !1
    },
    target: {
      type: HTMLElement
    },
    tipLabel: {
      type: String,
      default: "Overview map"
    }
  }
};
function Zj(i, e, t, r, n, s) {
  return xn(), Cn("div", null, [
    mr(i.$slots, "default")
  ]);
}
const I2 = /* @__PURE__ */ qe(qj, [["render", Zj]]), Jj = {
  name: "ol-scaleline-control",
  setup(i, e) {
    const { control: t } = cn(kj, i, e);
    return {
      control: t
    };
  },
  props: {
    className: {
      type: String,
      default: "ol-scale-line"
    },
    minWidth: {
      type: Number,
      default: 64
    },
    render: {
      type: Function
    },
    target: {
      type: HTMLElement
    },
    units: {
      type: String,
      default: "metric"
    },
    bar: {
      type: Boolean,
      default: !1
    },
    steps: {
      type: Number,
      default: 4
    },
    text: {
      type: Boolean,
      default: !1
    },
    dpi: {
      type: Number,
      default: void 0
    }
  }
};
function ez(i, e, t, r, n, s) {
  return ur("", !0);
}
const R2 = /* @__PURE__ */ qe(Jj, [["render", ez]]), tz = {
  name: "ol-zoom-control",
  setup(i, e) {
    const { control: t } = cn(nM, i, e);
    return {
      control: t
    };
  },
  props: {
    duration: {
      type: Number,
      default: 250
    },
    className: {
      type: String,
      default: "ol-zoom"
    },
    zoomInClassName: {
      type: String,
      default: "ol-zoom-in"
    },
    zoomOutClassName: {
      type: String,
      default: "ol-zoom-out"
    },
    zoomInLabel: {
      type: String,
      default: "+"
    },
    zoomOutLabel: {
      type: String,
      default: "-"
    },
    zoomInTipLabel: {
      type: String,
      default: "Zoom in"
    },
    zoomOutTipLabel: {
      type: String,
      default: "Zoom Out"
    },
    delta: {
      type: Number,
      default: 1
    },
    target: {
      type: HTMLElement
    }
  }
};
function rz(i, e, t, r, n, s) {
  return ur("", !0);
}
const M2 = /* @__PURE__ */ qe(tz, [["render", rz]]), iz = {
  name: "ol-zoomslider-control",
  setup(i, e) {
    const { control: t } = cn(Gj, i, e);
    return {
      control: t
    };
  },
  props: {
    duration: {
      type: Number,
      default: 200
    },
    className: {
      type: String,
      default: "ol-zoomslider"
    },
    render: {
      type: Function
    }
  }
};
function nz(i, e, t, r, n, s) {
  return ur("", !0);
}
const N2 = /* @__PURE__ */ qe(iz, [["render", nz]]), sz = {
  name: "ol-zoomtoextent-control",
  setup(i, e) {
    const { control: t } = cn(Vj, i, e);
    return {
      control: t
    };
  },
  props: {
    className: {
      type: String,
      default: "ol-zoom-extent"
    },
    target: {
      type: HTMLElement
    },
    label: {
      type: String,
      default: "E"
    },
    tipLabel: {
      type: String,
      default: "Fit to extent"
    },
    extent: {
      type: Array
    }
  }
};
function az(i, e, t, r, n, s) {
  return ur("", !0);
}
const P2 = /* @__PURE__ */ qe(sz, [["render", az]]), oz = {
  name: "ol-rotate-control",
  setup(i, e) {
    const { control: t } = cn(iM, i, e);
    return {
      control: t
    };
  },
  props: {
    className: {
      type: String,
      default: "ol-rotate"
    },
    label: {
      type: String,
      default: ""
    },
    tipLabel: {
      type: String,
      default: "Reset rotation"
    },
    compassClassName: {
      type: String,
      default: "ol-compass"
    },
    duration: {
      type: Number,
      default: 250
    },
    autoHide: {
      type: Boolean,
      default: !1
    },
    render: {
      type: Function
    },
    resetNorth: {
      type: Function
    },
    target: {
      type: HTMLElement
    }
  }
};
function Az(i, e, t, r, n, s) {
  return ur("", !0);
}
const P5 = /* @__PURE__ */ qe(oz, [["render", Az]]);
/*!
  * ol-contextmenu - v5.2.0
  * https://github.com/jonataswalker/ol-contextmenu
  * Built: Mon Mar 13 2023 13:25:53 GMT-0300 (Brasilia Standard Time)
  */
var lz = Object.defineProperty, hz = (i, e, t) => e in i ? lz(i, e, { enumerable: !0, configurable: !0, writable: !0, value: t }) : i[e] = t, Fs = (i, e, t) => (hz(i, typeof e != "symbol" ? e + "" : e, t), t);
let cz = class {
  /**
   * @param {string} type Type.
   */
  constructor(e) {
    this.propagationStopped, this.defaultPrevented, this.type = e, this.target = null;
  }
  /**
   * Prevent default. This means that no emulated `click`, `singleclick` or `doubleclick` events
   * will be fired.
   * @api
   */
  preventDefault() {
    this.defaultPrevented = !0;
  }
  /**
   * Stop event propagation.
   * @api
   */
  stopPropagation() {
    this.propagationStopped = !0;
  }
};
const oB = cz, uz = {
  /**
   * Triggered when a property is changed.
   * @event module:ol/Object.ObjectEvent#propertychange
   * @api
   */
  PROPERTYCHANGE: "propertychange"
};
let fz = class {
  constructor() {
    this.disposed = !1;
  }
  /**
   * Clean up.
   */
  dispose() {
    this.disposed || (this.disposed = !0, this.disposeInternal());
  }
  /**
   * Extension point for disposable objects.
   * @protected
   */
  disposeInternal() {
  }
};
const dz = fz;
function O2() {
}
function G4(i) {
  for (const e in i)
    delete i[e];
}
function gz(i) {
  let e;
  for (e in i)
    return !1;
  return !e;
}
let pz = class extends dz {
  /**
   * @param {*} [target] Default event target for dispatched events.
   */
  constructor(e) {
    super(), this.eventTarget_ = e, this.pendingRemovals_ = null, this.dispatching_ = null, this.listeners_ = null;
  }
  /**
   * @param {string} type Type.
   * @param {import("../events.js").Listener} listener Listener.
   */
  addEventListener(e, t) {
    if (!e || !t)
      return;
    const r = this.listeners_ || (this.listeners_ = {}), n = r[e] || (r[e] = []);
    n.includes(t) || n.push(t);
  }
  /**
   * Dispatches an event and calls all listeners listening for events
   * of this type. The event parameter can either be a string or an
   * Object with a `type` property.
   *
   * @param {import("./Event.js").default|string} event Event object.
   * @return {boolean|undefined} `false` if anyone called preventDefault on the
   *     event object or if any of the listeners returned false.
   * @api
   */
  dispatchEvent(e) {
    const t = typeof e == "string", r = t ? e : e.type, n = this.listeners_ && this.listeners_[r];
    if (!n)
      return;
    const s = t ? new oB(e) : (
      /** @type {Event} */
      e
    );
    s.target || (s.target = this.eventTarget_ || this);
    const a = this.dispatching_ || (this.dispatching_ = {}), o = this.pendingRemovals_ || (this.pendingRemovals_ = {});
    r in a || (a[r] = 0, o[r] = 0), ++a[r];
    let A;
    for (let l = 0, h = n.length; l < h; ++l)
      if ("handleEvent" in n[l] ? A = /** @type {import("../events.js").ListenerObject} */
      n[l].handleEvent(s) : A = /** @type {import("../events.js").ListenerFunction} */
      n[l].call(this, s), A === !1 || s.propagationStopped) {
        A = !1;
        break;
      }
    if (--a[r] === 0) {
      let l = o[r];
      for (delete o[r]; l--; )
        this.removeEventListener(r, O2);
      delete a[r];
    }
    return A;
  }
  /**
   * Clean up.
   */
  disposeInternal() {
    this.listeners_ && G4(this.listeners_);
  }
  /**
   * Get the listeners for a specified event type. Listeners are returned in the
   * order that they will be called in.
   *
   * @param {string} type Type.
   * @return {Array<import("../events.js").Listener>|undefined} Listeners.
   */
  getListeners(e) {
    return this.listeners_ && this.listeners_[e] || void 0;
  }
  /**
   * @param {string} [type] Type. If not provided,
   *     `true` will be returned if this event target has any listeners.
   * @return {boolean} Has listeners.
   */
  hasListener(e) {
    return this.listeners_ ? e ? e in this.listeners_ : Object.keys(this.listeners_).length > 0 : !1;
  }
  /**
   * @param {string} type Type.
   * @param {import("../events.js").Listener} listener Listener.
   */
  removeEventListener(e, t) {
    const r = this.listeners_ && this.listeners_[e];
    if (r) {
      const n = r.indexOf(t);
      n !== -1 && (this.pendingRemovals_ && e in this.pendingRemovals_ ? (r[n] = O2, ++this.pendingRemovals_[e]) : (r.splice(n, 1), r.length === 0 && delete this.listeners_[e]));
    }
  }
};
const mz = pz, vz = {
  /**
   * Generic change event. Triggered when the revision counter is increased.
   * @event module:ol/events/Event~BaseEvent#change
   * @api
   */
  CHANGE: "change",
  /**
   * Generic error event. Triggered when an error occurs.
   * @event module:ol/events/Event~BaseEvent#error
   * @api
   */
  ERROR: "error",
  BLUR: "blur",
  CLEAR: "clear",
  CONTEXTMENU: "contextmenu",
  CLICK: "click",
  DBLCLICK: "dblclick",
  DRAGENTER: "dragenter",
  DRAGOVER: "dragover",
  DROP: "drop",
  FOCUS: "focus",
  KEYDOWN: "keydown",
  KEYPRESS: "keypress",
  LOAD: "load",
  RESIZE: "resize",
  TOUCHMOVE: "touchmove",
  WHEEL: "wheel"
};
function Km(i, e, t, r, n) {
  if (r && r !== i && (t = t.bind(r)), n) {
    const a = t;
    t = function() {
      i.removeEventListener(e, t), a.apply(this, arguments);
    };
  }
  const s = {
    target: i,
    type: e,
    listener: t
  };
  return i.addEventListener(e, t), s;
}
function O5(i, e, t, r) {
  return Km(i, e, t, r, !0);
}
function U2(i) {
  i && i.target && (i.target.removeEventListener(i.type, i.listener), G4(i));
}
let yz = class extends mz {
  constructor() {
    super(), this.on = /** @type {ObservableOnSignature<import("./events").EventsKey>} */
    this.onInternal, this.once = /** @type {ObservableOnSignature<import("./events").EventsKey>} */
    this.onceInternal, this.un = /** @type {ObservableOnSignature<void>} */
    this.unInternal, this.revision_ = 0;
  }
  /**
   * Increases the revision counter and dispatches a 'change' event.
   * @api
   */
  changed() {
    ++this.revision_, this.dispatchEvent(vz.CHANGE);
  }
  /**
   * Get the version number for this object.  Each time the object is modified,
   * its version number will be incremented.
   * @return {number} Revision.
   * @api
   */
  getRevision() {
    return this.revision_;
  }
  /**
   * @param {string|Array<string>} type Type.
   * @param {function((Event|import("./events/Event").default)): ?} listener Listener.
   * @return {import("./events.js").EventsKey|Array<import("./events.js").EventsKey>} Event key.
   * @protected
   */
  onInternal(e, t) {
    if (Array.isArray(e)) {
      const r = e.length, n = new Array(r);
      for (let s = 0; s < r; ++s)
        n[s] = Km(this, e[s], t);
      return n;
    }
    return Km(
      this,
      /** @type {string} */
      e,
      t
    );
  }
  /**
   * @param {string|Array<string>} type Type.
   * @param {function((Event|import("./events/Event").default)): ?} listener Listener.
   * @return {import("./events.js").EventsKey|Array<import("./events.js").EventsKey>} Event key.
   * @protected
   */
  onceInternal(e, t) {
    let r;
    if (Array.isArray(e)) {
      const n = e.length;
      r = new Array(n);
      for (let s = 0; s < n; ++s)
        r[s] = O5(this, e[s], t);
    } else
      r = O5(
        this,
        /** @type {string} */
        e,
        t
      );
    return t.ol_key = r, r;
  }
  /**
   * Unlisten for a certain type of event.
   * @param {string|Array<string>} type Type.
   * @param {function((Event|import("./events/Event").default)): ?} listener Listener.
   * @protected
   */
  unInternal(e, t) {
    const r = (
      /** @type {Object} */
      t.ol_key
    );
    if (r)
      _z(r);
    else if (Array.isArray(e))
      for (let n = 0, s = e.length; n < s; ++n)
        this.removeEventListener(e[n], t);
    else
      this.removeEventListener(e, t);
  }
};
function _z(i) {
  if (Array.isArray(i))
    for (let e = 0, t = i.length; e < t; ++e)
      U2(i[e]);
  else
    U2(
      /** @type {import("./events.js").EventsKey} */
      i
    );
}
const wz = yz;
let xz = 0;
function Cz(i) {
  return i.ol_uid || (i.ol_uid = String(++xz));
}
let U5 = class extends oB {
  /**
   * @param {string} type The event type.
   * @param {string} key The property name.
   * @param {*} oldValue The old value for `key`.
   */
  constructor(e, t, r) {
    super(e), this.key = t, this.oldValue = r;
  }
}, Ez = class extends wz {
  /**
   * @param {Object<string, *>} [values] An object with key-value pairs.
   */
  constructor(e) {
    super(), this.on, this.once, this.un, Cz(this), this.values_ = null, e !== void 0 && this.setProperties(e);
  }
  /**
   * Gets a value.
   * @param {string} key Key name.
   * @return {*} Value.
   * @api
   */
  get(e) {
    let t;
    return this.values_ && this.values_.hasOwnProperty(e) && (t = this.values_[e]), t;
  }
  /**
   * Get a list of object property names.
   * @return {Array<string>} List of property names.
   * @api
   */
  getKeys() {
    return this.values_ && Object.keys(this.values_) || [];
  }
  /**
   * Get an object of all property names and values.
   * @return {Object<string, *>} Object.
   * @api
   */
  getProperties() {
    return this.values_ && Object.assign({}, this.values_) || {};
  }
  /**
   * @return {boolean} The object has properties.
   */
  hasProperties() {
    return !!this.values_;
  }
  /**
   * @param {string} key Key name.
   * @param {*} oldValue Old value.
   */
  notify(e, t) {
    let r;
    r = `change:${e}`, this.hasListener(r) && this.dispatchEvent(new U5(r, e, t)), r = uz.PROPERTYCHANGE, this.hasListener(r) && this.dispatchEvent(new U5(r, e, t));
  }
  /**
   * @param {string} key Key name.
   * @param {import("./events.js").Listener} listener Listener.
   */
  addChangeListener(e, t) {
    this.addEventListener(`change:${e}`, t);
  }
  /**
   * @param {string} key Key name.
   * @param {import("./events.js").Listener} listener Listener.
   */
  removeChangeListener(e, t) {
    this.removeEventListener(`change:${e}`, t);
  }
  /**
   * Sets a value.
   * @param {string} key Key name.
   * @param {*} value Value.
   * @param {boolean} [silent] Update without triggering an event.
   * @api
   */
  set(e, t, r) {
    const n = this.values_ || (this.values_ = {});
    if (r)
      n[e] = t;
    else {
      const s = n[e];
      n[e] = t, s !== t && this.notify(e, s);
    }
  }
  /**
   * Sets a collection of key-value pairs.  Note that this changes any existing
   * properties and adds new ones (it does not remove any existing properties).
   * @param {Object<string, *>} values Values.
   * @param {boolean} [silent] Update without triggering an event.
   * @api
   */
  setProperties(e, t) {
    for (const r in e)
      this.set(r, e[r], t);
  }
  /**
   * Apply any properties from another object without triggering events.
   * @param {BaseObject} source The source object.
   * @protected
   */
  applyProperties(e) {
    e.values_ && Object.assign(this.values_ || (this.values_ = {}), e.values_);
  }
  /**
   * Unsets a property.
   * @param {string} key Key name.
   * @param {boolean} [silent] Unset without triggering an event.
   * @api
   */
  unset(e, t) {
    if (this.values_ && e in this.values_) {
      const r = this.values_[e];
      delete this.values_[e], gz(this.values_) && (this.values_ = null), t || this.notify(e, r);
    }
  }
};
const Bz = Ez, bz = {
  /**
   * Triggered after a map frame is rendered.
   * @event module:ol/MapEvent~MapEvent#postrender
   * @api
   */
  POSTRENDER: "postrender",
  /**
   * Triggered when the map starts moving.
   * @event module:ol/MapEvent~MapEvent#movestart
   * @api
   */
  MOVESTART: "movestart",
  /**
   * Triggered after the map is moved.
   * @event module:ol/MapEvent~MapEvent#moveend
   * @api
   */
  MOVEEND: "moveend",
  /**
   * Triggered when loading of additional map data (tiles, images, features) starts.
   * @event module:ol/MapEvent~MapEvent#loadstart
   * @api
   */
  LOADSTART: "loadstart",
  /**
   * Triggered when loading of additional map data has completed.
   * @event module:ol/MapEvent~MapEvent#loadend
   * @api
   */
  LOADEND: "loadend"
};
function Q5(i) {
  return i && i.parentNode ? i.parentNode.removeChild(i) : null;
}
let Sz = class extends Bz {
  /**
   * @param {Options} options Control options.
   */
  constructor(e) {
    super();
    const t = e.element;
    t && !e.target && !t.style.pointerEvents && (t.style.pointerEvents = "auto"), this.element = t || null, this.target_ = null, this.map_ = null, this.listenerKeys = [], e.render && (this.render = e.render), e.target && this.setTarget(e.target);
  }
  /**
   * Clean up.
   */
  disposeInternal() {
    Q5(this.element), super.disposeInternal();
  }
  /**
   * Get the map associated with this control.
   * @return {import("../Map.js").default|null} Map.
   * @api
   */
  getMap() {
    return this.map_;
  }
  /**
   * Remove the control from its current map and attach it to the new map.
   * Pass `null` to just remove the control from the current map.
   * Subclasses may set up event handlers to get notified about changes to
   * the map here.
   * @param {import("../Map.js").default|null} map Map.
   * @api
   */
  setMap(e) {
    this.map_ && Q5(this.element);
    for (let t = 0, r = this.listenerKeys.length; t < r; ++t)
      U2(this.listenerKeys[t]);
    this.listenerKeys.length = 0, this.map_ = e, e && ((this.target_ ? this.target_ : e.getOverlayContainerStopEvent()).appendChild(this.element), this.render !== O2 && this.listenerKeys.push(
      Km(e, bz.POSTRENDER, this.render, this)
    ), e.render());
  }
  /**
   * Renders the control.
   * @param {import("../MapEvent.js").default} mapEvent Map event.
   * @api
   */
  render(e) {
  }
  /**
   * This function is used to set a target element for the control. It has no
   * effect if it is called after the control has been added to the map (i.e.
   * after `setMap` is called on the control). If no `target` is set in the
   * options passed to the control constructor and if `setTarget` is not called
   * then the control is added to the map's overlay container.
   * @param {HTMLElement|string} target Target.
   * @api
   */
  setTarget(e) {
    this.target_ = typeof e == "string" ? document.getElementById(e) : e;
  }
};
const Tz = Sz;
let Fz = class extends oB {
  /**
   * @param {string} type Event type.
   * @param {import("./Map.js").default} map Map.
   * @param {?import("./Map.js").FrameState} [frameState] Frame state.
   */
  constructor(e, t, r) {
    super(e), this.map = t, this.frameState = r !== void 0 ? r : null;
  }
};
const Lz = Fz;
let Iz = class extends Lz {
  /**
   * @param {string} type Event type.
   * @param {import("./Map.js").default} map Map.
   * @param {EVENT} originalEvent Original event.
   * @param {boolean} [dragging] Is the map currently being dragged?
   * @param {import("./Map.js").FrameState} [frameState] Frame state.
   * @param {Array<PointerEvent>} [activePointers] Active pointers.
   */
  constructor(e, t, r, n, s, a) {
    super(e, t, s), this.originalEvent = r, this.pixel_ = null, this.coordinate_ = null, this.dragging = n !== void 0 ? n : !1, this.activePointers = a;
  }
  /**
   * The map pixel relative to the viewport corresponding to the original event.
   * @type {import("./pixel.js").Pixel}
   * @api
   */
  get pixel() {
    return this.pixel_ || (this.pixel_ = this.map.getEventPixel(this.originalEvent)), this.pixel_;
  }
  set pixel(e) {
    this.pixel_ = e;
  }
  /**
   * The coordinate corresponding to the original browser event.  This will be in the user
   * projection if one is set.  Otherwise it will be in the view projection.
   * @type {import("./coordinate.js").Coordinate}
   * @api
   */
  get coordinate() {
    return this.coordinate_ || (this.coordinate_ = this.map.getCoordinateFromPixel(this.pixel)), this.coordinate_;
  }
  set coordinate(e) {
    this.coordinate_ = e;
  }
  /**
   * Prevents the default browser action.
   * See https://developer.mozilla.org/en-US/docs/Web/API/event.preventDefault.
   * @api
   */
  preventDefault() {
    super.preventDefault(), "preventDefault" in this.originalEvent && this.originalEvent.preventDefault();
  }
  /**
   * Prevents further propagation of the current event.
   * See https://developer.mozilla.org/en-US/docs/Web/API/event.stopPropagation.
   * @api
   */
  stopPropagation() {
    super.stopPropagation(), "stopPropagation" in this.originalEvent && this.originalEvent.stopPropagation();
  }
};
const Rz = Iz;
var AB = /* @__PURE__ */ ((i) => (i.CONTEXTMENU = "contextmenu", i.CLICK = "click", i.DBLCLICK = "dblclick", i))(AB || {}), VA = /* @__PURE__ */ ((i) => (i.BEFOREOPEN = "beforeopen", i.OPEN = "open", i.CLOSE = "close", i.ADD_MENU_ENTRY = "add-menu-entry", i))(VA || {});
let D5 = class extends Rz {
  constructor(e) {
    super(e.type, e.map, e.originalEvent);
  }
};
const Mz = {
  width: 150,
  scrollAt: 4,
  eventType: AB.CONTEXTMENU,
  defaultItems: !0,
  items: []
}, MA = "ol-ctx-menu", Fn = {
  namespace: MA,
  container: `${MA}-container`,
  separator: `${MA}-separator`,
  submenu: `${MA}-submenu`,
  hidden: `${MA}-hidden`,
  icon: `${MA}-icon`,
  zoomIn: `${MA}-zoom-in`,
  zoomOut: `${MA}-zoom-out`,
  unselectable: "ol-unselectable"
}, k5 = [
  {
    text: "Zoom In",
    classname: `${Fn.zoomIn} ${Fn.icon}`,
    callback: (i, e) => {
      const t = e.getView();
      t.animate({
        zoom: Number(t.getZoom()) + 1,
        duration: 700,
        center: i.coordinate
      });
    }
  },
  {
    text: "Zoom Out",
    classname: `${Fn.zoomOut} ${Fn.icon}`,
    callback: (i, e) => {
      const t = e.getView();
      t.animate({
        zoom: Number(t.getZoom()) - 1,
        duration: 700,
        center: i.coordinate
      });
    }
  }
];
var Q2 = {}, Nz = {
  get exports() {
    return Q2;
  },
  set exports(i) {
    Q2 = i;
  }
};
function lB() {
}
lB.prototype = {
  on: function(i, e, t) {
    var r = this.e || (this.e = {});
    return (r[i] || (r[i] = [])).push({
      fn: e,
      ctx: t
    }), this;
  },
  once: function(i, e, t) {
    var r = this;
    function n() {
      r.off(i, n), e.apply(t, arguments);
    }
    return n._ = e, this.on(i, n, t);
  },
  emit: function(i) {
    var e = [].slice.call(arguments, 1), t = ((this.e || (this.e = {}))[i] || []).slice(), r = 0, n = t.length;
    for (r; r < n; r++)
      t[r].fn.apply(t[r].ctx, e);
    return this;
  },
  off: function(i, e) {
    var t = this.e || (this.e = {}), r = t[i], n = [];
    if (r && e)
      for (var s = 0, a = r.length; s < a; s++)
        r[s].fn !== e && r[s].fn._ !== e && n.push(r[s]);
    return n.length ? t[i] = n : delete t[i], this;
  }
};
Nz.exports = lB;
var Pz = Q2.TinyEmitter = lB;
const jm = new Pz();
function zm(i) {
  const e = document.createDocumentFragment(), t = document.createElement("div");
  for (t.innerHTML = i; t.firstChild; )
    e.append(t.firstChild);
  return e;
}
function Oz(i) {
  var A, l;
  const e = document.importNode(i), t = i.offsetWidth;
  e.style.cssText = `position: fixed; top: 0; left: 0; overflow: auto; visibility: hidden; pointer-events: none; height: unset; max-height: unset; width: ${t}px`;
  const r = zm("<span>Foo</span>"), n = zm("<span>Foo</span>"), s = document.createElement("li"), a = document.createElement("li");
  s.append(r), a.append(n), e.append(s), e.append(a), (A = i.parentNode) == null || A.append(e);
  const o = e.offsetHeight / 2;
  return (l = i.parentNode) == null || l.removeChild(e), o;
}
function H5(i, e, t = !1, r = !1) {
  const n = `_${Math.random().toString(36).slice(2, 11)}`;
  if (typeof e != "string" && "text" in e) {
    const l = `<span>${e.text}</span>`, h = zm(l), c = document.createElement("li");
    e.classname = e.classname || "", e.icon && (e.classname === "" ? e.classname = Fn.icon : e.classname.includes(Fn.icon) === !1 && (e.classname += ` ${Fn.icon}`), c.setAttribute("style", `background-image:url(${e.icon})`)), c.id = n, c.className = e.classname, c.append(h), i.append(c);
    const u = {
      id: n,
      isSubmenu: t,
      isInsideSubmenu: r,
      isSeparator: !1,
      callback: "callback" in e ? e.callback : null,
      data: "data" in e ? e.data : null
    };
    return jm.emit(VA.ADD_MENU_ENTRY, u, c), c;
  }
  const s = `<li id="${n}" class="${Fn.separator}"><hr></li>`, a = zm(s);
  i.append(a);
  const o = i.lastChild, A = {
    id: n,
    isSubmenu: !1,
    isInsideSubmenu: !1,
    isSeparator: !0,
    callback: null,
    data: null
  };
  return jm.emit(VA.ADD_MENU_ENTRY, A, o), o;
}
function D2(i, e, t, r) {
  e.forEach((n) => {
    if (typeof n != "string" && "items" in n && Array.isArray(n.items)) {
      const s = H5(i, n, !0);
      s.classList.add(Fn.submenu);
      const a = document.createElement("ul");
      a.classList.add(Fn.container), a.style.width = `${t}px`, s.append(a), D2(a, n.items, t, !0);
    } else
      H5(i, n, !1, r);
  });
}
function J1(i, e) {
  if (!i)
    throw new Error(e);
}
let Uz = class extends Tz {
  constructor(e = {}) {
    J1(typeof e == "object", "@param `opts` should be object type!");
    const t = document.createElement("div");
    super({ element: t }), Fs(this, "map"), Fs(this, "container"), Fs(this, "coordinate", []), Fs(this, "pixel", []), Fs(this, "contextMenuEventListener"), Fs(this, "entryCallbackEventListener"), Fs(this, "mapMoveListener"), Fs(this, "lineHeight", 0), Fs(this, "disabled"), Fs(this, "opened"), Fs(this, "items", []), Fs(this, "menuEntries", /* @__PURE__ */ new Map()), Fs(this, "options"), this.options = { ...Mz, ...e };
    const r = document.createElement("ul");
    t.append(r), t.style.width = `${this.options.width}px`, t.classList.add(
      Fn.container,
      Fn.unselectable,
      Fn.hidden
    ), this.container = t, this.contextMenuEventListener = (n) => {
      this.handleContextMenu(n);
    }, this.entryCallbackEventListener = (n) => {
      this.handleEntryCallback(n);
    }, this.mapMoveListener = () => {
      this.handleMapMove();
    }, this.disabled = !1, this.opened = !1, window.addEventListener(
      "beforeunload",
      () => {
        this.removeListeners();
      },
      { once: !0 }
    );
  }
  clear() {
    for (const e of this.menuEntries.keys())
      this.removeMenuEntry(e);
    this.container.replaceChildren(), this.container.append(document.createElement("ul"));
  }
  enable() {
    this.disabled = !1;
  }
  disable() {
    this.disabled = !0;
  }
  getDefaultItems() {
    return k5;
  }
  countItems() {
    return this.menuEntries.size;
  }
  extend(e) {
    J1(Array.isArray(e), "@param `items` should be an Array."), D2(
      this.container.firstElementChild,
      e,
      this.options.width
    );
  }
  closeMenu() {
    this.opened = !1, this.container.classList.add(Fn.hidden), this.dispatchEvent(VA.CLOSE);
  }
  isOpen() {
    return this.opened;
  }
  updatePosition(e) {
    J1(Array.isArray(e), "@param `pixel` should be an Array."), this.isOpen() && (this.pixel = e, this.positionContainer());
  }
  pop() {
    const e = Array.from(this.menuEntries.keys()).pop();
    e && this.removeMenuEntry(e);
  }
  shift() {
    const e = Array.from(this.menuEntries.keys()).shift();
    e && this.removeMenuEntry(e);
  }
  push(e) {
    e && this.extend([e]);
  }
  setMap(e) {
    if (super.setMap(e), e) {
      this.map = e, this.map.getViewport().addEventListener(this.options.eventType, this.contextMenuEventListener, !1), this.map.on("movestart", () => {
        this.handleMapMove();
      }), jm.on(
        VA.ADD_MENU_ENTRY,
        (r, n) => {
          this.handleAddMenuEntry(r, n);
        },
        this
      ), this.items = this.options.defaultItems ? this.options.items.concat(k5) : this.options.items, D2(
        this.container.firstElementChild,
        this.items,
        this.options.width
      );
      const t = this.getMenuEntriesLength();
      this.lineHeight = t > 0 ? this.container.offsetHeight / t : Oz(this.container);
    } else
      this.removeListeners(), this.clear();
  }
  removeListeners() {
    this.map.getViewport().removeEventListener(this.options.eventType, this.contextMenuEventListener, !1), jm.off(VA.ADD_MENU_ENTRY);
  }
  removeMenuEntry(e) {
    const t = document.getElementById(e);
    t == null || t.remove(), t == null || t.removeEventListener("click", this.entryCallbackEventListener), this.menuEntries.delete(e);
  }
  handleContextMenu(e) {
    var t;
    this.coordinate = this.map.getEventCoordinate(e), this.pixel = this.map.getEventPixel(e), this.dispatchEvent(
      new D5({
        type: VA.BEFOREOPEN,
        map: this.map,
        originalEvent: e
      })
    ), !this.disabled && (this.options.eventType === AB.CONTEXTMENU && (e.stopPropagation(), e.preventDefault()), setTimeout(() => {
      this.openMenu(e);
    }), (t = e.target) == null || t.addEventListener(
      "pointerdown",
      (r) => {
        this.opened && (r.stopPropagation(), this.closeMenu());
      },
      { once: !0 }
    ));
  }
  openMenu(e) {
    this.opened = !0, this.positionContainer(), this.container.classList.remove(Fn.hidden), this.dispatchEvent(
      new D5({
        type: VA.OPEN,
        map: this.map,
        originalEvent: e
      })
    );
  }
  getMenuEntriesLength() {
    return Array.from(this.menuEntries).filter(
      ([, e]) => e.isSeparator === !1 && e.isSubmenu === !1 && e.isInsideSubmenu === !1
    ).length;
  }
  positionContainer() {
    const e = this.map.getSize() || [0, 0], t = {
      w: e[0] - this.pixel[0],
      h: e[1] - this.pixel[1]
    }, r = this.getMenuEntriesLength(), n = {
      w: this.container.offsetWidth,
      // a cheap way to recalculate container height
      // since offsetHeight is like cached
      h: Math.round(this.lineHeight * r)
    }, s = t.w >= n.w ? this.pixel[0] + 5 : this.pixel[0] - n.w;
    this.container.style.left = `${s}px`, this.container.style.top = t.h >= n.h ? `${this.pixel[1] - 10}px` : `${this.pixel[1] - n.h}px`, this.container.style.right = "auto", this.container.style.bottom = "auto", t.w -= n.w;
    const a = (l) => Array.from(l.children).filter(
      (h) => h.tagName === "LI" && h.classList.contains(Fn.submenu)
    );
    let o = 0;
    const A = (l, h) => {
      o += 1, a(l).forEach((c) => {
        const u = h >= n.w ? n.w - 8 : (n.w + 8) * -1, f = c.querySelector(
          `ul.${Fn.container}`
        ), g = Math.round(
          this.lineHeight * Array.from(f.children).filter((p) => p.tagName === "LI").length
        );
        f.style.left = `${u}px`, f.style.right = "auto", f.style.top = t.h >= g + n.h ? "0" : `-${f.offsetHeight - 25}px`, f.style.bottom = "auto", f.style.zIndex = String(o), a(f).length > 0 && A(f, h - n.w);
      });
    };
    A(this.container.firstElementChild, t.w);
  }
  handleMapMove() {
    this.closeMenu();
  }
  handleEntryCallback(e) {
    var s;
    e.preventDefault(), e.stopPropagation();
    const t = e.currentTarget, r = this.menuEntries.get(t.id);
    if (!r)
      return;
    const n = {
      coordinate: this.coordinate,
      data: r.data
    };
    this.closeMenu(), (s = r.callback) == null || s.call(r, n, this.map);
  }
  handleAddMenuEntry(e, t) {
    this.menuEntries.set(e.id, e), this.positionContainer(), "callback" in e && typeof e.callback == "function" && t.addEventListener("click", this.entryCallbackEventListener, !1);
  }
};
const Qz = {
  name: "ol-context-menu",
  setup(i, e) {
    const { control: t } = cn(Uz, i, e);
    return {
      control: t
    };
  },
  props: {
    eventType: {
      type: String,
      default: "contextmenu"
    },
    defaultItems: {
      type: Boolean,
      default: !0
    },
    width: {
      type: Number,
      default: 150
    },
    items: {
      type: Array,
      default: () => []
    }
  }
};
function Dz(i, e, t, r, n, s) {
  return ur("", !0);
}
const k2 = /* @__PURE__ */ qe(Qz, [["render", Dz]]);
var kz = class extends hn {
  constructor(e) {
    e = e || {};
    var t = document.createElement("div");
    super({
      element: t
    }), t.className = (e.className || "ol-swipe") + " ol-unselectable ol-control";
    var r = document.createElement("button");
    t.appendChild(r), t.addEventListener("mousedown", this.move.bind(this)), t.addEventListener("touchstart", this.move.bind(this)), this.precomposeRight_ = this.precomposeRight.bind(this), this.precomposeLeft_ = this.precomposeLeft.bind(this), this.postcompose_ = this.postcompose.bind(this), this.layers = [], e.layers && this.addLayer(e.layers, !1), e.rightLayers && this.addLayer(e.rightLayers, !0), this.on("propertychange", function(n) {
      if (this.getMap())
        try {
          this.getMap().renderSync();
        } catch {
        }
      this.get("orientation") === "horizontal" ? (this.element.style.top = this.get("position") * 100 + "%", this.element.style.left = "") : (this.get("orientation") !== "vertical" && this.set("orientation", "vertical"), this.element.style.left = this.get("position") * 100 + "%", this.element.style.top = ""), n.key === "orientation" && (this.element.classList.remove("horizontal", "vertical"), this.element.classList.add(this.get("orientation"))), this.isMoving || this.layers.forEach(function(s) {
        s.layer.getImageRatio && s.layer.changed();
      });
    }.bind(this)), this.set("position", e.position || 0.5), this.set("orientation", e.orientation || "vertical");
  }
  /**
   * Set the map instance the control associated with.
   * @param {_ol_Map_} map The map instance.
   */
  setMap(e) {
    var t, r;
    if (this.getMap()) {
      for (t = 0; t < this.layers.length; t++)
        r = this.layers[t], r.right ? r.layer.un(["precompose", "prerender"], this.precomposeRight_) : r.layer.un(["precompose", "prerender"], this.precomposeLeft_), r.layer.un(["postcompose", "postrender"], this.postcompose_);
      try {
        this.getMap().renderSync();
      } catch {
      }
    }
    if (super.setMap(e), e) {
      for (this._listener = [], t = 0; t < this.layers.length; t++)
        r = this.layers[t], r.right ? r.layer.on(["precompose", "prerender"], this.precomposeRight_) : r.layer.on(["precompose", "prerender"], this.precomposeLeft_), r.layer.on(["postcompose", "postrender"], this.postcompose_);
      try {
        e.renderSync();
      } catch {
      }
    }
  }
  /** @private
  */
  isLayer_(e) {
    for (var t = 0; t < this.layers.length; t++)
      if (this.layers[t].layer === e)
        return t;
    return -1;
  }
  /** Add a layer to clip
   *	@param {ol.layer|Array<ol.layer>} layer to clip
   *	@param {bool} add layer in the right part of the map, default left.
   */
  addLayer(e, t) {
    e instanceof Array || (e = [e]);
    for (var r = 0; r < e.length; r++) {
      var n = e[r];
      if (this.isLayer_(n) < 0 && (this.layers.push({ layer: n, right: t }), this.getMap())) {
        t ? n.on(["precompose", "prerender"], this.precomposeRight_) : n.on(["precompose", "prerender"], this.precomposeLeft_), n.on(["postcompose", "postrender"], this.postcompose_);
        try {
          this.getMap().renderSync();
        } catch {
        }
      }
    }
  }
  /** Remove all layers
   */
  removeLayers() {
    var e = [];
    this.layers.forEach(function(t) {
      e.push(t.layer);
    }), this.removeLayer(e);
  }
  /** Remove a layer to clip
   *	@param {ol.layer|Array<ol.layer>} layer to clip
   */
  removeLayer(e) {
    e instanceof Array || (e = [e]);
    for (var t = 0; t < e.length; t++) {
      var r = this.isLayer_(e[t]);
      r >= 0 && this.getMap() && (this.layers[r].right ? e[t].un(["precompose", "prerender"], this.precomposeRight_) : e[t].un(["precompose", "prerender"], this.precomposeLeft_), e[t].un(["postcompose", "postrender"], this.postcompose_), this.layers.splice(r, 1));
    }
    if (this.getMap())
      try {
        this.getMap().renderSync();
      } catch {
      }
  }
  /** Get visible rectangle
   * @returns {ol.extent}
   */
  getRectangle() {
    var e;
    return this.get("orientation") === "vertical" ? (e = this.getMap().getSize(), [0, 0, e[0] * this.get("position"), e[1]]) : (e = this.getMap().getSize(), [0, 0, e[0], e[1] * this.get("position")]);
  }
  /** @private
   */
  move(e) {
    var t = this, r;
    switch (this._movefn || (this._movefn = this.move.bind(this)), e.type) {
      case "touchcancel":
      case "touchend":
      case "mouseup": {
        t.isMoving = !1, ["mouseup", "mousemove", "touchend", "touchcancel", "touchmove"].forEach(function(A) {
          document.removeEventListener(A, t._movefn);
        }), this.layers.forEach(function(A) {
          A.layer.getImageRatio && A.layer.changed();
        });
        break;
      }
      case "mousedown":
      case "touchstart":
        t.isMoving = !0, ["mouseup", "mousemove", "touchend", "touchcancel", "touchmove"].forEach(function(A) {
          document.addEventListener(A, t._movefn);
        });
      case "mousemove":
      case "touchmove": {
        if (t.isMoving)
          if (t.get("orientation") === "vertical") {
            var n = e.pageX || e.touches && e.touches.length && e.touches[0].pageX || e.changedTouches && e.changedTouches.length && e.changedTouches[0].pageX;
            if (!n)
              break;
            n -= t.getMap().getTargetElement().getBoundingClientRect().left + window.pageXOffset - document.documentElement.clientLeft, r = t.getMap().getSize()[0];
            var s = r - Math.min(Math.max(0, r - n), r);
            r = s / r, t.set("position", r), t.dispatchEvent({ type: "moving", size: [s, t.getMap().getSize()[1]], position: [r, 0] });
          } else {
            var a = e.pageY || e.touches && e.touches.length && e.touches[0].pageY || e.changedTouches && e.changedTouches.length && e.changedTouches[0].pageY;
            if (!a)
              break;
            a -= t.getMap().getTargetElement().getBoundingClientRect().top + window.pageYOffset - document.documentElement.clientTop, r = t.getMap().getSize()[1];
            var o = r - Math.min(Math.max(0, r - a), r);
            r = o / r, t.set("position", r), t.dispatchEvent({ type: "moving", size: [t.getMap().getSize()[0], o], position: [0, r] });
          }
        break;
      }
    }
  }
  /** @private
   */
  _transformPt(e, t) {
    var r = e.inversePixelTransform, n = t[0], s = t[1];
    return t[0] = r[0] * n + r[2] * s + r[4], t[1] = r[1] * n + r[3] * s + r[5], t;
  }
  /** @private
   */
  _drawRect(e, t) {
    var r = e.inversePixelTransform;
    if (r) {
      var n = [
        [t[0][0], t[0][1]],
        [t[0][0], t[1][1]],
        [t[1][0], t[1][1]],
        [t[1][0], t[0][1]],
        [t[0][0], t[0][1]]
      ];
      if (e.context.save(), e.target.getImageRatio) {
        var s = -Math.atan2(e.frameState.pixelToCoordinateTransform[1], e.frameState.pixelToCoordinateTransform[0]);
        e.context.translate(e.frameState.size[0] / 2, e.frameState.size[1] / 2), e.context.rotate(s), e.context.translate(-e.frameState.size[0] / 2, -e.frameState.size[1] / 2);
      }
      n.forEach(function(o, A) {
        o = [
          o[0] * r[0] - o[1] * r[1] + r[4],
          -o[0] * r[2] + o[1] * r[3] + r[5]
        ], A ? e.context.lineTo(o[0], o[1]) : e.context.moveTo(o[0], o[1]);
      }), e.context.restore();
    } else {
      var a = e.frameState.pixelRatio;
      e.context.rect(t[0][0] * a, t[0][1] * a, t[1][0] * a, t[1][1] * a);
    }
  }
  /** @private
  */
  precomposeLeft(e) {
    var t = e.context;
    if (t instanceof WebGLRenderingContext) {
      if (e.type === "prerender") {
        t.clearColor(0, 0, 0, 0), t.clear(t.COLOR_BUFFER_BIT), t.enable(t.SCISSOR_TEST);
        var r = this.getMap().getSize(), n = this._transformPt(e, [0, r[1]]), s = this._transformPt(e, [r[0], 0]), a = s[0] - n[0], o = s[1] - n[1], A, l;
        this.get("orientation") === "vertical" ? (A = Math.round(a * this.get("position")), l = o) : (A = a, l = Math.round(o * this.get("position")), n[1] += o - l), t.scissor(n[0], n[1], A, l);
      }
    } else {
      var h = e.frameState.size;
      t.save(), t.beginPath();
      var c = [[0, 0], [h[0], h[1]]];
      this.get("orientation") === "vertical" ? c[1] = [
        h[0] * 0.5 + this.getMap().getSize()[0] * (this.get("position") - 0.5),
        h[1]
      ] : c[1] = [
        h[0],
        h[1] * 0.5 + this.getMap().getSize()[1] * (this.get("position") - 0.5)
      ], this._drawRect(e, c), t.clip();
    }
  }
  /** @private
  */
  precomposeRight(e) {
    var t = e.context;
    if (t instanceof WebGLRenderingContext) {
      if (e.type === "prerender") {
        t.clearColor(0, 0, 0, 0), t.clear(t.COLOR_BUFFER_BIT), t.enable(t.SCISSOR_TEST);
        var r = this.getMap().getSize(), n = this._transformPt(e, [0, r[1]]), s = this._transformPt(e, [r[0], 0]), a = s[0] - n[0], o = s[1] - n[1], A, l;
        this.get("orientation") === "vertical" ? (l = o, A = Math.round(a * (1 - this.get("position"))), n[0] += a - A) : (A = a, l = Math.round(o * (1 - this.get("position")))), t.scissor(n[0], n[1], A, l);
      }
    } else {
      var h = e.frameState.size;
      t.save(), t.beginPath();
      var c = [[0, 0], [h[0], h[1]]];
      this.get("orientation") === "vertical" ? c[0] = [
        h[0] * 0.5 + this.getMap().getSize()[0] * (this.get("position") - 0.5),
        0
      ] : c[0] = [
        0,
        h[1] * 0.5 + this.getMap().getSize()[1] * (this.get("position") - 0.5)
      ], this._drawRect(e, c), t.clip();
    }
  }
  /** @private
  */
  postcompose(e) {
    if (e.context instanceof WebGLRenderingContext) {
      if (e.type === "postrender") {
        var t = e.context;
        t.disable(t.SCISSOR_TEST);
      }
    } else
      e.target.getClassName && e.target.getClassName() !== "ol-layer" && e.target.get("declutter") ? setTimeout(function() {
        e.context.restore();
      }, 0) : e.context.restore();
  }
};
const Hz = {
  name: "ol-swipe-control",
  setup(i, e) {
    const { control: t } = cn(kz, i, e), { layerList: r } = uh(i);
    return r.value.forEach((n, s) => {
      t.value.addLayer(n, s == 1);
    }), {
      control: t
    };
  },
  props: {
    layerList: {
      type: Array
    },
    className: {
      type: String,
      default: "ol-swipe"
    },
    position: {
      type: Number,
      default: 0.5
    },
    orientation: {
      type: String,
      default: "vertical"
    }
  }
};
function Gz(i, e, t, r, n, s) {
  return ur("", !0);
}
const H2 = /* @__PURE__ */ qe(Hz, [["render", Gz]]);
var $z = class extends hn {
  constructor(e) {
    e = e || {};
    var t = document.createElement("DIV");
    if (t.classList.add("ol-unselectable", "ol-control", "ol-bar"), e.className) {
      var r = e.className.split(" ").filter(function(s) {
        return s.length > 0;
      });
      t.classList.add.apply(t.classList, r);
    }
    if (e.group && t.classList.add("ol-group"), super({
      element: t,
      target: e.target
    }), this.set("toggleOne", e.toggleOne), this.set("autoDeactivate", e.autoDeactivate), this.controls_ = [], e.controls instanceof Array)
      for (var n = 0; n < e.controls.length; n++)
        this.addControl(e.controls[n]);
  }
  /** Set the control visibility
   * @param {boolean} val
   */
  setVisible(e) {
    e ? this.element.style.display = "" : this.element.style.display = "none";
  }
  /** Get the control visibility
   * @return {boolean} b
   */
  getVisible() {
    return this.element.style.display != "none";
  }
  /**
   * Set the map instance the control is associated with
   * and add its controls associated to this map.
   * @param {ol_Map} map The map instance.
   */
  setMap(e) {
    super.setMap(e);
    for (var t = 0; t < this.controls_.length; t++) {
      var r = this.controls_[t];
      r.setMap(e);
    }
  }
  /** Get controls in the panel
   *	@param {Array<ol_control_Control>}
   */
  getControls() {
    return this.controls_;
  }
  /** Set tool bar position
   * @param {string} pos a combinaison of top|left|bottom|right separated with -
   */
  setPosition(e) {
    this.element.classList.remove("ol-left", "ol-top", "ol-bottom", "ol-right"), e = e.split("-");
    for (var t = 0; t < e.length; t++)
      switch (e[t]) {
        case "top":
        case "left":
        case "bottom":
        case "right":
          this.element.classList.add("ol-" + e[t]);
          break;
      }
  }
  /** Add a control to the bar
   *	@param {ol_control_Control} c control to add
   */
  addControl(e) {
    this.controls_.push(e), e.setTarget(this.element), this.getMap() && this.getMap().addControl(e), e.on("change:active", function(t) {
      this.onActivateControl_(t, e);
    }.bind(this)), e.getActive && this.onActivateControl_({ target: e, active: e.getActive() }, e);
  }
  /** Deativate all controls in a bar
   * @param {ol_control_Control} [except] a control
   */
  deactivateControls(e) {
    for (var t = 0; t < this.controls_.length; t++)
      this.controls_[t] !== e && this.controls_[t].setActive && this.controls_[t].setActive(!1);
  }
  /** Get active control in the bar
   * @returns {Array<ol_control_Control>}
   */
  getActiveControls() {
    for (var e = [], t = 0, r; r = this.controls_[t]; t++)
      r.getActive && r.getActive() && e.push(r);
    return e;
  }
  /** Auto activate/deactivate controls in the bar
   * @param {boolean} b activate/deactivate
   */
  setActive(e) {
    if (!e && this.get("autoDeactivate") && this.deactivateControls(), e)
      for (var t = this.getControls(), r = 0, n; n = t[r]; r++)
        n.get("autoActivate") && n.setActive(!0);
  }
  /** Post-process an activated/deactivated control
   *	@param {ol.event} e :an object with a target {_ol_control_} and active flag {bool}
   */
  onActivateControl_(e, t) {
    if (this.get("toggleOne")) {
      if (e.active) {
        var r;
        for (r = 0; r < this.controls_.length && this.controls_[r] !== t; r++)
          ;
        if (r == this.controls_.length)
          return;
        this.deactivateControls(this.controls_[r]);
      } else if (!this.getActiveControls().length) {
        for (var n = 0, s; s = this.controls_[n]; n++)
          if (s.get("autoActivate")) {
            s.setActive(!0);
            break;
          }
      }
    }
    e.type ? this.dispatchEvent({ type: "control:active", control: t, active: e.active }) : this.dispatchEvent({ type: "control:add", control: t, active: e.active });
  }
  /**
   * @param {string} name of the control to search
   * @return {ol.control.Control}
   */
  getControlsByName(e) {
    var t = this.getControls();
    return t.filter(
      function(r) {
        return r.get("name") === e;
      }
    );
  }
};
const Vz = {
  name: "ol-control-bar",
  setup(i, e) {
    const { control: t } = cn($z, i, e);
    return Ur("controlBar", t), {
      control: t
    };
  },
  props: {
    toggleOne: {
      type: Boolean,
      default: !0
    },
    group: {
      type: Boolean,
      default: !0
    }
  }
};
function Kz(i, e, t, r, n, s) {
  return mr(i.$slots, "default");
}
const G2 = /* @__PURE__ */ qe(Vz, [["render", Kz]]);
window.ol && ol.ext && !ol.ext.input && (ol.ext.input = {});
var jz = class extends ws {
  constructor(e) {
    e = e || {}, super();
    var t = this.input = e.input;
    t || (t = this.input = document.createElement("INPUT"), e.type && t.setAttribute("type", e.type), e.min !== void 0 && t.setAttribute("min", e.min), e.max !== void 0 && t.setAttribute("max", e.max), e.step !== void 0 && t.setAttribute("step", e.step), e.parent && e.parent.appendChild(t)), e.disabled && (t.disabled = !0), e.checked !== void 0 && (t.checked = !!e.checked), e.val !== void 0 && (t.value = e.val), e.hidden && (t.style.display = "none"), t.addEventListener("focus", function() {
      this.element && this.element.classList.add("ol-focus");
    }.bind(this));
    var r;
    t.addEventListener("focusout", function() {
      this.element && (r && clearTimeout(r), r = setTimeout(function() {
        this.element.classList.remove("ol-focus");
      }.bind(this), 0));
    }.bind(this));
  }
  /** Listen to drag event
   * @param {Element} elt
   * @param {function} cback when draggin on the element
   * @private
   */
  _listenDrag(e, t) {
    var r = function(n) {
      this.moving = !0, this.element.classList.add("ol-moving");
      var s = function(a) {
        a.type === "pointerup" && (document.removeEventListener("pointermove", s), document.removeEventListener("pointerup", s), document.removeEventListener("pointercancel", s), setTimeout(function() {
          this.moving = !1, this.element.classList.remove("ol-moving");
        }.bind(this))), a.target === e && t(a), a.stopPropagation(), a.preventDefault();
      }.bind(this);
      document.addEventListener("pointermove", s, !1), document.addEventListener("pointerup", s, !1), document.addEventListener("pointercancel", s, !1), n.stopPropagation(), n.preventDefault();
    }.bind(this);
    e.addEventListener("mousedown", r, !1), e.addEventListener("touchstart", r, !1);
  }
  /** Set the current value
   */
  setValue(e) {
    e !== void 0 && (this.input.value = e), this.input.dispatchEvent(new Event("change"));
  }
  /** Get the current getValue
   * @returns {string}
   */
  getValue() {
    return this.input.value;
  }
  /** Get the input element
   * @returns {Element}
   */
  getInputElement() {
    return this.input;
  }
}, hB = class extends jz {
  constructor(e) {
    e = e || {}, super(e);
    var t = this.element = document.createElement("LABEL");
    e.html instanceof Element ? t.appendChild(e.html) : e.html !== void 0 && (t.innerHTML = e.html), t.className = ("ol-ext-check ol-ext-checkbox " + (e.className || "")).trim(), this.input.parentNode && this.input.parentNode.insertBefore(t, this.input), t.appendChild(this.input), t.appendChild(document.createElement("SPAN")), e.after && t.appendChild(document.createTextNode(e.after)), this.input.addEventListener("change", function() {
      this.dispatchEvent({ type: "check", checked: this.input.checked, value: this.input.value });
    }.bind(this));
  }
  isChecked() {
    return this.input.checked;
  }
}, zz = class extends hB {
  constructor(e) {
    e = e || {}, super(e), this.element.className = ("ol-ext-toggle-switch " + (e.className || "")).trim();
  }
}, Xz = class extends hB {
  constructor(e) {
    e = e || {}, super(e), this.element.className = ("ol-ext-check ol-ext-radio " + (e.className || "")).trim();
  }
}, ae = {};
ae.create = function(i, e) {
  e = e || {};
  var t;
  if (i === "TEXT")
    t = document.createTextNode(e.html || ""), e.parent && e.parent.appendChild(t);
  else {
    t = document.createElement(i), /button/i.test(i) && t.setAttribute("type", "button");
    for (var r in e)
      switch (r) {
        case "className": {
          e.className && e.className.trim && t.setAttribute("class", e.className.trim());
          break;
        }
        case "text": {
          t.innerText = e.text;
          break;
        }
        case "html": {
          e.html instanceof Element ? t.appendChild(e.html) : e.html !== void 0 && (t.innerHTML = e.html);
          break;
        }
        case "parent": {
          e.parent && e.parent.appendChild(t);
          break;
        }
        case "options": {
          if (/select/i.test(i))
            for (var n in e.options)
              ae.create("OPTION", {
                html: n,
                value: e.options[n],
                parent: t
              });
          break;
        }
        case "style": {
          ae.setStyle(t, e.style);
          break;
        }
        case "change":
        case "click": {
          ae.addListener(t, r, e[r]);
          break;
        }
        case "on": {
          for (var s in e.on)
            ae.addListener(t, s, e.on[s]);
          break;
        }
        case "checked": {
          t.checked = !!e.checked;
          break;
        }
        default: {
          t.setAttribute(r, e[r]);
          break;
        }
      }
  }
  return t;
};
ae.createSwitch = function(i) {
  var e = ae.create("INPUT", {
    type: "checkbox",
    on: i.on,
    click: i.click,
    change: i.change,
    parent: i.parent
  }), t = Object.assign({ input: e }, i || {});
  return new zz(t), e;
};
ae.createCheck = function(i) {
  var e = ae.create("INPUT", {
    name: i.name,
    type: i.type === "radio" ? "radio" : "checkbox",
    on: i.on,
    parent: i.parent
  }), t = Object.assign({ input: e }, i || {});
  return i.type === "radio" ? new Xz(t) : new hB(t), e;
};
ae.setHTML = function(i, e) {
  e instanceof Element ? i.appendChild(e) : e !== void 0 && (i.innerHTML = e);
};
ae.appendText = function(i, e) {
  i.appendChild(document.createTextNode(e || ""));
};
ae.addListener = function(i, e, t, r) {
  typeof e == "string" && (e = e.split(" ")), e.forEach(function(n) {
    i.addEventListener(n, t, r);
  });
};
ae.removeListener = function(i, e, t) {
  typeof e == "string" && (e = e.split(" ")), e.forEach(function(r) {
    i.removeEventListener(r, t);
  });
};
ae.show = function(i) {
  i.style.display = "";
};
ae.hide = function(i) {
  i.style.display = "none";
};
ae.hidden = function(i) {
  return ae.getStyle(i, "display") === "none";
};
ae.toggle = function(i) {
  i.style.display = i.style.display === "none" ? "" : "none";
};
ae.setStyle = function(i, e) {
  for (var t in e)
    switch (t) {
      case "top":
      case "left":
      case "bottom":
      case "right":
      case "minWidth":
      case "maxWidth":
      case "width":
      case "height": {
        typeof e[t] == "number" ? i.style[t] = e[t] + "px" : i.style[t] = e[t];
        break;
      }
      default:
        i.style[t] = e[t];
    }
};
ae.getStyle = function(i, e) {
  var t, r = (i.ownerDocument || document).defaultView;
  if (r && r.getComputedStyle)
    e = e.replace(/([A-Z])/g, "-$1").toLowerCase(), t = r.getComputedStyle(i, null).getPropertyValue(e);
  else if (i.currentStyle && (e = e.replace(/-(\w)/g, function(n, s) {
    return s.toUpperCase();
  }), t = i.currentStyle[e], /^\d+(em|pt|%|ex)?$/i.test(t)))
    return function(n) {
      var s = i.style.left, a = i.runtimeStyle.left;
      return i.runtimeStyle.left = i.currentStyle.left, i.style.left = n || 0, n = i.style.pixelLeft + "px", i.style.left = s, i.runtimeStyle.left = a, n;
    }(t);
  return /px$/.test(t) ? parseInt(t) : t;
};
ae.outerHeight = function(i) {
  return i.offsetHeight + ae.getStyle(i, "marginBottom");
};
ae.outerWidth = function(i) {
  return i.offsetWidth + ae.getStyle(i, "marginLeft");
};
ae.offsetRect = function(i) {
  var e = i.getBoundingClientRect();
  return {
    top: e.top + (window.pageYOffset || document.documentElement.scrollTop || document.body.scrollTop || 0),
    left: e.left + (window.pageXOffset || document.documentElement.scrollLeft || document.body.scrollLeft || 0),
    height: e.height || e.bottom - e.top,
    width: e.width || e.right - e.left
  };
};
ae.getFixedOffset = function(i) {
  var e = {
    left: 0,
    top: 0
  }, t = function(r) {
    if (!r)
      return e;
    if (ae.getStyle(r, "position") === "absolute" && ae.getStyle(r, "transform") !== "none") {
      var n = r.getBoundingClientRect();
      return e.left += n.left, e.top += n.top, e;
    }
    return t(r.offsetParent);
  };
  return t(i.offsetParent);
};
ae.positionRect = function(i, e) {
  var t = 0, r = 0, n = function(s) {
    if (s)
      return t += s.offsetLeft, r += s.offsetTop, n(s.offsetParent);
    var a = {
      top: i.offsetTop + r,
      left: i.offsetLeft + t
    };
    return e && (a.top -= window.pageYOffset || document.documentElement.scrollTop || document.body.scrollTop || 0, a.left -= window.pageXOffset || document.documentElement.scrollLeft || document.body.scrollLeft || 0), a.bottom = a.top + i.offsetHeight, a.right = a.top + i.offsetWidth, a;
  };
  return n(i.offsetParent);
};
ae.scrollDiv = function(i, e) {
  e = e || {};
  var t = !1, r = 0, n, s = 0, a = typeof e.onmove == "function" ? e.onmove : function() {
  }, o = e.vertical ? "screenY" : "screenX", A = e.vertical ? "scrollTop" : "scrollLeft", l = !1, h, c, u = 0, f = function() {
    C && (u++, setTimeout(g));
  }, g = function() {
    if (C) {
      if (u--, u)
        return;
      var T = i.clientHeight, F = i.scrollHeight;
      h = T / F, C.style.height = h * 100 + "%", C.style.top = i.scrollTop / F * 100 + "%", w.style.height = T + "px", T > F - 0.5 ? w.classList.add("ol-100pc") : w.classList.remove("ol-100pc");
    }
  }, p = function(T) {
    T.target.classList.contains("ol-noscroll") || (l = !1, t = T[o], s = /* @__PURE__ */ new Date(), i.classList.add("ol-move"), T.preventDefault(), window.addEventListener("pointermove", y), ae.addListener(window, ["pointerup", "pointercancel"], S));
  }, y = function(T) {
    if (t !== !1) {
      var F = (c ? -1 / h : 1) * (t - T[o]);
      l = l || Math.round(F), i[A] += F, n = /* @__PURE__ */ new Date(), n - s && (r = (r + F / (n - s)) / 2), t = T[o], s = n, F && a(!0);
    } else
      l = !0;
  }, v = function(T) {
    var F = T > 0 ? Math.min(100, T / 2) : Math.max(-100, T / 2);
    T -= F, i[A] += F, -1 < T && T < 1 ? (l ? setTimeout(function() {
      i.classList.remove("ol-move");
    }) : i.classList.remove("ol-move"), l = !1, a(!1)) : setTimeout(function() {
      v(T);
    }, 40);
  }, w, C;
  if (e.vertical && e.minibar) {
    var E = function(T) {
      i.removeEventListener("pointermove", E), i.parentNode.classList.add("ol-miniscroll"), C = ae.create("DIV"), w = ae.create("DIV", {
        className: "ol-scroll",
        html: C
      }), i.parentNode.insertBefore(w, i), C.addEventListener("pointerdown", function(F) {
        c = !0, p(F);
      }), e.mousewheel && (ae.addListener(
        w,
        ["mousewheel", "DOMMouseScroll", "onmousewheel"],
        function(F) {
          M(F);
        }
      ), ae.addListener(
        C,
        ["mousewheel", "DOMMouseScroll", "onmousewheel"],
        function(F) {
          M(F);
        }
      )), i.parentNode.addEventListener("pointerenter", f), window.addEventListener("resize", f), T !== !1 && f();
    };
    i.parentNode ? E(!1) : i.addEventListener("pointermove", E), i.addEventListener("scroll", function() {
      f();
    });
  }
  i.style["touch-action"] = "none", i.style.overflow = "hidden", i.classList.add("ol-scrolldiv"), ae.addListener(i, ["pointerdown"], function(T) {
    c = !1, p(T);
  }), i.addEventListener("click", function(T) {
    i.classList.contains("ol-move") && (T.preventDefault(), T.stopPropagation());
  }, !0);
  var S = function(T) {
    s = /* @__PURE__ */ new Date() - s, s > 100 || c ? r = 0 : s > 0 && (r = ((r || 0) + (t - T[o]) / s) / 2), v(e.animate === !1 ? 0 : r * 200), t = !1, r = 0, s = 0, i.classList.contains("ol-move") ? i.classList.remove("ol-hasClick") : (i.classList.add("ol-hasClick"), setTimeout(function() {
      i.classList.remove("ol-hasClick");
    }, 500)), c = !1, window.removeEventListener("pointermove", y), ae.removeListener(window, ["pointerup", "pointercancel"], S);
  }, M = function(T) {
    var F = Math.max(-1, Math.min(1, T.wheelDelta || -T.detail));
    return i.classList.add("ol-move"), i[A] -= F * 30, i.classList.remove("ol-move"), !1;
  };
  return e.mousewheel && ae.addListener(
    i,
    ["mousewheel", "DOMMouseScroll", "onmousewheel"],
    M
  ), {
    refresh: f
  };
};
ae.dispatchEvent = function(i, e) {
  var t;
  try {
    t = new CustomEvent(i);
  } catch {
    t = document.createEvent("CustomEvent"), t.initCustomEvent(i, !0, !0, {});
  }
  e.dispatchEvent(t);
};
var $4 = class extends hn {
  constructor(e) {
    e = e || {};
    var t = document.createElement("div");
    t.className = (e.className || "") + " ol-button ol-unselectable ol-control", super({
      element: t,
      target: e.target
    });
    var r = this, n = this.button_ = document.createElement(/ol-text-button/.test(e.className) ? "div" : "button");
    n.type = "button", e.title && (n.title = e.title), e.name && (n.name = e.name), e.html instanceof Element ? n.appendChild(e.html) : n.innerHTML = e.html || "";
    var s = function(a) {
      a && a.preventDefault && (a.preventDefault(), a.stopPropagation()), e.handleClick && e.handleClick.call(r, a);
    };
    n.addEventListener("click", s), t.appendChild(n), !e.title && n.firstElementChild && (n.title = n.firstElementChild.title), e.title && this.set("title", e.title), e.title && this.set("title", e.title), e.name && this.set("name", e.name);
  }
  /** Set the control visibility
  * @param {boolean} b
  */
  setVisible(e) {
    e ? ae.show(this.element) : ae.hide(this.element);
  }
  /**
   * Set the button title
   * @param {string} title
   */
  setTitle(e) {
    this.button_.setAttribute("title", e);
  }
  /**
   * Set the button html
   * @param {string} html
   */
  setHtml(e) {
    ae.setHTML(this.button_, e);
  }
  /**
   * Get the button element
   * @returns {Element}
   */
  getButtonElement() {
    return this.button_;
  }
}, Wz = class extends $4 {
  constructor(e) {
    e = e || {}, e.toggleFn && (e.onToggle = e.toggleFn), e.handleClick = function() {
      t.toggle(), e.onToggle && e.onToggle.call(t, t.getActive());
    }, e.className = (e.className || "") + " ol-toggle", super(e);
    var t = this;
    this.interaction_ = e.interaction, this.interaction_ && (this.interaction_.setActive(e.active), this.interaction_.on("change:active", function() {
      t.setActive(t.interaction_.getActive());
    })), this.set("title", e.title), this.set("autoActivate", e.autoActivate), e.bar && this.setSubBar(e.bar), this.setActive(e.active), this.setDisable(e.disable);
  }
  /**
   * Set the map instance the control is associated with
   * and add interaction attached to it to this map.
   * @param {_ol_Map_} map The map instance.
   */
  setMap(e) {
    !e && this.getMap() && (this.interaction_ && this.getMap().removeInteraction(this.interaction_), this.subbar_ && this.getMap().removeControl(this.subbar_)), super.setMap(e), e && (this.interaction_ && e.addInteraction(this.interaction_), this.subbar_ && e.addControl(this.subbar_));
  }
  /** Get the subbar associated with a control
   * @return {ol_control_Bar}
   */
  getSubBar() {
    return this.subbar_;
  }
  /** Set the subbar associated with a control
   * @param {ol_control_Bar} [bar] a subbar if none remove the current subbar
   */
  setSubBar(e) {
    var t = this.getMap();
    t && this.subbar_ && t.removeControl(this.subbar_), this.subbar_ = e, e && (this.subbar_.setTarget(this.element), this.subbar_.element.classList.add("ol-option-bar"), t && t.addControl(this.subbar_));
  }
  /**
   * Test if the control is disabled.
   * @return {bool}.
   * @api stable
   */
  getDisable() {
    var e = this.element.querySelector("button");
    return e && e.disabled;
  }
  /** Disable the control. If disable, the control will be deactivated too.
  * @param {bool} b disable (or enable) the control, default false (enable)
  */
  setDisable(e) {
    this.getDisable() != e && (this.element.querySelector("button").disabled = e, e && this.getActive() && this.setActive(!1), this.dispatchEvent({ type: "change:disable", key: "disable", oldValue: !e, disable: e }));
  }
  /**
   * Test if the control is active.
   * @return {bool}.
   * @api stable
   */
  getActive() {
    return this.element.classList.contains("ol-active");
  }
  /** Toggle control state active/deactive
   */
  toggle() {
    this.getActive() ? this.setActive(!1) : this.setActive(!0);
  }
  /** Change control state
   * @param {bool} b activate or deactivate the control, default false
   */
  setActive(e) {
    this.interaction_ && this.interaction_.setActive(e), this.subbar_ && this.subbar_.setActive(e), this.getActive() !== e && (e ? this.element.classList.add("ol-active") : this.element.classList.remove("ol-active"), this.dispatchEvent({ type: "change:active", key: "active", oldValue: !e, active: e }));
  }
  /** Set the control interaction
  * @param {_ol_interaction_} i interaction to associate with the control
  */
  setInteraction(e) {
    this.interaction_ = e;
  }
  /** Get the control interaction
  * @return {_ol_interaction_} interaction associated with the control
  */
  getInteraction() {
    return this.interaction_;
  }
};
const Yz = {
  name: "ol-control-toggle",
  setup(i, e) {
    const { control: t } = cn(Wz, i, e);
    return {
      control: t
    };
  },
  props: {
    html: {
      type: String
    },
    interaction: {
      type: Object
    },
    className: {
      type: String
    },
    title: {
      type: String
    },
    onToggle: {
      type: Function
    }
  }
};
function qz(i, e, t, r, n, s) {
  return ur("", !0);
}
const $2 = /* @__PURE__ */ qe(Yz, [["render", qz]]), Zz = {
  name: "ol-control-button",
  setup(i, e) {
    const { control: t } = cn($4, i, e);
    return {
      control: t
    };
  },
  props: {
    html: {
      type: String
    },
    name: {
      type: String
    },
    className: {
      type: String
    },
    title: {
      type: String
    },
    handleClick: {
      type: Function
    }
  }
};
function Jz(i, e, t, r, n, s) {
  return ur("", !0);
}
const V2 = /* @__PURE__ */ qe(Zz, [["render", Jz]]);
var V4 = class extends hn {
  constructor(e) {
    e = e || {}, e.fullscreen && (e.target = document.body);
    var t = ae.create("DIV", {
      className: ((e.className || "") + (e.zoom ? " ol-zoom" : "") + " ol-ext-dialog").trim()
    });
    super({
      element: t,
      target: e.target
    }), t.addEventListener("click", function(s) {
      this.get("hideOnBack") && s.target === t && this.close(), this.get("hideOnClick") && this.close();
    }.bind(this));
    var r = ae.create("FORM", {
      on: {
        submit: this._onButton("submit")
      },
      parent: t
    });
    ae.create("H2", {
      parent: r
    }), ae.create("DIV", {
      className: "ol-closebox",
      click: this._onButton("cancel"),
      parent: r
    }), ae.create("DIV", {
      className: "ol-content",
      parent: r
    }), this._progress = ae.create("DIV", {
      style: { display: "none" },
      parent: r
    });
    var n = ae.create("DIV", {
      className: "ol-progress-bar",
      parent: this._progress
    });
    this._progressbar = ae.create("DIV", {
      parent: n
    }), this._progressMessage = ae.create("DIV", {
      className: "ol-progress-message",
      parent: this._progress
    }), ae.create("DIV", {
      className: "ol-buttons",
      parent: r
    }), this.set("closeBox", e.closeBox !== !1), this.set("zoom", !!e.zoom), this.set("hideOnClick", !!e.hideOnClick), this.set("hideOnBack", !!e.hideOnBack), this.set("className", t.className), this.set("closeOnSubmit", e.closeOnSubmit), this.set("buttons", e.buttons), this.setContent(e);
  }
  /** Show a new dialog
   * @param { * | Element | string } options options or a content to show
   *  @param {Element | String} options.content dialog content
   *  @param {string} options.title title of the dialog
   *  @param {string} options.className dialog class name
   *  @param {number} options.autoclose a delay in ms before auto close
   *  @param {boolean} options.hideOnBack close dialog when click the background
   *  @param {number} options.max if not null add a progress bar to the dialog
   *  @param {number} options.progress set the progress bar value
   *  @param {Object} options.buttons a key/value list of button to show
   *  @param {function} [options.onButton] a function that takes the button id and a list of input by className
   */
  show(e) {
    e && ((e instanceof Element || typeof e == "string") && (e = { content: e }), this.setContent(e)), this.element.classList.add("ol-visible");
    var t = this.element.querySelector('input[type="text"],input[type="search"],input[type="number"]');
    if (t && t.focus(), this.dispatchEvent({ type: "show" }), e) {
      if (e.autoclose) {
        var r = setTimeout(function() {
          this.hide();
        }.bind(this), e.autoclose);
        this.once("hide", function() {
          clearTimeout(r);
        });
      }
      if (e.hideOnBack) {
        var n = this.get("hideOnBack");
        this.set("hideOnBack", !0), this.once("hide", function() {
          this.set("hideOnBack", n);
        }.bind(this));
      }
    }
  }
  /** Open the dialog
   */
  open() {
    this.show();
  }
  /** Set the dialog content
   * @param {Element | String} content dialog content
   */
  setContentMessage(e) {
    if (e !== void 0) {
      var t = this.getContentElement();
      e instanceof Element && ae.setHTML(t, ""), ae.setHTML(t, e || "");
    }
  }
  /** Set the dialog title
   * @param {Element | String} content dialog content
   */
  setTitle(e) {
    var t = this.element.querySelector("form");
    t.querySelector("h2").innerText = e || "", e ? t.classList.add("ol-title") : t.classList.remove("ol-title");
  }
  /** Set the dialog content
   * @param {*} options
   *  @param {Element | String} options.content dialog content
   *  @param {string} options.title title of the dialog
   *  @param {string} options.className dialog class name
   *  @param {number} options.max if not null add a progress bar to the dialog
   *  @param {number} options.progress set the progress bar value
   *  @param {Object} options.buttons a key/value list of button to show
   *  @param {function} [options.onButton] a function that takes the button id and a list of input by className
   */
  setContent(e) {
    if (e) {
      this.element.className = this.get("className"), typeof e == "string" && (e = { content: e }), e = e || {}, this.setProgress(!1), e.max && this.setProgress(0, e.max), e.progress !== void 0 && this.setProgress(e.progress), this.get("zoom") ? this.element.classList.add("ol-zoom") : this.element.classList.remove("ol-zoom"), e.className && e.className.split(" ").forEach(function(a) {
        this.element.classList.add(a);
      }.bind(this));
      var t = this.element.querySelector("form");
      e.content !== void 0 && (e.content instanceof Element && ae.setHTML(t.querySelector(".ol-content"), ""), ae.setHTML(t.querySelector(".ol-content"), e.content || "")), this.setTitle(e.title), e.closeBox || this.get("closeBox") && e.closeBox !== !1 ? t.classList.add("ol-closebox") : t.classList.remove("ol-closebox");
      var r = this.element.querySelector(".ol-buttons");
      r.innerHTML = "";
      var n = e.buttons || this.get("buttons");
      if (n) {
        t.classList.add("ol-button");
        for (var s in n)
          ae.create("INPUT", {
            type: s === "submit" ? "submit" : "button",
            value: n[s],
            click: this._onButton(s, e.onButton),
            parent: r
          });
      } else
        t.classList.remove("ol-button");
    }
  }
  /** Get dialog content element
   * @returns {Element}
   */
  getContentElement() {
    return this.element.querySelector("form .ol-content");
  }
  /** Set progress
   * @param {number|boolean} val the progress value or false to hide the progressBar
   * @param {number} max
   * @param {string|element} message
   */
  setProgress(e, t, r) {
    if (e === !1) {
      ae.setStyle(this._progress, { display: "none" });
      return;
    }
    if (t > 0 ? this.set("max", Number(t)) : t = this.get("max"), !t)
      ae.setStyle(this._progress, { display: "none" });
    else {
      var n = Math.round(e / t * 100);
      ae.setStyle(this._progress, { display: "" }), this._progressbar.className = n ? "" : "notransition", ae.setStyle(this._progressbar, { width: n + "%" });
    }
    this._progressMessage.innerHTML = "", ae.setHTML(this._progressMessage, r || "");
  }
  /** Returns a function to do something on button click
   * @param {strnig} button button id
   * @param {function} callback
   * @returns {function}
   * @private
   */
  _onButton(e, t) {
    var r = function(n) {
      n.preventDefault(), (e !== "submit" || this.get("closeOnSubmit") !== !1) && this.hide();
      var s = this.getInputs();
      this.dispatchEvent({ type: "button", button: e, inputs: s }), typeof t == "function" && t(e, s);
    }.bind(this);
    return r;
  }
  /** Get inputs, textarea an select of the dialog by classname
   * @return {Object} a {key:value} list of Elements by classname
   */
  getInputs() {
    var e = {};
    return ["input", "textarea", "select"].forEach(function(t) {
      this.element.querySelectorAll("form " + t).forEach(function(r) {
        r.className && r.className.split(" ").forEach(function(n) {
          e[n] = r;
        });
      });
    }.bind(this)), e;
  }
  /** Close the dialog
   */
  hide() {
    this.element.classList.remove("ol-visible"), this.dispatchEvent({ type: "hide" });
  }
  /** Close the dialog 
   */
  close() {
    this.hide();
  }
  /** The dialog is shown
   * @return {bool} true if a dialog is open
   */
  isOpen() {
    return this.element.classList.contains("ol-visible");
  }
}, eX = function(i) {
  if (!i)
    return null;
  var e = i.getViewport().getElementsByClassName("ol-fixedoverlay")[0];
  return e || (i.getViewport().querySelector(".ol-layers") ? (e = document.createElement("canvas"), e.className = "ol-fixedoverlay", i.getViewport().querySelector(".ol-layers").after(e), i.on("precompose", function(t) {
    e.width = i.getSize()[0] * t.frameState.pixelRatio, e.height = i.getSize()[1] * t.frameState.pixelRatio;
  })) : e = i.getViewport().querySelector("canvas")), e;
}, cB = class extends hn {
  constructor(e) {
    e = e || {}, super(e), this.setStyle(e.style);
  }
  /**
   * Remove the control from its current map and attach it to the new map.
   * Subclasses may set up event handlers to get notified about changes to
   * the map here.
   * @param {ol_Map} map Map.
   * @api stable
   */
  setMap(e) {
    this.getCanvas(e);
    var t = this.getMap();
    if (this._listener && (Js(this._listener), this._listener = null), super.setMap(e), t)
      try {
        t.renderSync();
      } catch {
      }
    e && (this._listener = e.on("postcompose", this._draw.bind(this)));
  }
  /** Get canvas overlay
   */
  getCanvas(e) {
    return eX(e);
  }
  /** Get map Canvas
   * @private
   */
  getContext(e) {
    var t = e.context;
    if (!t && this.getMap()) {
      var r = this.getMap().getViewport().getElementsByClassName("ol-fixedoverlay")[0];
      t = r ? r.getContext("2d") : null;
    }
    return t;
  }
  /** Set Style
   * @api
   */
  setStyle(e) {
    this._style = e || new ln({});
  }
  /** Get style
   * @api
   */
  getStyle() {
    return this._style;
  }
  /** Get stroke
   * @api
   */
  getStroke() {
    var e = this._style.getStroke();
    return e || this._style.setStroke(new Zi({ color: "#000", width: 1.25 })), this._style.getStroke();
  }
  /** Get fill
   * @api
   */
  getFill() {
    var e = this._style.getFill();
    return e || this._style.setFill(new Wn({ color: "#fff" })), this._style.getFill();
  }
  /** Get stroke
   * @api
   */
  getTextStroke() {
    var e = this._style.getText();
    return e || (e = new ih({})), e.getStroke() || e.setStroke(new Zi({ color: "#fff", width: 3 })), e.getStroke();
  }
  /** Get text fill
   * @api
   */
  getTextFill() {
    var e = this._style.getText();
    return e || (e = new ih({})), e.getFill() || e.setFill(new Wn({ color: "#fff" })), e.getFill();
  }
  /** Get text font
   * @api
   */
  getTextFont() {
    var e = this._style.getText();
    return e || (e = new ih({})), e.getFont() || e.setFont("12px sans-serif"), e.getFont();
  }
  /** Draw the control on canvas
   * @protected
   */
  _draw() {
    console.warn("[CanvasBase] draw function not implemented.");
  }
};
function Xm(i, e, t, r, n, s, a) {
  let o, A;
  const l = (t - e) / r;
  if (l === 1)
    o = e;
  else if (l === 2)
    o = e, A = n;
  else if (l !== 0) {
    let h = i[e], c = i[e + 1], u = 0;
    const f = [0];
    for (let y = e + r; y < t; y += r) {
      const v = i[y], w = i[y + 1];
      u += Math.sqrt((v - h) * (v - h) + (w - c) * (w - c)), f.push(u), h = v, c = w;
    }
    const g = n * u, p = xQ(f, g);
    p < 0 ? (A = (g - f[-p - 2]) / (f[-p - 1] - f[-p - 2]), o = e + (-p - 2) * r) : o = e + p * r;
  }
  a = a > 1 ? a : 2, s = s || new Array(a);
  for (let h = 0; h < a; ++h)
    s[h] = o === void 0 ? NaN : A === void 0 ? i[o + h] : Ms(i[o + h], i[o + r + h], A);
  return s;
}
function K2(i, e, t, r, n, s) {
  if (t == e)
    return null;
  let a;
  if (n < i[e + r - 1])
    return s ? (a = i.slice(e, e + r), a[r - 1] = n, a) : null;
  if (i[t - 1] < n)
    return s ? (a = i.slice(t - r, t), a[r - 1] = n, a) : null;
  if (n == i[e + r - 1])
    return i.slice(e, e + r);
  let o = e / r, A = t / r;
  for (; o < A; ) {
    const u = o + A >> 1;
    n < i[(u + 1) * r - 1] ? A = u : o = u + 1;
  }
  const l = i[o * r - 1];
  if (n == l)
    return i.slice((o - 1) * r, (o - 1) * r + r);
  const h = i[(o + 1) * r - 1], c = (n - l) / (h - l);
  a = [];
  for (let u = 0; u < r - 1; ++u)
    a.push(
      Ms(
        i[(o - 1) * r + u],
        i[o * r + u],
        c
      )
    );
  return a.push(n), a;
}
function tX(i, e, t, r, n, s, a) {
  if (a)
    return K2(
      i,
      e,
      t[t.length - 1],
      r,
      n,
      s
    );
  let o;
  if (n < i[r - 1])
    return s ? (o = i.slice(0, r), o[r - 1] = n, o) : null;
  if (i[i.length - 1] < n)
    return s ? (o = i.slice(i.length - r), o[r - 1] = n, o) : null;
  for (let A = 0, l = t.length; A < l; ++A) {
    const h = t[A];
    if (e != h) {
      if (n < i[e + r - 1])
        return null;
      if (n <= i[h - 1])
        return K2(
          i,
          e,
          h,
          r,
          n,
          !1
        );
      e = h;
    }
  }
  return null;
}
let rX = class j2 extends Ea {
  /**
   * @param {Array<import("../coordinate.js").Coordinate>|Array<number>} coordinates Coordinates.
   *     For internal use, flat coordinates in combination with `layout` are also accepted.
   * @param {import("./Geometry.js").GeometryLayout} [layout] Layout.
   */
  constructor(e, t) {
    super(), this.flatMidpoint_ = null, this.flatMidpointRevision_ = -1, this.maxDelta_ = -1, this.maxDeltaRevision_ = -1, t !== void 0 && !Array.isArray(e[0]) ? this.setFlatCoordinates(
      t,
      /** @type {Array<number>} */
      e
    ) : this.setCoordinates(
      /** @type {Array<import("../coordinate.js").Coordinate>} */
      e,
      t
    );
  }
  /**
   * Append the passed coordinate to the coordinates of the linestring.
   * @param {import("../coordinate.js").Coordinate} coordinate Coordinate.
   * @api
   */
  appendCoordinate(e) {
    this.flatCoordinates ? Er(this.flatCoordinates, e) : this.flatCoordinates = e.slice(), this.changed();
  }
  /**
   * Make a complete copy of the geometry.
   * @return {!LineString} Clone.
   * @api
   */
  clone() {
    const e = new j2(
      this.flatCoordinates.slice(),
      this.layout
    );
    return e.applyProperties(this), e;
  }
  /**
   * @param {number} x X.
   * @param {number} y Y.
   * @param {import("../coordinate.js").Coordinate} closestPoint Closest point.
   * @param {number} minSquaredDistance Minimum squared distance.
   * @return {number} Minimum squared distance.
   */
  closestPointXY(e, t, r, n) {
    return n < yl(this.getExtent(), e, t) ? n : (this.maxDeltaRevision_ != this.getRevision() && (this.maxDelta_ = Math.sqrt(
      xE(
        this.flatCoordinates,
        0,
        this.flatCoordinates.length,
        this.stride,
        0
      )
    ), this.maxDeltaRevision_ = this.getRevision()), EE(
      this.flatCoordinates,
      0,
      this.flatCoordinates.length,
      this.stride,
      this.maxDelta_,
      !1,
      e,
      t,
      r,
      n
    ));
  }
  /**
   * Iterate over each segment, calling the provided callback.
   * If the callback returns a truthy value the function returns that
   * value immediately. Otherwise the function returns `false`.
   *
   * @param {function(this: S, import("../coordinate.js").Coordinate, import("../coordinate.js").Coordinate): T} callback Function
   *     called for each segment. The function will receive two arguments, the start and end coordinates of the segment.
   * @return {T|boolean} Value.
   * @template T,S
   * @api
   */
  forEachSegment(e) {
    return XR(
      this.flatCoordinates,
      0,
      this.flatCoordinates.length,
      this.stride,
      e
    );
  }
  /**
   * Returns the coordinate at `m` using linear interpolation, or `null` if no
   * such coordinate exists.
   *
   * `extrapolate` controls extrapolation beyond the range of Ms in the
   * MultiLineString. If `extrapolate` is `true` then Ms less than the first
   * M will return the first coordinate and Ms greater than the last M will
   * return the last coordinate.
   *
   * @param {number} m M.
   * @param {boolean} [extrapolate] Extrapolate. Default is `false`.
   * @return {import("../coordinate.js").Coordinate|null} Coordinate.
   * @api
   */
  getCoordinateAtM(e, t) {
    return this.layout != "XYM" && this.layout != "XYZM" ? null : (t = t !== void 0 ? t : !1, K2(
      this.flatCoordinates,
      0,
      this.flatCoordinates.length,
      this.stride,
      e,
      t
    ));
  }
  /**
   * Return the coordinates of the linestring.
   * @return {Array<import("../coordinate.js").Coordinate>} Coordinates.
   * @api
   */
  getCoordinates() {
    return Qo(
      this.flatCoordinates,
      0,
      this.flatCoordinates.length,
      this.stride
    );
  }
  /**
   * Return the coordinate at the provided fraction along the linestring.
   * The `fraction` is a number between 0 and 1, where 0 is the start of the
   * linestring and 1 is the end.
   * @param {number} fraction Fraction.
   * @param {import("../coordinate.js").Coordinate} [dest] Optional coordinate whose values will
   *     be modified. If not provided, a new coordinate will be returned.
   * @return {import("../coordinate.js").Coordinate} Coordinate of the interpolated point.
   * @api
   */
  getCoordinateAt(e, t) {
    return Xm(
      this.flatCoordinates,
      0,
      this.flatCoordinates.length,
      this.stride,
      e,
      t,
      this.stride
    );
  }
  /**
   * Return the length of the linestring on projected plane.
   * @return {number} Length (on projected plane).
   * @api
   */
  getLength() {
    return p4(
      this.flatCoordinates,
      0,
      this.flatCoordinates.length,
      this.stride
    );
  }
  /**
   * @return {Array<number>} Flat midpoint.
   */
  getFlatMidpoint() {
    return this.flatMidpointRevision_ != this.getRevision() && (this.flatMidpoint_ = this.getCoordinateAt(0.5, this.flatMidpoint_), this.flatMidpointRevision_ = this.getRevision()), this.flatMidpoint_;
  }
  /**
   * @param {number} squaredTolerance Squared tolerance.
   * @return {LineString} Simplified LineString.
   * @protected
   */
  getSimplifiedGeometryInternal(e) {
    const t = [];
    return t.length = SE(
      this.flatCoordinates,
      0,
      this.flatCoordinates.length,
      this.stride,
      e,
      t,
      0
    ), new j2(t, "XY");
  }
  /**
   * Get the type of this geometry.
   * @return {import("./Geometry.js").Type} Geometry type.
   * @api
   */
  getType() {
    return "LineString";
  }
  /**
   * Test if the geometry and the passed extent intersect.
   * @param {import("../extent.js").Extent} extent Extent.
   * @return {boolean} `true` if the geometry and the extent intersect.
   * @api
   */
  intersectsExtent(e) {
    return Ov(
      this.flatCoordinates,
      0,
      this.flatCoordinates.length,
      this.stride,
      e
    );
  }
  /**
   * Set the coordinates of the linestring.
   * @param {!Array<import("../coordinate.js").Coordinate>} coordinates Coordinates.
   * @param {import("./Geometry.js").GeometryLayout} [layout] Layout.
   * @api
   */
  setCoordinates(e, t) {
    this.setLayout(t, e, 1), this.flatCoordinates || (this.flatCoordinates = []), this.flatCoordinates.length = gg(
      this.flatCoordinates,
      0,
      e,
      this.stride
    ), this.changed();
  }
};
const Gr = rX;
window.ol && !ol.legend && (ol.legend = {});
var iX = class extends cB {
  constructor(e) {
    e = e || {};
    var t = document.createElement("div");
    if (super({
      element: t,
      target: e.target
    }), e.target)
      t.className = e.className || "ol-legend";
    else {
      t.className = (e.className || "ol-legend") + " ol-unselectable ol-control" + (e.collapsible === !1 ? " ol-uncollapsible" : " ol-collapsed");
      var r = document.createElement("button");
      r.setAttribute("type", "button"), r.addEventListener("click", function() {
        this.toggle();
      }.bind(this)), t.appendChild(r), r = document.createElement("button"), r.setAttribute("type", "button"), r.className = "ol-closebox", r.addEventListener("click", function() {
        this.toggle();
      }.bind(this)), t.appendChild(r);
    }
    this._legend = e.legend, this._legend.getCanvas().className = "ol-legendImg", t.appendChild(this._legend.getCanvas()), t.appendChild(this._legend.getListElement()), e.collapsible !== !1 && e.collapsed === !1 && this.show(), this._legend.on("select", function(n) {
      this.dispatchEvent(n);
    }.bind(this)), this._legend.on("refresh", function() {
      if (this._onCanvas && this.getMap())
        try {
          this.getMap().renderSync();
        } catch {
        }
    }.bind(this));
  }
  /** Get the legend associated with the control
   * @returns {ol_legend_Legend}
   */
  getLegend() {
    return this._legend;
  }
  /** Draw control on canvas
   * @param {boolean} b draw on canvas.
   */
  setCanvas(e) {
    if (this._onCanvas = e, this.element.style.visibility = e ? "hidden" : "visible", this.getMap())
      try {
        this.getMap().renderSync();
      } catch {
      }
  }
  /** Is control on canvas
   * @returns {boolean}
   */
  onCanvas() {
    return !!this._onCanvas;
  }
  /** Draw legend on canvas
   * @private
   */
  _draw(e) {
    if (this._onCanvas && !this.element.classList.contains("ol-collapsed")) {
      var t = this._legend.getCanvas(), r = this.getContext(e), n = r.canvas.height - t.height;
      r.save(), r.rect(0, n, t.width, t.height);
      var s = "#fff";
      this._legend.getTextStyle().getBackgroundFill() && (s = rl(this._legend.getTextStyle().getBackgroundFill().getColor())), r.fillStyle = r.strokeStyle = s, r.lineWidth = 10, r.lineJoin = "round", r.stroke(), r.clearRect(0, n, t.width, t.height), r.fill(), r.drawImage(t, 0, n), r.restore();
    }
  }
  /** Show control
   */
  show() {
    if (this.element.classList.contains("ol-collapsed") && (this.element.classList.remove("ol-collapsed"), this.dispatchEvent({ type: "change:collapse", collapsed: !1 }), this.getMap()))
      try {
        this.getMap().renderSync();
      } catch {
      }
  }
  /** Hide control
   */
  hide() {
    if (!this.element.classList.contains("ol-collapsed") && (this.element.classList.add("ol-collapsed"), this.dispatchEvent({ type: "change:collapse", collapsed: !0 }), this.getMap()))
      try {
        this.getMap().renderSync();
      } catch {
      }
  }
  /** Show/hide control
   * @returns {boolean}
   */
  collapse(e) {
    e === !1 ? this.show() : this.hide();
  }
  /** Is control collapsed
   * @returns {boolean}
   */
  isCollapsed() {
    return this.element.classList.contains("ol-collapsed");
  }
  /** Toggle control
   */
  toggle() {
    if (this.element.classList.toggle("ol-collapsed"), this.dispatchEvent({ type: "change:collapse", collapsed: this.element.classList.contains("ol-collapsed") }), this.getMap())
      try {
        this.getMap().renderSync();
      } catch {
      }
  }
}, K4 = class extends hn {
  constructor(e) {
    e = e || {};
    var t = ae.create("DIV", {
      className: e.className || "ol-print"
    });
    super({
      element: t,
      target: e.target
    }), e.target || (t.classList.add("ol-unselectable", "ol-control"), ae.create("BUTTON", {
      type: "button",
      title: e.title || "Print",
      click: function() {
        this.print();
      }.bind(this),
      parent: t
    })), this.set("immediate", e.immediate), this.set("imageType", e.imageType || "image/jpeg"), this.set("quality", e.quality || 0.8), this.set("orientation", e.orientation);
  }
  /** Helper function to copy result to clipboard
   * @param {Event} e print event
   * @return {boolean}
   * @private
   */
  toClipboard(e, t) {
    try {
      e.canvas.toBlob(function(r) {
        try {
          navigator.clipboard.write([
            new window.ClipboardItem(
              Object.defineProperty({}, r.type, {
                value: r,
                enumerable: !0
              })
            )
          ]), typeof t == "function" && t(!0);
        } catch {
          typeof t == "function" && t(!1);
        }
      });
    } catch {
      typeof t == "function" && t(!1);
    }
  }
  /** Helper function to copy result to clipboard
   * @param {any} options print options
   * @param {function} callback a callback function that takes a boolean if copy
   */
  copyMap(e, t) {
    this.once("print", function(r) {
      this.toClipboard(r, t);
    }.bind(this)), this.print(e);
  }
  /** Get map canvas
   * @private
   */
  _getCanvas(e, t, r) {
    var n;
    if (e.context)
      r = e.context.canvas;
    else {
      if (r)
        n = r.getContext("2d");
      else {
        r = document.createElement("canvas");
        var s = this.getMap().getSize();
        r.width = s[0], r.height = s[1], n = r.getContext("2d"), /jp.*g$/.test(t) && (n.fillStyle = this.get("bgColor") || "white", n.fillRect(0, 0, r.width, r.height));
      }
      this.getMap().getViewport().querySelectorAll(".ol-layers canvas, canvas.ol-fixedoverlay").forEach(function(a) {
        if (a.width) {
          if (n.save(), a.parentNode.style.opacity === "0")
            return;
          n.globalAlpha = parseFloat(a.parentNode.style.opacity) || 1, n.globalCompositeOperation = ae.getStyle(a.parentNode, "mix-blend-mode"), n.filter = ae.getStyle(a.parentNode, "filter");
          var o = ae.getStyle(a, "transform") || ae.getStyle(a, "-webkit-transform");
          /^matrix/.test(o) ? (o = o.replace(/^matrix\(|\)$/g, "").split(","), o.forEach(function(A, l) {
            o[l] = parseFloat(A);
          }), n.transform(o[0], o[1], o[2], o[3], o[4], o[5]), n.drawImage(a, 0, 0)) : n.drawImage(a, 0, 0, ae.getStyle(a, "width"), ae.getStyle(a, "height")), n.restore();
        }
      }.bind(this));
    }
    return r;
  }
  /** Fast print
   * @param {*} options print options
   *  @param {HTMLCanvasElement|undefined} [options.canvas] if none create one, only for ol@6+
   *  @parama {string} options.imageType
   */
  fastPrint(e, t) {
    e = e || {}, this._ol6 ? requestAnimationFrame(function() {
      t(this._getCanvas({}, e.imageType, e.canvas));
    }.bind(this)) : (this.getMap().once("postcompose", function(r) {
      r.context || (this._ol6 = !0), t(this._getCanvas(r, e.imageType, e.canvas));
    }.bind(this)), this.getMap().render());
  }
  /** Print the map
   * @param {Object} options
   *	@param {string} options.imageType A string indicating the image format, default the control one
   *	@param {number} options.quality Number between 0 and 1 indicating the image quality to use for image formats that use lossy compression such as image/jpeg and image/webp
   *  @param {boolean} options.immediate true to prevent delay for printing
   *  @param {boolean} [options.size=[210,297]]
   *  @param {boolean} [options.format=a4]
   *  @param {boolean} [options.orient] default control orientation
   *  @param {boolean} [options.margin=10]
   *  @param {*} options.any any options passed to the print event when fired
   * @api
   */
  print(e) {
    e = e || {};
    var t = e.imageType || this.get("imageType"), r = e.quality || this.get("quality");
    if (this.getMap()) {
      if (e.immediate !== "silent" && this.dispatchEvent(Object.assign({
        type: "printing"
      }, e)), !e.immediate) {
        setTimeout(function() {
          e = Object.assign({}, e), e.immediate = "silent", this.print(e);
        }.bind(this), 200);
        return;
      }
      this.getMap().once(this.get("immediate") ? "postcompose" : "rendercomplete", function(n) {
        var s = this._getCanvas(n, t), a = e.size || [210, 297], o = e.format || "a4", A, l, h, c = e.orient || this.get("orientation"), u = typeof e.margin == "number" ? e.margin : 10;
        if (s) {
          c !== "landscape" && c !== "portrait" && (c = s.width > s.height ? "landscape" : "portrait"), c === "landscape" && (a = [a[1], a[0]]);
          var f = Math.min((a[0] - 2 * u) / s.width, (a[1] - 2 * u) / s.height);
          A = f * s.width, l = f * s.height, h = [(a[0] - A) / 2, (a[1] - l) / 2];
        }
        var g;
        try {
          g = s ? s.toDataURL(t, r) : null;
        } catch {
          this.dispatchEvent({
            type: "error",
            canvas: s
          });
          return;
        }
        var p = Object.assign({
          type: "print",
          print: {
            format: o,
            orientation: c,
            unit: "mm",
            size: a,
            position: h,
            imageWidth: A,
            imageHeight: l
          },
          image: g,
          imageType: t,
          quality: r,
          canvas: s
        }, e);
        this.dispatchEvent(p);
      }.bind(this)), this.getMap().render();
    }
  }
}, nX = class extends cB {
  constructor(e) {
    e = e || {};
    var t = ae.create("DIV", {
      className: (e.className || "") + " ol-control-title ol-unselectable",
      style: {
        display: "block",
        visibility: "hidden"
      }
    });
    super({
      element: t,
      style: e.style
    }), this.setTitle(e.title || ""), this.setVisible(e.visible !== !1), this.element.style.font = this.getTextFont();
  }
  /**
   * Change the control style
   * @param {ol_style_Style} style
   */
  setStyle(e) {
    super.setStyle(e), this.element && (this.element.style.font = this.getTextFont()), this.getMap() && this.getMap().render();
  }
  /**
   * Set the map title
   * @param {string} map title.
   * @api stable
   */
  setTitle(e) {
    if (this.element.textContent = e, this.set("title", e), this.getMap())
      try {
        this.getMap().renderSync();
      } catch {
      }
  }
  /**
   * Get the map title
   * @param {string} map title.
   * @api stable
   */
  getTitle() {
    return this.get("title");
  }
  /**
   * Set control visibility
   * @param {bool} b
   * @api stable
   */
  setVisible(e) {
    if (this.element.style.display = e ? "block" : "none", this.getMap())
      try {
        this.getMap().renderSync();
      } catch {
      }
  }
  /**
   * Get control visibility
   * @return {bool}
   * @api stable
   */
  getVisible() {
    return this.element.style.display !== "none";
  }
  /** Draw title in the final canvas
   * @private
  */
  _draw(e) {
    if (this.getVisible()) {
      var t = this.getContext(e);
      if (t) {
        var r = e.frameState.pixelRatio;
        t.save(), t.scale(r, r);
        var n = this.element.getBoundingClientRect(), s = this.getMap().getViewport().getBoundingClientRect(), a = this.getMap().getSize()[0] / s.width;
        t.translate(
          Math.round((n.left - s.left) * a),
          Math.round((n.top - s.top) * a)
        );
        var o = this.element.clientHeight, A = this.element.clientWidth, l = A / 2;
        t.beginPath(), t.fillStyle = rl(this.getFill().getColor()), t.rect(0, 0, A, o), t.fill(), t.closePath(), t.beginPath(), t.fillStyle = rl(this.getTextFill().getColor()), t.strokeStyle = rl(this.getTextStroke().getColor()), t.lineWidth = this.getTextStroke().getWidth(), t.textAlign = "center", t.textBaseline = "middle", t.font = this.getTextFont(), t.lineWidth && t.strokeText(this.getTitle(), l, o / 2), t.fillText(this.getTitle(), l, o / 2), t.closePath(), t.restore();
      }
    }
  }
}, e_ = function(i, e) {
  var t = i.getView(), r = t.getProjection(), n = t.getCenter(), s = i.getPixelFromCoordinate(n);
  s[1] += 1;
  var a = i.getCoordinateFromPixel(s), o = gm(
    cl(n, r, "EPSG:4326"),
    cl(a, r, "EPSG:4326")
  );
  return o *= (e || 96) / 0.0254, o;
}, sX = function(i, e, t) {
  if (i && e) {
    var r = e;
    if (typeof e == "string" && (r = e.split("/")[1], r || (r = e), r = r.replace(/[^\d]/g, ""), r = parseInt(r)), !r)
      return;
    var n = i.getView(), s = n.getProjection(), a = n.getCenter(), o = i.getPixelFromCoordinate(a);
    o[1] += 1;
    var A = i.getCoordinateFromPixel(o), l = gm(
      cl(a, s, "EPSG:4326"),
      cl(A, s, "EPSG:4326")
    );
    return l *= (t || 96) / 0.0254, n.setResolution(n.getResolution() * r / l), r;
  }
}, G5 = class extends cB {
  constructor(e) {
    e = e || {};
    var t = document.createElement("div");
    t.className = "ol-control ol-compassctrl ol-unselectable ol-hidden" + (e.className ? " " + e.className : ""), t.style.position = "absolute", t.style.visibility = "hidden";
    var r = e.style instanceof Zi ? new ln({ stroke: e.style }) : e.style;
    e.style || (r = new ln({ stroke: new Zi({ width: 0 }) })), super({
      element: t,
      style: r
    }), this.set("rotateVithView", e.rotateWithView !== !1), this.setVisible(e.visible !== !1), this.setImage(e.image || e.src);
  }
  /** Set compass image
   * @param {Image|string} [img=default] the image or an url or 'compact' or 'default'
   */
  setImage(e) {
    if (e instanceof Image)
      this.img_ = e, this.img_.onload = function() {
        if (this.getMap())
          try {
            this.getMap().renderSync();
          } catch {
          }
      }.bind(this);
    else if (typeof e == "string")
      switch (e) {
        case "compact": {
          this.img_ = this.compactCompass_(this.element.clientWidth, this.getStroke().getColor());
          break;
        }
        case "default": {
          this.img_ = this.defaultCompass_(this.element.clientWidth, this.getStroke().getColor());
          break;
        }
        default: {
          this.img_ = new Image(), this.img_.onload = function() {
            if (this.getMap())
              try {
                this.getMap().renderSync();
              } catch {
              }
          }.bind(this), this.img_.src = e;
          break;
        }
      }
    else
      this.img_ = this.defaultCompass_(this.element.clientWidth, this.getStroke().getColor());
  }
  /** Create a default image.
   * @param {number} s the size of the compass
   * @private
   */
  compactCompass_(e, t) {
    var r = document.createElement("canvas"), n = r.getContext("2d");
    e = r.width = r.height = e || 150;
    var s = e / 2;
    return n.translate(s, s), n.fillStyle = t || "#963", n.lineWidth = 5, n.lineJoin = n.lineCap = "round", n.font = "bold " + s * 0.4 + "px sans-serif", n.textBaseline = "bottom", n.textAlign = "center", n.strokeStyle = "#fff", n.globalAlpha = 0.75, n.strokeText("N", 0, -s / 2), n.globalAlpha = 1, n.fillText("N", 0, -s / 2), n.beginPath(), n.moveTo(0, s / 4), n.lineTo(s / 3, s / 2), n.lineTo(0, -s / 2), n.lineTo(-s / 3, s / 2), n.lineTo(0, s / 4), n.lineWidth = 12, n.fillStyle = "#fff", n.globalAlpha = 0.75, n.fill(), n.stroke(), n.globalAlpha = 1, n.fillStyle = n.strokeStyle = t || "#963", n.lineWidth = 5, n.beginPath(), n.moveTo(0, s / 4), n.lineTo(0, -s / 2), n.lineTo(s / 3, s / 2), n.lineTo(0, s / 4), n.fill(), n.stroke(), n.beginPath(), n.moveTo(0, s / 4), n.lineTo(0, -s / 2), n.lineTo(-s / 3, s / 2), n.lineTo(0, s / 4), n.stroke(), r;
  }
  /** Create a default image.
   * @param {number} s the size of the compass
   * @private
   */
  defaultCompass_(e, t) {
    var r = document.createElement("canvas"), n = r.getContext("2d");
    e = r.width = r.height = e || 150;
    var s = e / 2, a = 0.22 * s;
    function o(l, h) {
      n.fillStyle = t || "#963", n.beginPath(), n.moveTo(0, 0), n.lineTo(l, 0), n.lineTo(h, h), n.moveTo(0, 0), n.lineTo(-l, 0), n.lineTo(-h, -h), n.moveTo(0, 0), n.lineTo(0, l), n.lineTo(-h, h), n.moveTo(0, 0), n.lineTo(0, -l), n.lineTo(h, -h), n.moveTo(0, 0), n.fill(), n.stroke();
    }
    function A(l, h) {
      n.globalCompositeOperation = "destination-out", n.fillStyle = "#fff", n.beginPath(), n.moveTo(0, 0), n.lineTo(l, 0), n.lineTo(h, -h), n.moveTo(0, 0), n.lineTo(-l, 0), n.lineTo(-h, h), n.moveTo(0, 0), n.lineTo(0, l), n.lineTo(h, h), n.moveTo(0, 0), n.lineTo(0, -l), n.lineTo(-h, -h), n.moveTo(0, 0), n.fill(), n.globalCompositeOperation = "source-over", n.beginPath(), n.moveTo(0, 0), n.lineTo(l, 0), n.lineTo(h, -h), n.moveTo(0, 0), n.lineTo(-l, 0), n.lineTo(-h, h), n.moveTo(0, 0), n.lineTo(0, l), n.lineTo(h, h), n.moveTo(0, 0), n.lineTo(0, -l), n.lineTo(-h, -h), n.moveTo(0, 0), n.stroke();
    }
    return n.translate(s, s), n.strokeStyle = t || "#963", n.lineWidth = 1.5, n.beginPath(), n.arc(0, 0, e * 0.41, 0, 2 * Math.PI), n.arc(0, 0, e * 0.44, 0, 2 * Math.PI), n.stroke(), n.rotate(Math.PI / 4), o(s * 0.9, a * 0.8), A(s * 0.9, a * 0.8), n.rotate(-Math.PI / 4), o(s, a), A(s, a), r;
  }
  /** Get control visibility
   * @return {boolean}
   */
  getVisible() {
    return ae.getStyle(this.element, "display") === "block";
  }
  /** Set visibility
   * @param {boolean} b
   */
  setVisible(e) {
    e ? this.element.classList.add("ol-visible") : this.element.classList.remove("ol-visible"), this.getMap() && this.getMap().render();
  }
  /** Draw compass
  * @param {ol.event} e postcompose event
  * @private
  */
  _draw(e) {
    var t = this.getContext(e);
    if (!(!t || !this.getVisible())) {
      var r = t.canvas, n, s = [];
      for (n = 0; n < 8; n++)
        s[n] = [Math.cos(Math.PI * n / 8), Math.sin(Math.PI * n / 8)];
      var a = e.frameState.pixelRatio;
      t.save(), t.scale(a, a);
      var o = this.element.clientWidth, A = this.element.clientHeight, l = { left: this.element.offsetLeft, top: this.element.offsetTop }, h = this.img_, c = e.frameState.viewState.rotation;
      if (t.beginPath(), t.translate(l.left + o / 2, l.top + A / 2), this.get("rotateVithView") && t.rotate(c), this.getStroke().getWidth()) {
        t.beginPath(), t.strokeStyle = this.getStroke().getColor(), t.lineWidth = this.getStroke().getWidth();
        var u = Math.max(r.width, r.height);
        for (n = 0; n < 8; n++)
          t.moveTo(-s[n][0] * u, -s[n][1] * u), t.lineTo(s[n][0] * u, s[n][1] * u);
        t.stroke();
      }
      h.width && t.drawImage(h, -o / 2, -A / 2, o, A), t.closePath(), t.restore();
    }
  }
}, Fh = class extends hn {
  constructor(e) {
    e = e || {};
    var t = ae.create("DIV", {
      className: (e.className || "ol-print") + " ol-unselectable ol-control"
    });
    super({
      element: t
    }), this._lang = e.lang || "en", ae.create("BUTTON", {
      type: "button",
      title: e.title || "Print",
      click: function() {
        this.print();
      }.bind(this),
      parent: t
    }), e.openWindow && this.on("print", function(P) {
      P.canvas && window.open().document.write('<img src="' + P.canvas.toDataURL() + '"/>');
    }), e.target = ae.create("DIV");
    var r = this._printCtrl = new K4(e);
    r.on(["print", "error", "printing"], function(P) {
      s.setAttribute("data-status", P.type), P.clipboard || this.dispatchEvent(P);
    }.bind(this)), this._compass = new G5({
      src: e.northImage || "compact",
      visible: !1,
      className: "olext-print-compass",
      style: new Zi({ color: "#333", width: 0 })
    });
    var n = this._printDialog = new V4({
      target: document.body,
      closeBox: !0,
      className: "ol-ext-print-dialog"
    }), s = n.getContentElement();
    this._input = {};
    var a = ae.create("DIV", {
      className: "ol-print-param",
      parent: s
    });
    this._pages = [ae.create("DIV", {
      className: "ol-page"
    })];
    var o = ae.create("DIV", {
      className: "ol-map",
      parent: this._pages[0]
    });
    ae.create("DIV", {
      html: this._pages[0],
      className: "ol-print-map",
      parent: s
    }), ae.create("H2", {
      html: this.i18n("title"),
      parent: a
    });
    var A = ae.create("UL", { parent: a }), l = ae.create("LI", {
      /*
      html: ol_ext_element.create('LABEL', {
        html: this.18n('orientation')
      }),
      */
      className: "ol-orientation",
      parent: A
    });
    this._input.orientation = { list: l };
    var h = ae.create("LABEL", {
      className: "portrait",
      parent: l
    });
    this._input.orientation.portrait = ae.create("INPUT", {
      type: "radio",
      name: "ol-print-orientation",
      value: "portrait",
      checked: !0,
      on: {
        change: function(P) {
          this.setOrientation(P.target.value);
        }.bind(this)
      },
      parent: h
    }), ae.create("SPAN", {
      html: this.i18n("portrait"),
      parent: h
    }), h = ae.create("LABEL", {
      className: "landscape",
      parent: l
    }), this._input.orientation.landscape = ae.create("INPUT", {
      type: "radio",
      name: "ol-print-orientation",
      value: "landscape",
      on: {
        change: function(P) {
          this.setOrientation(P.target.value);
        }.bind(this)
      },
      parent: h
    }), ae.create("SPAN", {
      html: this.i18n("landscape"),
      parent: h
    });
    var c;
    l = ae.create("LI", {
      html: ae.create("LABEL", {
        html: this.i18n("size")
      }),
      className: "ol-size",
      parent: A
    });
    var u = this._input.size = ae.create("SELECT", {
      on: {
        change: function() {
          this.setSize(u.value || $);
        }.bind(this)
      },
      parent: l
    });
    for (c in this.paperSize)
      ae.create("OPTION", {
        html: c + (this.paperSize[c] ? " - " + this.paperSize[c][0] + "x" + this.paperSize[c][1] + " mm" : this.i18n("custom")),
        value: c,
        parent: u
      });
    l = ae.create("LI", {
      html: ae.create("LABEL", {
        html: this.i18n("margin")
      }),
      className: "ol-margin",
      parent: A
    });
    var f = this._input.margin = ae.create("SELECT", {
      on: {
        change: function() {
          this.setMargin(f.value);
        }.bind(this)
      },
      parent: l
    });
    for (c in this.marginSize)
      ae.create("OPTION", {
        html: this.i18n(c) + " - " + this.marginSize[c] + " mm",
        value: this.marginSize[c],
        parent: f
      });
    l = ae.create("LI", {
      html: ae.create("LABEL", {
        html: this.i18n("scale")
      }),
      className: "ol-scale",
      parent: A
    });
    var g = this._input.scale = ae.create("SELECT", {
      on: {
        change: function() {
          this.setScale(parseInt(g.value));
        }.bind(this)
      },
      parent: l
    });
    Object.keys(this.scales).forEach(function(P) {
      ae.create("OPTION", {
        html: this.scales[P],
        value: P,
        parent: g
      });
    }.bind(this)), l = ae.create("LI", {
      className: "ol-legend",
      parent: A
    });
    var p = ae.createSwitch({
      html: this.i18n("legend"),
      checked: !1,
      on: {
        change: function() {
          L.legend.control.setCanvas(p.checked);
        }.bind(this)
      },
      parent: l
    });
    l = ae.create("LI", {
      className: "ol-print-north",
      parent: A
    });
    var y = this._input.north = ae.createSwitch({
      html: this.i18n("north"),
      checked: "checked",
      on: {
        change: function() {
          y.checked ? this._compass.element.classList.add("ol-print-compass") : this._compass.element.classList.remove("ol-print-compass"), this.getMap().render();
        }.bind(this)
      },
      parent: l
    });
    l = ae.create("LI", {
      className: "ol-print-title",
      parent: A
    });
    var v = ae.createSwitch({
      html: this.i18n("mapTitle"),
      checked: !1,
      on: {
        change: function(P) {
          L.title.control.setVisible(P.target.checked);
        }.bind(this)
      },
      parent: l
    }), w = ae.create("INPUT", {
      type: "text",
      placeholder: this.i18n("mapTitle"),
      on: {
        keydown: function(P) {
          P.keyCode === 13 && P.preventDefault();
        },
        keyup: function() {
          L.title.control.setTitle(w.value);
        },
        change: function() {
          L.title.control.setTitle(w.value);
        }.bind(this)
      },
      parent: l
    }), C = ae.create("DIV", {
      className: "ol-user-param",
      parent: a
    });
    l = ae.create("LI", {
      className: "ol-saveas",
      parent: A
    });
    var E = ae.create("DIV", {
      html: this.i18n("copied"),
      className: "ol-clipboard-copy",
      parent: l
    }), S = ae.create("SELECT", {
      on: {
        change: function() {
          if (this.formats[S.value].clipboard)
            r.copyMap(this.formats[S.value], function(X) {
              X && (E.classList.add("visible"), setTimeout(function() {
                E.classList.remove("visible");
              }, 1e3));
            });
          else {
            var P = typeof this.getSize() == "string" ? this.getSize() : null, Q = Object.assign({
              format: P,
              size: P ? this.paperSize[P] : null,
              orient: this.getOrientation(),
              margin: this.getMargin()
            }, this.formats[S.value]);
            r.print(Q);
          }
          S.value = "";
        }.bind(this)
      },
      parent: l
    });
    ae.create("OPTION", {
      html: this.i18n("saveas"),
      style: { display: "none" },
      value: "",
      parent: S
    }), this.formats.forEach(function(P, Q) {
      if (P.pdf) {
        if (e.pdf === !1)
          return;
      } else if (P.clipboard) {
        if (e.copy === !1)
          return;
      } else if (e.save === !1)
        return;
      ae.create("OPTION", {
        html: this.i18n(P.title),
        value: Q,
        parent: S
      });
    }.bind(this)), l = ae.create("LI", {
      className: "ol-savelegend",
      parent: A
    });
    var M = ae.create("DIV", {
      html: this.i18n("copied"),
      className: "ol-clipboard-copy",
      parent: l
    }), T = ae.create("SELECT", {
      on: {
        change: function() {
          var P = L.legend.control.getLegend().getCanvas(), Q = document.createElement("CANVAS");
          Q.width = P.width, Q.height = P.height;
          var X = Q.getContext("2d");
          if (X.fillStyle = "#fff", X.fillRect(0, 0, Q.width, Q.height), X.drawImage(P, 0, 0), this.formats[T.value].clipboard)
            Q.toBlob(function(b) {
              try {
                navigator.clipboard.write([
                  new window.ClipboardItem(
                    Object.defineProperty({}, b.type, {
                      value: b,
                      enumerable: !0
                    })
                  )
                ]), M.classList.add("visible"), setTimeout(function() {
                  M.classList.remove("visible");
                }, 1e3);
              } catch {
              }
            }, "image/png");
          else {
            var W;
            try {
              W = Q.toDataURL(this.formats[T.value].imageType, this.formats[T.value].quality);
              var q = typeof this.getSize() == "string" ? this.getSize() : "A4", Z = Q.width / 96 * 25.4, oe = Q.height / 96 * 25.4, ne = this.paperSize[q];
              this.getOrientation() === "landscape" && (ne = [ne[1], ne[0]]);
              var me = [
                (ne[0] - Z) / 2,
                (ne[1] - oe) / 2
              ];
              this.dispatchEvent({
                type: "print",
                print: {
                  legend: !0,
                  format: q,
                  orientation: this.getOrientation(),
                  unit: "mm",
                  size: this.paperSize[q],
                  position: me,
                  imageWidth: Z,
                  imageHeight: oe
                },
                image: W,
                imageType: this.formats[T.value].imageType,
                pdf: this.formats[T.value].pdf,
                quality: this.formats[T.value].quality,
                canvas: Q
              });
            } catch {
            }
          }
          T.value = "";
        }.bind(this)
      },
      parent: l
    });
    ae.create("OPTION", {
      html: this.i18n("saveLegend"),
      style: { display: "none" },
      value: "",
      parent: T
    }), this.formats.forEach(function(P, Q) {
      ae.create("OPTION", {
        html: this.i18n(P.title),
        value: Q,
        parent: T
      });
    }.bind(this));
    var F = ae.create("DIV", {
      className: "ol-ext-buttons",
      parent: a
    });
    ae.create("BUTTON", {
      html: this.i18n("printBt"),
      type: "submit",
      click: function(P) {
        P.preventDefault(), window.print();
      },
      parent: F
    }), ae.create("BUTTON", {
      html: this.i18n("cancel"),
      type: "button",
      click: function() {
        n.hide();
      },
      parent: F
    }), ae.create("DIV", {
      html: this.i18n("errorMsg"),
      className: "ol-error",
      parent: a
    });
    var k, $, I, L = {};
    n.on("show", function() {
      this.dispatchEvent({ type: "show", userElement: C, dialog: this._printDialog, page: this.getPage() });
      var P = this.getMap();
      P && (document.body.classList.add("ol-print-document"), k = P.getTargetElement(), $ = P.getSize(), typeof this.getSize() == "string" ? this.setSize(this.getSize()) : this.setSize($), P.setTarget(o), I && Js(I), I = P.on("moveend", function() {
        this.setScale(e_(P));
      }.bind(this)), this.setScale(e_(P)), L = {}, this.getMap().getControls().forEach(function(Q) {
        Q instanceof iX && (L.legend = { control: Q }), Q instanceof nX && (L.title = { control: Q }), Q instanceof G5 && (L.compass ? Q.element.classList.remove("ol-print-compass") : (this._input.north.checked ? Q.element.classList.add("ol-print-compass") : Q.element.classList.remove("ol-print-compass"), this._compass = Q, L.compass = { control: Q }));
      }.bind(this)), L.title ? (v.checked = L.title.isVisible = L.title.control.getVisible(), w.value = L.title.control.getTitle(), v.parentNode.parentNode.classList.remove("hidden")) : v.parentNode.parentNode.classList.add("hidden"), L.legend ? (L.legend.ison = L.legend.control.onCanvas(), L.legend.collapsed = L.legend.control.isCollapsed(), L.legend.control.collapse(!1), T.parentNode.classList.remove("hidden"), p.parentNode.parentNode.classList.remove("hidden"), p.checked = !L.legend.collapsed, L.legend.control.setCanvas(!L.legend.collapsed)) : (T.parentNode.classList.add("hidden"), p.parentNode.parentNode.classList.add("hidden")));
    }.bind(this)), n.on("hide", function() {
      document.body.classList.remove("ol-print-document"), k && (this.getMap().setTarget(k), k = null, I && Js(I), L.title && L.title.control.setVisible(L.title.isVisible), L.legend && (L.legend.control.setCanvas(L.legend.ison), L.legend.control.collapse(L.legend.collapsed)), this.dispatchEvent({ type: "hide" }));
    }.bind(this)), window.addEventListener("resize", function() {
      this.setSize();
    }.bind(this)), e.saveAs && this.on("print", function(P) {
      P.pdf || P.canvas.toBlob(function(Q) {
        var X = (P.print.legend ? "legend." : "map.") + P.imageType.replace("image/", "");
        e.saveAs(Q, X);
      }, P.imageType, P.quality);
    }), e.jsPDF && this.on("print", function(P) {
      if (P.pdf) {
        var Q = new e.jsPDF({
          orientation: P.print.orientation,
          unit: P.print.unit,
          format: P.print.size
        });
        Q.addImage(P.image, "JPEG", P.print.position[0], P.print.position[0], P.print.imageWidth, P.print.imageHeight), Q.save(P.print.legend ? "legend.pdf" : "map.pdf");
      }
    });
  }
  /** Add a new language
   * @param {string} lang lang id
   * @param {Objetct} labels
   */
  static addLang(e, t) {
    Fh.prototype._labels[e] = t;
  }
  /** Check if the dialog is oprn
   * @return {boolean}
   */
  isOpen() {
    return this._printDialog.isOpen();
  }
  /** Translate
   * @param {string} what
   * @returns {string}
   */
  i18n(e) {
    var t = this._labels.en[e] || "bad param";
    return this._labels[this._lang] && this._labels[this._lang][e] && (t = this._labels[this._lang][e]), t;
  }
  /** Get print orientation
   * @returns {string}
   */
  getOrientation() {
    return this._orientation || "portrait";
  }
  /** Set print orientation
   * @param {string} ori landscape or portrait
   */
  setOrientation(e) {
    this._orientation = e === "landscape" ? "landscape" : "portrait", this._input.orientation[this._orientation].checked = !0, this.setSize();
  }
  /** Get print margin
   * @returns {number}
   */
  getMargin() {
    return this._margin || 0;
  }
  /** Set print margin
   * @param {number}
   */
  setMargin(e) {
    this._margin = e, this._input.margin.value = e, this.setSize();
  }
  /** Get print size
   * @returns {ol.size}
   */
  getSize() {
    return this._size;
  }
  /** Set map print size
   * @param {ol/size|string} size map size as ol/size or A4, etc.
   */
  setSize(e) {
    if (this._printDialog.getContentElement().setAttribute("data-status", ""), e ? this._size = e : e = this._size, !!e) {
      if (typeof e == "string") {
        for (var t in this.paperSize)
          t && new RegExp(t, "i").test(e) && (e = t);
        this.paperSize[e] || (e = this._size = "A4"), this._input.size.value = e, e = [
          Math.trunc(this.paperSize[e][0] * 96 / 25.4),
          Math.trunc(this.paperSize[e][1] * 96 / 25.4)
        ], this.getOrientation() === "landscape" && (e = [e[1], e[0]]), this.getPage().classList.remove("margin");
      } else
        this._input.size.value = "", this.getPage().classList.add("margin");
      var r = this.getPage(), n = r.parentNode.getBoundingClientRect(), s = (n.width - 40) / e[0], a = (n.height - 40) / e[1], o = Math.min(s, a, 1);
      r.style.width = e[0] + "px", r.style.height = e[1] + "px", r.style["-webkit-transform"] = r.style.transform = "translate(-50%,-50%) scale(" + o + ")";
      var A = Math.round(5 / o);
      r.style["-webkit-box-shadow"] = r.style["box-shadow"] = A + "px " + A + "px " + A + "px rgba(0,0,0,.6)", r.style.padding = this.getMargin() * 96 / 25.4 + "px", this.getMap() && this.getMap().updateSize(), this.dispatchEvent({ type: "dialog:refresh" });
    }
  }
  /** Get dialog content element
   * @return {Element}
   */
  getContentElement() {
    return this._printDialog.getContentElement();
  }
  /** Get dialog user element
   * @return {Element}
   */
  getUserElement() {
    return this._printDialog.getContentElement().querySelector(".ol-user-param");
  }
  /** Get page element
   * @return {Element}
   */
  getPage() {
    return this._pages[0];
  }
  /**
   * Remove the control from its current map and attach it to the new map.
   * Subclasses may set up event handlers to get notified about changes to
   * the map here.
   * @param {ol.Map} map Map.
   * @api stable
   */
  setMap(e) {
    this.getMap() && (this.getMap().removeControl(this._compass), this.getMap().removeControl(this._printCtrl), this.getMap().removeControl(this._printDialog)), super.setMap(e), this.getMap() && (this.getMap().addControl(this._compass), this.getMap().addControl(this._printCtrl), this.getMap().addControl(this._printDialog));
  }
  /** Set the current scale (will change the scale of the map)
   * @param {number|string} value the scale factor or a scale string as 1/xxx
   */
  setScale(e) {
    sX(this.getMap(), e), this._input.scale.value = " " + Math.round(e / 100) * 100;
  }
  /** Get the current map scale factor
   * @return {number}
   */
  getScale() {
    return e_(this.getMap());
  }
  /** Show print dialog
   * @param {*}
   *  @param {ol/size|string} options.size map size as ol/size or A4, etc.
   *  @param {number|string} options.value the scale factor or a scale string as 1/xxx
   *  @param {string} options.orientation landscape or portrait
   *  @param {number} options.margin
   */
  print(e) {
    e = e || {}, e.size && this.setSize(e.size), e.scale && this.setScale(e.scale), e.orientation && this.setOrientation(e.orientation), e.margin && this.setMargin(e.margin), this._printDialog.show();
  }
  /** Get print control
   * @returns {ol_control_Print}
   */
  getrintControl() {
    return this._printCtrl;
  }
};
Fh.prototype._labels = {
  en: {
    title: "Print",
    orientation: "Orientation",
    portrait: "Portrait",
    landscape: "Landscape",
    size: "Page size",
    custom: "screen size",
    margin: "Margin",
    scale: "Scale",
    legend: "Legend",
    north: "North arrow",
    mapTitle: "Map title",
    saveas: "Save as...",
    saveLegend: "Save legend...",
    copied: " Copied to clipboard",
    errorMsg: "Can't save map canvas...",
    printBt: "Print...",
    clipboardFormat: "copy to clipboard...",
    jpegFormat: "save as jpeg",
    pngFormat: "save as png",
    pdfFormat: "save as pdf",
    none: "none",
    small: "small",
    large: "large",
    cancel: "cancel"
  },
  fr: {
    title: "Imprimer",
    orientation: "Orientation",
    portrait: "Portrait",
    landscape: "Paysage",
    size: "Taille du papier",
    custom: "taille cran",
    margin: "Marges",
    scale: "Echelle",
    legend: "Lgende",
    north: "Flche du nord",
    mapTitle: "Titre de la carte",
    saveas: "Enregistrer sous...",
    saveLegend: "Enregistrer la lgende...",
    copied: " Carte copie",
    errorMsg: "Impossible d'enregistrer la carte",
    printBt: "Imprimer",
    clipboardFormat: "copier dans le presse-papier...",
    jpegFormat: "enregistrer un jpeg",
    pngFormat: "enregistrer un png",
    pdfFormat: "enregistrer un pdf",
    none: "aucune",
    small: "petites",
    large: "larges",
    cancel: "annuler"
  },
  de: {
    title: "Drucken",
    orientation: "Ausrichtung",
    portrait: "Hochformat",
    landscape: "Querformat",
    size: "Papierformat",
    custom: "Bildschirmgre",
    margin: "Rand",
    scale: "Mastab",
    legend: "Legende",
    north: "Nordpfeil",
    mapTitle: "Kartentitel",
    saveas: "Speichern als...",
    saveLegend: "Legende speichern...",
    copied: " In die Zwischenablage kopiert",
    errorMsg: "Kann Karte nicht speichern...",
    printBt: "Drucken...",
    clipboardFormat: "in die Zwischenablage kopieren...",
    jpegFormat: "speichern als jpeg",
    pngFormat: "speichern als png",
    pdfFormat: "speichern als pdf",
    none: "kein",
    small: "klein",
    large: "gro",
    cancel: "abbrechen"
  },
  zh: {
    title: "",
    orientation: "",
    portrait: "",
    landscape: "",
    size: "",
    custom: "",
    margin: "",
    scale: "",
    legend: "",
    north: "",
    mapTitle: "",
    saveas: "...",
    saveLegend: "...",
    copied: " ",
    errorMsg: "...",
    printBt: "...",
    cancel: ""
  }
};
Fh.prototype.paperSize = {
  "": null,
  A0: [841, 1189],
  A1: [594, 841],
  A2: [420, 594],
  A3: [297, 420],
  A4: [210, 297],
  "US Letter": [215.9, 279.4],
  A5: [148, 210],
  B4: [257, 364],
  B5: [182, 257]
};
Fh.prototype.marginSize = {
  none: 0,
  small: 5,
  large: 10
};
Fh.prototype.formats = [
  {
    title: "clipboardFormat",
    imageType: "image/png",
    clipboard: !0
  },
  {
    title: "jpegFormat",
    imageType: "image/jpeg",
    quality: 0.8
  },
  {
    title: "pngFormat",
    imageType: "image/png",
    quality: 0.8
  },
  {
    title: "pdfFormat",
    imageType: "image/jpeg",
    pdf: !0
  }
];
Fh.prototype.scales = {
  " 5000": "1/5.000",
  " 10000": "1/10.000",
  " 25000": "1/25.000",
  " 50000": "1/50.000",
  " 100000": "1/100.000",
  " 250000": "1/250.000",
  " 1000000": "1/1.000.000"
};
var z2 = {}, aX = {
  get exports() {
    return z2;
  },
  set exports(i) {
    z2 = i;
  }
};
(function(i, e) {
  (function(t, r) {
    r();
  })(Uo, function() {
    function t(l, h) {
      return typeof h > "u" ? h = { autoBom: !1 } : typeof h != "object" && (console.warn("Deprecated: Expected third argument to be a object"), h = { autoBom: !h }), h.autoBom && /^\s*(?:text\/\S*|application\/xml|\S*\/\S*\+xml)\s*;.*charset\s*=\s*utf-8/i.test(l.type) ? new Blob(["\uFEFF", l], { type: l.type }) : l;
    }
    function r(l, h, c) {
      var u = new XMLHttpRequest();
      u.open("GET", l), u.responseType = "blob", u.onload = function() {
        A(u.response, h, c);
      }, u.onerror = function() {
        console.error("could not download file");
      }, u.send();
    }
    function n(l) {
      var h = new XMLHttpRequest();
      h.open("HEAD", l, !1);
      try {
        h.send();
      } catch {
      }
      return 200 <= h.status && 299 >= h.status;
    }
    function s(l) {
      try {
        l.dispatchEvent(new MouseEvent("click"));
      } catch {
        var h = document.createEvent("MouseEvents");
        h.initMouseEvent("click", !0, !0, window, 0, 0, 0, 80, 20, !1, !1, !1, !1, 0, null), l.dispatchEvent(h);
      }
    }
    var a = typeof window == "object" && window.window === window ? window : typeof self == "object" && self.self === self ? self : typeof Uo == "object" && Uo.global === Uo ? Uo : void 0, o = a.navigator && /Macintosh/.test(navigator.userAgent) && /AppleWebKit/.test(navigator.userAgent) && !/Safari/.test(navigator.userAgent), A = a.saveAs || (typeof window != "object" || window !== a ? function() {
    } : "download" in HTMLAnchorElement.prototype && !o ? function(l, h, c) {
      var u = a.URL || a.webkitURL, f = document.createElement("a");
      h = h || l.name || "download", f.download = h, f.rel = "noopener", typeof l == "string" ? (f.href = l, f.origin === location.origin ? s(f) : n(f.href) ? r(l, h, c) : s(f, f.target = "_blank")) : (f.href = u.createObjectURL(l), setTimeout(function() {
        u.revokeObjectURL(f.href);
      }, 4e4), setTimeout(function() {
        s(f);
      }, 0));
    } : "msSaveOrOpenBlob" in navigator ? function(l, h, c) {
      if (h = h || l.name || "download", typeof l != "string")
        navigator.msSaveOrOpenBlob(t(l, c), h);
      else if (n(l))
        r(l, h, c);
      else {
        var u = document.createElement("a");
        u.href = l, u.target = "_blank", setTimeout(function() {
          s(u);
        });
      }
    } : function(l, h, c, u) {
      if (u = u || open("", "_blank"), u && (u.document.title = u.document.body.innerText = "downloading..."), typeof l == "string")
        return r(l, h, c);
      var f = l.type === "application/octet-stream", g = /constructor/i.test(a.HTMLElement) || a.safari, p = /CriOS\/[\d]+/.test(navigator.userAgent);
      if ((p || f && g || o) && typeof FileReader < "u") {
        var y = new FileReader();
        y.onloadend = function() {
          var C = y.result;
          C = p ? C : C.replace(/^data:[^;]*;/, "data:attachment/file;"), u ? u.location.href = C : location = C, u = null;
        }, y.readAsDataURL(l);
      } else {
        var v = a.URL || a.webkitURL, w = v.createObjectURL(l);
        u ? u.location = w : location.href = w, u = null, setTimeout(function() {
          v.revokeObjectURL(w);
        }, 4e4);
      }
    });
    a.saveAs = A.saveAs = A, i.exports = A;
  });
})(aX);
const j4 = z2;
function $r(i) {
  return $r = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(e) {
    return typeof e;
  } : function(e) {
    return e && typeof Symbol == "function" && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e;
  }, $r(i);
}
var rs = Uint8Array, is = Uint16Array, Yd = Uint32Array, ty = new rs([
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  1,
  1,
  1,
  1,
  2,
  2,
  2,
  2,
  3,
  3,
  3,
  3,
  4,
  4,
  4,
  4,
  5,
  5,
  5,
  5,
  0,
  /* unused */
  0,
  0,
  /* impossible */
  0
]), ry = new rs([
  0,
  0,
  0,
  0,
  1,
  1,
  2,
  2,
  3,
  3,
  4,
  4,
  5,
  5,
  6,
  6,
  7,
  7,
  8,
  8,
  9,
  9,
  10,
  10,
  11,
  11,
  12,
  12,
  13,
  13,
  /* unused */
  0,
  0
]), X2 = new rs([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]), z4 = function(i, e) {
  for (var t = new is(31), r = 0; r < 31; ++r)
    t[r] = e += 1 << i[r - 1];
  for (var n = new Yd(t[30]), r = 1; r < 30; ++r)
    for (var s = t[r]; s < t[r + 1]; ++s)
      n[s] = s - t[r] << 5 | r;
  return [t, n];
}, X4 = z4(ty, 2), W4 = X4[0], W2 = X4[1];
W4[28] = 258, W2[258] = 28;
var Y4 = z4(ry, 0), oX = Y4[0], $5 = Y4[1], Y2 = new is(32768);
for (var oi = 0; oi < 32768; ++oi) {
  var NA = (oi & 43690) >>> 1 | (oi & 21845) << 1;
  NA = (NA & 52428) >>> 2 | (NA & 13107) << 2, NA = (NA & 61680) >>> 4 | (NA & 3855) << 4, Y2[oi] = ((NA & 65280) >>> 8 | (NA & 255) << 8) >>> 1;
}
var za = function(i, e, t) {
  for (var r = i.length, n = 0, s = new is(e); n < r; ++n)
    ++s[i[n] - 1];
  var a = new is(e);
  for (n = 0; n < e; ++n)
    a[n] = a[n - 1] + s[n - 1] << 1;
  var o;
  if (t) {
    o = new is(1 << e);
    var A = 15 - e;
    for (n = 0; n < r; ++n)
      if (i[n])
        for (var l = n << 4 | i[n], h = e - i[n], c = a[i[n] - 1]++ << h, u = c | (1 << h) - 1; c <= u; ++c)
          o[Y2[c] >>> A] = l;
  } else
    for (o = new is(r), n = 0; n < r; ++n)
      o[n] = Y2[a[i[n] - 1]++] >>> 15 - i[n];
  return o;
}, dl = new rs(288);
for (var oi = 0; oi < 144; ++oi)
  dl[oi] = 8;
for (var oi = 144; oi < 256; ++oi)
  dl[oi] = 9;
for (var oi = 256; oi < 280; ++oi)
  dl[oi] = 7;
for (var oi = 280; oi < 288; ++oi)
  dl[oi] = 8;
var qd = new rs(32);
for (var oi = 0; oi < 32; ++oi)
  qd[oi] = 5;
var AX = /* @__PURE__ */ za(dl, 9, 0), lX = /* @__PURE__ */ za(dl, 9, 1), hX = /* @__PURE__ */ za(qd, 5, 0), cX = /* @__PURE__ */ za(qd, 5, 1), t_ = function(i) {
  for (var e = i[0], t = 1; t < i.length; ++t)
    i[t] > e && (e = i[t]);
  return e;
}, da = function(i, e, t) {
  var r = e / 8 >> 0;
  return (i[r] | i[r + 1] << 8) >>> (e & 7) & t;
}, r_ = function(i, e) {
  var t = e / 8 >> 0;
  return (i[t] | i[t + 1] << 8 | i[t + 2] << 16) >>> (e & 7);
}, uB = function(i) {
  return (i / 8 >> 0) + (i & 7 && 1);
}, q4 = function(i, e, t) {
  (e == null || e < 0) && (e = 0), (t == null || t > i.length) && (t = i.length);
  var r = new (i instanceof is ? is : i instanceof Yd ? Yd : rs)(t - e);
  return r.set(i.subarray(e, t)), r;
}, uX = function(i, e, t) {
  var r = i.length, n = !e || t, s = !t || t.i;
  t || (t = {}), e || (e = new rs(r * 3));
  var a = function(ie) {
    var ue = e.length;
    if (ie > ue) {
      var fe = new rs(Math.max(ue * 2, ie));
      fe.set(e), e = fe;
    }
  }, o = t.f || 0, A = t.p || 0, l = t.b || 0, h = t.l, c = t.d, u = t.m, f = t.n, g = r * 8;
  do {
    if (!h) {
      t.f = o = da(i, A, 1);
      var p = da(i, A + 1, 3);
      if (A += 3, p)
        if (p == 1)
          h = lX, c = cX, u = 9, f = 5;
        else if (p == 2) {
          var C = da(i, A, 31) + 257, E = da(i, A + 10, 15) + 4, S = C + da(i, A + 5, 31) + 1;
          A += 14;
          for (var M = new rs(S), T = new rs(19), F = 0; F < E; ++F)
            T[X2[F]] = da(i, A + F * 3, 7);
          A += E * 3;
          var k = t_(T), $ = (1 << k) - 1;
          if (!s && A + S * (k + 7) > g)
            break;
          for (var I = za(T, k, 1), F = 0; F < S; ) {
            var L = I[da(i, A, $)];
            A += L & 15;
            var y = L >>> 4;
            if (y < 16)
              M[F++] = y;
            else {
              var P = 0, Q = 0;
              for (y == 16 ? (Q = 3 + da(i, A, 3), A += 2, P = M[F - 1]) : y == 17 ? (Q = 3 + da(i, A, 7), A += 3) : y == 18 && (Q = 11 + da(i, A, 127), A += 7); Q--; )
                M[F++] = P;
            }
          }
          var X = M.subarray(0, C), W = M.subarray(C);
          u = t_(X), f = t_(W), h = za(X, u, 1), c = za(W, f, 1);
        } else
          throw "invalid block type";
      else {
        var y = uB(A) + 4, v = i[y - 4] | i[y - 3] << 8, w = y + v;
        if (w > r) {
          if (s)
            throw "unexpected EOF";
          break;
        }
        n && a(l + v), e.set(i.subarray(y, w), l), t.b = l += v, t.p = A = w * 8;
        continue;
      }
      if (A > g)
        throw "unexpected EOF";
    }
    n && a(l + 131072);
    for (var q = (1 << u) - 1, Z = (1 << f) - 1, oe = u + f + 18; s || A + oe < g; ) {
      var P = h[r_(i, A) & q], ne = P >>> 4;
      if (A += P & 15, A > g)
        throw "unexpected EOF";
      if (!P)
        throw "invalid length/literal";
      if (ne < 256)
        e[l++] = ne;
      else if (ne == 256) {
        h = null;
        break;
      } else {
        var me = ne - 254;
        if (ne > 264) {
          var F = ne - 257, b = ty[F];
          me = da(i, A, (1 << b) - 1) + W4[F], A += b;
        }
        var H = c[r_(i, A) & Z], V = H >>> 4;
        if (!H)
          throw "invalid distance";
        A += H & 15;
        var W = oX[V];
        if (V > 3) {
          var b = ry[V];
          W += r_(i, A) & (1 << b) - 1, A += b;
        }
        if (A > g)
          throw "unexpected EOF";
        n && a(l + 131072);
        for (var j = l + me; l < j; l += 4)
          e[l] = e[l - W], e[l + 1] = e[l + 1 - W], e[l + 2] = e[l + 2 - W], e[l + 3] = e[l + 3 - W];
        l = j;
      }
    }
    t.l = h, t.p = A, t.b = l, h && (o = 1, t.m = u, t.d = c, t.n = f);
  } while (!o);
  return l == e.length ? e : q4(e, 0, l);
}, bo = function(i, e, t) {
  t <<= e & 7;
  var r = e / 8 >> 0;
  i[r] |= t, i[r + 1] |= t >>> 8;
}, Mf = function(i, e, t) {
  t <<= e & 7;
  var r = e / 8 >> 0;
  i[r] |= t, i[r + 1] |= t >>> 8, i[r + 2] |= t >>> 16;
}, i_ = function(i, e) {
  for (var t = [], r = 0; r < i.length; ++r)
    i[r] && t.push({ s: r, f: i[r] });
  var n = t.length, s = t.slice();
  if (!n)
    return [new rs(0), 0];
  if (n == 1) {
    var a = new rs(t[0].s + 1);
    return a[t[0].s] = 1, [a, 1];
  }
  t.sort(function(S, M) {
    return S.f - M.f;
  }), t.push({ s: -1, f: 25001 });
  var o = t[0], A = t[1], l = 0, h = 1, c = 2;
  for (t[0] = { s: -1, f: o.f + A.f, l: o, r: A }; h != n - 1; )
    o = t[t[l].f < t[c].f ? l++ : c++], A = t[l != h && t[l].f < t[c].f ? l++ : c++], t[h++] = { s: -1, f: o.f + A.f, l: o, r: A };
  for (var u = s[0].s, r = 1; r < n; ++r)
    s[r].s > u && (u = s[r].s);
  var f = new is(u + 1), g = q2(t[h - 1], f, 0);
  if (g > e) {
    var r = 0, p = 0, y = g - e, v = 1 << y;
    for (s.sort(function(M, T) {
      return f[T.s] - f[M.s] || M.f - T.f;
    }); r < n; ++r) {
      var w = s[r].s;
      if (f[w] > e)
        p += v - (1 << g - f[w]), f[w] = e;
      else
        break;
    }
    for (p >>>= y; p > 0; ) {
      var C = s[r].s;
      f[C] < e ? p -= 1 << e - f[C]++ - 1 : ++r;
    }
    for (; r >= 0 && p; --r) {
      var E = s[r].s;
      f[E] == e && (--f[E], ++p);
    }
    g = e;
  }
  return [new rs(f), g];
}, q2 = function(i, e, t) {
  return i.s == -1 ? Math.max(q2(i.l, e, t + 1), q2(i.r, e, t + 1)) : e[i.s] = t;
}, V5 = function(i) {
  for (var e = i.length; e && !i[--e]; )
    ;
  for (var t = new is(++e), r = 0, n = i[0], s = 1, a = function(A) {
    t[r++] = A;
  }, o = 1; o <= e; ++o)
    if (i[o] == n && o != e)
      ++s;
    else {
      if (!n && s > 2) {
        for (; s > 138; s -= 138)
          a(32754);
        s > 2 && (a(s > 10 ? s - 11 << 5 | 28690 : s - 3 << 5 | 12305), s = 0);
      } else if (s > 3) {
        for (a(n), --s; s > 6; s -= 6)
          a(8304);
        s > 2 && (a(s - 3 << 5 | 8208), s = 0);
      }
      for (; s--; )
        a(n);
      s = 1, n = i[o];
    }
  return [t.subarray(0, r), e];
}, Nf = function(i, e) {
  for (var t = 0, r = 0; r < e.length; ++r)
    t += i[r] * e[r];
  return t;
}, z0 = function(i, e, t) {
  var r = t.length, n = uB(e + 2);
  i[n] = r & 255, i[n + 1] = r >>> 8, i[n + 2] = i[n] ^ 255, i[n + 3] = i[n + 1] ^ 255;
  for (var s = 0; s < r; ++s)
    i[n + s + 4] = t[s];
  return (n + 4 + r) * 8;
}, K5 = function(i, e, t, r, n, s, a, o, A, l, h) {
  bo(e, h++, t), ++n[256];
  for (var c = i_(n, 15), u = c[0], f = c[1], g = i_(s, 15), p = g[0], y = g[1], v = V5(u), w = v[0], C = v[1], E = V5(p), S = E[0], M = E[1], T = new is(19), F = 0; F < w.length; ++F)
    T[w[F] & 31]++;
  for (var F = 0; F < S.length; ++F)
    T[S[F] & 31]++;
  for (var k = i_(T, 7), $ = k[0], I = k[1], L = 19; L > 4 && !$[X2[L - 1]]; --L)
    ;
  var P = l + 5 << 3, Q = Nf(n, dl) + Nf(s, qd) + a, X = Nf(n, u) + Nf(s, p) + a + 14 + 3 * L + Nf(T, $) + (2 * T[16] + 3 * T[17] + 7 * T[18]);
  if (P <= Q && P <= X)
    return z0(e, h, i.subarray(A, A + l));
  var W, q, Z, oe;
  if (bo(e, h, 1 + (X < Q)), h += 2, X < Q) {
    W = za(u, f, 0), q = u, Z = za(p, y, 0), oe = p;
    var ne = za($, I, 0);
    bo(e, h, C - 257), bo(e, h + 5, M - 1), bo(e, h + 10, L - 4), h += 14;
    for (var F = 0; F < L; ++F)
      bo(e, h + 3 * F, $[X2[F]]);
    h += 3 * L;
    for (var me = [w, S], b = 0; b < 2; ++b)
      for (var H = me[b], F = 0; F < H.length; ++F) {
        var V = H[F] & 31;
        bo(e, h, ne[V]), h += $[V], V > 15 && (bo(e, h, H[F] >>> 5 & 127), h += H[F] >>> 12);
      }
  } else
    W = AX, q = dl, Z = hX, oe = qd;
  for (var F = 0; F < o; ++F)
    if (r[F] > 255) {
      var V = r[F] >>> 18 & 31;
      Mf(e, h, W[V + 257]), h += q[V + 257], V > 7 && (bo(e, h, r[F] >>> 23 & 31), h += ty[V]);
      var j = r[F] & 31;
      Mf(e, h, Z[j]), h += oe[j], j > 3 && (Mf(e, h, r[F] >>> 5 & 8191), h += ry[j]);
    } else
      Mf(e, h, W[r[F]]), h += q[r[F]];
  return Mf(e, h, W[256]), h + q[256];
}, fX = /* @__PURE__ */ new Yd([65540, 131080, 131088, 131104, 262176, 1048704, 1048832, 2114560, 2117632]), dX = /* @__PURE__ */ new rs(0), gX = function(i, e, t, r, n, s) {
  var a = i.length, o = new rs(r + a + 5 * (1 + Math.floor(a / 7e3)) + n), A = o.subarray(r, o.length - n), l = 0;
  if (!e || a < 8)
    for (var h = 0; h <= a; h += 65535) {
      var c = h + 65535;
      c < a ? l = z0(A, l, i.subarray(h, c)) : (A[h] = s, l = z0(A, l, i.subarray(h, a)));
    }
  else {
    for (var u = fX[e - 1], f = u >>> 13, g = u & 8191, p = (1 << t) - 1, y = new is(32768), v = new is(p + 1), w = Math.ceil(t / 3), C = 2 * w, E = function(We) {
      return (i[We] ^ i[We + 1] << w ^ i[We + 2] << C) & p;
    }, S = new Yd(25e3), M = new is(288), T = new is(32), F = 0, k = 0, h = 0, $ = 0, I = 0, L = 0; h < a; ++h) {
      var P = E(h), Q = h & 32767, X = v[P];
      if (y[Q] = X, v[P] = Q, I <= h) {
        var W = a - h;
        if ((F > 7e3 || $ > 24576) && W > 423) {
          l = K5(i, A, 0, S, M, T, k, $, L, h - L, l), $ = F = k = 0, L = h;
          for (var q = 0; q < 286; ++q)
            M[q] = 0;
          for (var q = 0; q < 30; ++q)
            T[q] = 0;
        }
        var Z = 2, oe = 0, ne = g, me = Q - X & 32767;
        if (W > 2 && P == E(h - me))
          for (var b = Math.min(f, W) - 1, H = Math.min(32767, h), V = Math.min(258, W); me <= H && --ne && Q != X; ) {
            if (i[h + Z] == i[h + Z - me]) {
              for (var j = 0; j < V && i[h + j] == i[h + j - me]; ++j)
                ;
              if (j > Z) {
                if (Z = j, oe = me, j > b)
                  break;
                for (var ie = Math.min(me, j - 2), ue = 0, q = 0; q < ie; ++q) {
                  var fe = h - me + q + 32768 & 32767, ee = y[fe], xe = fe - ee + 32768 & 32767;
                  xe > ue && (ue = xe, X = fe);
                }
              }
            }
            Q = X, X = y[Q], me += Q - X + 32768 & 32767;
          }
        if (oe) {
          S[$++] = 268435456 | W2[Z] << 18 | $5[oe];
          var Ee = W2[Z] & 31, Ue = $5[oe] & 31;
          k += ty[Ee] + ry[Ue], ++M[257 + Ee], ++T[Ue], I = h + Z, ++F;
        } else
          S[$++] = i[h], ++M[i[h]];
      }
    }
    l = K5(i, A, s, S, M, T, k, $, L, h - L, l), s || (l = z0(A, l, dX));
  }
  return q4(o, 0, r + uB(l) + n);
}, pX = function() {
  var i = 1, e = 0;
  return {
    p: function(t) {
      for (var r = i, n = e, s = t.length, a = 0; a != s; ) {
        for (var o = Math.min(a + 5552, s); a < o; ++a)
          r += t[a], n += r;
        r %= 65521, n %= 65521;
      }
      i = r, e = n;
    },
    d: function() {
      return (i >>> 8 << 16 | (e & 255) << 8 | e >>> 8) + ((i & 255) << 23) * 2;
    }
  };
}, mX = function(i, e, t, r, n) {
  return gX(i, e.level == null ? 6 : e.level, e.mem == null ? Math.ceil(Math.max(8, Math.min(13, Math.log(i.length))) * 1.5) : 12 + e.mem, t, r, !n);
}, vX = function(i, e, t) {
  for (; t; ++e)
    i[e] = t, t >>>= 8;
}, yX = function(i, e) {
  var t = e.level, r = t == 0 ? 0 : t < 6 ? 1 : t == 9 ? 3 : 2;
  i[0] = 120, i[1] = r << 6 | (r ? 32 - 2 * r : 1);
}, _X = function(i) {
  if ((i[0] & 15) != 8 || i[0] >>> 4 > 7 || (i[0] << 8 | i[1]) % 31)
    throw "invalid zlib data";
  if (i[1] & 32)
    throw "invalid zlib data: preset dictionaries not supported";
};
function Z2(i, e) {
  e === void 0 && (e = {});
  var t = pX();
  t.p(i);
  var r = mX(i, e, 2, 4);
  return yX(r, e), vX(r, r.length - 4, t.d()), r;
}
function wX(i, e) {
  return uX((_X(i), i.subarray(2, -4)), e);
}
/** @license
 *
 * jsPDF - PDF Document creation from JavaScript
 * Version 2.5.1 Built on 2022-01-28T15:37:57.791Z
 *                      CommitID 00000000
 *
 * Copyright (c) 2010-2021 James Hall <james@parall.ax>, https://github.com/MrRio/jsPDF
 *               2015-2021 yWorks GmbH, http://www.yworks.com
 *               2015-2021 Lukas Hollnder <lukas.hollaender@yworks.com>, https://github.com/HackbrettXXX
 *               2016-2018 Aras Abbasi <aras.abbasi@gmail.com>
 *               2010 Aaron Spike, https://github.com/acspike
 *               2012 Willow Systems Corporation, https://github.com/willowsystems
 *               2012 Pablo Hess, https://github.com/pablohess
 *               2012 Florian Jenett, https://github.com/fjenett
 *               2013 Warren Weckesser, https://github.com/warrenweckesser
 *               2013 Youssef Beddad, https://github.com/lifof
 *               2013 Lee Driscoll, https://github.com/lsdriscoll
 *               2013 Stefan Slonevskiy, https://github.com/stefslon
 *               2013 Jeremy Morel, https://github.com/jmorel
 *               2013 Christoph Hartmann, https://github.com/chris-rock
 *               2014 Juan Pablo Gaviria, https://github.com/juanpgaviria
 *               2014 James Makes, https://github.com/dollaruw
 *               2014 Diego Casorran, https://github.com/diegocr
 *               2014 Steven Spungin, https://github.com/Flamenco
 *               2014 Kenneth Glassey, https://github.com/Gavvers
 *
 * Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files (the
 * "Software"), to deal in the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 *
 * The above copyright notice and this permission notice shall be
 * included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
 * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
 * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
 * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 *
 * Contributor(s):
 *    siefkenj, ahwolf, rickygu, Midnith, saintclair, eaparango,
 *    kim3er, mfo, alnorth, Flamenco
 */
var It = function() {
  return typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : this;
}();
function n_() {
  It.console && typeof It.console.log == "function" && It.console.log.apply(It.console, arguments);
}
var Yr = { log: n_, warn: function(i) {
  It.console && (typeof It.console.warn == "function" ? It.console.warn.apply(It.console, arguments) : n_.call(null, arguments));
}, error: function(i) {
  It.console && (typeof It.console.error == "function" ? It.console.error.apply(It.console, arguments) : n_(i));
} };
function s_(i, e, t) {
  var r = new XMLHttpRequest();
  r.open("GET", i), r.responseType = "blob", r.onload = function() {
    Hl(r.response, e, t);
  }, r.onerror = function() {
    Yr.error("could not download file");
  }, r.send();
}
function j5(i) {
  var e = new XMLHttpRequest();
  e.open("HEAD", i, !1);
  try {
    e.send();
  } catch {
  }
  return e.status >= 200 && e.status <= 299;
}
function Dp(i) {
  try {
    i.dispatchEvent(new MouseEvent("click"));
  } catch {
    var e = document.createEvent("MouseEvents");
    e.initMouseEvent("click", !0, !0, window, 0, 0, 0, 80, 20, !1, !1, !1, !1, 0, null), i.dispatchEvent(e);
  }
}
var dd, J2, Hl = It.saveAs || ((typeof window > "u" ? "undefined" : $r(window)) !== "object" || window !== It ? function() {
} : typeof HTMLAnchorElement < "u" && "download" in HTMLAnchorElement.prototype ? function(i, e, t) {
  var r = It.URL || It.webkitURL, n = document.createElement("a");
  e = e || i.name || "download", n.download = e, n.rel = "noopener", typeof i == "string" ? (n.href = i, n.origin !== location.origin ? j5(n.href) ? s_(i, e, t) : Dp(n, n.target = "_blank") : Dp(n)) : (n.href = r.createObjectURL(i), setTimeout(function() {
    r.revokeObjectURL(n.href);
  }, 4e4), setTimeout(function() {
    Dp(n);
  }, 0));
} : "msSaveOrOpenBlob" in navigator ? function(i, e, t) {
  if (e = e || i.name || "download", typeof i == "string")
    if (j5(i))
      s_(i, e, t);
    else {
      var r = document.createElement("a");
      r.href = i, r.target = "_blank", setTimeout(function() {
        Dp(r);
      });
    }
  else
    navigator.msSaveOrOpenBlob(function(n, s) {
      return s === void 0 ? s = { autoBom: !1 } : $r(s) !== "object" && (Yr.warn("Deprecated: Expected third argument to be a object"), s = { autoBom: !s }), s.autoBom && /^\s*(?:text\/\S*|application\/xml|\S*\/\S*\+xml)\s*;.*charset\s*=\s*utf-8/i.test(n.type) ? new Blob([String.fromCharCode(65279), n], { type: n.type }) : n;
    }(i, t), e);
} : function(i, e, t, r) {
  if ((r = r || open("", "_blank")) && (r.document.title = r.document.body.innerText = "downloading..."), typeof i == "string")
    return s_(i, e, t);
  var n = i.type === "application/octet-stream", s = /constructor/i.test(It.HTMLElement) || It.safari, a = /CriOS\/[\d]+/.test(navigator.userAgent);
  if ((a || n && s) && (typeof FileReader > "u" ? "undefined" : $r(FileReader)) === "object") {
    var o = new FileReader();
    o.onloadend = function() {
      var h = o.result;
      h = a ? h : h.replace(/^data:[^;]*;/, "data:attachment/file;"), r ? r.location.href = h : location = h, r = null;
    }, o.readAsDataURL(i);
  } else {
    var A = It.URL || It.webkitURL, l = A.createObjectURL(i);
    r ? r.location = l : location.href = l, r = null, setTimeout(function() {
      A.revokeObjectURL(l);
    }, 4e4);
  }
});
/**
 * A class to parse color values
 * @author Stoyan Stefanov <sstoo@gmail.com>
 * {@link   http://www.phpied.com/rgb-color-parser-in-javascript/}
 * @license Use it if you like it
 */
function Z4(i) {
  var e;
  i = i || "", this.ok = !1, i.charAt(0) == "#" && (i = i.substr(1, 6)), i = { aliceblue: "f0f8ff", antiquewhite: "faebd7", aqua: "00ffff", aquamarine: "7fffd4", azure: "f0ffff", beige: "f5f5dc", bisque: "ffe4c4", black: "000000", blanchedalmond: "ffebcd", blue: "0000ff", blueviolet: "8a2be2", brown: "a52a2a", burlywood: "deb887", cadetblue: "5f9ea0", chartreuse: "7fff00", chocolate: "d2691e", coral: "ff7f50", cornflowerblue: "6495ed", cornsilk: "fff8dc", crimson: "dc143c", cyan: "00ffff", darkblue: "00008b", darkcyan: "008b8b", darkgoldenrod: "b8860b", darkgray: "a9a9a9", darkgreen: "006400", darkkhaki: "bdb76b", darkmagenta: "8b008b", darkolivegreen: "556b2f", darkorange: "ff8c00", darkorchid: "9932cc", darkred: "8b0000", darksalmon: "e9967a", darkseagreen: "8fbc8f", darkslateblue: "483d8b", darkslategray: "2f4f4f", darkturquoise: "00ced1", darkviolet: "9400d3", deeppink: "ff1493", deepskyblue: "00bfff", dimgray: "696969", dodgerblue: "1e90ff", feldspar: "d19275", firebrick: "b22222", floralwhite: "fffaf0", forestgreen: "228b22", fuchsia: "ff00ff", gainsboro: "dcdcdc", ghostwhite: "f8f8ff", gold: "ffd700", goldenrod: "daa520", gray: "808080", green: "008000", greenyellow: "adff2f", honeydew: "f0fff0", hotpink: "ff69b4", indianred: "cd5c5c", indigo: "4b0082", ivory: "fffff0", khaki: "f0e68c", lavender: "e6e6fa", lavenderblush: "fff0f5", lawngreen: "7cfc00", lemonchiffon: "fffacd", lightblue: "add8e6", lightcoral: "f08080", lightcyan: "e0ffff", lightgoldenrodyellow: "fafad2", lightgrey: "d3d3d3", lightgreen: "90ee90", lightpink: "ffb6c1", lightsalmon: "ffa07a", lightseagreen: "20b2aa", lightskyblue: "87cefa", lightslateblue: "8470ff", lightslategray: "778899", lightsteelblue: "b0c4de", lightyellow: "ffffe0", lime: "00ff00", limegreen: "32cd32", linen: "faf0e6", magenta: "ff00ff", maroon: "800000", mediumaquamarine: "66cdaa", mediumblue: "0000cd", mediumorchid: "ba55d3", mediumpurple: "9370d8", mediumseagreen: "3cb371", mediumslateblue: "7b68ee", mediumspringgreen: "00fa9a", mediumturquoise: "48d1cc", mediumvioletred: "c71585", midnightblue: "191970", mintcream: "f5fffa", mistyrose: "ffe4e1", moccasin: "ffe4b5", navajowhite: "ffdead", navy: "000080", oldlace: "fdf5e6", olive: "808000", olivedrab: "6b8e23", orange: "ffa500", orangered: "ff4500", orchid: "da70d6", palegoldenrod: "eee8aa", palegreen: "98fb98", paleturquoise: "afeeee", palevioletred: "d87093", papayawhip: "ffefd5", peachpuff: "ffdab9", peru: "cd853f", pink: "ffc0cb", plum: "dda0dd", powderblue: "b0e0e6", purple: "800080", red: "ff0000", rosybrown: "bc8f8f", royalblue: "4169e1", saddlebrown: "8b4513", salmon: "fa8072", sandybrown: "f4a460", seagreen: "2e8b57", seashell: "fff5ee", sienna: "a0522d", silver: "c0c0c0", skyblue: "87ceeb", slateblue: "6a5acd", slategray: "708090", snow: "fffafa", springgreen: "00ff7f", steelblue: "4682b4", tan: "d2b48c", teal: "008080", thistle: "d8bfd8", tomato: "ff6347", turquoise: "40e0d0", violet: "ee82ee", violetred: "d02090", wheat: "f5deb3", white: "ffffff", whitesmoke: "f5f5f5", yellow: "ffff00", yellowgreen: "9acd32" }[i = (i = i.replace(/ /g, "")).toLowerCase()] || i;
  for (var t = [{ re: /^rgb\((\d{1,3}),\s*(\d{1,3}),\s*(\d{1,3})\)$/, example: ["rgb(123, 234, 45)", "rgb(255,234,245)"], process: function(o) {
    return [parseInt(o[1]), parseInt(o[2]), parseInt(o[3])];
  } }, { re: /^(\w{2})(\w{2})(\w{2})$/, example: ["#00ff00", "336699"], process: function(o) {
    return [parseInt(o[1], 16), parseInt(o[2], 16), parseInt(o[3], 16)];
  } }, { re: /^(\w{1})(\w{1})(\w{1})$/, example: ["#fb0", "f0f"], process: function(o) {
    return [parseInt(o[1] + o[1], 16), parseInt(o[2] + o[2], 16), parseInt(o[3] + o[3], 16)];
  } }], r = 0; r < t.length; r++) {
    var n = t[r].re, s = t[r].process, a = n.exec(i);
    a && (e = s(a), this.r = e[0], this.g = e[1], this.b = e[2], this.ok = !0);
  }
  this.r = this.r < 0 || isNaN(this.r) ? 0 : this.r > 255 ? 255 : this.r, this.g = this.g < 0 || isNaN(this.g) ? 0 : this.g > 255 ? 255 : this.g, this.b = this.b < 0 || isNaN(this.b) ? 0 : this.b > 255 ? 255 : this.b, this.toRGB = function() {
    return "rgb(" + this.r + ", " + this.g + ", " + this.b + ")";
  }, this.toHex = function() {
    var o = this.r.toString(16), A = this.g.toString(16), l = this.b.toString(16);
    return o.length == 1 && (o = "0" + o), A.length == 1 && (A = "0" + A), l.length == 1 && (l = "0" + l), "#" + o + A + l;
  };
}
/**
 * @license
 * Joseph Myers does not specify a particular license for his work.
 *
 * Author: Joseph Myers
 * Accessed from: http://www.myersdaily.org/joseph/javascript/md5.js
 *
 * Modified by: Owen Leong
 */
function a_(i, e) {
  var t = i[0], r = i[1], n = i[2], s = i[3];
  t = Qn(t, r, n, s, e[0], 7, -680876936), s = Qn(s, t, r, n, e[1], 12, -389564586), n = Qn(n, s, t, r, e[2], 17, 606105819), r = Qn(r, n, s, t, e[3], 22, -1044525330), t = Qn(t, r, n, s, e[4], 7, -176418897), s = Qn(s, t, r, n, e[5], 12, 1200080426), n = Qn(n, s, t, r, e[6], 17, -1473231341), r = Qn(r, n, s, t, e[7], 22, -45705983), t = Qn(t, r, n, s, e[8], 7, 1770035416), s = Qn(s, t, r, n, e[9], 12, -1958414417), n = Qn(n, s, t, r, e[10], 17, -42063), r = Qn(r, n, s, t, e[11], 22, -1990404162), t = Qn(t, r, n, s, e[12], 7, 1804603682), s = Qn(s, t, r, n, e[13], 12, -40341101), n = Qn(n, s, t, r, e[14], 17, -1502002290), t = Dn(t, r = Qn(r, n, s, t, e[15], 22, 1236535329), n, s, e[1], 5, -165796510), s = Dn(s, t, r, n, e[6], 9, -1069501632), n = Dn(n, s, t, r, e[11], 14, 643717713), r = Dn(r, n, s, t, e[0], 20, -373897302), t = Dn(t, r, n, s, e[5], 5, -701558691), s = Dn(s, t, r, n, e[10], 9, 38016083), n = Dn(n, s, t, r, e[15], 14, -660478335), r = Dn(r, n, s, t, e[4], 20, -405537848), t = Dn(t, r, n, s, e[9], 5, 568446438), s = Dn(s, t, r, n, e[14], 9, -1019803690), n = Dn(n, s, t, r, e[3], 14, -187363961), r = Dn(r, n, s, t, e[8], 20, 1163531501), t = Dn(t, r, n, s, e[13], 5, -1444681467), s = Dn(s, t, r, n, e[2], 9, -51403784), n = Dn(n, s, t, r, e[7], 14, 1735328473), t = kn(t, r = Dn(r, n, s, t, e[12], 20, -1926607734), n, s, e[5], 4, -378558), s = kn(s, t, r, n, e[8], 11, -2022574463), n = kn(n, s, t, r, e[11], 16, 1839030562), r = kn(r, n, s, t, e[14], 23, -35309556), t = kn(t, r, n, s, e[1], 4, -1530992060), s = kn(s, t, r, n, e[4], 11, 1272893353), n = kn(n, s, t, r, e[7], 16, -155497632), r = kn(r, n, s, t, e[10], 23, -1094730640), t = kn(t, r, n, s, e[13], 4, 681279174), s = kn(s, t, r, n, e[0], 11, -358537222), n = kn(n, s, t, r, e[3], 16, -722521979), r = kn(r, n, s, t, e[6], 23, 76029189), t = kn(t, r, n, s, e[9], 4, -640364487), s = kn(s, t, r, n, e[12], 11, -421815835), n = kn(n, s, t, r, e[15], 16, 530742520), t = Hn(t, r = kn(r, n, s, t, e[2], 23, -995338651), n, s, e[0], 6, -198630844), s = Hn(s, t, r, n, e[7], 10, 1126891415), n = Hn(n, s, t, r, e[14], 15, -1416354905), r = Hn(r, n, s, t, e[5], 21, -57434055), t = Hn(t, r, n, s, e[12], 6, 1700485571), s = Hn(s, t, r, n, e[3], 10, -1894986606), n = Hn(n, s, t, r, e[10], 15, -1051523), r = Hn(r, n, s, t, e[1], 21, -2054922799), t = Hn(t, r, n, s, e[8], 6, 1873313359), s = Hn(s, t, r, n, e[15], 10, -30611744), n = Hn(n, s, t, r, e[6], 15, -1560198380), r = Hn(r, n, s, t, e[13], 21, 1309151649), t = Hn(t, r, n, s, e[4], 6, -145523070), s = Hn(s, t, r, n, e[11], 10, -1120210379), n = Hn(n, s, t, r, e[2], 15, 718787259), r = Hn(r, n, s, t, e[9], 21, -343485551), i[0] = YA(t, i[0]), i[1] = YA(r, i[1]), i[2] = YA(n, i[2]), i[3] = YA(s, i[3]);
}
function iy(i, e, t, r, n, s) {
  return e = YA(YA(e, i), YA(r, s)), YA(e << n | e >>> 32 - n, t);
}
function Qn(i, e, t, r, n, s, a) {
  return iy(e & t | ~e & r, i, e, n, s, a);
}
function Dn(i, e, t, r, n, s, a) {
  return iy(e & r | t & ~r, i, e, n, s, a);
}
function kn(i, e, t, r, n, s, a) {
  return iy(e ^ t ^ r, i, e, n, s, a);
}
function Hn(i, e, t, r, n, s, a) {
  return iy(t ^ (e | ~r), i, e, n, s, a);
}
function J4(i) {
  var e, t = i.length, r = [1732584193, -271733879, -1732584194, 271733878];
  for (e = 64; e <= i.length; e += 64)
    a_(r, xX(i.substring(e - 64, e)));
  i = i.substring(e - 64);
  var n = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
  for (e = 0; e < i.length; e++)
    n[e >> 2] |= i.charCodeAt(e) << (e % 4 << 3);
  if (n[e >> 2] |= 128 << (e % 4 << 3), e > 55)
    for (a_(r, n), e = 0; e < 16; e++)
      n[e] = 0;
  return n[14] = 8 * t, a_(r, n), r;
}
function xX(i) {
  var e, t = [];
  for (e = 0; e < 64; e += 4)
    t[e >> 2] = i.charCodeAt(e) + (i.charCodeAt(e + 1) << 8) + (i.charCodeAt(e + 2) << 16) + (i.charCodeAt(e + 3) << 24);
  return t;
}
dd = It.atob.bind(It), J2 = It.btoa.bind(It);
var z5 = "0123456789abcdef".split("");
function CX(i) {
  for (var e = "", t = 0; t < 4; t++)
    e += z5[i >> 8 * t + 4 & 15] + z5[i >> 8 * t & 15];
  return e;
}
function EX(i) {
  return String.fromCharCode((255 & i) >> 0, (65280 & i) >> 8, (16711680 & i) >> 16, (4278190080 & i) >> 24);
}
function ex(i) {
  return J4(i).map(EX).join("");
}
var BX = function(i) {
  for (var e = 0; e < i.length; e++)
    i[e] = CX(i[e]);
  return i.join("");
}(J4("hello")) != "5d41402abc4b2a76b9719d911017c592";
function YA(i, e) {
  if (BX) {
    var t = (65535 & i) + (65535 & e);
    return (i >> 16) + (e >> 16) + (t >> 16) << 16 | 65535 & t;
  }
  return i + e & 4294967295;
}
/**
 * @license
 * FPDF is released under a permissive license: there is no usage restriction.
 * You may embed it freely in your application (commercial or not), with or
 * without modifications.
 *
 * Reference: http://www.fpdf.org/en/script/script37.php
 */
function tx(i, e) {
  var t, r, n, s;
  if (i !== t) {
    for (var a = (n = i, s = 1 + (256 / i.length >> 0), new Array(s + 1).join(n)), o = [], A = 0; A < 256; A++)
      o[A] = A;
    var l = 0;
    for (A = 0; A < 256; A++) {
      var h = o[A];
      l = (l + h + a.charCodeAt(A)) % 256, o[A] = o[l], o[l] = h;
    }
    t = i, r = o;
  } else
    o = r;
  var c = e.length, u = 0, f = 0, g = "";
  for (A = 0; A < c; A++)
    f = (f + (h = o[u = (u + 1) % 256])) % 256, o[u] = o[f], o[f] = h, a = o[(o[u] + o[f]) % 256], g += String.fromCharCode(e.charCodeAt(A) ^ a);
  return g;
}
/**
 * @license
 * Licensed under the MIT License.
 * http://opensource.org/licenses/mit-license
 * Author: Owen Leong (@owenl131)
 * Date: 15 Oct 2020
 * References:
 * https://www.cs.cmu.edu/~dst/Adobe/Gallery/anon21jul01-pdf-encryption.txt
 * https://github.com/foliojs/pdfkit/blob/master/lib/security.js
 * http://www.fpdf.org/en/script/script37.php
 */
var X5 = { print: 4, modify: 8, copy: 16, "annot-forms": 32 };
function Fc(i, e, t, r) {
  this.v = 1, this.r = 2;
  var n = 192;
  i.forEach(function(o) {
    if (X5.perm !== void 0)
      throw new Error("Invalid permission: " + o);
    n += X5[o];
  }), this.padding = "(N^NuAd\0NV\b..\0h>/\fdSiz";
  var s = (e + this.padding).substr(0, 32), a = (t + this.padding).substr(0, 32);
  this.O = this.processOwnerPassword(s, a), this.P = -(1 + (255 ^ n)), this.encryptionKey = ex(s + this.O + this.lsbFirstWord(this.P) + this.hexToBytes(r)).substr(0, 5), this.U = tx(this.encryptionKey, this.padding);
}
function Lc(i) {
  if (/[^\u0000-\u00ff]/.test(i))
    throw new Error("Invalid PDF Name Object: " + i + ", Only accept ASCII characters.");
  for (var e = "", t = i.length, r = 0; r < t; r++) {
    var n = i.charCodeAt(r);
    n < 33 || n === 35 || n === 37 || n === 40 || n === 41 || n === 47 || n === 60 || n === 62 || n === 91 || n === 93 || n === 123 || n === 125 || n > 126 ? e += "#" + ("0" + n.toString(16)).slice(-2) : e += i[r];
  }
  return e;
}
function W5(i) {
  if ($r(i) !== "object")
    throw new Error("Invalid Context passed to initialize PubSub (jsPDF-module)");
  var e = {};
  this.subscribe = function(t, r, n) {
    if (n = n || !1, typeof t != "string" || typeof r != "function" || typeof n != "boolean")
      throw new Error("Invalid arguments passed to PubSub.subscribe (jsPDF-module)");
    e.hasOwnProperty(t) || (e[t] = {});
    var s = Math.random().toString(35);
    return e[t][s] = [r, !!n], s;
  }, this.unsubscribe = function(t) {
    for (var r in e)
      if (e[r][t])
        return delete e[r][t], Object.keys(e[r]).length === 0 && delete e[r], !0;
    return !1;
  }, this.publish = function(t) {
    if (e.hasOwnProperty(t)) {
      var r = Array.prototype.slice.call(arguments, 1), n = [];
      for (var s in e[t]) {
        var a = e[t][s];
        try {
          a[0].apply(i, r);
        } catch (o) {
          It.console && Yr.error("jsPDF PubSub Error", o.message, o);
        }
        a[1] && n.push(s);
      }
      n.length && n.forEach(this.unsubscribe);
    }
  }, this.getTopics = function() {
    return e;
  };
}
function Wm(i) {
  if (!(this instanceof Wm))
    return new Wm(i);
  var e = "opacity,stroke-opacity".split(",");
  for (var t in i)
    i.hasOwnProperty(t) && e.indexOf(t) >= 0 && (this[t] = i[t]);
  this.id = "", this.objectNumber = -1;
}
function eN(i, e) {
  this.gState = i, this.matrix = e, this.id = "", this.objectNumber = -1;
}
function $l(i, e, t, r, n) {
  if (!(this instanceof $l))
    return new $l(i, e, t, r, n);
  this.type = i === "axial" ? 2 : 3, this.coords = e, this.colors = t, eN.call(this, r, n);
}
function Gc(i, e, t, r, n) {
  if (!(this instanceof Gc))
    return new Gc(i, e, t, r, n);
  this.boundingBox = i, this.xStep = e, this.yStep = t, this.stream = "", this.cloneIndex = 0, eN.call(this, r, n);
}
function Lt(i) {
  var e, t = typeof arguments[0] == "string" ? arguments[0] : "p", r = arguments[1], n = arguments[2], s = arguments[3], a = [], o = 1, A = 16, l = "S", h = null;
  $r(i = i || {}) === "object" && (t = i.orientation, r = i.unit || r, n = i.format || n, s = i.compress || i.compressPdf || s, (h = i.encryption || null) !== null && (h.userPassword = h.userPassword || "", h.ownerPassword = h.ownerPassword || "", h.userPermissions = h.userPermissions || []), o = typeof i.userUnit == "number" ? Math.abs(i.userUnit) : 1, i.precision !== void 0 && (e = i.precision), i.floatPrecision !== void 0 && (A = i.floatPrecision), l = i.defaultPathOperation || "S"), a = i.filters || (s === !0 ? ["FlateEncode"] : a), r = r || "mm", t = ("" + (t || "P")).toLowerCase();
  var c = i.putOnlyUsedFonts || !1, u = {}, f = { internal: {}, __private__: {} };
  f.__private__.PubSub = W5;
  var g = "1.3", p = f.__private__.getPdfVersion = function() {
    return g;
  };
  f.__private__.setPdfVersion = function(_) {
    g = _;
  };
  var y = { a0: [2383.94, 3370.39], a1: [1683.78, 2383.94], a2: [1190.55, 1683.78], a3: [841.89, 1190.55], a4: [595.28, 841.89], a5: [419.53, 595.28], a6: [297.64, 419.53], a7: [209.76, 297.64], a8: [147.4, 209.76], a9: [104.88, 147.4], a10: [73.7, 104.88], b0: [2834.65, 4008.19], b1: [2004.09, 2834.65], b2: [1417.32, 2004.09], b3: [1000.63, 1417.32], b4: [708.66, 1000.63], b5: [498.9, 708.66], b6: [354.33, 498.9], b7: [249.45, 354.33], b8: [175.75, 249.45], b9: [124.72, 175.75], b10: [87.87, 124.72], c0: [2599.37, 3676.54], c1: [1836.85, 2599.37], c2: [1298.27, 1836.85], c3: [918.43, 1298.27], c4: [649.13, 918.43], c5: [459.21, 649.13], c6: [323.15, 459.21], c7: [229.61, 323.15], c8: [161.57, 229.61], c9: [113.39, 161.57], c10: [79.37, 113.39], dl: [311.81, 623.62], letter: [612, 792], "government-letter": [576, 756], legal: [612, 1008], "junior-legal": [576, 360], ledger: [1224, 792], tabloid: [792, 1224], "credit-card": [153, 243] };
  f.__private__.getPageFormats = function() {
    return y;
  };
  var v = f.__private__.getPageFormat = function(_) {
    return y[_];
  };
  n = n || "a4";
  var w = { COMPAT: "compat", ADVANCED: "advanced" }, C = w.COMPAT;
  function E() {
    this.saveGraphicsState(), Y(new gt(Ne, 0, 0, -Ne, 0, gA() * Ne).toString() + " cm"), this.setFontSize(this.getFontSize() / Ne), l = "n", C = w.ADVANCED;
  }
  function S() {
    this.restoreGraphicsState(), l = "S", C = w.COMPAT;
  }
  var M = f.__private__.combineFontStyleAndFontWeight = function(_, N) {
    if (_ == "bold" && N == "normal" || _ == "bold" && N == 400 || _ == "normal" && N == "italic" || _ == "bold" && N == "italic")
      throw new Error("Invalid Combination of fontweight and fontstyle");
    return N && (_ = N == 400 || N === "normal" ? _ === "italic" ? "italic" : "normal" : N != 700 && N !== "bold" || _ !== "normal" ? (N == 700 ? "bold" : N) + "" + _ : "bold"), _;
  };
  f.advancedAPI = function(_) {
    var N = C === w.COMPAT;
    return N && E.call(this), typeof _ != "function" || (_(this), N && S.call(this)), this;
  }, f.compatAPI = function(_) {
    var N = C === w.ADVANCED;
    return N && S.call(this), typeof _ != "function" || (_(this), N && E.call(this)), this;
  }, f.isAdvancedAPI = function() {
    return C === w.ADVANCED;
  };
  var T, F = function(_) {
    if (C !== w.ADVANCED)
      throw new Error(_ + " is only available in 'advanced' API mode. You need to call advancedAPI() first.");
  }, k = f.roundToPrecision = f.__private__.roundToPrecision = function(_, N) {
    var z = e || N;
    if (isNaN(_) || isNaN(z))
      throw new Error("Invalid argument passed to jsPDF.roundToPrecision");
    return _.toFixed(z).replace(/0+$/, "");
  };
  T = f.hpf = f.__private__.hpf = typeof A == "number" ? function(_) {
    if (isNaN(_))
      throw new Error("Invalid argument passed to jsPDF.hpf");
    return k(_, A);
  } : A === "smart" ? function(_) {
    if (isNaN(_))
      throw new Error("Invalid argument passed to jsPDF.hpf");
    return k(_, _ > -1 && _ < 1 ? 16 : 5);
  } : function(_) {
    if (isNaN(_))
      throw new Error("Invalid argument passed to jsPDF.hpf");
    return k(_, 16);
  };
  var $ = f.f2 = f.__private__.f2 = function(_) {
    if (isNaN(_))
      throw new Error("Invalid argument passed to jsPDF.f2");
    return k(_, 2);
  }, I = f.__private__.f3 = function(_) {
    if (isNaN(_))
      throw new Error("Invalid argument passed to jsPDF.f3");
    return k(_, 3);
  }, L = f.scale = f.__private__.scale = function(_) {
    if (isNaN(_))
      throw new Error("Invalid argument passed to jsPDF.scale");
    return C === w.COMPAT ? _ * Ne : C === w.ADVANCED ? _ : void 0;
  }, P = function(_) {
    return C === w.COMPAT ? gA() - _ : C === w.ADVANCED ? _ : void 0;
  }, Q = function(_) {
    return L(P(_));
  };
  f.__private__.setPrecision = f.setPrecision = function(_) {
    typeof parseInt(_, 10) == "number" && (e = parseInt(_, 10));
  };
  var X, W = "00000000000000000000000000000000", q = f.__private__.getFileId = function() {
    return W;
  }, Z = f.__private__.setFileId = function(_) {
    return W = _ !== void 0 && /^[a-fA-F0-9]{32}$/.test(_) ? _.toUpperCase() : W.split("").map(function() {
      return "ABCDEF0123456789".charAt(Math.floor(16 * Math.random()));
    }).join(""), h !== null && (Pn = new Fc(h.userPermissions, h.userPassword, h.ownerPassword, W)), W;
  };
  f.setFileId = function(_) {
    return Z(_), this;
  }, f.getFileId = function() {
    return q();
  };
  var oe = f.__private__.convertDateToPDFDate = function(_) {
    var N = _.getTimezoneOffset(), z = N < 0 ? "+" : "-", re = Math.floor(Math.abs(N / 60)), de = Math.abs(N % 60), _e = [z, V(re), "'", V(de), "'"].join("");
    return ["D:", _.getFullYear(), V(_.getMonth() + 1), V(_.getDate()), V(_.getHours()), V(_.getMinutes()), V(_.getSeconds()), _e].join("");
  }, ne = f.__private__.convertPDFDateToDate = function(_) {
    var N = parseInt(_.substr(2, 4), 10), z = parseInt(_.substr(6, 2), 10) - 1, re = parseInt(_.substr(8, 2), 10), de = parseInt(_.substr(10, 2), 10), _e = parseInt(_.substr(12, 2), 10), Oe = parseInt(_.substr(14, 2), 10);
    return new Date(N, z, re, de, _e, Oe, 0);
  }, me = f.__private__.setCreationDate = function(_) {
    var N;
    if (_ === void 0 && (_ = /* @__PURE__ */ new Date()), _ instanceof Date)
      N = oe(_);
    else {
      if (!/^D:(20[0-2][0-9]|203[0-7]|19[7-9][0-9])(0[0-9]|1[0-2])([0-2][0-9]|3[0-1])(0[0-9]|1[0-9]|2[0-3])(0[0-9]|[1-5][0-9])(0[0-9]|[1-5][0-9])(\+0[0-9]|\+1[0-4]|-0[0-9]|-1[0-1])'(0[0-9]|[1-5][0-9])'?$/.test(_))
        throw new Error("Invalid argument passed to jsPDF.setCreationDate");
      N = _;
    }
    return X = N;
  }, b = f.__private__.getCreationDate = function(_) {
    var N = X;
    return _ === "jsDate" && (N = ne(X)), N;
  };
  f.setCreationDate = function(_) {
    return me(_), this;
  }, f.getCreationDate = function(_) {
    return b(_);
  };
  var H, V = f.__private__.padd2 = function(_) {
    return ("0" + parseInt(_)).slice(-2);
  }, j = f.__private__.padd2Hex = function(_) {
    return ("00" + (_ = _.toString())).substr(_.length);
  }, ie = 0, ue = [], fe = [], ee = 0, xe = [], Ee = [], Ue = !1, ke = fe, We = function() {
    ie = 0, ee = 0, fe = [], ue = [], xe = [], nt = ni(), he = ni();
  };
  f.__private__.setCustomOutputDestination = function(_) {
    Ue = !0, ke = _;
  };
  var ve = function(_) {
    Ue || (ke = _);
  };
  f.__private__.resetCustomOutputDestination = function() {
    Ue = !1, ke = fe;
  };
  var Y = f.__private__.out = function(_) {
    return _ = _.toString(), ee += _.length + 1, ke.push(_), ke;
  }, mt = f.__private__.write = function(_) {
    return Y(arguments.length === 1 ? _.toString() : Array.prototype.join.call(arguments, " "));
  }, Ze = f.__private__.getArrayBuffer = function(_) {
    for (var N = _.length, z = new ArrayBuffer(N), re = new Uint8Array(z); N--; )
      re[N] = _.charCodeAt(N);
    return z;
  }, Fe = [["Helvetica", "helvetica", "normal", "WinAnsiEncoding"], ["Helvetica-Bold", "helvetica", "bold", "WinAnsiEncoding"], ["Helvetica-Oblique", "helvetica", "italic", "WinAnsiEncoding"], ["Helvetica-BoldOblique", "helvetica", "bolditalic", "WinAnsiEncoding"], ["Courier", "courier", "normal", "WinAnsiEncoding"], ["Courier-Bold", "courier", "bold", "WinAnsiEncoding"], ["Courier-Oblique", "courier", "italic", "WinAnsiEncoding"], ["Courier-BoldOblique", "courier", "bolditalic", "WinAnsiEncoding"], ["Times-Roman", "times", "normal", "WinAnsiEncoding"], ["Times-Bold", "times", "bold", "WinAnsiEncoding"], ["Times-Italic", "times", "italic", "WinAnsiEncoding"], ["Times-BoldItalic", "times", "bolditalic", "WinAnsiEncoding"], ["ZapfDingbats", "zapfdingbats", "normal", null], ["Symbol", "symbol", "normal", null]];
  f.__private__.getStandardFonts = function() {
    return Fe;
  };
  var Re = i.fontSize || 16;
  f.__private__.setFontSize = f.setFontSize = function(_) {
    return Re = C === w.ADVANCED ? _ / Ne : _, this;
  };
  var De, Le = f.__private__.getFontSize = f.getFontSize = function() {
    return C === w.COMPAT ? Re : Re * Ne;
  }, Ge = i.R2L || !1;
  f.__private__.setR2L = f.setR2L = function(_) {
    return Ge = _, this;
  }, f.__private__.getR2L = f.getR2L = function() {
    return Ge;
  };
  var ze, ft = f.__private__.setZoomMode = function(_) {
    var N = [void 0, null, "fullwidth", "fullheight", "fullpage", "original"];
    if (/^(?:\d+\.\d*|\d*\.\d+|\d+)%$/.test(_))
      De = _;
    else if (isNaN(_)) {
      if (N.indexOf(_) === -1)
        throw new Error('zoom must be Integer (e.g. 2), a percentage Value (e.g. 300%) or fullwidth, fullheight, fullpage, original. "' + _ + '" is not recognized.');
      De = _;
    } else
      De = parseInt(_, 10);
  };
  f.__private__.getZoomMode = function() {
    return De;
  };
  var Et, Mt = f.__private__.setPageMode = function(_) {
    if ([void 0, null, "UseNone", "UseOutlines", "UseThumbs", "FullScreen"].indexOf(_) == -1)
      throw new Error('Page mode must be one of UseNone, UseOutlines, UseThumbs, or FullScreen. "' + _ + '" is not recognized.');
    ze = _;
  };
  f.__private__.getPageMode = function() {
    return ze;
  };
  var Ut = f.__private__.setLayoutMode = function(_) {
    if ([void 0, null, "continuous", "single", "twoleft", "tworight", "two"].indexOf(_) == -1)
      throw new Error('Layout mode must be one of continuous, single, twoleft, tworight. "' + _ + '" is not recognized.');
    Et = _;
  };
  f.__private__.getLayoutMode = function() {
    return Et;
  }, f.__private__.setDisplayMode = f.setDisplayMode = function(_, N, z) {
    return ft(_), Ut(N), Mt(z), this;
  };
  var At = { title: "", subject: "", author: "", keywords: "", creator: "" };
  f.__private__.getDocumentProperty = function(_) {
    if (Object.keys(At).indexOf(_) === -1)
      throw new Error("Invalid argument passed to jsPDF.getDocumentProperty");
    return At[_];
  }, f.__private__.getDocumentProperties = function() {
    return At;
  }, f.__private__.setDocumentProperties = f.setProperties = f.setDocumentProperties = function(_) {
    for (var N in At)
      At.hasOwnProperty(N) && _[N] && (At[N] = _[N]);
    return this;
  }, f.__private__.setDocumentProperty = function(_, N) {
    if (Object.keys(At).indexOf(_) === -1)
      throw new Error("Invalid arguments passed to jsPDF.setDocumentProperty");
    return At[_] = N;
  };
  var vt, Ne, Qr, kt, fn, Ar = {}, Zt = {}, ii = [], Jt = {}, rn = {}, ar = {}, Ai = {}, yr = null, Lr = 0, bt = [], Ot = new W5(f), li = i.hotfixes || [], _r = {}, di = {}, zr = [], gt = function _(N, z, re, de, _e, Oe) {
    if (!(this instanceof _))
      return new _(N, z, re, de, _e, Oe);
    isNaN(N) && (N = 1), isNaN(z) && (z = 0), isNaN(re) && (re = 0), isNaN(de) && (de = 1), isNaN(_e) && (_e = 0), isNaN(Oe) && (Oe = 0), this._matrix = [N, z, re, de, _e, Oe];
  };
  Object.defineProperty(gt.prototype, "sx", { get: function() {
    return this._matrix[0];
  }, set: function(_) {
    this._matrix[0] = _;
  } }), Object.defineProperty(gt.prototype, "shy", { get: function() {
    return this._matrix[1];
  }, set: function(_) {
    this._matrix[1] = _;
  } }), Object.defineProperty(gt.prototype, "shx", { get: function() {
    return this._matrix[2];
  }, set: function(_) {
    this._matrix[2] = _;
  } }), Object.defineProperty(gt.prototype, "sy", { get: function() {
    return this._matrix[3];
  }, set: function(_) {
    this._matrix[3] = _;
  } }), Object.defineProperty(gt.prototype, "tx", { get: function() {
    return this._matrix[4];
  }, set: function(_) {
    this._matrix[4] = _;
  } }), Object.defineProperty(gt.prototype, "ty", { get: function() {
    return this._matrix[5];
  }, set: function(_) {
    this._matrix[5] = _;
  } }), Object.defineProperty(gt.prototype, "a", { get: function() {
    return this._matrix[0];
  }, set: function(_) {
    this._matrix[0] = _;
  } }), Object.defineProperty(gt.prototype, "b", { get: function() {
    return this._matrix[1];
  }, set: function(_) {
    this._matrix[1] = _;
  } }), Object.defineProperty(gt.prototype, "c", { get: function() {
    return this._matrix[2];
  }, set: function(_) {
    this._matrix[2] = _;
  } }), Object.defineProperty(gt.prototype, "d", { get: function() {
    return this._matrix[3];
  }, set: function(_) {
    this._matrix[3] = _;
  } }), Object.defineProperty(gt.prototype, "e", { get: function() {
    return this._matrix[4];
  }, set: function(_) {
    this._matrix[4] = _;
  } }), Object.defineProperty(gt.prototype, "f", { get: function() {
    return this._matrix[5];
  }, set: function(_) {
    this._matrix[5] = _;
  } }), Object.defineProperty(gt.prototype, "rotation", { get: function() {
    return Math.atan2(this.shx, this.sx);
  } }), Object.defineProperty(gt.prototype, "scaleX", { get: function() {
    return this.decompose().scale.sx;
  } }), Object.defineProperty(gt.prototype, "scaleY", { get: function() {
    return this.decompose().scale.sy;
  } }), Object.defineProperty(gt.prototype, "isIdentity", { get: function() {
    return this.sx === 1 && this.shy === 0 && this.shx === 0 && this.sy === 1 && this.tx === 0 && this.ty === 0;
  } }), gt.prototype.join = function(_) {
    return [this.sx, this.shy, this.shx, this.sy, this.tx, this.ty].map(T).join(_);
  }, gt.prototype.multiply = function(_) {
    var N = _.sx * this.sx + _.shy * this.shx, z = _.sx * this.shy + _.shy * this.sy, re = _.shx * this.sx + _.sy * this.shx, de = _.shx * this.shy + _.sy * this.sy, _e = _.tx * this.sx + _.ty * this.shx + this.tx, Oe = _.tx * this.shy + _.ty * this.sy + this.ty;
    return new gt(N, z, re, de, _e, Oe);
  }, gt.prototype.decompose = function() {
    var _ = this.sx, N = this.shy, z = this.shx, re = this.sy, de = this.tx, _e = this.ty, Oe = Math.sqrt(_ * _ + N * N), Je = (_ /= Oe) * z + (N /= Oe) * re;
    z -= _ * Je, re -= N * Je;
    var xt = Math.sqrt(z * z + re * re);
    return Je /= xt, _ * (re /= xt) < N * (z /= xt) && (_ = -_, N = -N, Je = -Je, Oe = -Oe), { scale: new gt(Oe, 0, 0, xt, 0, 0), translate: new gt(1, 0, 0, 1, de, _e), rotate: new gt(_, N, -N, _, 0, 0), skew: new gt(1, 0, Je, 1, 0, 0) };
  }, gt.prototype.toString = function(_) {
    return this.join(" ");
  }, gt.prototype.inversed = function() {
    var _ = this.sx, N = this.shy, z = this.shx, re = this.sy, de = this.tx, _e = this.ty, Oe = 1 / (_ * re - N * z), Je = re * Oe, xt = -N * Oe, Gt = -z * Oe, Yt = _ * Oe;
    return new gt(Je, xt, Gt, Yt, -Je * de - Gt * _e, -xt * de - Yt * _e);
  }, gt.prototype.applyToPoint = function(_) {
    var N = _.x * this.sx + _.y * this.shx + this.tx, z = _.x * this.shy + _.y * this.sy + this.ty;
    return new Gh(N, z);
  }, gt.prototype.applyToRectangle = function(_) {
    var N = this.applyToPoint(_), z = this.applyToPoint(new Gh(_.x + _.w, _.y + _.h));
    return new of(N.x, N.y, z.x - N.x, z.y - N.y);
  }, gt.prototype.clone = function() {
    var _ = this.sx, N = this.shy, z = this.shx, re = this.sy, de = this.tx, _e = this.ty;
    return new gt(_, N, z, re, de, _e);
  }, f.Matrix = gt;
  var Ci = f.matrixMult = function(_, N) {
    return N.multiply(_);
  }, fr = new gt(1, 0, 0, 1, 0, 0);
  f.unitMatrix = f.identityMatrix = fr;
  var Ir = function(_, N) {
    if (!rn[_]) {
      var z = (N instanceof $l ? "Sh" : "P") + (Object.keys(Jt).length + 1).toString(10);
      N.id = z, rn[_] = z, Jt[z] = N, Ot.publish("addPattern", N);
    }
  };
  f.ShadingPattern = $l, f.TilingPattern = Gc, f.addShadingPattern = function(_, N) {
    return F("addShadingPattern()"), Ir(_, N), this;
  }, f.beginTilingPattern = function(_) {
    F("beginTilingPattern()"), rp(_.boundingBox[0], _.boundingBox[1], _.boundingBox[2] - _.boundingBox[0], _.boundingBox[3] - _.boundingBox[1], _.matrix);
  }, f.endTilingPattern = function(_, N) {
    F("endTilingPattern()"), N.stream = Ee[H].join(`
`), Ir(_, N), Ot.publish("endTilingPattern", N), zr.pop().restore();
  };
  var Cr = f.__private__.newObject = function() {
    var _ = ni();
    return Nn(_, !0), _;
  }, ni = f.__private__.newObjectDeferred = function() {
    return ie++, ue[ie] = function() {
      return ee;
    }, ie;
  }, Nn = function(_, N) {
    return N = typeof N == "boolean" && N, ue[_] = ee, N && Y(_ + " 0 obj"), _;
  }, hA = f.__private__.newAdditionalObject = function() {
    var _ = { objId: ni(), content: "" };
    return xe.push(_), _;
  }, nt = ni(), he = ni(), Pe = f.__private__.decodeColorString = function(_) {
    var N = _.split(" ");
    if (N.length !== 2 || N[1] !== "g" && N[1] !== "G")
      N.length === 5 && (N[4] === "k" || N[4] === "K") && (N = [(1 - N[0]) * (1 - N[3]), (1 - N[1]) * (1 - N[3]), (1 - N[2]) * (1 - N[3]), "r"]);
    else {
      var z = parseFloat(N[0]);
      N = [z, z, z, "r"];
    }
    for (var re = "#", de = 0; de < 3; de++)
      re += ("0" + Math.floor(255 * parseFloat(N[de])).toString(16)).slice(-2);
    return re;
  }, Ke = f.__private__.encodeColorString = function(_) {
    var N;
    typeof _ == "string" && (_ = { ch1: _ });
    var z = _.ch1, re = _.ch2, de = _.ch3, _e = _.ch4, Oe = _.pdfColorType === "draw" ? ["G", "RG", "K"] : ["g", "rg", "k"];
    if (typeof z == "string" && z.charAt(0) !== "#") {
      var Je = new Z4(z);
      if (Je.ok)
        z = Je.toHex();
      else if (!/^\d*\.?\d*$/.test(z))
        throw new Error('Invalid color "' + z + '" passed to jsPDF.encodeColorString.');
    }
    if (typeof z == "string" && /^#[0-9A-Fa-f]{3}$/.test(z) && (z = "#" + z[1] + z[1] + z[2] + z[2] + z[3] + z[3]), typeof z == "string" && /^#[0-9A-Fa-f]{6}$/.test(z)) {
      var xt = parseInt(z.substr(1), 16);
      z = xt >> 16 & 255, re = xt >> 8 & 255, de = 255 & xt;
    }
    if (re === void 0 || _e === void 0 && z === re && re === de)
      if (typeof z == "string")
        N = z + " " + Oe[0];
      else
        switch (_.precision) {
          case 2:
            N = $(z / 255) + " " + Oe[0];
            break;
          case 3:
          default:
            N = I(z / 255) + " " + Oe[0];
        }
    else if (_e === void 0 || $r(_e) === "object") {
      if (_e && !isNaN(_e.a) && _e.a === 0)
        return N = ["1.", "1.", "1.", Oe[1]].join(" ");
      if (typeof z == "string")
        N = [z, re, de, Oe[1]].join(" ");
      else
        switch (_.precision) {
          case 2:
            N = [$(z / 255), $(re / 255), $(de / 255), Oe[1]].join(" ");
            break;
          default:
          case 3:
            N = [I(z / 255), I(re / 255), I(de / 255), Oe[1]].join(" ");
        }
    } else if (typeof z == "string")
      N = [z, re, de, _e, Oe[2]].join(" ");
    else
      switch (_.precision) {
        case 2:
          N = [$(z), $(re), $(de), $(_e), Oe[2]].join(" ");
          break;
        case 3:
        default:
          N = [I(z), I(re), I(de), I(_e), Oe[2]].join(" ");
      }
    return N;
  }, er = f.__private__.getFilters = function() {
    return a;
  }, Dr = f.__private__.putStream = function(_) {
    var N = (_ = _ || {}).data || "", z = _.filters || er(), re = _.alreadyAppliedFilters || [], de = _.addLength1 || !1, _e = N.length, Oe = _.objectId, Je = function(On) {
      return On;
    };
    if (h !== null && Oe === void 0)
      throw new Error("ObjectId must be passed to putStream for file encryption");
    h !== null && (Je = Pn.encryptor(Oe, 0));
    var xt = {};
    z === !0 && (z = ["FlateEncode"]);
    var Gt = _.additionalKeyValues || [], Yt = (xt = Lt.API.processDataByFilters !== void 0 ? Lt.API.processDataByFilters(N, z) : { data: N, reverseChain: [] }).reverseChain + (Array.isArray(re) ? re.join(" ") : re.toString());
    if (xt.data.length !== 0 && (Gt.push({ key: "Length", value: xt.data.length }), de === !0 && Gt.push({ key: "Length1", value: _e })), Yt.length != 0)
      if (Yt.split("/").length - 1 == 1)
        Gt.push({ key: "Filter", value: Yt });
      else {
        Gt.push({ key: "Filter", value: "[" + Yt + "]" });
        for (var vr = 0; vr < Gt.length; vr += 1)
          if (Gt[vr].key === "DecodeParms") {
            for (var gi = [], Ei = 0; Ei < xt.reverseChain.split("/").length - 1; Ei += 1)
              gi.push("null");
            gi.push(Gt[vr].value), Gt[vr].value = "[" + gi.join(" ") + "]";
          }
      }
    Y("<<");
    for (var $i = 0; $i < Gt.length; $i++)
      Y("/" + Gt[$i].key + " " + Gt[$i].value);
    Y(">>"), xt.data.length !== 0 && (Y("stream"), Y(Je(xt.data)), Y("endstream"));
  }, Xr = f.__private__.putPage = function(_) {
    var N = _.number, z = _.data, re = _.objId, de = _.contentsObjId;
    Nn(re, !0), Y("<</Type /Page"), Y("/Parent " + _.rootDictionaryObjId + " 0 R"), Y("/Resources " + _.resourceDictionaryObjId + " 0 R"), Y("/MediaBox [" + parseFloat(T(_.mediaBox.bottomLeftX)) + " " + parseFloat(T(_.mediaBox.bottomLeftY)) + " " + T(_.mediaBox.topRightX) + " " + T(_.mediaBox.topRightY) + "]"), _.cropBox !== null && Y("/CropBox [" + T(_.cropBox.bottomLeftX) + " " + T(_.cropBox.bottomLeftY) + " " + T(_.cropBox.topRightX) + " " + T(_.cropBox.topRightY) + "]"), _.bleedBox !== null && Y("/BleedBox [" + T(_.bleedBox.bottomLeftX) + " " + T(_.bleedBox.bottomLeftY) + " " + T(_.bleedBox.topRightX) + " " + T(_.bleedBox.topRightY) + "]"), _.trimBox !== null && Y("/TrimBox [" + T(_.trimBox.bottomLeftX) + " " + T(_.trimBox.bottomLeftY) + " " + T(_.trimBox.topRightX) + " " + T(_.trimBox.topRightY) + "]"), _.artBox !== null && Y("/ArtBox [" + T(_.artBox.bottomLeftX) + " " + T(_.artBox.bottomLeftY) + " " + T(_.artBox.topRightX) + " " + T(_.artBox.topRightY) + "]"), typeof _.userUnit == "number" && _.userUnit !== 1 && Y("/UserUnit " + _.userUnit), Ot.publish("putPage", { objId: re, pageContext: bt[N], pageNumber: N, page: z }), Y("/Contents " + de + " 0 R"), Y(">>"), Y("endobj");
    var _e = z.join(`
`);
    return C === w.ADVANCED && (_e += `
Q`), Nn(de, !0), Dr({ data: _e, filters: er(), objectId: de }), Y("endobj"), re;
  }, si = f.__private__.putPages = function() {
    var _, N, z = [];
    for (_ = 1; _ <= Lr; _++)
      bt[_].objId = ni(), bt[_].contentsObjId = ni();
    for (_ = 1; _ <= Lr; _++)
      z.push(Xr({ number: _, data: Ee[_], objId: bt[_].objId, contentsObjId: bt[_].contentsObjId, mediaBox: bt[_].mediaBox, cropBox: bt[_].cropBox, bleedBox: bt[_].bleedBox, trimBox: bt[_].trimBox, artBox: bt[_].artBox, userUnit: bt[_].userUnit, rootDictionaryObjId: nt, resourceDictionaryObjId: he }));
    Nn(nt, !0), Y("<</Type /Pages");
    var re = "/Kids [";
    for (N = 0; N < Lr; N++)
      re += z[N] + " 0 R ";
    Y(re + "]"), Y("/Count " + Lr), Y(">>"), Y("endobj"), Ot.publish("postPutPages");
  }, ia = function(_) {
    Ot.publish("putFont", { font: _, out: Y, newObject: Cr, putStream: Dr }), _.isAlreadyPutted !== !0 && (_.objectNumber = Cr(), Y("<<"), Y("/Type /Font"), Y("/BaseFont /" + Lc(_.postScriptName)), Y("/Subtype /Type1"), typeof _.encoding == "string" && Y("/Encoding /" + _.encoding), Y("/FirstChar 32"), Y("/LastChar 255"), Y(">>"), Y("endobj"));
  }, nn = function() {
    for (var _ in Ar)
      Ar.hasOwnProperty(_) && (c === !1 || c === !0 && u.hasOwnProperty(_)) && ia(Ar[_]);
  }, co = function(_) {
    _.objectNumber = Cr();
    var N = [];
    N.push({ key: "Type", value: "/XObject" }), N.push({ key: "Subtype", value: "/Form" }), N.push({ key: "BBox", value: "[" + [T(_.x), T(_.y), T(_.x + _.width), T(_.y + _.height)].join(" ") + "]" }), N.push({ key: "Matrix", value: "[" + _.matrix.toString() + "]" });
    var z = _.pages[1].join(`
`);
    Dr({ data: z, additionalKeyValues: N, objectId: _.objectNumber }), Y("endobj");
  }, cA = function() {
    for (var _ in _r)
      _r.hasOwnProperty(_) && co(_r[_]);
  }, Wu = function(_, N) {
    var z, re = [], de = 1 / (N - 1);
    for (z = 0; z < 1; z += de)
      re.push(z);
    if (re.push(1), _[0].offset != 0) {
      var _e = { offset: 0, color: _[0].color };
      _.unshift(_e);
    }
    if (_[_.length - 1].offset != 1) {
      var Oe = { offset: 1, color: _[_.length - 1].color };
      _.push(Oe);
    }
    for (var Je = "", xt = 0, Gt = 0; Gt < re.length; Gt++) {
      for (z = re[Gt]; z > _[xt + 1].offset; )
        xt++;
      var Yt = _[xt].offset, vr = (z - Yt) / (_[xt + 1].offset - Yt), gi = _[xt].color, Ei = _[xt + 1].color;
      Je += j(Math.round((1 - vr) * gi[0] + vr * Ei[0]).toString(16)) + j(Math.round((1 - vr) * gi[1] + vr * Ei[1]).toString(16)) + j(Math.round((1 - vr) * gi[2] + vr * Ei[2]).toString(16));
    }
    return Je.trim();
  }, ky = function(_, N) {
    N || (N = 21);
    var z = Cr(), re = Wu(_.colors, N), de = [];
    de.push({ key: "FunctionType", value: "0" }), de.push({ key: "Domain", value: "[0.0 1.0]" }), de.push({ key: "Size", value: "[" + N + "]" }), de.push({ key: "BitsPerSample", value: "8" }), de.push({ key: "Range", value: "[0.0 1.0 0.0 1.0 0.0 1.0]" }), de.push({ key: "Decode", value: "[0.0 1.0 0.0 1.0 0.0 1.0]" }), Dr({ data: re, additionalKeyValues: de, alreadyAppliedFilters: ["/ASCIIHexDecode"], objectId: z }), Y("endobj"), _.objectNumber = Cr(), Y("<< /ShadingType " + _.type), Y("/ColorSpace /DeviceRGB");
    var _e = "/Coords [" + T(parseFloat(_.coords[0])) + " " + T(parseFloat(_.coords[1])) + " ";
    _.type === 2 ? _e += T(parseFloat(_.coords[2])) + " " + T(parseFloat(_.coords[3])) : _e += T(parseFloat(_.coords[2])) + " " + T(parseFloat(_.coords[3])) + " " + T(parseFloat(_.coords[4])) + " " + T(parseFloat(_.coords[5])), Y(_e += "]"), _.matrix && Y("/Matrix [" + _.matrix.toString() + "]"), Y("/Function " + z + " 0 R"), Y("/Extend [true true]"), Y(">>"), Y("endobj");
  }, Hy = function(_, N) {
    var z = ni(), re = Cr();
    N.push({ resourcesOid: z, objectOid: re }), _.objectNumber = re;
    var de = [];
    de.push({ key: "Type", value: "/Pattern" }), de.push({ key: "PatternType", value: "1" }), de.push({ key: "PaintType", value: "1" }), de.push({ key: "TilingType", value: "1" }), de.push({ key: "BBox", value: "[" + _.boundingBox.map(T).join(" ") + "]" }), de.push({ key: "XStep", value: T(_.xStep) }), de.push({ key: "YStep", value: T(_.yStep) }), de.push({ key: "Resources", value: z + " 0 R" }), _.matrix && de.push({ key: "Matrix", value: "[" + _.matrix.toString() + "]" }), Dr({ data: _.stream, additionalKeyValues: de, objectId: _.objectNumber }), Y("endobj");
  }, Nh = function(_) {
    var N;
    for (N in Jt)
      Jt.hasOwnProperty(N) && (Jt[N] instanceof $l ? ky(Jt[N]) : Jt[N] instanceof Gc && Hy(Jt[N], _));
  }, Dg = function(_) {
    for (var N in _.objectNumber = Cr(), Y("<<"), _)
      switch (N) {
        case "opacity":
          Y("/ca " + $(_[N]));
          break;
        case "stroke-opacity":
          Y("/CA " + $(_[N]));
      }
    Y(">>"), Y("endobj");
  }, Gy = function() {
    var _;
    for (_ in ar)
      ar.hasOwnProperty(_) && Dg(ar[_]);
  }, Yu = function() {
    for (var _ in Y("/XObject <<"), _r)
      _r.hasOwnProperty(_) && _r[_].objectNumber >= 0 && Y("/" + _ + " " + _r[_].objectNumber + " 0 R");
    Ot.publish("putXobjectDict"), Y(">>");
  }, $y = function() {
    Pn.oid = Cr(), Y("<<"), Y("/Filter /Standard"), Y("/V " + Pn.v), Y("/R " + Pn.r), Y("/U <" + Pn.toHexString(Pn.U) + ">"), Y("/O <" + Pn.toHexString(Pn.O) + ">"), Y("/P " + Pn.P), Y(">>"), Y("endobj");
  }, kg = function() {
    for (var _ in Y("/Font <<"), Ar)
      Ar.hasOwnProperty(_) && (c === !1 || c === !0 && u.hasOwnProperty(_)) && Y("/" + _ + " " + Ar[_].objectNumber + " 0 R");
    Y(">>");
  }, Vy = function() {
    if (Object.keys(Jt).length > 0) {
      for (var _ in Y("/Shading <<"), Jt)
        Jt.hasOwnProperty(_) && Jt[_] instanceof $l && Jt[_].objectNumber >= 0 && Y("/" + _ + " " + Jt[_].objectNumber + " 0 R");
      Ot.publish("putShadingPatternDict"), Y(">>");
    }
  }, Ph = function(_) {
    if (Object.keys(Jt).length > 0) {
      for (var N in Y("/Pattern <<"), Jt)
        Jt.hasOwnProperty(N) && Jt[N] instanceof f.TilingPattern && Jt[N].objectNumber >= 0 && Jt[N].objectNumber < _ && Y("/" + N + " " + Jt[N].objectNumber + " 0 R");
      Ot.publish("putTilingPatternDict"), Y(">>");
    }
  }, Ky = function() {
    if (Object.keys(ar).length > 0) {
      var _;
      for (_ in Y("/ExtGState <<"), ar)
        ar.hasOwnProperty(_) && ar[_].objectNumber >= 0 && Y("/" + _ + " " + ar[_].objectNumber + " 0 R");
      Ot.publish("putGStateDict"), Y(">>");
    }
  }, Ri = function(_) {
    Nn(_.resourcesOid, !0), Y("<<"), Y("/ProcSet [/PDF /Text /ImageB /ImageC /ImageI]"), kg(), Vy(), Ph(_.objectOid), Ky(), Yu(), Y(">>"), Y("endobj");
  }, Hg = function() {
    var _ = [];
    nn(), Gy(), cA(), Nh(_), Ot.publish("putResources"), _.forEach(Ri), Ri({ resourcesOid: he, objectOid: Number.MAX_SAFE_INTEGER }), Ot.publish("postPutResources");
  }, Gg = function() {
    Ot.publish("putAdditionalObjects");
    for (var _ = 0; _ < xe.length; _++) {
      var N = xe[_];
      Nn(N.objId, !0), Y(N.content), Y("endobj");
    }
    Ot.publish("postPutAdditionalObjects");
  }, $g = function(_) {
    Zt[_.fontName] = Zt[_.fontName] || {}, Zt[_.fontName][_.fontStyle] = _.id;
  }, qu = function(_, N, z, re, de) {
    var _e = { id: "F" + (Object.keys(Ar).length + 1).toString(10), postScriptName: _, fontName: N, fontStyle: z, encoding: re, isStandardFont: de || !1, metadata: {} };
    return Ot.publish("addFont", { font: _e, instance: this }), Ar[_e.id] = _e, $g(_e), _e.id;
  }, jy = function(_) {
    for (var N = 0, z = Fe.length; N < z; N++) {
      var re = qu.call(this, _[N][0], _[N][1], _[N][2], Fe[N][3], !0);
      c === !1 && (u[re] = !0);
      var de = _[N][0].split("-");
      $g({ id: re, fontName: de[0], fontStyle: de[1] || "" });
    }
    Ot.publish("addFonts", { fonts: Ar, dictionary: Zt });
  }, na = function(_) {
    return _.foo = function() {
      try {
        return _.apply(this, arguments);
      } catch (re) {
        var N = re.stack || "";
        ~N.indexOf(" at ") && (N = N.split(" at ")[1]);
        var z = "Error in function " + N.split(`
`)[0].split("<")[0] + ": " + re.message;
        if (!It.console)
          throw new Error(z);
        It.console.error(z, re), It.alert && alert(z);
      }
    }, _.foo.bar = _, _.foo;
  }, Oh = function(_, N) {
    var z, re, de, _e, Oe, Je, xt, Gt, Yt;
    if (de = (N = N || {}).sourceEncoding || "Unicode", Oe = N.outputEncoding, (N.autoencode || Oe) && Ar[vt].metadata && Ar[vt].metadata[de] && Ar[vt].metadata[de].encoding && (_e = Ar[vt].metadata[de].encoding, !Oe && Ar[vt].encoding && (Oe = Ar[vt].encoding), !Oe && _e.codePages && (Oe = _e.codePages[0]), typeof Oe == "string" && (Oe = _e[Oe]), Oe)) {
      for (xt = !1, Je = [], z = 0, re = _.length; z < re; z++)
        (Gt = Oe[_.charCodeAt(z)]) ? Je.push(String.fromCharCode(Gt)) : Je.push(_[z]), Je[z].charCodeAt(0) >> 8 && (xt = !0);
      _ = Je.join("");
    }
    for (z = _.length; xt === void 0 && z !== 0; )
      _.charCodeAt(z - 1) >> 8 && (xt = !0), z--;
    if (!xt)
      return _;
    for (Je = N.noBOM ? [] : [254, 255], z = 0, re = _.length; z < re; z++) {
      if ((Yt = (Gt = _.charCodeAt(z)) >> 8) >> 8)
        throw new Error("Character at position " + z + " of string '" + _ + "' exceeds 16bits. Cannot be encoded into UCS-2 BE");
      Je.push(Yt), Je.push(Gt - (Yt << 8));
    }
    return String.fromCharCode.apply(void 0, Je);
  }, as = f.__private__.pdfEscape = f.pdfEscape = function(_, N) {
    return Oh(_, N).replace(/\\/g, "\\\\").replace(/\(/g, "\\(").replace(/\)/g, "\\)");
  }, Zu = f.__private__.beginPage = function(_) {
    Ee[++Lr] = [], bt[Lr] = { objId: 0, contentsObjId: 0, userUnit: Number(o), artBox: null, bleedBox: null, cropBox: null, trimBox: null, mediaBox: { bottomLeftX: 0, bottomLeftY: 0, topRightX: Number(_[0]), topRightY: Number(_[1]) } }, Kg(Lr), ve(Ee[H]);
  }, Vg = function(_, N) {
    var z, re, de;
    switch (t = N || t, typeof _ == "string" && (z = v(_.toLowerCase()), Array.isArray(z) && (re = z[0], de = z[1])), Array.isArray(_) && (re = _[0] * Ne, de = _[1] * Ne), isNaN(re) && (re = n[0], de = n[1]), (re > 14400 || de > 14400) && (Yr.warn("A page in a PDF can not be wider or taller than 14400 userUnit. jsPDF limits the width/height to 14400"), re = Math.min(14400, re), de = Math.min(14400, de)), n = [re, de], t.substr(0, 1)) {
      case "l":
        de > re && (n = [de, re]);
        break;
      case "p":
        re > de && (n = [de, re]);
    }
    Zu(n), qg(rf), Y(sa), sf !== 0 && Y(sf + " J"), af !== 0 && Y(af + " j"), Ot.publish("addPage", { pageNumber: Lr });
  }, zy = function(_) {
    _ > 0 && _ <= Lr && (Ee.splice(_, 1), bt.splice(_, 1), Lr--, H > Lr && (H = Lr), this.setPage(H));
  }, Kg = function(_) {
    _ > 0 && _ <= Lr && (H = _);
  }, Xy = f.__private__.getNumberOfPages = f.getNumberOfPages = function() {
    return Ee.length - 1;
  }, jg = function(_, N, z) {
    var re, de = void 0;
    return z = z || {}, _ = _ !== void 0 ? _ : Ar[vt].fontName, N = N !== void 0 ? N : Ar[vt].fontStyle, re = _.toLowerCase(), Zt[re] !== void 0 && Zt[re][N] !== void 0 ? de = Zt[re][N] : Zt[_] !== void 0 && Zt[_][N] !== void 0 ? de = Zt[_][N] : z.disableWarning === !1 && Yr.warn("Unable to look up font label for font '" + _ + "', '" + N + "'. Refer to getFontList() for available fonts."), de || z.noFallback || (de = Zt.times[N]) == null && (de = Zt.times.normal), de;
  }, Wy = f.__private__.putInfo = function() {
    var _ = Cr(), N = function(re) {
      return re;
    };
    for (var z in h !== null && (N = Pn.encryptor(_, 0)), Y("<<"), Y("/Producer (" + as(N("jsPDF " + Lt.version)) + ")"), At)
      At.hasOwnProperty(z) && At[z] && Y("/" + z.substr(0, 1).toUpperCase() + z.substr(1) + " (" + as(N(At[z])) + ")");
    Y("/CreationDate (" + as(N(X)) + ")"), Y(">>"), Y("endobj");
  }, Ju = f.__private__.putCatalog = function(_) {
    var N = (_ = _ || {}).rootDictionaryObjId || nt;
    switch (Cr(), Y("<<"), Y("/Type /Catalog"), Y("/Pages " + N + " 0 R"), De || (De = "fullwidth"), De) {
      case "fullwidth":
        Y("/OpenAction [3 0 R /FitH null]");
        break;
      case "fullheight":
        Y("/OpenAction [3 0 R /FitV null]");
        break;
      case "fullpage":
        Y("/OpenAction [3 0 R /Fit]");
        break;
      case "original":
        Y("/OpenAction [3 0 R /XYZ null null 1]");
        break;
      default:
        var z = "" + De;
        z.substr(z.length - 1) === "%" && (De = parseInt(De) / 100), typeof De == "number" && Y("/OpenAction [3 0 R /XYZ null null " + $(De) + "]");
    }
    switch (Et || (Et = "continuous"), Et) {
      case "continuous":
        Y("/PageLayout /OneColumn");
        break;
      case "single":
        Y("/PageLayout /SinglePage");
        break;
      case "two":
      case "twoleft":
        Y("/PageLayout /TwoColumnLeft");
        break;
      case "tworight":
        Y("/PageLayout /TwoColumnRight");
    }
    ze && Y("/PageMode /" + ze), Ot.publish("putCatalog"), Y(">>"), Y("endobj");
  }, Yy = f.__private__.putTrailer = function() {
    Y("trailer"), Y("<<"), Y("/Size " + (ie + 1)), Y("/Root " + ie + " 0 R"), Y("/Info " + (ie - 1) + " 0 R"), h !== null && Y("/Encrypt " + Pn.oid + " 0 R"), Y("/ID [ <" + W + "> <" + W + "> ]"), Y(">>");
  }, qy = f.__private__.putHeader = function() {
    Y("%PDF-" + g), Y("%");
  }, Zy = f.__private__.putXRef = function() {
    var _ = "0000000000";
    Y("xref"), Y("0 " + (ie + 1)), Y("0000000000 65535 f ");
    for (var N = 1; N <= ie; N++)
      typeof ue[N] == "function" ? Y((_ + ue[N]()).slice(-10) + " 00000 n ") : ue[N] !== void 0 ? Y((_ + ue[N]).slice(-10) + " 00000 n ") : Y("0000000000 00000 n ");
  }, uo = f.__private__.buildDocument = function() {
    We(), ve(fe), Ot.publish("buildDocument"), qy(), si(), Gg(), Hg(), h !== null && $y(), Wy(), Ju();
    var _ = ee;
    return Zy(), Yy(), Y("startxref"), Y("" + _), Y("%%EOF"), ve(Ee[H]), fe.join(`
`);
  }, Uh = f.__private__.getBlob = function(_) {
    return new Blob([Ze(_)], { type: "application/pdf" });
  }, Qh = f.output = f.__private__.output = na(function(_, N) {
    switch (typeof (N = N || {}) == "string" ? N = { filename: N } : N.filename = N.filename || "generated.pdf", _) {
      case void 0:
        return uo();
      case "save":
        f.save(N.filename);
        break;
      case "arraybuffer":
        return Ze(uo());
      case "blob":
        return Uh(uo());
      case "bloburi":
      case "bloburl":
        if (It.URL !== void 0 && typeof It.URL.createObjectURL == "function")
          return It.URL && It.URL.createObjectURL(Uh(uo())) || void 0;
        Yr.warn("bloburl is not supported by your system, because URL.createObjectURL is not supported by your browser.");
        break;
      case "datauristring":
      case "dataurlstring":
        var z = "", re = uo();
        try {
          z = J2(re);
        } catch {
          z = J2(unescape(encodeURIComponent(re)));
        }
        return "data:application/pdf;filename=" + N.filename + ";base64," + z;
      case "pdfobjectnewwindow":
        if (Object.prototype.toString.call(It) === "[object Window]") {
          var de = "https://cdnjs.cloudflare.com/ajax/libs/pdfobject/2.1.1/pdfobject.min.js", _e = ' integrity="sha512-4ze/a9/4jqu+tX9dfOqJYSvyYd5M6qum/3HpCLr+/Jqf0whc37VUbkpNGHR7/8pSnCFw47T1fmIpwBV7UySh3g==" crossorigin="anonymous"';
          N.pdfObjectUrl && (de = N.pdfObjectUrl, _e = "");
          var Oe = '<html><style>html, body { padding: 0; margin: 0; } iframe { width: 100%; height: 100%; border: 0;}  </style><body><script src="' + de + '"' + _e + '><\/script><script >PDFObject.embed("' + this.output("dataurlstring") + '", ' + JSON.stringify(N) + ");<\/script></body></html>", Je = It.open();
          return Je !== null && Je.document.write(Oe), Je;
        }
        throw new Error("The option pdfobjectnewwindow just works in a browser-environment.");
      case "pdfjsnewwindow":
        if (Object.prototype.toString.call(It) === "[object Window]") {
          var xt = '<html><style>html, body { padding: 0; margin: 0; } iframe { width: 100%; height: 100%; border: 0;}  </style><body><iframe id="pdfViewer" src="' + (N.pdfJsUrl || "examples/PDF.js/web/viewer.html") + "?file=&downloadName=" + N.filename + '" width="500px" height="400px" /></body></html>', Gt = It.open();
          if (Gt !== null) {
            Gt.document.write(xt);
            var Yt = this;
            Gt.document.documentElement.querySelector("#pdfViewer").onload = function() {
              Gt.document.title = N.filename, Gt.document.documentElement.querySelector("#pdfViewer").contentWindow.PDFViewerApplication.open(Yt.output("bloburl"));
            };
          }
          return Gt;
        }
        throw new Error("The option pdfjsnewwindow just works in a browser-environment.");
      case "dataurlnewwindow":
        if (Object.prototype.toString.call(It) !== "[object Window]")
          throw new Error("The option dataurlnewwindow just works in a browser-environment.");
        var vr = '<html><style>html, body { padding: 0; margin: 0; } iframe { width: 100%; height: 100%; border: 0;}  </style><body><iframe src="' + this.output("datauristring", N) + '"></iframe></body></html>', gi = It.open();
        if (gi !== null && (gi.document.write(vr), gi.document.title = N.filename), gi || typeof safari > "u")
          return gi;
        break;
      case "datauri":
      case "dataurl":
        return It.document.location.href = this.output("datauristring", N);
      default:
        return null;
    }
  }), zg = function(_) {
    return Array.isArray(li) === !0 && li.indexOf(_) > -1;
  };
  switch (r) {
    case "pt":
      Ne = 1;
      break;
    case "mm":
      Ne = 72 / 25.4;
      break;
    case "cm":
      Ne = 72 / 2.54;
      break;
    case "in":
      Ne = 72;
      break;
    case "px":
      Ne = zg("px_scaling") == 1 ? 0.75 : 96 / 72;
      break;
    case "pc":
    case "em":
      Ne = 12;
      break;
    case "ex":
      Ne = 6;
      break;
    default:
      if (typeof r != "number")
        throw new Error("Invalid unit: " + r);
      Ne = r;
  }
  var Pn = null;
  me(), Z();
  var Jy = function(_) {
    return h !== null ? Pn.encryptor(_, 0) : function(N) {
      return N;
    };
  }, Xg = f.__private__.getPageInfo = f.getPageInfo = function(_) {
    if (isNaN(_) || _ % 1 != 0)
      throw new Error("Invalid argument passed to jsPDF.getPageInfo");
    return { objId: bt[_].objId, pageNumber: _, pageContext: bt[_] };
  }, Qt = f.__private__.getPageInfoByObjId = function(_) {
    if (isNaN(_) || _ % 1 != 0)
      throw new Error("Invalid argument passed to jsPDF.getPageInfoByObjId");
    for (var N in bt)
      if (bt[N].objId === _)
        break;
    return Xg(N);
  }, e1 = f.__private__.getCurrentPageInfo = f.getCurrentPageInfo = function() {
    return { objId: bt[H].objId, pageNumber: H, pageContext: bt[H] };
  };
  f.addPage = function() {
    return Vg.apply(this, arguments), this;
  }, f.setPage = function() {
    return Kg.apply(this, arguments), ve.call(this, Ee[H]), this;
  }, f.insertPage = function(_) {
    return this.addPage(), this.movePage(H, _), this;
  }, f.movePage = function(_, N) {
    var z, re;
    if (_ > N) {
      z = Ee[_], re = bt[_];
      for (var de = _; de > N; de--)
        Ee[de] = Ee[de - 1], bt[de] = bt[de - 1];
      Ee[N] = z, bt[N] = re, this.setPage(N);
    } else if (_ < N) {
      z = Ee[_], re = bt[_];
      for (var _e = _; _e < N; _e++)
        Ee[_e] = Ee[_e + 1], bt[_e] = bt[_e + 1];
      Ee[N] = z, bt[N] = re, this.setPage(N);
    }
    return this;
  }, f.deletePage = function() {
    return zy.apply(this, arguments), this;
  }, f.__private__.text = f.text = function(_, N, z, re, de) {
    var _e, Oe, Je, xt, Gt, Yt, vr, gi, Ei, $i = (re = re || {}).scope || this;
    if (typeof _ == "number" && typeof N == "number" && (typeof z == "string" || Array.isArray(z))) {
      var On = z;
      z = N, N = _, _ = On;
    }
    if (arguments[3] instanceof gt ? (F("The transform parameter of text() with a Matrix value"), Ei = de) : (Je = arguments[4], xt = arguments[5], $r(vr = arguments[3]) === "object" && vr !== null || (typeof Je == "string" && (xt = Je, Je = null), typeof vr == "string" && (xt = vr, vr = null), typeof vr == "number" && (Je = vr, vr = null), re = { flags: vr, angle: Je, align: xt })), isNaN(N) || isNaN(z) || _ == null)
      throw new Error("Invalid arguments passed to jsPDF.text");
    if (_.length === 0)
      return $i;
    var dn = "", aa = !1, Bs = typeof re.lineHeightFactor == "number" ? re.lineHeightFactor : Bl, go = $i.internal.scaleFactor;
    function ip(qr) {
      return qr = qr.split("	").join(Array(re.TabLen || 9).join(" ")), as(qr, vr);
    }
    function cf(qr) {
      for (var Zr, Mi = qr.concat(), sn = [], yo = Mi.length; yo--; )
        typeof (Zr = Mi.shift()) == "string" ? sn.push(Zr) : Array.isArray(qr) && (Zr.length === 1 || Zr[1] === void 0 && Zr[2] === void 0) ? sn.push(Zr[0]) : sn.push([Zr[0], Zr[1], Zr[2]]);
      return sn;
    }
    function uf(qr, Zr) {
      var Mi;
      if (typeof qr == "string")
        Mi = Zr(qr)[0];
      else if (Array.isArray(qr)) {
        for (var sn, yo, _A = qr.concat(), Zh = [], sp = _A.length; sp--; )
          typeof (sn = _A.shift()) == "string" ? Zh.push(Zr(sn)[0]) : Array.isArray(sn) && typeof sn[0] == "string" && (yo = Zr(sn[0], sn[1], sn[2]), Zh.push([yo[0], yo[1], yo[2]]));
        Mi = Zh;
      }
      return Mi;
    }
    var Vh = !1, ff = !0;
    if (typeof _ == "string")
      Vh = !0;
    else if (Array.isArray(_)) {
      var df = _.concat();
      Oe = [];
      for (var Kh, os = df.length; os--; )
        (typeof (Kh = df.shift()) != "string" || Array.isArray(Kh) && typeof Kh[0] != "string") && (ff = !1);
      Vh = ff;
    }
    if (Vh === !1)
      throw new Error('Type of text must be string or Array. "' + _ + '" is not recognized.');
    typeof _ == "string" && (_ = _.match(/[\r?\n]/) ? _.split(/\r\n|\r|\n/g) : [_]);
    var jh = Re / $i.internal.scaleFactor, zh = jh * (Bs - 1);
    switch (re.baseline) {
      case "bottom":
        z -= zh;
        break;
      case "top":
        z += jh - zh;
        break;
      case "hanging":
        z += jh - 2 * zh;
        break;
      case "middle":
        z += jh / 2 - zh;
    }
    if ((Yt = re.maxWidth || 0) > 0 && (typeof _ == "string" ? _ = $i.splitTextToSize(_, Yt) : Object.prototype.toString.call(_) === "[object Array]" && (_ = _.reduce(function(qr, Zr) {
      return qr.concat($i.splitTextToSize(Zr, Yt));
    }, []))), _e = { text: _, x: N, y: z, options: re, mutex: { pdfEscape: as, activeFontKey: vt, fonts: Ar, activeFontSize: Re } }, Ot.publish("preProcessText", _e), _ = _e.text, Je = (re = _e.options).angle, !(Ei instanceof gt) && Je && typeof Je == "number") {
      Je *= Math.PI / 180, re.rotationDirection === 0 && (Je = -Je), C === w.ADVANCED && (Je = -Je);
      var Xh = Math.cos(Je), gf = Math.sin(Je);
      Ei = new gt(Xh, gf, -gf, Xh, 0, 0);
    } else
      Je && Je instanceof gt && (Ei = Je);
    C !== w.ADVANCED || Ei || (Ei = fr), (Gt = re.charSpace || Hh) !== void 0 && (dn += T(L(Gt)) + ` Tc
`, this.setCharSpace(this.getCharSpace() || 0)), (gi = re.horizontalScale) !== void 0 && (dn += T(100 * gi) + ` Tz
`), re.lang;
    var As = -1, h1 = re.renderingMode !== void 0 ? re.renderingMode : re.stroke, pf = $i.internal.getCurrentPageInfo().pageContext;
    switch (h1) {
      case 0:
      case !1:
      case "fill":
        As = 0;
        break;
      case 1:
      case !0:
      case "stroke":
        As = 1;
        break;
      case 2:
      case "fillThenStroke":
        As = 2;
        break;
      case 3:
      case "invisible":
        As = 3;
        break;
      case 4:
      case "fillAndAddForClipping":
        As = 4;
        break;
      case 5:
      case "strokeAndAddPathForClipping":
        As = 5;
        break;
      case 6:
      case "fillThenStrokeAndAddToPathForClipping":
        As = 6;
        break;
      case 7:
      case "addToPathForClipping":
        As = 7;
    }
    var np = pf.usedRenderingMode !== void 0 ? pf.usedRenderingMode : -1;
    As !== -1 ? dn += As + ` Tr
` : np !== -1 && (dn += `0 Tr
`), As !== -1 && (pf.usedRenderingMode = As), xt = re.align || "left";
    var oa, mf = Re * Bs, c1 = $i.internal.pageSize.getWidth(), u1 = Ar[vt];
    Gt = re.charSpace || Hh, Yt = re.maxWidth || 0, vr = Object.assign({ autoencode: !0, noBOM: !0 }, re.flags);
    var pA = [];
    if (Object.prototype.toString.call(_) === "[object Array]") {
      var ks;
      Oe = cf(_), xt !== "left" && (oa = Oe.map(function(qr) {
        return $i.getStringUnitWidth(qr, { font: u1, charSpace: Gt, fontSize: Re, doKerning: !1 }) * Re / go;
      }));
      var Aa, mA = 0;
      if (xt === "right") {
        N -= oa[0], _ = [], os = Oe.length;
        for (var Ra = 0; Ra < os; Ra++)
          Ra === 0 ? (Aa = fo(N), ks = fA(z)) : (Aa = L(mA - oa[Ra]), ks = -mf), _.push([Oe[Ra], Aa, ks]), mA = oa[Ra];
      } else if (xt === "center") {
        N -= oa[0] / 2, _ = [], os = Oe.length;
        for (var po = 0; po < os; po++)
          po === 0 ? (Aa = fo(N), ks = fA(z)) : (Aa = L((mA - oa[po]) / 2), ks = -mf), _.push([Oe[po], Aa, ks]), mA = oa[po];
      } else if (xt === "left") {
        _ = [], os = Oe.length;
        for (var Wh = 0; Wh < os; Wh++)
          _.push(Oe[Wh]);
      } else {
        if (xt !== "justify")
          throw new Error('Unrecognized alignment option, use "left", "center", "right" or "justify".');
        _ = [], os = Oe.length, Yt = Yt !== 0 ? Yt : c1;
        for (var la = 0; la < os; la++)
          ks = la === 0 ? fA(z) : -mf, Aa = la === 0 ? fo(N) : 0, la < os - 1 ? pA.push(T(L((Yt - oa[la]) / (Oe[la].split(" ").length - 1)))) : pA.push(0), _.push([Oe[la], Aa, ks]);
      }
    }
    var Yh = typeof re.R2L == "boolean" ? re.R2L : Ge;
    Yh === !0 && (_ = uf(_, function(qr, Zr, Mi) {
      return [qr.split("").reverse().join(""), Zr, Mi];
    })), _e = { text: _, x: N, y: z, options: re, mutex: { pdfEscape: as, activeFontKey: vt, fonts: Ar, activeFontSize: Re } }, Ot.publish("postProcessText", _e), _ = _e.text, aa = _e.mutex.isHex || !1;
    var vf = Ar[vt].encoding;
    vf !== "WinAnsiEncoding" && vf !== "StandardEncoding" || (_ = uf(_, function(qr, Zr, Mi) {
      return [ip(qr), Zr, Mi];
    })), Oe = cf(_), _ = [];
    for (var vA, ha, mo, Tl = 0, qh = 1, Fl = Array.isArray(Oe[0]) ? qh : Tl, yA = "", yf = function(qr, Zr, Mi) {
      var sn = "";
      return Mi instanceof gt ? (Mi = typeof re.angle == "number" ? Ci(Mi, new gt(1, 0, 0, 1, qr, Zr)) : Ci(new gt(1, 0, 0, 1, qr, Zr), Mi), C === w.ADVANCED && (Mi = Ci(new gt(1, 0, 0, -1, 0, 0), Mi)), sn = Mi.join(" ") + ` Tm
`) : sn = T(qr) + " " + T(Zr) + ` Td
`, sn;
    }, Hs = 0; Hs < Oe.length; Hs++) {
      switch (yA = "", Fl) {
        case qh:
          mo = (aa ? "<" : "(") + Oe[Hs][0] + (aa ? ">" : ")"), vA = parseFloat(Oe[Hs][1]), ha = parseFloat(Oe[Hs][2]);
          break;
        case Tl:
          mo = (aa ? "<" : "(") + Oe[Hs] + (aa ? ">" : ")"), vA = fo(N), ha = fA(z);
      }
      pA !== void 0 && pA[Hs] !== void 0 && (yA = pA[Hs] + ` Tw
`), Hs === 0 ? _.push(yA + yf(vA, ha, Ei) + mo) : Fl === Tl ? _.push(yA + mo) : Fl === qh && _.push(yA + yf(vA, ha, Ei) + mo);
    }
    _ = Fl === Tl ? _.join(` Tj
T* `) : _.join(` Tj
`), _ += ` Tj
`;
    var vo = `BT
/`;
    return vo += vt + " " + Re + ` Tf
`, vo += T(Re * Bs) + ` TL
`, vo += bl + `
`, vo += dn, vo += _, Y(vo += "ET"), u[vt] = !0, $i;
  };
  var t1 = f.__private__.clip = f.clip = function(_) {
    return Y(_ === "evenodd" ? "W*" : "W"), this;
  };
  f.clipEvenOdd = function() {
    return t1("evenodd");
  }, f.__private__.discardPath = f.discardPath = function() {
    return Y("n"), this;
  };
  var Ia = f.__private__.isValidStyle = function(_) {
    var N = !1;
    return [void 0, null, "S", "D", "F", "DF", "FD", "f", "f*", "B", "B*", "n"].indexOf(_) !== -1 && (N = !0), N;
  };
  f.__private__.setDefaultPathOperation = f.setDefaultPathOperation = function(_) {
    return Ia(_) && (l = _), this;
  };
  var Wg = f.__private__.getStyle = f.getStyle = function(_) {
    var N = l;
    switch (_) {
      case "D":
      case "S":
        N = "S";
        break;
      case "F":
        N = "f";
        break;
      case "FD":
      case "DF":
        N = "B";
        break;
      case "f":
      case "f*":
      case "B":
      case "B*":
        N = _;
    }
    return N;
  }, Yg = f.close = function() {
    return Y("h"), this;
  };
  f.stroke = function() {
    return Y("S"), this;
  }, f.fill = function(_) {
    return Dh("f", _), this;
  }, f.fillEvenOdd = function(_) {
    return Dh("f*", _), this;
  }, f.fillStroke = function(_) {
    return Dh("B", _), this;
  }, f.fillStrokeEvenOdd = function(_) {
    return Dh("B*", _), this;
  };
  var Dh = function(_, N) {
    $r(N) === "object" ? i1(N, _) : Y(_);
  }, ef = function(_) {
    _ === null || C === w.ADVANCED && _ === void 0 || (_ = Wg(_), Y(_));
  };
  function r1(_, N, z, re, de) {
    var _e = new Gc(N || this.boundingBox, z || this.xStep, re || this.yStep, this.gState, de || this.matrix);
    _e.stream = this.stream;
    var Oe = _ + "$$" + this.cloneIndex++ + "$$";
    return Ir(Oe, _e), _e;
  }
  var i1 = function(_, N) {
    var z = rn[_.key], re = Jt[z];
    if (re instanceof $l)
      Y("q"), Y(n1(N)), re.gState && f.setGState(re.gState), Y(_.matrix.toString() + " cm"), Y("/" + z + " sh"), Y("Q");
    else if (re instanceof Gc) {
      var de = new gt(1, 0, 0, -1, 0, gA());
      _.matrix && (de = de.multiply(_.matrix || fr), z = r1.call(re, _.key, _.boundingBox, _.xStep, _.yStep, de).id), Y("q"), Y("/Pattern cs"), Y("/" + z + " scn"), re.gState && f.setGState(re.gState), Y(N), Y("Q");
    }
  }, n1 = function(_) {
    switch (_) {
      case "f":
      case "F":
        return "W n";
      case "f*":
        return "W* n";
      case "B":
        return "W S";
      case "B*":
        return "W* S";
      case "S":
        return "W S";
      case "n":
        return "W n";
    }
  }, tf = f.moveTo = function(_, N) {
    return Y(T(L(_)) + " " + T(Q(N)) + " m"), this;
  }, El = f.lineTo = function(_, N) {
    return Y(T(L(_)) + " " + T(Q(N)) + " l"), this;
  }, uA = f.curveTo = function(_, N, z, re, de, _e) {
    return Y([T(L(_)), T(Q(N)), T(L(z)), T(Q(re)), T(L(de)), T(Q(_e)), "c"].join(" ")), this;
  };
  f.__private__.line = f.line = function(_, N, z, re, de) {
    if (isNaN(_) || isNaN(N) || isNaN(z) || isNaN(re) || !Ia(de))
      throw new Error("Invalid arguments passed to jsPDF.line");
    return C === w.COMPAT ? this.lines([[z - _, re - N]], _, N, [1, 1], de || "S") : this.lines([[z - _, re - N]], _, N, [1, 1]).stroke();
  }, f.__private__.lines = f.lines = function(_, N, z, re, de, _e) {
    var Oe, Je, xt, Gt, Yt, vr, gi, Ei, $i, On, dn, aa;
    if (typeof _ == "number" && (aa = z, z = N, N = _, _ = aa), re = re || [1, 1], _e = _e || !1, isNaN(N) || isNaN(z) || !Array.isArray(_) || !Array.isArray(re) || !Ia(de) || typeof _e != "boolean")
      throw new Error("Invalid arguments passed to jsPDF.lines");
    for (tf(N, z), Oe = re[0], Je = re[1], Gt = _.length, On = N, dn = z, xt = 0; xt < Gt; xt++)
      (Yt = _[xt]).length === 2 ? (On = Yt[0] * Oe + On, dn = Yt[1] * Je + dn, El(On, dn)) : (vr = Yt[0] * Oe + On, gi = Yt[1] * Je + dn, Ei = Yt[2] * Oe + On, $i = Yt[3] * Je + dn, On = Yt[4] * Oe + On, dn = Yt[5] * Je + dn, uA(vr, gi, Ei, $i, On, dn));
    return _e && Yg(), ef(de), this;
  }, f.path = function(_) {
    for (var N = 0; N < _.length; N++) {
      var z = _[N], re = z.c;
      switch (z.op) {
        case "m":
          tf(re[0], re[1]);
          break;
        case "l":
          El(re[0], re[1]);
          break;
        case "c":
          uA.apply(this, re);
          break;
        case "h":
          Yg();
      }
    }
    return this;
  }, f.__private__.rect = f.rect = function(_, N, z, re, de) {
    if (isNaN(_) || isNaN(N) || isNaN(z) || isNaN(re) || !Ia(de))
      throw new Error("Invalid arguments passed to jsPDF.rect");
    return C === w.COMPAT && (re = -re), Y([T(L(_)), T(Q(N)), T(L(z)), T(L(re)), "re"].join(" ")), ef(de), this;
  }, f.__private__.triangle = f.triangle = function(_, N, z, re, de, _e, Oe) {
    if (isNaN(_) || isNaN(N) || isNaN(z) || isNaN(re) || isNaN(de) || isNaN(_e) || !Ia(Oe))
      throw new Error("Invalid arguments passed to jsPDF.triangle");
    return this.lines([[z - _, re - N], [de - z, _e - re], [_ - de, N - _e]], _, N, [1, 1], Oe, !0), this;
  }, f.__private__.roundedRect = f.roundedRect = function(_, N, z, re, de, _e, Oe) {
    if (isNaN(_) || isNaN(N) || isNaN(z) || isNaN(re) || isNaN(de) || isNaN(_e) || !Ia(Oe))
      throw new Error("Invalid arguments passed to jsPDF.roundedRect");
    var Je = 4 / 3 * (Math.SQRT2 - 1);
    return de = Math.min(de, 0.5 * z), _e = Math.min(_e, 0.5 * re), this.lines([[z - 2 * de, 0], [de * Je, 0, de, _e - _e * Je, de, _e], [0, re - 2 * _e], [0, _e * Je, -de * Je, _e, -de, _e], [2 * de - z, 0], [-de * Je, 0, -de, -_e * Je, -de, -_e], [0, 2 * _e - re], [0, -_e * Je, de * Je, -_e, de, -_e]], _ + de, N, [1, 1], Oe, !0), this;
  }, f.__private__.ellipse = f.ellipse = function(_, N, z, re, de) {
    if (isNaN(_) || isNaN(N) || isNaN(z) || isNaN(re) || !Ia(de))
      throw new Error("Invalid arguments passed to jsPDF.ellipse");
    var _e = 4 / 3 * (Math.SQRT2 - 1) * z, Oe = 4 / 3 * (Math.SQRT2 - 1) * re;
    return tf(_ + z, N), uA(_ + z, N - Oe, _ + _e, N - re, _, N - re), uA(_ - _e, N - re, _ - z, N - Oe, _ - z, N), uA(_ - z, N + Oe, _ - _e, N + re, _, N + re), uA(_ + _e, N + re, _ + z, N + Oe, _ + z, N), ef(de), this;
  }, f.__private__.circle = f.circle = function(_, N, z, re) {
    if (isNaN(_) || isNaN(N) || isNaN(z) || !Ia(re))
      throw new Error("Invalid arguments passed to jsPDF.circle");
    return this.ellipse(_, N, z, z, re);
  }, f.setFont = function(_, N, z) {
    return z && (N = M(N, z)), vt = jg(_, N, { disableWarning: !1 }), this;
  };
  var s1 = f.__private__.getFont = f.getFont = function() {
    return Ar[jg.apply(f, arguments)];
  };
  f.__private__.getFontList = f.getFontList = function() {
    var _, N, z = {};
    for (_ in Zt)
      if (Zt.hasOwnProperty(_))
        for (N in z[_] = [], Zt[_])
          Zt[_].hasOwnProperty(N) && z[_].push(N);
    return z;
  }, f.addFont = function(_, N, z, re, de) {
    var _e = ["StandardEncoding", "MacRomanEncoding", "Identity-H", "WinAnsiEncoding"];
    return arguments[3] && _e.indexOf(arguments[3]) !== -1 ? de = arguments[3] : arguments[3] && _e.indexOf(arguments[3]) == -1 && (z = M(z, re)), de = de || "Identity-H", qu.call(this, _, N, z, de);
  };
  var Bl, rf = i.lineWidth || 0.200025, kh = f.__private__.getLineWidth = f.getLineWidth = function() {
    return rf;
  }, qg = f.__private__.setLineWidth = f.setLineWidth = function(_) {
    return rf = _, Y(T(L(_)) + " w"), this;
  };
  f.__private__.setLineDash = Lt.API.setLineDash = Lt.API.setLineDashPattern = function(_, N) {
    if (_ = _ || [], N = N || 0, isNaN(N) || !Array.isArray(_))
      throw new Error("Invalid arguments passed to jsPDF.setLineDash");
    return _ = _.map(function(z) {
      return T(L(z));
    }).join(" "), N = T(L(N)), Y("[" + _ + "] " + N + " d"), this;
  };
  var Zg = f.__private__.getLineHeight = f.getLineHeight = function() {
    return Re * Bl;
  };
  f.__private__.getLineHeight = f.getLineHeight = function() {
    return Re * Bl;
  };
  var Jg = f.__private__.setLineHeightFactor = f.setLineHeightFactor = function(_) {
    return typeof (_ = _ || 1.15) == "number" && (Bl = _), this;
  }, ep = f.__private__.getLineHeightFactor = f.getLineHeightFactor = function() {
    return Bl;
  };
  Jg(i.lineHeight);
  var fo = f.__private__.getHorizontalCoordinate = function(_) {
    return L(_);
  }, fA = f.__private__.getVerticalCoordinate = function(_) {
    return C === w.ADVANCED ? _ : bt[H].mediaBox.topRightY - bt[H].mediaBox.bottomLeftY - L(_);
  }, a1 = f.__private__.getHorizontalCoordinateString = f.getHorizontalCoordinateString = function(_) {
    return T(fo(_));
  }, dA = f.__private__.getVerticalCoordinateString = f.getVerticalCoordinateString = function(_) {
    return T(fA(_));
  }, sa = i.strokeColor || "0 G";
  f.__private__.getStrokeColor = f.getDrawColor = function() {
    return Pe(sa);
  }, f.__private__.setStrokeColor = f.setDrawColor = function(_, N, z, re) {
    return sa = Ke({ ch1: _, ch2: N, ch3: z, ch4: re, pdfColorType: "draw", precision: 2 }), Y(sa), this;
  };
  var nf = i.fillColor || "0 g";
  f.__private__.getFillColor = f.getFillColor = function() {
    return Pe(nf);
  }, f.__private__.setFillColor = f.setFillColor = function(_, N, z, re) {
    return nf = Ke({ ch1: _, ch2: N, ch3: z, ch4: re, pdfColorType: "fill", precision: 2 }), Y(nf), this;
  };
  var bl = i.textColor || "0 g", o1 = f.__private__.getTextColor = f.getTextColor = function() {
    return Pe(bl);
  };
  f.__private__.setTextColor = f.setTextColor = function(_, N, z, re) {
    return bl = Ke({ ch1: _, ch2: N, ch3: z, ch4: re, pdfColorType: "text", precision: 3 }), this;
  };
  var Hh = i.charSpace, A1 = f.__private__.getCharSpace = f.getCharSpace = function() {
    return parseFloat(Hh || 0);
  };
  f.__private__.setCharSpace = f.setCharSpace = function(_) {
    if (isNaN(_))
      throw new Error("Invalid argument passed to jsPDF.setCharSpace");
    return Hh = _, this;
  };
  var sf = 0;
  f.CapJoinStyles = { 0: 0, butt: 0, but: 0, miter: 0, 1: 1, round: 1, rounded: 1, circle: 1, 2: 2, projecting: 2, project: 2, square: 2, bevel: 2 }, f.__private__.setLineCap = f.setLineCap = function(_) {
    var N = f.CapJoinStyles[_];
    if (N === void 0)
      throw new Error("Line cap style of '" + _ + "' is not recognized. See or extend .CapJoinStyles property for valid styles");
    return sf = N, Y(N + " J"), this;
  };
  var af = 0;
  f.__private__.setLineJoin = f.setLineJoin = function(_) {
    var N = f.CapJoinStyles[_];
    if (N === void 0)
      throw new Error("Line join style of '" + _ + "' is not recognized. See or extend .CapJoinStyles property for valid styles");
    return af = N, Y(N + " j"), this;
  }, f.__private__.setLineMiterLimit = f.__private__.setMiterLimit = f.setLineMiterLimit = f.setMiterLimit = function(_) {
    if (_ = _ || 0, isNaN(_))
      throw new Error("Invalid argument passed to jsPDF.setLineMiterLimit");
    return Y(T(L(_)) + " M"), this;
  }, f.GState = Wm, f.setGState = function(_) {
    (_ = typeof _ == "string" ? ar[Ai[_]] : tp(null, _)).equals(yr) || (Y("/" + _.id + " gs"), yr = _);
  };
  var tp = function(_, N) {
    if (!_ || !Ai[_]) {
      var z = !1;
      for (var re in ar)
        if (ar.hasOwnProperty(re) && ar[re].equals(N)) {
          z = !0;
          break;
        }
      if (z)
        N = ar[re];
      else {
        var de = "GS" + (Object.keys(ar).length + 1).toString(10);
        ar[de] = N, N.id = de;
      }
      return _ && (Ai[_] = N.id), Ot.publish("addGState", N), N;
    }
  };
  f.addGState = function(_, N) {
    return tp(_, N), this;
  }, f.saveGraphicsState = function() {
    return Y("q"), ii.push({ key: vt, size: Re, color: bl }), this;
  }, f.restoreGraphicsState = function() {
    Y("Q");
    var _ = ii.pop();
    return vt = _.key, Re = _.size, bl = _.color, yr = null, this;
  }, f.setCurrentTransformationMatrix = function(_) {
    return Y(_.toString() + " cm"), this;
  }, f.comment = function(_) {
    return Y("#" + _), this;
  };
  var Gh = function(_, N) {
    var z = _ || 0;
    Object.defineProperty(this, "x", { enumerable: !0, get: function() {
      return z;
    }, set: function(_e) {
      isNaN(_e) || (z = parseFloat(_e));
    } });
    var re = N || 0;
    Object.defineProperty(this, "y", { enumerable: !0, get: function() {
      return re;
    }, set: function(_e) {
      isNaN(_e) || (re = parseFloat(_e));
    } });
    var de = "pt";
    return Object.defineProperty(this, "type", { enumerable: !0, get: function() {
      return de;
    }, set: function(_e) {
      de = _e.toString();
    } }), this;
  }, of = function(_, N, z, re) {
    Gh.call(this, _, N), this.type = "rect";
    var de = z || 0;
    Object.defineProperty(this, "w", { enumerable: !0, get: function() {
      return de;
    }, set: function(Oe) {
      isNaN(Oe) || (de = parseFloat(Oe));
    } });
    var _e = re || 0;
    return Object.defineProperty(this, "h", { enumerable: !0, get: function() {
      return _e;
    }, set: function(Oe) {
      isNaN(Oe) || (_e = parseFloat(Oe));
    } }), this;
  }, Af = function() {
    this.page = Lr, this.currentPage = H, this.pages = Ee.slice(0), this.pagesContext = bt.slice(0), this.x = Qr, this.y = kt, this.matrix = fn, this.width = Sl(H), this.height = gA(H), this.outputDestination = ke, this.id = "", this.objectNumber = -1;
  };
  Af.prototype.restore = function() {
    Lr = this.page, H = this.currentPage, bt = this.pagesContext, Ee = this.pages, Qr = this.x, kt = this.y, fn = this.matrix, lf(H, this.width), hf(H, this.height), ke = this.outputDestination;
  };
  var rp = function(_, N, z, re, de) {
    zr.push(new Af()), Lr = H = 0, Ee = [], Qr = _, kt = N, fn = de, Zu([z, re]);
  }, l1 = function(_) {
    if (di[_])
      zr.pop().restore();
    else {
      var N = new Af(), z = "Xo" + (Object.keys(_r).length + 1).toString(10);
      N.id = z, di[_] = z, _r[z] = N, Ot.publish("addFormObject", N), zr.pop().restore();
    }
  };
  for (var $h in f.beginFormObject = function(_, N, z, re, de) {
    return rp(_, N, z, re, de), this;
  }, f.endFormObject = function(_) {
    return l1(_), this;
  }, f.doFormObject = function(_, N) {
    var z = _r[di[_]];
    return Y("q"), Y(N.toString() + " cm"), Y("/" + z.id + " Do"), Y("Q"), this;
  }, f.getFormObject = function(_) {
    var N = _r[di[_]];
    return { x: N.x, y: N.y, width: N.width, height: N.height, matrix: N.matrix };
  }, f.save = function(_, N) {
    return _ = _ || "generated.pdf", (N = N || {}).returnPromise = N.returnPromise || !1, N.returnPromise === !1 ? (Hl(Uh(uo()), _), typeof Hl.unload == "function" && It.setTimeout && setTimeout(Hl.unload, 911), this) : new Promise(function(z, re) {
      try {
        var de = Hl(Uh(uo()), _);
        typeof Hl.unload == "function" && It.setTimeout && setTimeout(Hl.unload, 911), z(de);
      } catch (_e) {
        re(_e.message);
      }
    });
  }, Lt.API)
    Lt.API.hasOwnProperty($h) && ($h === "events" && Lt.API.events.length ? function(_, N) {
      var z, re, de;
      for (de = N.length - 1; de !== -1; de--)
        z = N[de][0], re = N[de][1], _.subscribe.apply(_, [z].concat(typeof re == "function" ? [re] : re));
    }(Ot, Lt.API.events) : f[$h] = Lt.API[$h]);
  var Sl = f.getPageWidth = function(_) {
    return (bt[_ = _ || H].mediaBox.topRightX - bt[_].mediaBox.bottomLeftX) / Ne;
  }, lf = f.setPageWidth = function(_, N) {
    bt[_].mediaBox.topRightX = N * Ne + bt[_].mediaBox.bottomLeftX;
  }, gA = f.getPageHeight = function(_) {
    return (bt[_ = _ || H].mediaBox.topRightY - bt[_].mediaBox.bottomLeftY) / Ne;
  }, hf = f.setPageHeight = function(_, N) {
    bt[_].mediaBox.topRightY = N * Ne + bt[_].mediaBox.bottomLeftY;
  };
  return f.internal = { pdfEscape: as, getStyle: Wg, getFont: s1, getFontSize: Le, getCharSpace: A1, getTextColor: o1, getLineHeight: Zg, getLineHeightFactor: ep, getLineWidth: kh, write: mt, getHorizontalCoordinate: fo, getVerticalCoordinate: fA, getCoordinateString: a1, getVerticalCoordinateString: dA, collections: {}, newObject: Cr, newAdditionalObject: hA, newObjectDeferred: ni, newObjectDeferredBegin: Nn, getFilters: er, putStream: Dr, events: Ot, scaleFactor: Ne, pageSize: { getWidth: function() {
    return Sl(H);
  }, setWidth: function(_) {
    lf(H, _);
  }, getHeight: function() {
    return gA(H);
  }, setHeight: function(_) {
    hf(H, _);
  } }, encryptionOptions: h, encryption: Pn, getEncryptor: Jy, output: Qh, getNumberOfPages: Xy, pages: Ee, out: Y, f2: $, f3: I, getPageInfo: Xg, getPageInfoByObjId: Qt, getCurrentPageInfo: e1, getPDFVersion: p, Point: Gh, Rectangle: of, Matrix: gt, hasHotfix: zg }, Object.defineProperty(f.internal.pageSize, "width", { get: function() {
    return Sl(H);
  }, set: function(_) {
    lf(H, _);
  }, enumerable: !0, configurable: !0 }), Object.defineProperty(f.internal.pageSize, "height", { get: function() {
    return gA(H);
  }, set: function(_) {
    hf(H, _);
  }, enumerable: !0, configurable: !0 }), jy.call(f, Fe), vt = "F1", Vg(n, t), Ot.publish("initialized"), f;
}
Fc.prototype.lsbFirstWord = function(i) {
  return String.fromCharCode(i >> 0 & 255, i >> 8 & 255, i >> 16 & 255, i >> 24 & 255);
}, Fc.prototype.toHexString = function(i) {
  return i.split("").map(function(e) {
    return ("0" + (255 & e.charCodeAt(0)).toString(16)).slice(-2);
  }).join("");
}, Fc.prototype.hexToBytes = function(i) {
  for (var e = [], t = 0; t < i.length; t += 2)
    e.push(String.fromCharCode(parseInt(i.substr(t, 2), 16)));
  return e.join("");
}, Fc.prototype.processOwnerPassword = function(i, e) {
  return tx(ex(e).substr(0, 5), i);
}, Fc.prototype.encryptor = function(i, e) {
  var t = ex(this.encryptionKey + String.fromCharCode(255 & i, i >> 8 & 255, i >> 16 & 255, 255 & e, e >> 8 & 255)).substr(0, 10);
  return function(r) {
    return tx(t, r);
  };
}, Wm.prototype.equals = function(i) {
  var e, t = "id,objectNumber,equals";
  if (!i || $r(i) !== $r(this))
    return !1;
  var r = 0;
  for (e in this)
    if (!(t.indexOf(e) >= 0)) {
      if (this.hasOwnProperty(e) && !i.hasOwnProperty(e) || this[e] !== i[e])
        return !1;
      r++;
    }
  for (e in i)
    i.hasOwnProperty(e) && t.indexOf(e) < 0 && r--;
  return r === 0;
}, Lt.API = { events: [] }, Lt.version = "2.5.1";
var bi = Lt.API, fB = 1, Lh = function(i) {
  return i.replace(/\\/g, "\\\\").replace(/\(/g, "\\(").replace(/\)/g, "\\)");
}, Ac = function(i) {
  return i.replace(/\\\\/g, "\\").replace(/\\\(/g, "(").replace(/\\\)/g, ")");
}, Ht = function(i) {
  return i.toFixed(2);
}, PA = function(i) {
  return i.toFixed(5);
};
bi.__acroform__ = {};
var Cs = function(i, e) {
  i.prototype = Object.create(e.prototype), i.prototype.constructor = i;
}, Y5 = function(i) {
  return i * fB;
}, Ua = function(i) {
  var e = new rN(), t = ot.internal.getHeight(i) || 0, r = ot.internal.getWidth(i) || 0;
  return e.BBox = [0, 0, Number(Ht(r)), Number(Ht(t))], e;
}, bX = bi.__acroform__.setBit = function(i, e) {
  if (i = i || 0, e = e || 0, isNaN(i) || isNaN(e))
    throw new Error("Invalid arguments passed to jsPDF.API.__acroform__.setBit");
  return i |= 1 << e;
}, SX = bi.__acroform__.clearBit = function(i, e) {
  if (i = i || 0, e = e || 0, isNaN(i) || isNaN(e))
    throw new Error("Invalid arguments passed to jsPDF.API.__acroform__.clearBit");
  return i &= ~(1 << e);
}, TX = bi.__acroform__.getBit = function(i, e) {
  if (isNaN(i) || isNaN(e))
    throw new Error("Invalid arguments passed to jsPDF.API.__acroform__.getBit");
  return i & 1 << e ? 1 : 0;
}, Qi = bi.__acroform__.getBitForPdf = function(i, e) {
  if (isNaN(i) || isNaN(e))
    throw new Error("Invalid arguments passed to jsPDF.API.__acroform__.getBitForPdf");
  return TX(i, e - 1);
}, Di = bi.__acroform__.setBitForPdf = function(i, e) {
  if (isNaN(i) || isNaN(e))
    throw new Error("Invalid arguments passed to jsPDF.API.__acroform__.setBitForPdf");
  return bX(i, e - 1);
}, ki = bi.__acroform__.clearBitForPdf = function(i, e) {
  if (isNaN(i) || isNaN(e))
    throw new Error("Invalid arguments passed to jsPDF.API.__acroform__.clearBitForPdf");
  return SX(i, e - 1);
}, FX = bi.__acroform__.calculateCoordinates = function(i, e) {
  var t = e.internal.getHorizontalCoordinate, r = e.internal.getVerticalCoordinate, n = i[0], s = i[1], a = i[2], o = i[3], A = {};
  return A.lowerLeft_X = t(n) || 0, A.lowerLeft_Y = r(s + o) || 0, A.upperRight_X = t(n + a) || 0, A.upperRight_Y = r(s) || 0, [Number(Ht(A.lowerLeft_X)), Number(Ht(A.lowerLeft_Y)), Number(Ht(A.upperRight_X)), Number(Ht(A.upperRight_Y))];
}, LX = function(i) {
  if (i.appearanceStreamContent)
    return i.appearanceStreamContent;
  if (i.V || i.DV) {
    var e = [], t = i._V || i.DV, r = rx(i, t), n = i.scope.internal.getFont(i.fontName, i.fontStyle).id;
    e.push("/Tx BMC"), e.push("q"), e.push("BT"), e.push(i.scope.__private__.encodeColorString(i.color)), e.push("/" + n + " " + Ht(r.fontSize) + " Tf"), e.push("1 0 0 1 0 0 Tm"), e.push(r.text), e.push("ET"), e.push("Q"), e.push("EMC");
    var s = Ua(i);
    return s.scope = i.scope, s.stream = e.join(`
`), s;
  }
}, rx = function(i, e) {
  var t = i.fontSize === 0 ? i.maxFontSize : i.fontSize, r = { text: "", fontSize: "" }, n = (e = (e = e.substr(0, 1) == "(" ? e.substr(1) : e).substr(e.length - 1) == ")" ? e.substr(0, e.length - 1) : e).split(" ");
  n = i.multiline ? n.map(function(I) {
    return I.split(`
`);
  }) : n.map(function(I) {
    return [I];
  });
  var s = t, a = ot.internal.getHeight(i) || 0;
  a = a < 0 ? -a : a;
  var o = ot.internal.getWidth(i) || 0;
  o = o < 0 ? -o : o;
  var A = function(I, L, P) {
    if (I + 1 < n.length) {
      var Q = L + " " + n[I + 1][0];
      return kp(Q, i, P).width <= o - 4;
    }
    return !1;
  };
  s++;
  e:
    for (; s > 0; ) {
      e = "", s--;
      var l, h, c = kp("3", i, s).height, u = i.multiline ? a - s : (a - c) / 2, f = u += 2, g = 0, p = 0, y = 0;
      if (s <= 0) {
        e = `(...) Tj
`, e += "% Width of Text: " + kp(e, i, s = 12).width + ", FieldWidth:" + o + `
`;
        break;
      }
      for (var v = "", w = 0, C = 0; C < n.length; C++)
        if (n.hasOwnProperty(C)) {
          var E = !1;
          if (n[C].length !== 1 && y !== n[C].length - 1) {
            if ((c + 2) * (w + 2) + 2 > a)
              continue e;
            v += n[C][y], E = !0, p = C, C--;
          } else {
            v = (v += n[C][y] + " ").substr(v.length - 1) == " " ? v.substr(0, v.length - 1) : v;
            var S = parseInt(C), M = A(S, v, s), T = C >= n.length - 1;
            if (M && !T) {
              v += " ", y = 0;
              continue;
            }
            if (M || T) {
              if (T)
                p = S;
              else if (i.multiline && (c + 2) * (w + 2) + 2 > a)
                continue e;
            } else {
              if (!i.multiline || (c + 2) * (w + 2) + 2 > a)
                continue e;
              p = S;
            }
          }
          for (var F = "", k = g; k <= p; k++) {
            var $ = n[k];
            if (i.multiline) {
              if (k === p) {
                F += $[y] + " ", y = (y + 1) % $.length;
                continue;
              }
              if (k === g) {
                F += $[$.length - 1] + " ";
                continue;
              }
            }
            F += $[0] + " ";
          }
          switch (F = F.substr(F.length - 1) == " " ? F.substr(0, F.length - 1) : F, h = kp(F, i, s).width, i.textAlign) {
            case "right":
              l = o - h - 2;
              break;
            case "center":
              l = (o - h) / 2;
              break;
            case "left":
            default:
              l = 2;
          }
          e += Ht(l) + " " + Ht(f) + ` Td
`, e += "(" + Lh(F) + `) Tj
`, e += -Ht(l) + ` 0 Td
`, f = -(s + 2), h = 0, g = E ? p : p + 1, w++, v = "";
        }
      break;
    }
  return r.text = e, r.fontSize = s, r;
}, kp = function(i, e, t) {
  var r = e.scope.internal.getFont(e.fontName, e.fontStyle), n = e.scope.getStringUnitWidth(i, { font: r, fontSize: parseFloat(t), charSpace: 0 }) * parseFloat(t);
  return { height: e.scope.getStringUnitWidth("3", { font: r, fontSize: parseFloat(t), charSpace: 0 }) * parseFloat(t) * 1.5, width: n };
}, IX = { fields: [], xForms: [], acroFormDictionaryRoot: null, printedOut: !1, internal: null, isInitialized: !1 }, RX = function(i, e) {
  var t = { type: "reference", object: i };
  e.internal.getPageInfo(i.page).pageContext.annotations.find(function(r) {
    return r.type === t.type && r.object === t.object;
  }) === void 0 && e.internal.getPageInfo(i.page).pageContext.annotations.push(t);
}, MX = function(i, e) {
  for (var t in i)
    if (i.hasOwnProperty(t)) {
      var r = t, n = i[t];
      e.internal.newObjectDeferredBegin(n.objId, !0), $r(n) === "object" && typeof n.putStream == "function" && n.putStream(), delete i[r];
    }
}, NX = function(i, e) {
  if (e.scope = i, i.internal !== void 0 && (i.internal.acroformPlugin === void 0 || i.internal.acroformPlugin.isInitialized === !1)) {
    if (Ta.FieldNum = 0, i.internal.acroformPlugin = JSON.parse(JSON.stringify(IX)), i.internal.acroformPlugin.acroFormDictionaryRoot)
      throw new Error("Exception while creating AcroformDictionary");
    fB = i.internal.scaleFactor, i.internal.acroformPlugin.acroFormDictionaryRoot = new iN(), i.internal.acroformPlugin.acroFormDictionaryRoot.scope = i, i.internal.acroformPlugin.acroFormDictionaryRoot._eventID = i.internal.events.subscribe("postPutResources", function() {
      (function(t) {
        t.internal.events.unsubscribe(t.internal.acroformPlugin.acroFormDictionaryRoot._eventID), delete t.internal.acroformPlugin.acroFormDictionaryRoot._eventID, t.internal.acroformPlugin.printedOut = !0;
      })(i);
    }), i.internal.events.subscribe("buildDocument", function() {
      (function(t) {
        t.internal.acroformPlugin.acroFormDictionaryRoot.objId = void 0;
        var r = t.internal.acroformPlugin.acroFormDictionaryRoot.Fields;
        for (var n in r)
          if (r.hasOwnProperty(n)) {
            var s = r[n];
            s.objId = void 0, s.hasAnnotation && RX(s, t);
          }
      })(i);
    }), i.internal.events.subscribe("putCatalog", function() {
      (function(t) {
        if (t.internal.acroformPlugin.acroFormDictionaryRoot === void 0)
          throw new Error("putCatalogCallback: Root missing.");
        t.internal.write("/AcroForm " + t.internal.acroformPlugin.acroFormDictionaryRoot.objId + " 0 R");
      })(i);
    }), i.internal.events.subscribe("postPutPages", function(t) {
      (function(r, n) {
        var s = !r;
        for (var a in r || (n.internal.newObjectDeferredBegin(n.internal.acroformPlugin.acroFormDictionaryRoot.objId, !0), n.internal.acroformPlugin.acroFormDictionaryRoot.putStream()), r = r || n.internal.acroformPlugin.acroFormDictionaryRoot.Kids)
          if (r.hasOwnProperty(a)) {
            var o = r[a], A = [], l = o.Rect;
            if (o.Rect && (o.Rect = FX(o.Rect, n)), n.internal.newObjectDeferredBegin(o.objId, !0), o.DA = ot.createDefaultAppearanceStream(o), $r(o) === "object" && typeof o.getKeyValueListForStream == "function" && (A = o.getKeyValueListForStream()), o.Rect = l, o.hasAppearanceStream && !o.appearanceStreamContent) {
              var h = LX(o);
              A.push({ key: "AP", value: "<</N " + h + ">>" }), n.internal.acroformPlugin.xForms.push(h);
            }
            if (o.appearanceStreamContent) {
              var c = "";
              for (var u in o.appearanceStreamContent)
                if (o.appearanceStreamContent.hasOwnProperty(u)) {
                  var f = o.appearanceStreamContent[u];
                  if (c += "/" + u + " ", c += "<<", Object.keys(f).length >= 1 || Array.isArray(f)) {
                    for (var a in f)
                      if (f.hasOwnProperty(a)) {
                        var g = f[a];
                        typeof g == "function" && (g = g.call(n, o)), c += "/" + a + " " + g + " ", n.internal.acroformPlugin.xForms.indexOf(g) >= 0 || n.internal.acroformPlugin.xForms.push(g);
                      }
                  } else
                    typeof (g = f) == "function" && (g = g.call(n, o)), c += "/" + a + " " + g, n.internal.acroformPlugin.xForms.indexOf(g) >= 0 || n.internal.acroformPlugin.xForms.push(g);
                  c += ">>";
                }
              A.push({ key: "AP", value: `<<
` + c + ">>" });
            }
            n.internal.putStream({ additionalKeyValues: A, objectId: o.objId }), n.internal.out("endobj");
          }
        s && MX(n.internal.acroformPlugin.xForms, n);
      })(t, i);
    }), i.internal.acroformPlugin.isInitialized = !0;
  }
}, tN = bi.__acroform__.arrayToPdfArray = function(i, e, t) {
  var r = function(a) {
    return a;
  };
  if (Array.isArray(i)) {
    for (var n = "[", s = 0; s < i.length; s++)
      switch (s !== 0 && (n += " "), $r(i[s])) {
        case "boolean":
        case "number":
        case "object":
          n += i[s].toString();
          break;
        case "string":
          i[s].substr(0, 1) !== "/" ? (e !== void 0 && t && (r = t.internal.getEncryptor(e)), n += "(" + Lh(r(i[s].toString())) + ")") : n += i[s].toString();
      }
    return n += "]";
  }
  throw new Error("Invalid argument passed to jsPDF.__acroform__.arrayToPdfArray");
}, o_ = function(i, e, t) {
  var r = function(n) {
    return n;
  };
  return e !== void 0 && t && (r = t.internal.getEncryptor(e)), (i = i || "").toString(), i = "(" + Lh(r(i)) + ")";
}, $a = function() {
  this._objId = void 0, this._scope = void 0, Object.defineProperty(this, "objId", { get: function() {
    if (this._objId === void 0) {
      if (this.scope === void 0)
        return;
      this._objId = this.scope.internal.newObjectDeferred();
    }
    return this._objId;
  }, set: function(i) {
    this._objId = i;
  } }), Object.defineProperty(this, "scope", { value: this._scope, writable: !0 });
};
$a.prototype.toString = function() {
  return this.objId + " 0 R";
}, $a.prototype.putStream = function() {
  var i = this.getKeyValueListForStream();
  this.scope.internal.putStream({ data: this.stream, additionalKeyValues: i, objectId: this.objId }), this.scope.internal.out("endobj");
}, $a.prototype.getKeyValueListForStream = function() {
  var i = [], e = Object.getOwnPropertyNames(this).filter(function(s) {
    return s != "content" && s != "appearanceStreamContent" && s != "scope" && s != "objId" && s.substring(0, 1) != "_";
  });
  for (var t in e)
    if (Object.getOwnPropertyDescriptor(this, e[t]).configurable === !1) {
      var r = e[t], n = this[r];
      n && (Array.isArray(n) ? i.push({ key: r, value: tN(n, this.objId, this.scope) }) : n instanceof $a ? (n.scope = this.scope, i.push({ key: r, value: n.objId + " 0 R" })) : typeof n != "function" && i.push({ key: r, value: n }));
    }
  return i;
};
var rN = function() {
  $a.call(this), Object.defineProperty(this, "Type", { value: "/XObject", configurable: !1, writable: !0 }), Object.defineProperty(this, "Subtype", { value: "/Form", configurable: !1, writable: !0 }), Object.defineProperty(this, "FormType", { value: 1, configurable: !1, writable: !0 });
  var i, e = [];
  Object.defineProperty(this, "BBox", { configurable: !1, get: function() {
    return e;
  }, set: function(t) {
    e = t;
  } }), Object.defineProperty(this, "Resources", { value: "2 0 R", configurable: !1, writable: !0 }), Object.defineProperty(this, "stream", { enumerable: !1, configurable: !0, set: function(t) {
    i = t.trim();
  }, get: function() {
    return i || null;
  } });
};
Cs(rN, $a);
var iN = function() {
  $a.call(this);
  var i, e = [];
  Object.defineProperty(this, "Kids", { enumerable: !1, configurable: !0, get: function() {
    return e.length > 0 ? e : void 0;
  } }), Object.defineProperty(this, "Fields", { enumerable: !1, configurable: !1, get: function() {
    return e;
  } }), Object.defineProperty(this, "DA", { enumerable: !1, configurable: !1, get: function() {
    if (i) {
      var t = function(r) {
        return r;
      };
      return this.scope && (t = this.scope.internal.getEncryptor(this.objId)), "(" + Lh(t(i)) + ")";
    }
  }, set: function(t) {
    i = t;
  } });
};
Cs(iN, $a);
var Ta = function i() {
  $a.call(this);
  var e = 4;
  Object.defineProperty(this, "F", { enumerable: !1, configurable: !1, get: function() {
    return e;
  }, set: function(v) {
    if (isNaN(v))
      throw new Error('Invalid value "' + v + '" for attribute F supplied.');
    e = v;
  } }), Object.defineProperty(this, "showWhenPrinted", { enumerable: !0, configurable: !0, get: function() {
    return !!Qi(e, 3);
  }, set: function(v) {
    v ? this.F = Di(e, 3) : this.F = ki(e, 3);
  } });
  var t = 0;
  Object.defineProperty(this, "Ff", { enumerable: !1, configurable: !1, get: function() {
    return t;
  }, set: function(v) {
    if (isNaN(v))
      throw new Error('Invalid value "' + v + '" for attribute Ff supplied.');
    t = v;
  } });
  var r = [];
  Object.defineProperty(this, "Rect", { enumerable: !1, configurable: !1, get: function() {
    if (r.length !== 0)
      return r;
  }, set: function(v) {
    r = v !== void 0 ? v : [];
  } }), Object.defineProperty(this, "x", { enumerable: !0, configurable: !0, get: function() {
    return !r || isNaN(r[0]) ? 0 : r[0];
  }, set: function(v) {
    r[0] = v;
  } }), Object.defineProperty(this, "y", { enumerable: !0, configurable: !0, get: function() {
    return !r || isNaN(r[1]) ? 0 : r[1];
  }, set: function(v) {
    r[1] = v;
  } }), Object.defineProperty(this, "width", { enumerable: !0, configurable: !0, get: function() {
    return !r || isNaN(r[2]) ? 0 : r[2];
  }, set: function(v) {
    r[2] = v;
  } }), Object.defineProperty(this, "height", { enumerable: !0, configurable: !0, get: function() {
    return !r || isNaN(r[3]) ? 0 : r[3];
  }, set: function(v) {
    r[3] = v;
  } });
  var n = "";
  Object.defineProperty(this, "FT", { enumerable: !0, configurable: !1, get: function() {
    return n;
  }, set: function(v) {
    switch (v) {
      case "/Btn":
      case "/Tx":
      case "/Ch":
      case "/Sig":
        n = v;
        break;
      default:
        throw new Error('Invalid value "' + v + '" for attribute FT supplied.');
    }
  } });
  var s = null;
  Object.defineProperty(this, "T", { enumerable: !0, configurable: !1, get: function() {
    if (!s || s.length < 1) {
      if (this instanceof Ym)
        return;
      s = "FieldObject" + i.FieldNum++;
    }
    var v = function(w) {
      return w;
    };
    return this.scope && (v = this.scope.internal.getEncryptor(this.objId)), "(" + Lh(v(s)) + ")";
  }, set: function(v) {
    s = v.toString();
  } }), Object.defineProperty(this, "fieldName", { configurable: !0, enumerable: !0, get: function() {
    return s;
  }, set: function(v) {
    s = v;
  } });
  var a = "helvetica";
  Object.defineProperty(this, "fontName", { enumerable: !0, configurable: !0, get: function() {
    return a;
  }, set: function(v) {
    a = v;
  } });
  var o = "normal";
  Object.defineProperty(this, "fontStyle", { enumerable: !0, configurable: !0, get: function() {
    return o;
  }, set: function(v) {
    o = v;
  } });
  var A = 0;
  Object.defineProperty(this, "fontSize", { enumerable: !0, configurable: !0, get: function() {
    return A;
  }, set: function(v) {
    A = v;
  } });
  var l = void 0;
  Object.defineProperty(this, "maxFontSize", { enumerable: !0, configurable: !0, get: function() {
    return l === void 0 ? 50 / fB : l;
  }, set: function(v) {
    l = v;
  } });
  var h = "black";
  Object.defineProperty(this, "color", { enumerable: !0, configurable: !0, get: function() {
    return h;
  }, set: function(v) {
    h = v;
  } });
  var c = "/F1 0 Tf 0 g";
  Object.defineProperty(this, "DA", { enumerable: !0, configurable: !1, get: function() {
    if (!(!c || this instanceof Ym || this instanceof nh))
      return o_(c, this.objId, this.scope);
  }, set: function(v) {
    v = v.toString(), c = v;
  } });
  var u = null;
  Object.defineProperty(this, "DV", { enumerable: !1, configurable: !1, get: function() {
    if (u)
      return this instanceof yn ? u : o_(u, this.objId, this.scope);
  }, set: function(v) {
    v = v.toString(), u = this instanceof yn ? v : v.substr(0, 1) === "(" ? Ac(v.substr(1, v.length - 2)) : Ac(v);
  } }), Object.defineProperty(this, "defaultValue", { enumerable: !0, configurable: !0, get: function() {
    return this instanceof yn ? Ac(u.substr(1, u.length - 1)) : u;
  }, set: function(v) {
    v = v.toString(), u = this instanceof yn ? "/" + v : v;
  } });
  var f = null;
  Object.defineProperty(this, "_V", { enumerable: !1, configurable: !1, get: function() {
    if (f)
      return f;
  }, set: function(v) {
    this.V = v;
  } }), Object.defineProperty(this, "V", { enumerable: !1, configurable: !1, get: function() {
    if (f)
      return this instanceof yn ? f : o_(f, this.objId, this.scope);
  }, set: function(v) {
    v = v.toString(), f = this instanceof yn ? v : v.substr(0, 1) === "(" ? Ac(v.substr(1, v.length - 2)) : Ac(v);
  } }), Object.defineProperty(this, "value", { enumerable: !0, configurable: !0, get: function() {
    return this instanceof yn ? Ac(f.substr(1, f.length - 1)) : f;
  }, set: function(v) {
    v = v.toString(), f = this instanceof yn ? "/" + v : v;
  } }), Object.defineProperty(this, "hasAnnotation", { enumerable: !0, configurable: !0, get: function() {
    return this.Rect;
  } }), Object.defineProperty(this, "Type", { enumerable: !0, configurable: !1, get: function() {
    return this.hasAnnotation ? "/Annot" : null;
  } }), Object.defineProperty(this, "Subtype", { enumerable: !0, configurable: !1, get: function() {
    return this.hasAnnotation ? "/Widget" : null;
  } });
  var g, p = !1;
  Object.defineProperty(this, "hasAppearanceStream", { enumerable: !0, configurable: !0, get: function() {
    return p;
  }, set: function(v) {
    v = !!v, p = v;
  } }), Object.defineProperty(this, "page", { enumerable: !0, configurable: !0, get: function() {
    if (g)
      return g;
  }, set: function(v) {
    g = v;
  } }), Object.defineProperty(this, "readOnly", { enumerable: !0, configurable: !0, get: function() {
    return !!Qi(this.Ff, 1);
  }, set: function(v) {
    v ? this.Ff = Di(this.Ff, 1) : this.Ff = ki(this.Ff, 1);
  } }), Object.defineProperty(this, "required", { enumerable: !0, configurable: !0, get: function() {
    return !!Qi(this.Ff, 2);
  }, set: function(v) {
    v ? this.Ff = Di(this.Ff, 2) : this.Ff = ki(this.Ff, 2);
  } }), Object.defineProperty(this, "noExport", { enumerable: !0, configurable: !0, get: function() {
    return !!Qi(this.Ff, 3);
  }, set: function(v) {
    v ? this.Ff = Di(this.Ff, 3) : this.Ff = ki(this.Ff, 3);
  } });
  var y = null;
  Object.defineProperty(this, "Q", { enumerable: !0, configurable: !1, get: function() {
    if (y !== null)
      return y;
  }, set: function(v) {
    if ([0, 1, 2].indexOf(v) === -1)
      throw new Error('Invalid value "' + v + '" for attribute Q supplied.');
    y = v;
  } }), Object.defineProperty(this, "textAlign", { get: function() {
    var v;
    switch (y) {
      case 0:
      default:
        v = "left";
        break;
      case 1:
        v = "center";
        break;
      case 2:
        v = "right";
    }
    return v;
  }, configurable: !0, enumerable: !0, set: function(v) {
    switch (v) {
      case "right":
      case 2:
        y = 2;
        break;
      case "center":
      case 1:
        y = 1;
        break;
      case "left":
      case 0:
      default:
        y = 0;
    }
  } });
};
Cs(Ta, $a);
var eu = function() {
  Ta.call(this), this.FT = "/Ch", this.V = "()", this.fontName = "zapfdingbats";
  var i = 0;
  Object.defineProperty(this, "TI", { enumerable: !0, configurable: !1, get: function() {
    return i;
  }, set: function(t) {
    i = t;
  } }), Object.defineProperty(this, "topIndex", { enumerable: !0, configurable: !0, get: function() {
    return i;
  }, set: function(t) {
    i = t;
  } });
  var e = [];
  Object.defineProperty(this, "Opt", { enumerable: !0, configurable: !1, get: function() {
    return tN(e, this.objId, this.scope);
  }, set: function(t) {
    var r, n;
    n = [], typeof (r = t) == "string" && (n = function(s, a, o) {
      o || (o = 1);
      for (var A, l = []; A = a.exec(s); )
        l.push(A[o]);
      return l;
    }(r, /\((.*?)\)/g)), e = n;
  } }), this.getOptions = function() {
    return e;
  }, this.setOptions = function(t) {
    e = t, this.sort && e.sort();
  }, this.addOption = function(t) {
    t = (t = t || "").toString(), e.push(t), this.sort && e.sort();
  }, this.removeOption = function(t, r) {
    for (r = r || !1, t = (t = t || "").toString(); e.indexOf(t) !== -1 && (e.splice(e.indexOf(t), 1), r !== !1); )
      ;
  }, Object.defineProperty(this, "combo", { enumerable: !0, configurable: !0, get: function() {
    return !!Qi(this.Ff, 18);
  }, set: function(t) {
    t ? this.Ff = Di(this.Ff, 18) : this.Ff = ki(this.Ff, 18);
  } }), Object.defineProperty(this, "edit", { enumerable: !0, configurable: !0, get: function() {
    return !!Qi(this.Ff, 19);
  }, set: function(t) {
    this.combo === !0 && (t ? this.Ff = Di(this.Ff, 19) : this.Ff = ki(this.Ff, 19));
  } }), Object.defineProperty(this, "sort", { enumerable: !0, configurable: !0, get: function() {
    return !!Qi(this.Ff, 20);
  }, set: function(t) {
    t ? (this.Ff = Di(this.Ff, 20), e.sort()) : this.Ff = ki(this.Ff, 20);
  } }), Object.defineProperty(this, "multiSelect", { enumerable: !0, configurable: !0, get: function() {
    return !!Qi(this.Ff, 22);
  }, set: function(t) {
    t ? this.Ff = Di(this.Ff, 22) : this.Ff = ki(this.Ff, 22);
  } }), Object.defineProperty(this, "doNotSpellCheck", { enumerable: !0, configurable: !0, get: function() {
    return !!Qi(this.Ff, 23);
  }, set: function(t) {
    t ? this.Ff = Di(this.Ff, 23) : this.Ff = ki(this.Ff, 23);
  } }), Object.defineProperty(this, "commitOnSelChange", { enumerable: !0, configurable: !0, get: function() {
    return !!Qi(this.Ff, 27);
  }, set: function(t) {
    t ? this.Ff = Di(this.Ff, 27) : this.Ff = ki(this.Ff, 27);
  } }), this.hasAppearanceStream = !1;
};
Cs(eu, Ta);
var tu = function() {
  eu.call(this), this.fontName = "helvetica", this.combo = !1;
};
Cs(tu, eu);
var ru = function() {
  tu.call(this), this.combo = !0;
};
Cs(ru, tu);
var X0 = function() {
  ru.call(this), this.edit = !0;
};
Cs(X0, ru);
var yn = function() {
  Ta.call(this), this.FT = "/Btn", Object.defineProperty(this, "noToggleToOff", { enumerable: !0, configurable: !0, get: function() {
    return !!Qi(this.Ff, 15);
  }, set: function(t) {
    t ? this.Ff = Di(this.Ff, 15) : this.Ff = ki(this.Ff, 15);
  } }), Object.defineProperty(this, "radio", { enumerable: !0, configurable: !0, get: function() {
    return !!Qi(this.Ff, 16);
  }, set: function(t) {
    t ? this.Ff = Di(this.Ff, 16) : this.Ff = ki(this.Ff, 16);
  } }), Object.defineProperty(this, "pushButton", { enumerable: !0, configurable: !0, get: function() {
    return !!Qi(this.Ff, 17);
  }, set: function(t) {
    t ? this.Ff = Di(this.Ff, 17) : this.Ff = ki(this.Ff, 17);
  } }), Object.defineProperty(this, "radioIsUnison", { enumerable: !0, configurable: !0, get: function() {
    return !!Qi(this.Ff, 26);
  }, set: function(t) {
    t ? this.Ff = Di(this.Ff, 26) : this.Ff = ki(this.Ff, 26);
  } });
  var i, e = {};
  Object.defineProperty(this, "MK", { enumerable: !1, configurable: !1, get: function() {
    var t = function(s) {
      return s;
    };
    if (this.scope && (t = this.scope.internal.getEncryptor(this.objId)), Object.keys(e).length !== 0) {
      var r, n = [];
      for (r in n.push("<<"), e)
        n.push("/" + r + " (" + Lh(t(e[r])) + ")");
      return n.push(">>"), n.join(`
`);
    }
  }, set: function(t) {
    $r(t) === "object" && (e = t);
  } }), Object.defineProperty(this, "caption", { enumerable: !0, configurable: !0, get: function() {
    return e.CA || "";
  }, set: function(t) {
    typeof t == "string" && (e.CA = t);
  } }), Object.defineProperty(this, "AS", { enumerable: !1, configurable: !1, get: function() {
    return i;
  }, set: function(t) {
    i = t;
  } }), Object.defineProperty(this, "appearanceState", { enumerable: !0, configurable: !0, get: function() {
    return i.substr(1, i.length - 1);
  }, set: function(t) {
    i = "/" + t;
  } });
};
Cs(yn, Ta);
var W0 = function() {
  yn.call(this), this.pushButton = !0;
};
Cs(W0, yn);
var iu = function() {
  yn.call(this), this.radio = !0, this.pushButton = !1;
  var i = [];
  Object.defineProperty(this, "Kids", { enumerable: !0, configurable: !1, get: function() {
    return i;
  }, set: function(e) {
    i = e !== void 0 ? e : [];
  } });
};
Cs(iu, yn);
var Ym = function() {
  var i, e;
  Ta.call(this), Object.defineProperty(this, "Parent", { enumerable: !1, configurable: !1, get: function() {
    return i;
  }, set: function(n) {
    i = n;
  } }), Object.defineProperty(this, "optionName", { enumerable: !1, configurable: !0, get: function() {
    return e;
  }, set: function(n) {
    e = n;
  } });
  var t, r = {};
  Object.defineProperty(this, "MK", { enumerable: !1, configurable: !1, get: function() {
    var n = function(o) {
      return o;
    };
    this.scope && (n = this.scope.internal.getEncryptor(this.objId));
    var s, a = [];
    for (s in a.push("<<"), r)
      a.push("/" + s + " (" + Lh(n(r[s])) + ")");
    return a.push(">>"), a.join(`
`);
  }, set: function(n) {
    $r(n) === "object" && (r = n);
  } }), Object.defineProperty(this, "caption", { enumerable: !0, configurable: !0, get: function() {
    return r.CA || "";
  }, set: function(n) {
    typeof n == "string" && (r.CA = n);
  } }), Object.defineProperty(this, "AS", { enumerable: !1, configurable: !1, get: function() {
    return t;
  }, set: function(n) {
    t = n;
  } }), Object.defineProperty(this, "appearanceState", { enumerable: !0, configurable: !0, get: function() {
    return t.substr(1, t.length - 1);
  }, set: function(n) {
    t = "/" + n;
  } }), this.caption = "l", this.appearanceState = "Off", this._AppearanceType = ot.RadioButton.Circle, this.appearanceStreamContent = this._AppearanceType.createAppearanceStream(this.optionName);
};
Cs(Ym, Ta), iu.prototype.setAppearance = function(i) {
  if (!("createAppearanceStream" in i) || !("getCA" in i))
    throw new Error("Couldn't assign Appearance to RadioButton. Appearance was Invalid!");
  for (var e in this.Kids)
    if (this.Kids.hasOwnProperty(e)) {
      var t = this.Kids[e];
      t.appearanceStreamContent = i.createAppearanceStream(t.optionName), t.caption = i.getCA();
    }
}, iu.prototype.createOption = function(i) {
  var e = new Ym();
  return e.Parent = this, e.optionName = i, this.Kids.push(e), PX.call(this.scope, e), e;
};
var Y0 = function() {
  yn.call(this), this.fontName = "zapfdingbats", this.caption = "3", this.appearanceState = "On", this.value = "On", this.textAlign = "center", this.appearanceStreamContent = ot.CheckBox.createAppearanceStream();
};
Cs(Y0, yn);
var nh = function() {
  Ta.call(this), this.FT = "/Tx", Object.defineProperty(this, "multiline", { enumerable: !0, configurable: !0, get: function() {
    return !!Qi(this.Ff, 13);
  }, set: function(e) {
    e ? this.Ff = Di(this.Ff, 13) : this.Ff = ki(this.Ff, 13);
  } }), Object.defineProperty(this, "fileSelect", { enumerable: !0, configurable: !0, get: function() {
    return !!Qi(this.Ff, 21);
  }, set: function(e) {
    e ? this.Ff = Di(this.Ff, 21) : this.Ff = ki(this.Ff, 21);
  } }), Object.defineProperty(this, "doNotSpellCheck", { enumerable: !0, configurable: !0, get: function() {
    return !!Qi(this.Ff, 23);
  }, set: function(e) {
    e ? this.Ff = Di(this.Ff, 23) : this.Ff = ki(this.Ff, 23);
  } }), Object.defineProperty(this, "doNotScroll", { enumerable: !0, configurable: !0, get: function() {
    return !!Qi(this.Ff, 24);
  }, set: function(e) {
    e ? this.Ff = Di(this.Ff, 24) : this.Ff = ki(this.Ff, 24);
  } }), Object.defineProperty(this, "comb", { enumerable: !0, configurable: !0, get: function() {
    return !!Qi(this.Ff, 25);
  }, set: function(e) {
    e ? this.Ff = Di(this.Ff, 25) : this.Ff = ki(this.Ff, 25);
  } }), Object.defineProperty(this, "richText", { enumerable: !0, configurable: !0, get: function() {
    return !!Qi(this.Ff, 26);
  }, set: function(e) {
    e ? this.Ff = Di(this.Ff, 26) : this.Ff = ki(this.Ff, 26);
  } });
  var i = null;
  Object.defineProperty(this, "MaxLen", { enumerable: !0, configurable: !1, get: function() {
    return i;
  }, set: function(e) {
    i = e;
  } }), Object.defineProperty(this, "maxLength", { enumerable: !0, configurable: !0, get: function() {
    return i;
  }, set: function(e) {
    Number.isInteger(e) && (i = e);
  } }), Object.defineProperty(this, "hasAppearanceStream", { enumerable: !0, configurable: !0, get: function() {
    return this.V || this.DV;
  } });
};
Cs(nh, Ta);
var q0 = function() {
  nh.call(this), Object.defineProperty(this, "password", { enumerable: !0, configurable: !0, get: function() {
    return !!Qi(this.Ff, 14);
  }, set: function(i) {
    i ? this.Ff = Di(this.Ff, 14) : this.Ff = ki(this.Ff, 14);
  } }), this.password = !0;
};
Cs(q0, nh);
var ot = { CheckBox: { createAppearanceStream: function() {
  return { N: { On: ot.CheckBox.YesNormal }, D: { On: ot.CheckBox.YesPushDown, Off: ot.CheckBox.OffPushDown } };
}, YesPushDown: function(i) {
  var e = Ua(i);
  e.scope = i.scope;
  var t = [], r = i.scope.internal.getFont(i.fontName, i.fontStyle).id, n = i.scope.__private__.encodeColorString(i.color), s = rx(i, i.caption);
  return t.push("0.749023 g"), t.push("0 0 " + Ht(ot.internal.getWidth(i)) + " " + Ht(ot.internal.getHeight(i)) + " re"), t.push("f"), t.push("BMC"), t.push("q"), t.push("0 0 1 rg"), t.push("/" + r + " " + Ht(s.fontSize) + " Tf " + n), t.push("BT"), t.push(s.text), t.push("ET"), t.push("Q"), t.push("EMC"), e.stream = t.join(`
`), e;
}, YesNormal: function(i) {
  var e = Ua(i);
  e.scope = i.scope;
  var t = i.scope.internal.getFont(i.fontName, i.fontStyle).id, r = i.scope.__private__.encodeColorString(i.color), n = [], s = ot.internal.getHeight(i), a = ot.internal.getWidth(i), o = rx(i, i.caption);
  return n.push("1 g"), n.push("0 0 " + Ht(a) + " " + Ht(s) + " re"), n.push("f"), n.push("q"), n.push("0 0 1 rg"), n.push("0 0 " + Ht(a - 1) + " " + Ht(s - 1) + " re"), n.push("W"), n.push("n"), n.push("0 g"), n.push("BT"), n.push("/" + t + " " + Ht(o.fontSize) + " Tf " + r), n.push(o.text), n.push("ET"), n.push("Q"), e.stream = n.join(`
`), e;
}, OffPushDown: function(i) {
  var e = Ua(i);
  e.scope = i.scope;
  var t = [];
  return t.push("0.749023 g"), t.push("0 0 " + Ht(ot.internal.getWidth(i)) + " " + Ht(ot.internal.getHeight(i)) + " re"), t.push("f"), e.stream = t.join(`
`), e;
} }, RadioButton: { Circle: { createAppearanceStream: function(i) {
  var e = { D: { Off: ot.RadioButton.Circle.OffPushDown }, N: {} };
  return e.N[i] = ot.RadioButton.Circle.YesNormal, e.D[i] = ot.RadioButton.Circle.YesPushDown, e;
}, getCA: function() {
  return "l";
}, YesNormal: function(i) {
  var e = Ua(i);
  e.scope = i.scope;
  var t = [], r = ot.internal.getWidth(i) <= ot.internal.getHeight(i) ? ot.internal.getWidth(i) / 4 : ot.internal.getHeight(i) / 4;
  r = Number((0.9 * r).toFixed(5));
  var n = ot.internal.Bezier_C, s = Number((r * n).toFixed(5));
  return t.push("q"), t.push("1 0 0 1 " + PA(ot.internal.getWidth(i) / 2) + " " + PA(ot.internal.getHeight(i) / 2) + " cm"), t.push(r + " 0 m"), t.push(r + " " + s + " " + s + " " + r + " 0 " + r + " c"), t.push("-" + s + " " + r + " -" + r + " " + s + " -" + r + " 0 c"), t.push("-" + r + " -" + s + " -" + s + " -" + r + " 0 -" + r + " c"), t.push(s + " -" + r + " " + r + " -" + s + " " + r + " 0 c"), t.push("f"), t.push("Q"), e.stream = t.join(`
`), e;
}, YesPushDown: function(i) {
  var e = Ua(i);
  e.scope = i.scope;
  var t = [], r = ot.internal.getWidth(i) <= ot.internal.getHeight(i) ? ot.internal.getWidth(i) / 4 : ot.internal.getHeight(i) / 4;
  r = Number((0.9 * r).toFixed(5));
  var n = Number((2 * r).toFixed(5)), s = Number((n * ot.internal.Bezier_C).toFixed(5)), a = Number((r * ot.internal.Bezier_C).toFixed(5));
  return t.push("0.749023 g"), t.push("q"), t.push("1 0 0 1 " + PA(ot.internal.getWidth(i) / 2) + " " + PA(ot.internal.getHeight(i) / 2) + " cm"), t.push(n + " 0 m"), t.push(n + " " + s + " " + s + " " + n + " 0 " + n + " c"), t.push("-" + s + " " + n + " -" + n + " " + s + " -" + n + " 0 c"), t.push("-" + n + " -" + s + " -" + s + " -" + n + " 0 -" + n + " c"), t.push(s + " -" + n + " " + n + " -" + s + " " + n + " 0 c"), t.push("f"), t.push("Q"), t.push("0 g"), t.push("q"), t.push("1 0 0 1 " + PA(ot.internal.getWidth(i) / 2) + " " + PA(ot.internal.getHeight(i) / 2) + " cm"), t.push(r + " 0 m"), t.push(r + " " + a + " " + a + " " + r + " 0 " + r + " c"), t.push("-" + a + " " + r + " -" + r + " " + a + " -" + r + " 0 c"), t.push("-" + r + " -" + a + " -" + a + " -" + r + " 0 -" + r + " c"), t.push(a + " -" + r + " " + r + " -" + a + " " + r + " 0 c"), t.push("f"), t.push("Q"), e.stream = t.join(`
`), e;
}, OffPushDown: function(i) {
  var e = Ua(i);
  e.scope = i.scope;
  var t = [], r = ot.internal.getWidth(i) <= ot.internal.getHeight(i) ? ot.internal.getWidth(i) / 4 : ot.internal.getHeight(i) / 4;
  r = Number((0.9 * r).toFixed(5));
  var n = Number((2 * r).toFixed(5)), s = Number((n * ot.internal.Bezier_C).toFixed(5));
  return t.push("0.749023 g"), t.push("q"), t.push("1 0 0 1 " + PA(ot.internal.getWidth(i) / 2) + " " + PA(ot.internal.getHeight(i) / 2) + " cm"), t.push(n + " 0 m"), t.push(n + " " + s + " " + s + " " + n + " 0 " + n + " c"), t.push("-" + s + " " + n + " -" + n + " " + s + " -" + n + " 0 c"), t.push("-" + n + " -" + s + " -" + s + " -" + n + " 0 -" + n + " c"), t.push(s + " -" + n + " " + n + " -" + s + " " + n + " 0 c"), t.push("f"), t.push("Q"), e.stream = t.join(`
`), e;
} }, Cross: { createAppearanceStream: function(i) {
  var e = { D: { Off: ot.RadioButton.Cross.OffPushDown }, N: {} };
  return e.N[i] = ot.RadioButton.Cross.YesNormal, e.D[i] = ot.RadioButton.Cross.YesPushDown, e;
}, getCA: function() {
  return "8";
}, YesNormal: function(i) {
  var e = Ua(i);
  e.scope = i.scope;
  var t = [], r = ot.internal.calculateCross(i);
  return t.push("q"), t.push("1 1 " + Ht(ot.internal.getWidth(i) - 2) + " " + Ht(ot.internal.getHeight(i) - 2) + " re"), t.push("W"), t.push("n"), t.push(Ht(r.x1.x) + " " + Ht(r.x1.y) + " m"), t.push(Ht(r.x2.x) + " " + Ht(r.x2.y) + " l"), t.push(Ht(r.x4.x) + " " + Ht(r.x4.y) + " m"), t.push(Ht(r.x3.x) + " " + Ht(r.x3.y) + " l"), t.push("s"), t.push("Q"), e.stream = t.join(`
`), e;
}, YesPushDown: function(i) {
  var e = Ua(i);
  e.scope = i.scope;
  var t = ot.internal.calculateCross(i), r = [];
  return r.push("0.749023 g"), r.push("0 0 " + Ht(ot.internal.getWidth(i)) + " " + Ht(ot.internal.getHeight(i)) + " re"), r.push("f"), r.push("q"), r.push("1 1 " + Ht(ot.internal.getWidth(i) - 2) + " " + Ht(ot.internal.getHeight(i) - 2) + " re"), r.push("W"), r.push("n"), r.push(Ht(t.x1.x) + " " + Ht(t.x1.y) + " m"), r.push(Ht(t.x2.x) + " " + Ht(t.x2.y) + " l"), r.push(Ht(t.x4.x) + " " + Ht(t.x4.y) + " m"), r.push(Ht(t.x3.x) + " " + Ht(t.x3.y) + " l"), r.push("s"), r.push("Q"), e.stream = r.join(`
`), e;
}, OffPushDown: function(i) {
  var e = Ua(i);
  e.scope = i.scope;
  var t = [];
  return t.push("0.749023 g"), t.push("0 0 " + Ht(ot.internal.getWidth(i)) + " " + Ht(ot.internal.getHeight(i)) + " re"), t.push("f"), e.stream = t.join(`
`), e;
} } }, createDefaultAppearanceStream: function(i) {
  var e = i.scope.internal.getFont(i.fontName, i.fontStyle).id, t = i.scope.__private__.encodeColorString(i.color);
  return "/" + e + " " + i.fontSize + " Tf " + t;
} };
ot.internal = { Bezier_C: 0.551915024494, calculateCross: function(i) {
  var e = ot.internal.getWidth(i), t = ot.internal.getHeight(i), r = Math.min(e, t);
  return { x1: { x: (e - r) / 2, y: (t - r) / 2 + r }, x2: { x: (e - r) / 2 + r, y: (t - r) / 2 }, x3: { x: (e - r) / 2, y: (t - r) / 2 }, x4: { x: (e - r) / 2 + r, y: (t - r) / 2 + r } };
} }, ot.internal.getWidth = function(i) {
  var e = 0;
  return $r(i) === "object" && (e = Y5(i.Rect[2])), e;
}, ot.internal.getHeight = function(i) {
  var e = 0;
  return $r(i) === "object" && (e = Y5(i.Rect[3])), e;
};
var PX = bi.addField = function(i) {
  if (NX(this, i), !(i instanceof Ta))
    throw new Error("Invalid argument passed to jsPDF.addField.");
  var e;
  return (e = i).scope.internal.acroformPlugin.printedOut && (e.scope.internal.acroformPlugin.printedOut = !1, e.scope.internal.acroformPlugin.acroFormDictionaryRoot = null), e.scope.internal.acroformPlugin.acroFormDictionaryRoot.Fields.push(e), i.page = i.scope.internal.getCurrentPageInfo().pageNumber, this;
};
bi.AcroFormChoiceField = eu, bi.AcroFormListBox = tu, bi.AcroFormComboBox = ru, bi.AcroFormEditBox = X0, bi.AcroFormButton = yn, bi.AcroFormPushButton = W0, bi.AcroFormRadioButton = iu, bi.AcroFormCheckBox = Y0, bi.AcroFormTextField = nh, bi.AcroFormPasswordField = q0, bi.AcroFormAppearance = ot, bi.AcroForm = { ChoiceField: eu, ListBox: tu, ComboBox: ru, EditBox: X0, Button: yn, PushButton: W0, RadioButton: iu, CheckBox: Y0, TextField: nh, PasswordField: q0, Appearance: ot }, Lt.AcroForm = { ChoiceField: eu, ListBox: tu, ComboBox: ru, EditBox: X0, Button: yn, PushButton: W0, RadioButton: iu, CheckBox: Y0, TextField: nh, PasswordField: q0, Appearance: ot };
function nN(i) {
  return i.reduce(function(e, t, r) {
    return e[t] = r, e;
  }, {});
}
(function(i) {
  i.__addimage__ = {};
  var e = "UNKNOWN", t = { PNG: [[137, 80, 78, 71]], TIFF: [[77, 77, 0, 42], [73, 73, 42, 0]], JPEG: [[255, 216, 255, 224, void 0, void 0, 74, 70, 73, 70, 0], [255, 216, 255, 225, void 0, void 0, 69, 120, 105, 102, 0, 0], [255, 216, 255, 219], [255, 216, 255, 238]], JPEG2000: [[0, 0, 0, 12, 106, 80, 32, 32]], GIF87a: [[71, 73, 70, 56, 55, 97]], GIF89a: [[71, 73, 70, 56, 57, 97]], WEBP: [[82, 73, 70, 70, void 0, void 0, void 0, void 0, 87, 69, 66, 80]], BMP: [[66, 77], [66, 65], [67, 73], [67, 80], [73, 67], [80, 84]] }, r = i.__addimage__.getImageFileTypeByImageData = function(I, L) {
    var P, Q, X, W, q, Z = e;
    if ((L = L || e) === "RGBA" || I.data !== void 0 && I.data instanceof Uint8ClampedArray && "height" in I && "width" in I)
      return "RGBA";
    if (M(I))
      for (q in t)
        for (X = t[q], P = 0; P < X.length; P += 1) {
          for (W = !0, Q = 0; Q < X[P].length; Q += 1)
            if (X[P][Q] !== void 0 && X[P][Q] !== I[Q]) {
              W = !1;
              break;
            }
          if (W === !0) {
            Z = q;
            break;
          }
        }
    else
      for (q in t)
        for (X = t[q], P = 0; P < X.length; P += 1) {
          for (W = !0, Q = 0; Q < X[P].length; Q += 1)
            if (X[P][Q] !== void 0 && X[P][Q] !== I.charCodeAt(Q)) {
              W = !1;
              break;
            }
          if (W === !0) {
            Z = q;
            break;
          }
        }
    return Z === e && L !== e && (Z = L), Z;
  }, n = function I(L) {
    for (var P = this.internal.write, Q = this.internal.putStream, X = (0, this.internal.getFilters)(); X.indexOf("FlateEncode") !== -1; )
      X.splice(X.indexOf("FlateEncode"), 1);
    L.objectId = this.internal.newObject();
    var W = [];
    if (W.push({ key: "Type", value: "/XObject" }), W.push({ key: "Subtype", value: "/Image" }), W.push({ key: "Width", value: L.width }), W.push({ key: "Height", value: L.height }), L.colorSpace === y.INDEXED ? W.push({ key: "ColorSpace", value: "[/Indexed /DeviceRGB " + (L.palette.length / 3 - 1) + " " + ("sMask" in L && L.sMask !== void 0 ? L.objectId + 2 : L.objectId + 1) + " 0 R]" }) : (W.push({ key: "ColorSpace", value: "/" + L.colorSpace }), L.colorSpace === y.DEVICE_CMYK && W.push({ key: "Decode", value: "[1 0 1 0 1 0 1 0]" })), W.push({ key: "BitsPerComponent", value: L.bitsPerComponent }), "decodeParameters" in L && L.decodeParameters !== void 0 && W.push({ key: "DecodeParms", value: "<<" + L.decodeParameters + ">>" }), "transparency" in L && Array.isArray(L.transparency)) {
      for (var q = "", Z = 0, oe = L.transparency.length; Z < oe; Z++)
        q += L.transparency[Z] + " " + L.transparency[Z] + " ";
      W.push({ key: "Mask", value: "[" + q + "]" });
    }
    L.sMask !== void 0 && W.push({ key: "SMask", value: L.objectId + 1 + " 0 R" });
    var ne = L.filter !== void 0 ? ["/" + L.filter] : void 0;
    if (Q({ data: L.data, additionalKeyValues: W, alreadyAppliedFilters: ne, objectId: L.objectId }), P("endobj"), "sMask" in L && L.sMask !== void 0) {
      var me = "/Predictor " + L.predictor + " /Colors 1 /BitsPerComponent " + L.bitsPerComponent + " /Columns " + L.width, b = { width: L.width, height: L.height, colorSpace: "DeviceGray", bitsPerComponent: L.bitsPerComponent, decodeParameters: me, data: L.sMask };
      "filter" in L && (b.filter = L.filter), I.call(this, b);
    }
    if (L.colorSpace === y.INDEXED) {
      var H = this.internal.newObject();
      Q({ data: F(new Uint8Array(L.palette)), objectId: H }), P("endobj");
    }
  }, s = function() {
    var I = this.internal.collections.addImage_images;
    for (var L in I)
      n.call(this, I[L]);
  }, a = function() {
    var I, L = this.internal.collections.addImage_images, P = this.internal.write;
    for (var Q in L)
      P("/I" + (I = L[Q]).index, I.objectId, "0", "R");
  }, o = function() {
    this.internal.collections.addImage_images || (this.internal.collections.addImage_images = {}, this.internal.events.subscribe("putResources", s), this.internal.events.subscribe("putXobjectDict", a));
  }, A = function() {
    var I = this.internal.collections.addImage_images;
    return o.call(this), I;
  }, l = function() {
    return Object.keys(this.internal.collections.addImage_images).length;
  }, h = function(I) {
    return typeof i["process" + I.toUpperCase()] == "function";
  }, c = function(I) {
    return $r(I) === "object" && I.nodeType === 1;
  }, u = function(I, L) {
    if (I.nodeName === "IMG" && I.hasAttribute("src")) {
      var P = "" + I.getAttribute("src");
      if (P.indexOf("data:image/") === 0)
        return dd(unescape(P).split("base64,").pop());
      var Q = i.loadFile(P, !0);
      if (Q !== void 0)
        return Q;
    }
    if (I.nodeName === "CANVAS") {
      if (I.width === 0 || I.height === 0)
        throw new Error("Given canvas must have data. Canvas width: " + I.width + ", height: " + I.height);
      var X;
      switch (L) {
        case "PNG":
          X = "image/png";
          break;
        case "WEBP":
          X = "image/webp";
          break;
        case "JPEG":
        case "JPG":
        default:
          X = "image/jpeg";
      }
      return dd(I.toDataURL(X, 1).split("base64,").pop());
    }
  }, f = function(I) {
    var L = this.internal.collections.addImage_images;
    if (L) {
      for (var P in L)
        if (I === L[P].alias)
          return L[P];
    }
  }, g = function(I, L, P) {
    return I || L || (I = -96, L = -96), I < 0 && (I = -1 * P.width * 72 / I / this.internal.scaleFactor), L < 0 && (L = -1 * P.height * 72 / L / this.internal.scaleFactor), I === 0 && (I = L * P.width / P.height), L === 0 && (L = I * P.height / P.width), [I, L];
  }, p = function(I, L, P, Q, X, W) {
    var q = g.call(this, P, Q, X), Z = this.internal.getCoordinateString, oe = this.internal.getVerticalCoordinateString, ne = A.call(this);
    if (P = q[0], Q = q[1], ne[X.index] = X, W) {
      W *= Math.PI / 180;
      var me = Math.cos(W), b = Math.sin(W), H = function(j) {
        return j.toFixed(4);
      }, V = [H(me), H(b), H(-1 * b), H(me), 0, 0, "cm"];
    }
    this.internal.write("q"), W ? (this.internal.write([1, "0", "0", 1, Z(I), oe(L + Q), "cm"].join(" ")), this.internal.write(V.join(" ")), this.internal.write([Z(P), "0", "0", Z(Q), "0", "0", "cm"].join(" "))) : this.internal.write([Z(P), "0", "0", Z(Q), Z(I), oe(L + Q), "cm"].join(" ")), this.isAdvancedAPI() && this.internal.write([1, 0, 0, -1, 0, 0, "cm"].join(" ")), this.internal.write("/I" + X.index + " Do"), this.internal.write("Q");
  }, y = i.color_spaces = { DEVICE_RGB: "DeviceRGB", DEVICE_GRAY: "DeviceGray", DEVICE_CMYK: "DeviceCMYK", CAL_GREY: "CalGray", CAL_RGB: "CalRGB", LAB: "Lab", ICC_BASED: "ICCBased", INDEXED: "Indexed", PATTERN: "Pattern", SEPARATION: "Separation", DEVICE_N: "DeviceN" };
  i.decode = { DCT_DECODE: "DCTDecode", FLATE_DECODE: "FlateDecode", LZW_DECODE: "LZWDecode", JPX_DECODE: "JPXDecode", JBIG2_DECODE: "JBIG2Decode", ASCII85_DECODE: "ASCII85Decode", ASCII_HEX_DECODE: "ASCIIHexDecode", RUN_LENGTH_DECODE: "RunLengthDecode", CCITT_FAX_DECODE: "CCITTFaxDecode" };
  var v = i.image_compression = { NONE: "NONE", FAST: "FAST", MEDIUM: "MEDIUM", SLOW: "SLOW" }, w = i.__addimage__.sHashCode = function(I) {
    var L, P, Q = 0;
    if (typeof I == "string")
      for (P = I.length, L = 0; L < P; L++)
        Q = (Q << 5) - Q + I.charCodeAt(L), Q |= 0;
    else if (M(I))
      for (P = I.byteLength / 2, L = 0; L < P; L++)
        Q = (Q << 5) - Q + I[L], Q |= 0;
    return Q;
  }, C = i.__addimage__.validateStringAsBase64 = function(I) {
    (I = I || "").toString().trim();
    var L = !0;
    return I.length === 0 && (L = !1), I.length % 4 != 0 && (L = !1), /^[A-Za-z0-9+/]+$/.test(I.substr(0, I.length - 2)) === !1 && (L = !1), /^[A-Za-z0-9/][A-Za-z0-9+/]|[A-Za-z0-9+/]=|==$/.test(I.substr(-2)) === !1 && (L = !1), L;
  }, E = i.__addimage__.extractImageFromDataUrl = function(I) {
    var L = (I = I || "").split("base64,"), P = null;
    if (L.length === 2) {
      var Q = /^data:(\w*\/\w*);*(charset=(?!charset=)[\w=-]*)*;*$/.exec(L[0]);
      Array.isArray(Q) && (P = { mimeType: Q[1], charset: Q[2], data: L[1] });
    }
    return P;
  }, S = i.__addimage__.supportsArrayBuffer = function() {
    return typeof ArrayBuffer < "u" && typeof Uint8Array < "u";
  };
  i.__addimage__.isArrayBuffer = function(I) {
    return S() && I instanceof ArrayBuffer;
  };
  var M = i.__addimage__.isArrayBufferView = function(I) {
    return S() && typeof Uint32Array < "u" && (I instanceof Int8Array || I instanceof Uint8Array || typeof Uint8ClampedArray < "u" && I instanceof Uint8ClampedArray || I instanceof Int16Array || I instanceof Uint16Array || I instanceof Int32Array || I instanceof Uint32Array || I instanceof Float32Array || I instanceof Float64Array);
  }, T = i.__addimage__.binaryStringToUint8Array = function(I) {
    for (var L = I.length, P = new Uint8Array(L), Q = 0; Q < L; Q++)
      P[Q] = I.charCodeAt(Q);
    return P;
  }, F = i.__addimage__.arrayBufferToBinaryString = function(I) {
    for (var L = "", P = M(I) ? I : new Uint8Array(I), Q = 0; Q < P.length; Q += 8192)
      L += String.fromCharCode.apply(null, P.subarray(Q, Q + 8192));
    return L;
  };
  i.addImage = function() {
    var I, L, P, Q, X, W, q, Z, oe;
    if (typeof arguments[1] == "number" ? (L = e, P = arguments[1], Q = arguments[2], X = arguments[3], W = arguments[4], q = arguments[5], Z = arguments[6], oe = arguments[7]) : (L = arguments[1], P = arguments[2], Q = arguments[3], X = arguments[4], W = arguments[5], q = arguments[6], Z = arguments[7], oe = arguments[8]), $r(I = arguments[0]) === "object" && !c(I) && "imageData" in I) {
      var ne = I;
      I = ne.imageData, L = ne.format || L || e, P = ne.x || P || 0, Q = ne.y || Q || 0, X = ne.w || ne.width || X, W = ne.h || ne.height || W, q = ne.alias || q, Z = ne.compression || Z, oe = ne.rotation || ne.angle || oe;
    }
    var me = this.internal.getFilters();
    if (Z === void 0 && me.indexOf("FlateEncode") !== -1 && (Z = "SLOW"), isNaN(P) || isNaN(Q))
      throw new Error("Invalid coordinates passed to jsPDF.addImage");
    o.call(this);
    var b = k.call(this, I, L, q, Z);
    return p.call(this, P, Q, X, W, b, oe), this;
  };
  var k = function(I, L, P, Q) {
    var X, W, q;
    if (typeof I == "string" && r(I) === e) {
      I = unescape(I);
      var Z = $(I, !1);
      (Z !== "" || (Z = i.loadFile(I, !0)) !== void 0) && (I = Z);
    }
    if (c(I) && (I = u(I, L)), L = r(I, L), !h(L))
      throw new Error("addImage does not support files of type '" + L + "', please ensure that a plugin for '" + L + "' support is added.");
    if (((q = P) == null || q.length === 0) && (P = function(oe) {
      return typeof oe == "string" || M(oe) ? w(oe) : M(oe.data) ? w(oe.data) : null;
    }(I)), (X = f.call(this, P)) || (S() && (I instanceof Uint8Array || L === "RGBA" || (W = I, I = T(I))), X = this["process" + L.toUpperCase()](I, l.call(this), P, function(oe) {
      return oe && typeof oe == "string" && (oe = oe.toUpperCase()), oe in i.image_compression ? oe : v.NONE;
    }(Q), W)), !X)
      throw new Error("An unknown error occurred whilst processing the image.");
    return X;
  }, $ = i.__addimage__.convertBase64ToBinaryString = function(I, L) {
    var P;
    L = typeof L != "boolean" || L;
    var Q, X = "";
    if (typeof I == "string") {
      Q = (P = E(I)) !== null ? P.data : I;
      try {
        X = dd(Q);
      } catch (W) {
        if (L)
          throw C(Q) ? new Error("atob-Error in jsPDF.convertBase64ToBinaryString " + W.message) : new Error("Supplied Data is not a valid base64-String jsPDF.convertBase64ToBinaryString ");
      }
    }
    return X;
  };
  i.getImageProperties = function(I) {
    var L, P, Q = "";
    if (c(I) && (I = u(I)), typeof I == "string" && r(I) === e && ((Q = $(I, !1)) === "" && (Q = i.loadFile(I) || ""), I = Q), P = r(I), !h(P))
      throw new Error("addImage does not support files of type '" + P + "', please ensure that a plugin for '" + P + "' support is added.");
    if (!S() || I instanceof Uint8Array || (I = T(I)), !(L = this["process" + P.toUpperCase()](I)))
      throw new Error("An unknown error occurred whilst processing the image");
    return L.fileType = P, L;
  };
})(Lt.API), /**
 * @license
 * Copyright (c) 2014 Steven Spungin (TwelveTone LLC)  steven@twelvetone.tv
 *
 * Licensed under the MIT License.
 * http://opensource.org/licenses/mit-license
 */
function(i) {
  var e = function(t) {
    if (t !== void 0 && t != "")
      return !0;
  };
  Lt.API.events.push(["addPage", function(t) {
    this.internal.getPageInfo(t.pageNumber).pageContext.annotations = [];
  }]), i.events.push(["putPage", function(t) {
    for (var r, n, s, a = this.internal.getCoordinateString, o = this.internal.getVerticalCoordinateString, A = this.internal.getPageInfoByObjId(t.objId), l = t.pageContext.annotations, h = !1, c = 0; c < l.length && !h; c++)
      switch ((r = l[c]).type) {
        case "link":
          (e(r.options.url) || e(r.options.pageNumber)) && (h = !0);
          break;
        case "reference":
        case "text":
        case "freetext":
          h = !0;
      }
    if (h != 0) {
      this.internal.write("/Annots [");
      for (var u = 0; u < l.length; u++) {
        r = l[u];
        var f = this.internal.pdfEscape, g = this.internal.getEncryptor(t.objId);
        switch (r.type) {
          case "reference":
            this.internal.write(" " + r.object.objId + " 0 R ");
            break;
          case "text":
            var p = this.internal.newAdditionalObject(), y = this.internal.newAdditionalObject(), v = this.internal.getEncryptor(p.objId), w = r.title || "Note";
            s = "<</Type /Annot /Subtype /Text " + (n = "/Rect [" + a(r.bounds.x) + " " + o(r.bounds.y + r.bounds.h) + " " + a(r.bounds.x + r.bounds.w) + " " + o(r.bounds.y) + "] ") + "/Contents (" + f(v(r.contents)) + ")", s += " /Popup " + y.objId + " 0 R", s += " /P " + A.objId + " 0 R", s += " /T (" + f(v(w)) + ") >>", p.content = s;
            var C = p.objId + " 0 R";
            s = "<</Type /Annot /Subtype /Popup " + (n = "/Rect [" + a(r.bounds.x + 30) + " " + o(r.bounds.y + r.bounds.h) + " " + a(r.bounds.x + r.bounds.w + 30) + " " + o(r.bounds.y) + "] ") + " /Parent " + C, r.open && (s += " /Open true"), s += " >>", y.content = s, this.internal.write(p.objId, "0 R", y.objId, "0 R");
            break;
          case "freetext":
            n = "/Rect [" + a(r.bounds.x) + " " + o(r.bounds.y) + " " + a(r.bounds.x + r.bounds.w) + " " + o(r.bounds.y + r.bounds.h) + "] ";
            var E = r.color || "#000000";
            s = "<</Type /Annot /Subtype /FreeText " + n + "/Contents (" + f(g(r.contents)) + ")", s += " /DS(font: Helvetica,sans-serif 12.0pt; text-align:left; color:#" + E + ")", s += " /Border [0 0 0]", s += " >>", this.internal.write(s);
            break;
          case "link":
            if (r.options.name) {
              var S = this.annotations._nameMap[r.options.name];
              r.options.pageNumber = S.page, r.options.top = S.y;
            } else
              r.options.top || (r.options.top = 0);
            if (n = "/Rect [" + r.finalBounds.x + " " + r.finalBounds.y + " " + r.finalBounds.w + " " + r.finalBounds.h + "] ", s = "", r.options.url)
              s = "<</Type /Annot /Subtype /Link " + n + "/Border [0 0 0] /A <</S /URI /URI (" + f(g(r.options.url)) + ") >>";
            else if (r.options.pageNumber)
              switch (s = "<</Type /Annot /Subtype /Link " + n + "/Border [0 0 0] /Dest [" + this.internal.getPageInfo(r.options.pageNumber).objId + " 0 R", r.options.magFactor = r.options.magFactor || "XYZ", r.options.magFactor) {
                case "Fit":
                  s += " /Fit]";
                  break;
                case "FitH":
                  s += " /FitH " + r.options.top + "]";
                  break;
                case "FitV":
                  r.options.left = r.options.left || 0, s += " /FitV " + r.options.left + "]";
                  break;
                case "XYZ":
                default:
                  var M = o(r.options.top);
                  r.options.left = r.options.left || 0, r.options.zoom === void 0 && (r.options.zoom = 0), s += " /XYZ " + r.options.left + " " + M + " " + r.options.zoom + "]";
              }
            s != "" && (s += " >>", this.internal.write(s));
        }
      }
      this.internal.write("]");
    }
  }]), i.createAnnotation = function(t) {
    var r = this.internal.getCurrentPageInfo();
    switch (t.type) {
      case "link":
        this.link(t.bounds.x, t.bounds.y, t.bounds.w, t.bounds.h, t);
        break;
      case "text":
      case "freetext":
        r.pageContext.annotations.push(t);
    }
  }, i.link = function(t, r, n, s, a) {
    var o = this.internal.getCurrentPageInfo(), A = this.internal.getCoordinateString, l = this.internal.getVerticalCoordinateString;
    o.pageContext.annotations.push({ finalBounds: { x: A(t), y: l(r), w: A(t + n), h: l(r + s) }, options: a, type: "link" });
  }, i.textWithLink = function(t, r, n, s) {
    var a, o, A = this.getTextWidth(t), l = this.internal.getLineHeight() / this.internal.scaleFactor;
    if (s.maxWidth !== void 0) {
      o = s.maxWidth;
      var h = this.splitTextToSize(t, o).length;
      a = Math.ceil(l * h);
    } else
      o = A, a = l;
    return this.text(t, r, n, s), n += 0.2 * l, s.align === "center" && (r -= A / 2), s.align === "right" && (r -= A), this.link(r, n - l, o, a, s), A;
  }, i.getTextWidth = function(t) {
    var r = this.internal.getFontSize();
    return this.getStringUnitWidth(t) * r / this.internal.scaleFactor;
  };
}(Lt.API), /**
 * @license
 * Copyright (c) 2017 Aras Abbasi
 *
 * Licensed under the MIT License.
 * http://opensource.org/licenses/mit-license
 */
function(i) {
  var e = { 1569: [65152], 1570: [65153, 65154], 1571: [65155, 65156], 1572: [65157, 65158], 1573: [65159, 65160], 1574: [65161, 65162, 65163, 65164], 1575: [65165, 65166], 1576: [65167, 65168, 65169, 65170], 1577: [65171, 65172], 1578: [65173, 65174, 65175, 65176], 1579: [65177, 65178, 65179, 65180], 1580: [65181, 65182, 65183, 65184], 1581: [65185, 65186, 65187, 65188], 1582: [65189, 65190, 65191, 65192], 1583: [65193, 65194], 1584: [65195, 65196], 1585: [65197, 65198], 1586: [65199, 65200], 1587: [65201, 65202, 65203, 65204], 1588: [65205, 65206, 65207, 65208], 1589: [65209, 65210, 65211, 65212], 1590: [65213, 65214, 65215, 65216], 1591: [65217, 65218, 65219, 65220], 1592: [65221, 65222, 65223, 65224], 1593: [65225, 65226, 65227, 65228], 1594: [65229, 65230, 65231, 65232], 1601: [65233, 65234, 65235, 65236], 1602: [65237, 65238, 65239, 65240], 1603: [65241, 65242, 65243, 65244], 1604: [65245, 65246, 65247, 65248], 1605: [65249, 65250, 65251, 65252], 1606: [65253, 65254, 65255, 65256], 1607: [65257, 65258, 65259, 65260], 1608: [65261, 65262], 1609: [65263, 65264, 64488, 64489], 1610: [65265, 65266, 65267, 65268], 1649: [64336, 64337], 1655: [64477], 1657: [64358, 64359, 64360, 64361], 1658: [64350, 64351, 64352, 64353], 1659: [64338, 64339, 64340, 64341], 1662: [64342, 64343, 64344, 64345], 1663: [64354, 64355, 64356, 64357], 1664: [64346, 64347, 64348, 64349], 1667: [64374, 64375, 64376, 64377], 1668: [64370, 64371, 64372, 64373], 1670: [64378, 64379, 64380, 64381], 1671: [64382, 64383, 64384, 64385], 1672: [64392, 64393], 1676: [64388, 64389], 1677: [64386, 64387], 1678: [64390, 64391], 1681: [64396, 64397], 1688: [64394, 64395], 1700: [64362, 64363, 64364, 64365], 1702: [64366, 64367, 64368, 64369], 1705: [64398, 64399, 64400, 64401], 1709: [64467, 64468, 64469, 64470], 1711: [64402, 64403, 64404, 64405], 1713: [64410, 64411, 64412, 64413], 1715: [64406, 64407, 64408, 64409], 1722: [64414, 64415], 1723: [64416, 64417, 64418, 64419], 1726: [64426, 64427, 64428, 64429], 1728: [64420, 64421], 1729: [64422, 64423, 64424, 64425], 1733: [64480, 64481], 1734: [64473, 64474], 1735: [64471, 64472], 1736: [64475, 64476], 1737: [64482, 64483], 1739: [64478, 64479], 1740: [64508, 64509, 64510, 64511], 1744: [64484, 64485, 64486, 64487], 1746: [64430, 64431], 1747: [64432, 64433] }, t = { 65247: { 65154: 65269, 65156: 65271, 65160: 65273, 65166: 65275 }, 65248: { 65154: 65270, 65156: 65272, 65160: 65274, 65166: 65276 }, 65165: { 65247: { 65248: { 65258: 65010 } } }, 1617: { 1612: 64606, 1613: 64607, 1614: 64608, 1615: 64609, 1616: 64610 } }, r = { 1612: 64606, 1613: 64607, 1614: 64608, 1615: 64609, 1616: 64610 }, n = [1570, 1571, 1573, 1575];
  i.__arabicParser__ = {};
  var s = i.__arabicParser__.isInArabicSubstitutionA = function(p) {
    return e[p.charCodeAt(0)] !== void 0;
  }, a = i.__arabicParser__.isArabicLetter = function(p) {
    return typeof p == "string" && /^[\u0600-\u06FF\u0750-\u077F\u08A0-\u08FF\uFB50-\uFDFF\uFE70-\uFEFF]+$/.test(p);
  }, o = i.__arabicParser__.isArabicEndLetter = function(p) {
    return a(p) && s(p) && e[p.charCodeAt(0)].length <= 2;
  }, A = i.__arabicParser__.isArabicAlfLetter = function(p) {
    return a(p) && n.indexOf(p.charCodeAt(0)) >= 0;
  };
  i.__arabicParser__.arabicLetterHasIsolatedForm = function(p) {
    return a(p) && s(p) && e[p.charCodeAt(0)].length >= 1;
  };
  var l = i.__arabicParser__.arabicLetterHasFinalForm = function(p) {
    return a(p) && s(p) && e[p.charCodeAt(0)].length >= 2;
  };
  i.__arabicParser__.arabicLetterHasInitialForm = function(p) {
    return a(p) && s(p) && e[p.charCodeAt(0)].length >= 3;
  };
  var h = i.__arabicParser__.arabicLetterHasMedialForm = function(p) {
    return a(p) && s(p) && e[p.charCodeAt(0)].length == 4;
  }, c = i.__arabicParser__.resolveLigatures = function(p) {
    var y = 0, v = t, w = "", C = 0;
    for (y = 0; y < p.length; y += 1)
      v[p.charCodeAt(y)] !== void 0 ? (C++, typeof (v = v[p.charCodeAt(y)]) == "number" && (w += String.fromCharCode(v), v = t, C = 0), y === p.length - 1 && (v = t, w += p.charAt(y - (C - 1)), y -= C - 1, C = 0)) : (v = t, w += p.charAt(y - C), y -= C, C = 0);
    return w;
  };
  i.__arabicParser__.isArabicDiacritic = function(p) {
    return p !== void 0 && r[p.charCodeAt(0)] !== void 0;
  };
  var u = i.__arabicParser__.getCorrectForm = function(p, y, v) {
    return a(p) ? s(p) === !1 ? -1 : !l(p) || !a(y) && !a(v) || !a(v) && o(y) || o(p) && !a(y) || o(p) && A(y) || o(p) && o(y) ? 0 : h(p) && a(y) && !o(y) && a(v) && l(v) ? 3 : o(p) || !a(v) ? 1 : 2 : -1;
  }, f = function(p) {
    var y = 0, v = 0, w = 0, C = "", E = "", S = "", M = (p = p || "").split("\\s+"), T = [];
    for (y = 0; y < M.length; y += 1) {
      for (T.push(""), v = 0; v < M[y].length; v += 1)
        C = M[y][v], E = M[y][v - 1], S = M[y][v + 1], a(C) ? (w = u(C, E, S), T[y] += w !== -1 ? String.fromCharCode(e[C.charCodeAt(0)][w]) : C) : T[y] += C;
      T[y] = c(T[y]);
    }
    return T.join(" ");
  }, g = i.__arabicParser__.processArabic = i.processArabic = function() {
    var p, y = typeof arguments[0] == "string" ? arguments[0] : arguments[0].text, v = [];
    if (Array.isArray(y)) {
      var w = 0;
      for (v = [], w = 0; w < y.length; w += 1)
        Array.isArray(y[w]) ? v.push([f(y[w][0]), y[w][1], y[w][2]]) : v.push([f(y[w])]);
      p = v;
    } else
      p = f(y);
    return typeof arguments[0] == "string" ? p : (arguments[0].text = p, arguments[0]);
  };
  i.events.push(["preProcessText", g]);
}(Lt.API), Lt.API.autoPrint = function(i) {
  var e;
  switch ((i = i || {}).variant = i.variant || "non-conform", i.variant) {
    case "javascript":
      this.addJS("print({});");
      break;
    case "non-conform":
    default:
      this.internal.events.subscribe("postPutResources", function() {
        e = this.internal.newObject(), this.internal.out("<<"), this.internal.out("/S /Named"), this.internal.out("/Type /Action"), this.internal.out("/N /Print"), this.internal.out(">>"), this.internal.out("endobj");
      }), this.internal.events.subscribe("putCatalog", function() {
        this.internal.out("/OpenAction " + e + " 0 R");
      });
  }
  return this;
}, /**
 * @license
 * Copyright (c) 2014 Steven Spungin (TwelveTone LLC)  steven@twelvetone.tv
 *
 * Licensed under the MIT License.
 * http://opensource.org/licenses/mit-license
 */
function(i) {
  var e = function() {
    var t = void 0;
    Object.defineProperty(this, "pdf", { get: function() {
      return t;
    }, set: function(o) {
      t = o;
    } });
    var r = 150;
    Object.defineProperty(this, "width", { get: function() {
      return r;
    }, set: function(o) {
      r = isNaN(o) || Number.isInteger(o) === !1 || o < 0 ? 150 : o, this.getContext("2d").pageWrapXEnabled && (this.getContext("2d").pageWrapX = r + 1);
    } });
    var n = 300;
    Object.defineProperty(this, "height", { get: function() {
      return n;
    }, set: function(o) {
      n = isNaN(o) || Number.isInteger(o) === !1 || o < 0 ? 300 : o, this.getContext("2d").pageWrapYEnabled && (this.getContext("2d").pageWrapY = n + 1);
    } });
    var s = [];
    Object.defineProperty(this, "childNodes", { get: function() {
      return s;
    }, set: function(o) {
      s = o;
    } });
    var a = {};
    Object.defineProperty(this, "style", { get: function() {
      return a;
    }, set: function(o) {
      a = o;
    } }), Object.defineProperty(this, "parentNode", {});
  };
  e.prototype.getContext = function(t, r) {
    var n;
    if ((t = t || "2d") !== "2d")
      return null;
    for (n in r)
      this.pdf.context2d.hasOwnProperty(n) && (this.pdf.context2d[n] = r[n]);
    return this.pdf.context2d._canvas = this, this.pdf.context2d;
  }, e.prototype.toDataURL = function() {
    throw new Error("toDataURL is not implemented.");
  }, i.events.push(["initialized", function() {
    this.canvas = new e(), this.canvas.pdf = this;
  }]);
}(Lt.API), function(i) {
  var e = { left: 0, top: 0, bottom: 0, right: 0 }, t = !1, r = function() {
    this.internal.__cell__ === void 0 && (this.internal.__cell__ = {}, this.internal.__cell__.padding = 3, this.internal.__cell__.headerFunction = void 0, this.internal.__cell__.margins = Object.assign({}, e), this.internal.__cell__.margins.width = this.getPageWidth(), n.call(this));
  }, n = function() {
    this.internal.__cell__.lastCell = new s(), this.internal.__cell__.pages = 1;
  }, s = function() {
    var A = arguments[0];
    Object.defineProperty(this, "x", { enumerable: !0, get: function() {
      return A;
    }, set: function(p) {
      A = p;
    } });
    var l = arguments[1];
    Object.defineProperty(this, "y", { enumerable: !0, get: function() {
      return l;
    }, set: function(p) {
      l = p;
    } });
    var h = arguments[2];
    Object.defineProperty(this, "width", { enumerable: !0, get: function() {
      return h;
    }, set: function(p) {
      h = p;
    } });
    var c = arguments[3];
    Object.defineProperty(this, "height", { enumerable: !0, get: function() {
      return c;
    }, set: function(p) {
      c = p;
    } });
    var u = arguments[4];
    Object.defineProperty(this, "text", { enumerable: !0, get: function() {
      return u;
    }, set: function(p) {
      u = p;
    } });
    var f = arguments[5];
    Object.defineProperty(this, "lineNumber", { enumerable: !0, get: function() {
      return f;
    }, set: function(p) {
      f = p;
    } });
    var g = arguments[6];
    return Object.defineProperty(this, "align", { enumerable: !0, get: function() {
      return g;
    }, set: function(p) {
      g = p;
    } }), this;
  };
  s.prototype.clone = function() {
    return new s(this.x, this.y, this.width, this.height, this.text, this.lineNumber, this.align);
  }, s.prototype.toArray = function() {
    return [this.x, this.y, this.width, this.height, this.text, this.lineNumber, this.align];
  }, i.setHeaderFunction = function(A) {
    return r.call(this), this.internal.__cell__.headerFunction = typeof A == "function" ? A : void 0, this;
  }, i.getTextDimensions = function(A, l) {
    r.call(this);
    var h = (l = l || {}).fontSize || this.getFontSize(), c = l.font || this.getFont(), u = l.scaleFactor || this.internal.scaleFactor, f = 0, g = 0, p = 0, y = this;
    if (!Array.isArray(A) && typeof A != "string") {
      if (typeof A != "number")
        throw new Error("getTextDimensions expects text-parameter to be of type String or type Number or an Array of Strings.");
      A = String(A);
    }
    var v = l.maxWidth;
    v > 0 ? typeof A == "string" ? A = this.splitTextToSize(A, v) : Object.prototype.toString.call(A) === "[object Array]" && (A = A.reduce(function(C, E) {
      return C.concat(y.splitTextToSize(E, v));
    }, [])) : A = Array.isArray(A) ? A : [A];
    for (var w = 0; w < A.length; w++)
      f < (p = this.getStringUnitWidth(A[w], { font: c }) * h) && (f = p);
    return f !== 0 && (g = A.length), { w: f /= u, h: Math.max((g * h * this.getLineHeightFactor() - h * (this.getLineHeightFactor() - 1)) / u, 0) };
  }, i.cellAddPage = function() {
    r.call(this), this.addPage();
    var A = this.internal.__cell__.margins || e;
    return this.internal.__cell__.lastCell = new s(A.left, A.top, void 0, void 0), this.internal.__cell__.pages += 1, this;
  };
  var a = i.cell = function() {
    var A;
    A = arguments[0] instanceof s ? arguments[0] : new s(arguments[0], arguments[1], arguments[2], arguments[3], arguments[4], arguments[5]), r.call(this);
    var l = this.internal.__cell__.lastCell, h = this.internal.__cell__.padding, c = this.internal.__cell__.margins || e, u = this.internal.__cell__.tableHeaderRow, f = this.internal.__cell__.printHeaders;
    return l.lineNumber !== void 0 && (l.lineNumber === A.lineNumber ? (A.x = (l.x || 0) + (l.width || 0), A.y = l.y || 0) : l.y + l.height + A.height + c.bottom > this.getPageHeight() ? (this.cellAddPage(), A.y = c.top, f && u && (this.printHeaderRow(A.lineNumber, !0), A.y += u[0].height)) : A.y = l.y + l.height || A.y), A.text[0] !== void 0 && (this.rect(A.x, A.y, A.width, A.height, t === !0 ? "FD" : void 0), A.align === "right" ? this.text(A.text, A.x + A.width - h, A.y + h, { align: "right", baseline: "top" }) : A.align === "center" ? this.text(A.text, A.x + A.width / 2, A.y + h, { align: "center", baseline: "top", maxWidth: A.width - h - h }) : this.text(A.text, A.x + h, A.y + h, { align: "left", baseline: "top", maxWidth: A.width - h - h })), this.internal.__cell__.lastCell = A, this;
  };
  i.table = function(A, l, h, c, u) {
    if (r.call(this), !h)
      throw new Error("No data for PDF table.");
    var f, g, p, y, v = [], w = [], C = [], E = {}, S = {}, M = [], T = [], F = (u = u || {}).autoSize || !1, k = u.printHeaders !== !1, $ = u.css && u.css["font-size"] !== void 0 ? 16 * u.css["font-size"] : u.fontSize || 12, I = u.margins || Object.assign({ width: this.getPageWidth() }, e), L = typeof u.padding == "number" ? u.padding : 3, P = u.headerBackgroundColor || "#c8c8c8", Q = u.headerTextColor || "#000";
    if (n.call(this), this.internal.__cell__.printHeaders = k, this.internal.__cell__.margins = I, this.internal.__cell__.table_font_size = $, this.internal.__cell__.padding = L, this.internal.__cell__.headerBackgroundColor = P, this.internal.__cell__.headerTextColor = Q, this.setFontSize($), c == null)
      w = v = Object.keys(h[0]), C = v.map(function() {
        return "left";
      });
    else if (Array.isArray(c) && $r(c[0]) === "object")
      for (v = c.map(function(ne) {
        return ne.name;
      }), w = c.map(function(ne) {
        return ne.prompt || ne.name || "";
      }), C = c.map(function(ne) {
        return ne.align || "left";
      }), f = 0; f < c.length; f += 1)
        S[c[f].name] = c[f].width * (19.049976 / 25.4);
    else
      Array.isArray(c) && typeof c[0] == "string" && (w = v = c, C = v.map(function() {
        return "left";
      }));
    if (F || Array.isArray(c) && typeof c[0] == "string")
      for (f = 0; f < v.length; f += 1) {
        for (E[y = v[f]] = h.map(function(ne) {
          return ne[y];
        }), this.setFont(void 0, "bold"), M.push(this.getTextDimensions(w[f], { fontSize: this.internal.__cell__.table_font_size, scaleFactor: this.internal.scaleFactor }).w), g = E[y], this.setFont(void 0, "normal"), p = 0; p < g.length; p += 1)
          M.push(this.getTextDimensions(g[p], { fontSize: this.internal.__cell__.table_font_size, scaleFactor: this.internal.scaleFactor }).w);
        S[y] = Math.max.apply(null, M) + L + L, M = [];
      }
    if (k) {
      var X = {};
      for (f = 0; f < v.length; f += 1)
        X[v[f]] = {}, X[v[f]].text = w[f], X[v[f]].align = C[f];
      var W = o.call(this, X, S);
      T = v.map(function(ne) {
        return new s(A, l, S[ne], W, X[ne].text, void 0, X[ne].align);
      }), this.setTableHeaderRow(T), this.printHeaderRow(1, !1);
    }
    var q = c.reduce(function(ne, me) {
      return ne[me.name] = me.align, ne;
    }, {});
    for (f = 0; f < h.length; f += 1) {
      "rowStart" in u && u.rowStart instanceof Function && u.rowStart({ row: f, data: h[f] }, this);
      var Z = o.call(this, h[f], S);
      for (p = 0; p < v.length; p += 1) {
        var oe = h[f][v[p]];
        "cellStart" in u && u.cellStart instanceof Function && u.cellStart({ row: f, col: p, data: oe }, this), a.call(this, new s(A, l, S[v[p]], Z, oe, f + 2, q[v[p]]));
      }
    }
    return this.internal.__cell__.table_x = A, this.internal.__cell__.table_y = l, this;
  };
  var o = function(A, l) {
    var h = this.internal.__cell__.padding, c = this.internal.__cell__.table_font_size, u = this.internal.scaleFactor;
    return Object.keys(A).map(function(f) {
      var g = A[f];
      return this.splitTextToSize(g.hasOwnProperty("text") ? g.text : g, l[f] - h - h);
    }, this).map(function(f) {
      return this.getLineHeightFactor() * f.length * c / u + h + h;
    }, this).reduce(function(f, g) {
      return Math.max(f, g);
    }, 0);
  };
  i.setTableHeaderRow = function(A) {
    r.call(this), this.internal.__cell__.tableHeaderRow = A;
  }, i.printHeaderRow = function(A, l) {
    if (r.call(this), !this.internal.__cell__.tableHeaderRow)
      throw new Error("Property tableHeaderRow does not exist.");
    var h;
    if (t = !0, typeof this.internal.__cell__.headerFunction == "function") {
      var c = this.internal.__cell__.headerFunction(this, this.internal.__cell__.pages);
      this.internal.__cell__.lastCell = new s(c[0], c[1], c[2], c[3], void 0, -1);
    }
    this.setFont(void 0, "bold");
    for (var u = [], f = 0; f < this.internal.__cell__.tableHeaderRow.length; f += 1) {
      h = this.internal.__cell__.tableHeaderRow[f].clone(), l && (h.y = this.internal.__cell__.margins.top || 0, u.push(h)), h.lineNumber = A;
      var g = this.getTextColor();
      this.setTextColor(this.internal.__cell__.headerTextColor), this.setFillColor(this.internal.__cell__.headerBackgroundColor), a.call(this, h), this.setTextColor(g);
    }
    u.length > 0 && this.setTableHeaderRow(u), this.setFont(void 0, "normal"), t = !1;
  };
}(Lt.API);
var sN = { italic: ["italic", "oblique", "normal"], oblique: ["oblique", "italic", "normal"], normal: ["normal", "oblique", "italic"] }, aN = ["ultra-condensed", "extra-condensed", "condensed", "semi-condensed", "normal", "semi-expanded", "expanded", "extra-expanded", "ultra-expanded"], ix = nN(aN), oN = [100, 200, 300, 400, 500, 600, 700, 800, 900], OX = nN(oN);
function nx(i) {
  var e = i.family.replace(/"|'/g, "").toLowerCase(), t = function(s) {
    return sN[s = s || "normal"] ? s : "normal";
  }(i.style), r = function(s) {
    if (!s)
      return 400;
    if (typeof s == "number")
      return s >= 100 && s <= 900 && s % 100 == 0 ? s : 400;
    if (/^\d00$/.test(s))
      return parseInt(s);
    switch (s) {
      case "bold":
        return 700;
      case "normal":
      default:
        return 400;
    }
  }(i.weight), n = function(s) {
    return typeof ix[s = s || "normal"] == "number" ? s : "normal";
  }(i.stretch);
  return { family: e, style: t, weight: r, stretch: n, src: i.src || [], ref: i.ref || { name: e, style: [n, t, r].join(" ") } };
}
function q5(i, e, t, r) {
  var n;
  for (n = t; n >= 0 && n < e.length; n += r)
    if (i[e[n]])
      return i[e[n]];
  for (n = t; n >= 0 && n < e.length; n -= r)
    if (i[e[n]])
      return i[e[n]];
}
var UX = { "sans-serif": "helvetica", fixed: "courier", monospace: "courier", terminal: "courier", cursive: "times", fantasy: "times", serif: "times" }, Z5 = { caption: "times", icon: "times", menu: "times", "message-box": "times", "small-caption": "times", "status-bar": "times" };
function J5(i) {
  return [i.stretch, i.style, i.weight, i.family].join(" ");
}
function QX(i, e, t) {
  for (var r = (t = t || {}).defaultFontFamily || "times", n = Object.assign({}, UX, t.genericFontFamilies || {}), s = null, a = null, o = 0; o < e.length; ++o)
    if (n[(s = nx(e[o])).family] && (s.family = n[s.family]), i.hasOwnProperty(s.family)) {
      a = i[s.family];
      break;
    }
  if (!(a = a || i[r]))
    throw new Error("Could not find a font-family for the rule '" + J5(s) + "' and default family '" + r + "'.");
  if (a = function(A, l) {
    if (l[A])
      return l[A];
    var h = ix[A], c = h <= ix.normal ? -1 : 1, u = q5(l, aN, h, c);
    if (!u)
      throw new Error("Could not find a matching font-stretch value for " + A);
    return u;
  }(s.stretch, a), a = function(A, l) {
    if (l[A])
      return l[A];
    for (var h = sN[A], c = 0; c < h.length; ++c)
      if (l[h[c]])
        return l[h[c]];
    throw new Error("Could not find a matching font-style for " + A);
  }(s.style, a), !(a = function(A, l) {
    if (l[A])
      return l[A];
    if (A === 400 && l[500])
      return l[500];
    if (A === 500 && l[400])
      return l[400];
    var h = OX[A], c = q5(l, oN, h, A < 400 ? -1 : 1);
    if (!c)
      throw new Error("Could not find a matching font-weight for value " + A);
    return c;
  }(s.weight, a)))
    throw new Error("Failed to resolve a font for the rule '" + J5(s) + "'.");
  return a;
}
function eT(i) {
  return i.trimLeft();
}
function DX(i, e) {
  for (var t = 0; t < i.length; ) {
    if (i.charAt(t) === e)
      return [i.substring(0, t), i.substring(t + 1)];
    t += 1;
  }
  return null;
}
function kX(i) {
  var e = i.match(/^(-[a-z_]|[a-z_])[a-z0-9_-]*/i);
  return e === null ? null : [e[0], i.substring(e[0].length)];
}
var Hp, tT, rT, A_ = ["times"];
(function(i) {
  var e, t, r, n, s, a, o, A, l, h = function(b) {
    return b = b || {}, this.isStrokeTransparent = b.isStrokeTransparent || !1, this.strokeOpacity = b.strokeOpacity || 1, this.strokeStyle = b.strokeStyle || "#000000", this.fillStyle = b.fillStyle || "#000000", this.isFillTransparent = b.isFillTransparent || !1, this.fillOpacity = b.fillOpacity || 1, this.font = b.font || "10px sans-serif", this.textBaseline = b.textBaseline || "alphabetic", this.textAlign = b.textAlign || "left", this.lineWidth = b.lineWidth || 1, this.lineJoin = b.lineJoin || "miter", this.lineCap = b.lineCap || "butt", this.path = b.path || [], this.transform = b.transform !== void 0 ? b.transform.clone() : new A(), this.globalCompositeOperation = b.globalCompositeOperation || "normal", this.globalAlpha = b.globalAlpha || 1, this.clip_path = b.clip_path || [], this.currentPoint = b.currentPoint || new a(), this.miterLimit = b.miterLimit || 10, this.lastPoint = b.lastPoint || new a(), this.lineDashOffset = b.lineDashOffset || 0, this.lineDash = b.lineDash || [], this.margin = b.margin || [0, 0, 0, 0], this.prevPageLastElemOffset = b.prevPageLastElemOffset || 0, this.ignoreClearRect = typeof b.ignoreClearRect != "boolean" || b.ignoreClearRect, this;
  };
  i.events.push(["initialized", function() {
    this.context2d = new c(this), e = this.internal.f2, t = this.internal.getCoordinateString, r = this.internal.getVerticalCoordinateString, n = this.internal.getHorizontalCoordinate, s = this.internal.getVerticalCoordinate, a = this.internal.Point, o = this.internal.Rectangle, A = this.internal.Matrix, l = new h();
  }]);
  var c = function(b) {
    Object.defineProperty(this, "canvas", { get: function() {
      return { parentNode: !1, style: !1 };
    } });
    var H = b;
    Object.defineProperty(this, "pdf", { get: function() {
      return H;
    } });
    var V = !1;
    Object.defineProperty(this, "pageWrapXEnabled", { get: function() {
      return V;
    }, set: function(ve) {
      V = !!ve;
    } });
    var j = !1;
    Object.defineProperty(this, "pageWrapYEnabled", { get: function() {
      return j;
    }, set: function(ve) {
      j = !!ve;
    } });
    var ie = 0;
    Object.defineProperty(this, "posX", { get: function() {
      return ie;
    }, set: function(ve) {
      isNaN(ve) || (ie = ve);
    } });
    var ue = 0;
    Object.defineProperty(this, "posY", { get: function() {
      return ue;
    }, set: function(ve) {
      isNaN(ve) || (ue = ve);
    } }), Object.defineProperty(this, "margin", { get: function() {
      return l.margin;
    }, set: function(ve) {
      var Y;
      typeof ve == "number" ? Y = [ve, ve, ve, ve] : ((Y = new Array(4))[0] = ve[0], Y[1] = ve.length >= 2 ? ve[1] : Y[0], Y[2] = ve.length >= 3 ? ve[2] : Y[0], Y[3] = ve.length >= 4 ? ve[3] : Y[1]), l.margin = Y;
    } });
    var fe = !1;
    Object.defineProperty(this, "autoPaging", { get: function() {
      return fe;
    }, set: function(ve) {
      fe = ve;
    } });
    var ee = 0;
    Object.defineProperty(this, "lastBreak", { get: function() {
      return ee;
    }, set: function(ve) {
      ee = ve;
    } });
    var xe = [];
    Object.defineProperty(this, "pageBreaks", { get: function() {
      return xe;
    }, set: function(ve) {
      xe = ve;
    } }), Object.defineProperty(this, "ctx", { get: function() {
      return l;
    }, set: function(ve) {
      ve instanceof h && (l = ve);
    } }), Object.defineProperty(this, "path", { get: function() {
      return l.path;
    }, set: function(ve) {
      l.path = ve;
    } });
    var Ee = [];
    Object.defineProperty(this, "ctxStack", { get: function() {
      return Ee;
    }, set: function(ve) {
      Ee = ve;
    } }), Object.defineProperty(this, "fillStyle", { get: function() {
      return this.ctx.fillStyle;
    }, set: function(ve) {
      var Y;
      Y = u(ve), this.ctx.fillStyle = Y.style, this.ctx.isFillTransparent = Y.a === 0, this.ctx.fillOpacity = Y.a, this.pdf.setFillColor(Y.r, Y.g, Y.b, { a: Y.a }), this.pdf.setTextColor(Y.r, Y.g, Y.b, { a: Y.a });
    } }), Object.defineProperty(this, "strokeStyle", { get: function() {
      return this.ctx.strokeStyle;
    }, set: function(ve) {
      var Y = u(ve);
      this.ctx.strokeStyle = Y.style, this.ctx.isStrokeTransparent = Y.a === 0, this.ctx.strokeOpacity = Y.a, Y.a === 0 ? this.pdf.setDrawColor(255, 255, 255) : (Y.a, this.pdf.setDrawColor(Y.r, Y.g, Y.b));
    } }), Object.defineProperty(this, "lineCap", { get: function() {
      return this.ctx.lineCap;
    }, set: function(ve) {
      ["butt", "round", "square"].indexOf(ve) !== -1 && (this.ctx.lineCap = ve, this.pdf.setLineCap(ve));
    } }), Object.defineProperty(this, "lineWidth", { get: function() {
      return this.ctx.lineWidth;
    }, set: function(ve) {
      isNaN(ve) || (this.ctx.lineWidth = ve, this.pdf.setLineWidth(ve));
    } }), Object.defineProperty(this, "lineJoin", { get: function() {
      return this.ctx.lineJoin;
    }, set: function(ve) {
      ["bevel", "round", "miter"].indexOf(ve) !== -1 && (this.ctx.lineJoin = ve, this.pdf.setLineJoin(ve));
    } }), Object.defineProperty(this, "miterLimit", { get: function() {
      return this.ctx.miterLimit;
    }, set: function(ve) {
      isNaN(ve) || (this.ctx.miterLimit = ve, this.pdf.setMiterLimit(ve));
    } }), Object.defineProperty(this, "textBaseline", { get: function() {
      return this.ctx.textBaseline;
    }, set: function(ve) {
      this.ctx.textBaseline = ve;
    } }), Object.defineProperty(this, "textAlign", { get: function() {
      return this.ctx.textAlign;
    }, set: function(ve) {
      ["right", "end", "center", "left", "start"].indexOf(ve) !== -1 && (this.ctx.textAlign = ve);
    } });
    var Ue = null;
    function ke(ve, Y) {
      if (Ue === null) {
        var mt = function(Ze) {
          var Fe = [];
          return Object.keys(Ze).forEach(function(Re) {
            Ze[Re].forEach(function(De) {
              var Le = null;
              switch (De) {
                case "bold":
                  Le = { family: Re, weight: "bold" };
                  break;
                case "italic":
                  Le = { family: Re, style: "italic" };
                  break;
                case "bolditalic":
                  Le = { family: Re, weight: "bold", style: "italic" };
                  break;
                case "":
                case "normal":
                  Le = { family: Re };
              }
              Le !== null && (Le.ref = { name: Re, style: De }, Fe.push(Le));
            });
          }), Fe;
        }(ve.getFontList());
        Ue = function(Ze) {
          for (var Fe = {}, Re = 0; Re < Ze.length; ++Re) {
            var De = nx(Ze[Re]), Le = De.family, Ge = De.stretch, ze = De.style, ft = De.weight;
            Fe[Le] = Fe[Le] || {}, Fe[Le][Ge] = Fe[Le][Ge] || {}, Fe[Le][Ge][ze] = Fe[Le][Ge][ze] || {}, Fe[Le][Ge][ze][ft] = De;
          }
          return Fe;
        }(mt.concat(Y));
      }
      return Ue;
    }
    var We = null;
    Object.defineProperty(this, "fontFaces", { get: function() {
      return We;
    }, set: function(ve) {
      Ue = null, We = ve;
    } }), Object.defineProperty(this, "font", { get: function() {
      return this.ctx.font;
    }, set: function(ve) {
      var Y;
      if (this.ctx.font = ve, (Y = /^\s*(?=(?:(?:[-a-z]+\s*){0,2}(italic|oblique))?)(?=(?:(?:[-a-z]+\s*){0,2}(small-caps))?)(?=(?:(?:[-a-z]+\s*){0,2}(bold(?:er)?|lighter|[1-9]00))?)(?:(?:normal|\1|\2|\3)\s*){0,3}((?:xx?-)?(?:small|large)|medium|smaller|larger|[.\d]+(?:\%|in|[cem]m|ex|p[ctx]))(?:\s*\/\s*(normal|[.\d]+(?:\%|in|[cem]m|ex|p[ctx])))?\s*([-_,\"\'\sa-z]+?)\s*$/i.exec(ve)) !== null) {
        var mt = Y[1], Ze = (Y[2], Y[3]), Fe = Y[4], Re = (Y[5], Y[6]), De = /^([.\d]+)((?:%|in|[cem]m|ex|p[ctx]))$/i.exec(Fe)[2];
        Fe = Math.floor(De === "px" ? parseFloat(Fe) * this.pdf.internal.scaleFactor : De === "em" ? parseFloat(Fe) * this.pdf.getFontSize() : parseFloat(Fe) * this.pdf.internal.scaleFactor), this.pdf.setFontSize(Fe);
        var Le = function(At) {
          var vt, Ne, Qr = [], kt = At.trim();
          if (kt === "")
            return A_;
          if (kt in Z5)
            return [Z5[kt]];
          for (; kt !== ""; ) {
            switch (Ne = null, vt = (kt = eT(kt)).charAt(0)) {
              case '"':
              case "'":
                Ne = DX(kt.substring(1), vt);
                break;
              default:
                Ne = kX(kt);
            }
            if (Ne === null || (Qr.push(Ne[0]), (kt = eT(Ne[1])) !== "" && kt.charAt(0) !== ","))
              return A_;
            kt = kt.replace(/^,/, "");
          }
          return Qr;
        }(Re);
        if (this.fontFaces) {
          var Ge = QX(ke(this.pdf, this.fontFaces), Le.map(function(At) {
            return { family: At, stretch: "normal", weight: Ze, style: mt };
          }));
          this.pdf.setFont(Ge.ref.name, Ge.ref.style);
        } else {
          var ze = "";
          (Ze === "bold" || parseInt(Ze, 10) >= 700 || mt === "bold") && (ze = "bold"), mt === "italic" && (ze += "italic"), ze.length === 0 && (ze = "normal");
          for (var ft = "", Et = { arial: "Helvetica", Arial: "Helvetica", verdana: "Helvetica", Verdana: "Helvetica", helvetica: "Helvetica", Helvetica: "Helvetica", "sans-serif": "Helvetica", fixed: "Courier", monospace: "Courier", terminal: "Courier", cursive: "Times", fantasy: "Times", serif: "Times" }, Mt = 0; Mt < Le.length; Mt++) {
            if (this.pdf.internal.getFont(Le[Mt], ze, { noFallback: !0, disableWarning: !0 }) !== void 0) {
              ft = Le[Mt];
              break;
            }
            if (ze === "bolditalic" && this.pdf.internal.getFont(Le[Mt], "bold", { noFallback: !0, disableWarning: !0 }) !== void 0)
              ft = Le[Mt], ze = "bold";
            else if (this.pdf.internal.getFont(Le[Mt], "normal", { noFallback: !0, disableWarning: !0 }) !== void 0) {
              ft = Le[Mt], ze = "normal";
              break;
            }
          }
          if (ft === "") {
            for (var Ut = 0; Ut < Le.length; Ut++)
              if (Et[Le[Ut]]) {
                ft = Et[Le[Ut]];
                break;
              }
          }
          ft = ft === "" ? "Times" : ft, this.pdf.setFont(ft, ze);
        }
      }
    } }), Object.defineProperty(this, "globalCompositeOperation", { get: function() {
      return this.ctx.globalCompositeOperation;
    }, set: function(ve) {
      this.ctx.globalCompositeOperation = ve;
    } }), Object.defineProperty(this, "globalAlpha", { get: function() {
      return this.ctx.globalAlpha;
    }, set: function(ve) {
      this.ctx.globalAlpha = ve;
    } }), Object.defineProperty(this, "lineDashOffset", { get: function() {
      return this.ctx.lineDashOffset;
    }, set: function(ve) {
      this.ctx.lineDashOffset = ve, me.call(this);
    } }), Object.defineProperty(this, "lineDash", { get: function() {
      return this.ctx.lineDash;
    }, set: function(ve) {
      this.ctx.lineDash = ve, me.call(this);
    } }), Object.defineProperty(this, "ignoreClearRect", { get: function() {
      return this.ctx.ignoreClearRect;
    }, set: function(ve) {
      this.ctx.ignoreClearRect = !!ve;
    } });
  };
  c.prototype.setLineDash = function(b) {
    this.lineDash = b;
  }, c.prototype.getLineDash = function() {
    return this.lineDash.length % 2 ? this.lineDash.concat(this.lineDash) : this.lineDash.slice();
  }, c.prototype.fill = function() {
    E.call(this, "fill", !1);
  }, c.prototype.stroke = function() {
    E.call(this, "stroke", !1);
  }, c.prototype.beginPath = function() {
    this.path = [{ type: "begin" }];
  }, c.prototype.moveTo = function(b, H) {
    if (isNaN(b) || isNaN(H))
      throw Yr.error("jsPDF.context2d.moveTo: Invalid arguments", arguments), new Error("Invalid arguments passed to jsPDF.context2d.moveTo");
    var V = this.ctx.transform.applyToPoint(new a(b, H));
    this.path.push({ type: "mt", x: V.x, y: V.y }), this.ctx.lastPoint = new a(b, H);
  }, c.prototype.closePath = function() {
    var b = new a(0, 0), H = 0;
    for (H = this.path.length - 1; H !== -1; H--)
      if (this.path[H].type === "begin" && $r(this.path[H + 1]) === "object" && typeof this.path[H + 1].x == "number") {
        b = new a(this.path[H + 1].x, this.path[H + 1].y);
        break;
      }
    this.path.push({ type: "close" }), this.ctx.lastPoint = new a(b.x, b.y);
  }, c.prototype.lineTo = function(b, H) {
    if (isNaN(b) || isNaN(H))
      throw Yr.error("jsPDF.context2d.lineTo: Invalid arguments", arguments), new Error("Invalid arguments passed to jsPDF.context2d.lineTo");
    var V = this.ctx.transform.applyToPoint(new a(b, H));
    this.path.push({ type: "lt", x: V.x, y: V.y }), this.ctx.lastPoint = new a(V.x, V.y);
  }, c.prototype.clip = function() {
    this.ctx.clip_path = JSON.parse(JSON.stringify(this.path)), E.call(this, null, !0);
  }, c.prototype.quadraticCurveTo = function(b, H, V, j) {
    if (isNaN(V) || isNaN(j) || isNaN(b) || isNaN(H))
      throw Yr.error("jsPDF.context2d.quadraticCurveTo: Invalid arguments", arguments), new Error("Invalid arguments passed to jsPDF.context2d.quadraticCurveTo");
    var ie = this.ctx.transform.applyToPoint(new a(V, j)), ue = this.ctx.transform.applyToPoint(new a(b, H));
    this.path.push({ type: "qct", x1: ue.x, y1: ue.y, x: ie.x, y: ie.y }), this.ctx.lastPoint = new a(ie.x, ie.y);
  }, c.prototype.bezierCurveTo = function(b, H, V, j, ie, ue) {
    if (isNaN(ie) || isNaN(ue) || isNaN(b) || isNaN(H) || isNaN(V) || isNaN(j))
      throw Yr.error("jsPDF.context2d.bezierCurveTo: Invalid arguments", arguments), new Error("Invalid arguments passed to jsPDF.context2d.bezierCurveTo");
    var fe = this.ctx.transform.applyToPoint(new a(ie, ue)), ee = this.ctx.transform.applyToPoint(new a(b, H)), xe = this.ctx.transform.applyToPoint(new a(V, j));
    this.path.push({ type: "bct", x1: ee.x, y1: ee.y, x2: xe.x, y2: xe.y, x: fe.x, y: fe.y }), this.ctx.lastPoint = new a(fe.x, fe.y);
  }, c.prototype.arc = function(b, H, V, j, ie, ue) {
    if (isNaN(b) || isNaN(H) || isNaN(V) || isNaN(j) || isNaN(ie))
      throw Yr.error("jsPDF.context2d.arc: Invalid arguments", arguments), new Error("Invalid arguments passed to jsPDF.context2d.arc");
    if (ue = !!ue, !this.ctx.transform.isIdentity) {
      var fe = this.ctx.transform.applyToPoint(new a(b, H));
      b = fe.x, H = fe.y;
      var ee = this.ctx.transform.applyToPoint(new a(0, V)), xe = this.ctx.transform.applyToPoint(new a(0, 0));
      V = Math.sqrt(Math.pow(ee.x - xe.x, 2) + Math.pow(ee.y - xe.y, 2));
    }
    Math.abs(ie - j) >= 2 * Math.PI && (j = 0, ie = 2 * Math.PI), this.path.push({ type: "arc", x: b, y: H, radius: V, startAngle: j, endAngle: ie, counterclockwise: ue });
  }, c.prototype.arcTo = function(b, H, V, j, ie) {
    throw new Error("arcTo not implemented.");
  }, c.prototype.rect = function(b, H, V, j) {
    if (isNaN(b) || isNaN(H) || isNaN(V) || isNaN(j))
      throw Yr.error("jsPDF.context2d.rect: Invalid arguments", arguments), new Error("Invalid arguments passed to jsPDF.context2d.rect");
    this.moveTo(b, H), this.lineTo(b + V, H), this.lineTo(b + V, H + j), this.lineTo(b, H + j), this.lineTo(b, H), this.lineTo(b + V, H), this.lineTo(b, H);
  }, c.prototype.fillRect = function(b, H, V, j) {
    if (isNaN(b) || isNaN(H) || isNaN(V) || isNaN(j))
      throw Yr.error("jsPDF.context2d.fillRect: Invalid arguments", arguments), new Error("Invalid arguments passed to jsPDF.context2d.fillRect");
    if (!f.call(this)) {
      var ie = {};
      this.lineCap !== "butt" && (ie.lineCap = this.lineCap, this.lineCap = "butt"), this.lineJoin !== "miter" && (ie.lineJoin = this.lineJoin, this.lineJoin = "miter"), this.beginPath(), this.rect(b, H, V, j), this.fill(), ie.hasOwnProperty("lineCap") && (this.lineCap = ie.lineCap), ie.hasOwnProperty("lineJoin") && (this.lineJoin = ie.lineJoin);
    }
  }, c.prototype.strokeRect = function(b, H, V, j) {
    if (isNaN(b) || isNaN(H) || isNaN(V) || isNaN(j))
      throw Yr.error("jsPDF.context2d.strokeRect: Invalid arguments", arguments), new Error("Invalid arguments passed to jsPDF.context2d.strokeRect");
    g.call(this) || (this.beginPath(), this.rect(b, H, V, j), this.stroke());
  }, c.prototype.clearRect = function(b, H, V, j) {
    if (isNaN(b) || isNaN(H) || isNaN(V) || isNaN(j))
      throw Yr.error("jsPDF.context2d.clearRect: Invalid arguments", arguments), new Error("Invalid arguments passed to jsPDF.context2d.clearRect");
    this.ignoreClearRect || (this.fillStyle = "#ffffff", this.fillRect(b, H, V, j));
  }, c.prototype.save = function(b) {
    b = typeof b != "boolean" || b;
    for (var H = this.pdf.internal.getCurrentPageInfo().pageNumber, V = 0; V < this.pdf.internal.getNumberOfPages(); V++)
      this.pdf.setPage(V + 1), this.pdf.internal.out("q");
    if (this.pdf.setPage(H), b) {
      this.ctx.fontSize = this.pdf.internal.getFontSize();
      var j = new h(this.ctx);
      this.ctxStack.push(this.ctx), this.ctx = j;
    }
  }, c.prototype.restore = function(b) {
    b = typeof b != "boolean" || b;
    for (var H = this.pdf.internal.getCurrentPageInfo().pageNumber, V = 0; V < this.pdf.internal.getNumberOfPages(); V++)
      this.pdf.setPage(V + 1), this.pdf.internal.out("Q");
    this.pdf.setPage(H), b && this.ctxStack.length !== 0 && (this.ctx = this.ctxStack.pop(), this.fillStyle = this.ctx.fillStyle, this.strokeStyle = this.ctx.strokeStyle, this.font = this.ctx.font, this.lineCap = this.ctx.lineCap, this.lineWidth = this.ctx.lineWidth, this.lineJoin = this.ctx.lineJoin, this.lineDash = this.ctx.lineDash, this.lineDashOffset = this.ctx.lineDashOffset);
  }, c.prototype.toDataURL = function() {
    throw new Error("toDataUrl not implemented.");
  };
  var u = function(b) {
    var H, V, j, ie;
    if (b.isCanvasGradient === !0 && (b = b.getColor()), !b)
      return { r: 0, g: 0, b: 0, a: 0, style: b };
    if (/transparent|rgba\s*\(\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*,\s*0+\s*\)/.test(b))
      H = 0, V = 0, j = 0, ie = 0;
    else {
      var ue = /rgb\s*\(\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*\)/.exec(b);
      if (ue !== null)
        H = parseInt(ue[1]), V = parseInt(ue[2]), j = parseInt(ue[3]), ie = 1;
      else if ((ue = /rgba\s*\(\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*,\s*([\d.]+)\s*\)/.exec(b)) !== null)
        H = parseInt(ue[1]), V = parseInt(ue[2]), j = parseInt(ue[3]), ie = parseFloat(ue[4]);
      else {
        if (ie = 1, typeof b == "string" && b.charAt(0) !== "#") {
          var fe = new Z4(b);
          b = fe.ok ? fe.toHex() : "#000000";
        }
        b.length === 4 ? (H = b.substring(1, 2), H += H, V = b.substring(2, 3), V += V, j = b.substring(3, 4), j += j) : (H = b.substring(1, 3), V = b.substring(3, 5), j = b.substring(5, 7)), H = parseInt(H, 16), V = parseInt(V, 16), j = parseInt(j, 16);
      }
    }
    return { r: H, g: V, b: j, a: ie, style: b };
  }, f = function() {
    return this.ctx.isFillTransparent || this.globalAlpha == 0;
  }, g = function() {
    return !!(this.ctx.isStrokeTransparent || this.globalAlpha == 0);
  };
  c.prototype.fillText = function(b, H, V, j) {
    if (isNaN(H) || isNaN(V) || typeof b != "string")
      throw Yr.error("jsPDF.context2d.fillText: Invalid arguments", arguments), new Error("Invalid arguments passed to jsPDF.context2d.fillText");
    if (j = isNaN(j) ? void 0 : j, !f.call(this)) {
      var ie = Z(this.ctx.transform.rotation), ue = this.ctx.transform.scaleX;
      L.call(this, { text: b, x: H, y: V, scale: ue, angle: ie, align: this.textAlign, maxWidth: j });
    }
  }, c.prototype.strokeText = function(b, H, V, j) {
    if (isNaN(H) || isNaN(V) || typeof b != "string")
      throw Yr.error("jsPDF.context2d.strokeText: Invalid arguments", arguments), new Error("Invalid arguments passed to jsPDF.context2d.strokeText");
    if (!g.call(this)) {
      j = isNaN(j) ? void 0 : j;
      var ie = Z(this.ctx.transform.rotation), ue = this.ctx.transform.scaleX;
      L.call(this, { text: b, x: H, y: V, scale: ue, renderingMode: "stroke", angle: ie, align: this.textAlign, maxWidth: j });
    }
  }, c.prototype.measureText = function(b) {
    if (typeof b != "string")
      throw Yr.error("jsPDF.context2d.measureText: Invalid arguments", arguments), new Error("Invalid arguments passed to jsPDF.context2d.measureText");
    var H = this.pdf, V = this.pdf.internal.scaleFactor, j = H.internal.getFontSize(), ie = H.getStringUnitWidth(b) * j / H.internal.scaleFactor, ue = function(fe) {
      var ee = (fe = fe || {}).width || 0;
      return Object.defineProperty(this, "width", { get: function() {
        return ee;
      } }), this;
    };
    return new ue({ width: ie *= Math.round(96 * V / 72 * 1e4) / 1e4 });
  }, c.prototype.scale = function(b, H) {
    if (isNaN(b) || isNaN(H))
      throw Yr.error("jsPDF.context2d.scale: Invalid arguments", arguments), new Error("Invalid arguments passed to jsPDF.context2d.scale");
    var V = new A(b, 0, 0, H, 0, 0);
    this.ctx.transform = this.ctx.transform.multiply(V);
  }, c.prototype.rotate = function(b) {
    if (isNaN(b))
      throw Yr.error("jsPDF.context2d.rotate: Invalid arguments", arguments), new Error("Invalid arguments passed to jsPDF.context2d.rotate");
    var H = new A(Math.cos(b), Math.sin(b), -Math.sin(b), Math.cos(b), 0, 0);
    this.ctx.transform = this.ctx.transform.multiply(H);
  }, c.prototype.translate = function(b, H) {
    if (isNaN(b) || isNaN(H))
      throw Yr.error("jsPDF.context2d.translate: Invalid arguments", arguments), new Error("Invalid arguments passed to jsPDF.context2d.translate");
    var V = new A(1, 0, 0, 1, b, H);
    this.ctx.transform = this.ctx.transform.multiply(V);
  }, c.prototype.transform = function(b, H, V, j, ie, ue) {
    if (isNaN(b) || isNaN(H) || isNaN(V) || isNaN(j) || isNaN(ie) || isNaN(ue))
      throw Yr.error("jsPDF.context2d.transform: Invalid arguments", arguments), new Error("Invalid arguments passed to jsPDF.context2d.transform");
    var fe = new A(b, H, V, j, ie, ue);
    this.ctx.transform = this.ctx.transform.multiply(fe);
  }, c.prototype.setTransform = function(b, H, V, j, ie, ue) {
    b = isNaN(b) ? 1 : b, H = isNaN(H) ? 0 : H, V = isNaN(V) ? 0 : V, j = isNaN(j) ? 1 : j, ie = isNaN(ie) ? 0 : ie, ue = isNaN(ue) ? 0 : ue, this.ctx.transform = new A(b, H, V, j, ie, ue);
  };
  var p = function() {
    return this.margin[0] > 0 || this.margin[1] > 0 || this.margin[2] > 0 || this.margin[3] > 0;
  };
  c.prototype.drawImage = function(b, H, V, j, ie, ue, fe, ee, xe) {
    var Ee = this.pdf.getImageProperties(b), Ue = 1, ke = 1, We = 1, ve = 1;
    j !== void 0 && ee !== void 0 && (We = ee / j, ve = xe / ie, Ue = Ee.width / j * ee / j, ke = Ee.height / ie * xe / ie), ue === void 0 && (ue = H, fe = V, H = 0, V = 0), j !== void 0 && ee === void 0 && (ee = j, xe = ie), j === void 0 && ee === void 0 && (ee = Ee.width, xe = Ee.height);
    for (var Y, mt = this.ctx.transform.decompose(), Ze = Z(mt.rotate.shx), Fe = new A(), Re = (Fe = (Fe = (Fe = Fe.multiply(mt.translate)).multiply(mt.skew)).multiply(mt.scale)).applyToRectangle(new o(ue - H * We, fe - V * ve, j * Ue, ie * ke)), De = y.call(this, Re), Le = [], Ge = 0; Ge < De.length; Ge += 1)
      Le.indexOf(De[Ge]) === -1 && Le.push(De[Ge]);
    if (C(Le), this.autoPaging)
      for (var ze = Le[0], ft = Le[Le.length - 1], Et = ze; Et < ft + 1; Et++) {
        this.pdf.setPage(Et);
        var Mt = this.pdf.internal.pageSize.width - this.margin[3] - this.margin[1], Ut = Et === 1 ? this.posY + this.margin[0] : this.margin[0], At = this.pdf.internal.pageSize.height - this.posY - this.margin[0] - this.margin[2], vt = this.pdf.internal.pageSize.height - this.margin[0] - this.margin[2], Ne = Et === 1 ? 0 : At + (Et - 2) * vt;
        if (this.ctx.clip_path.length !== 0) {
          var Qr = this.path;
          Y = JSON.parse(JSON.stringify(this.ctx.clip_path)), this.path = w(Y, this.posX + this.margin[3], -Ne + Ut + this.ctx.prevPageLastElemOffset), S.call(this, "fill", !0), this.path = Qr;
        }
        var kt = JSON.parse(JSON.stringify(Re));
        kt = w([kt], this.posX + this.margin[3], -Ne + Ut + this.ctx.prevPageLastElemOffset)[0];
        var fn = (Et > ze || Et < ft) && p.call(this);
        fn && (this.pdf.saveGraphicsState(), this.pdf.rect(this.margin[3], this.margin[0], Mt, vt, null).clip().discardPath()), this.pdf.addImage(b, "JPEG", kt.x, kt.y, kt.w, kt.h, null, null, Ze), fn && this.pdf.restoreGraphicsState();
      }
    else
      this.pdf.addImage(b, "JPEG", Re.x, Re.y, Re.w, Re.h, null, null, Ze);
  };
  var y = function(b, H, V) {
    var j = [];
    H = H || this.pdf.internal.pageSize.width, V = V || this.pdf.internal.pageSize.height - this.margin[0] - this.margin[2];
    var ie = this.posY + this.ctx.prevPageLastElemOffset;
    switch (b.type) {
      default:
      case "mt":
      case "lt":
        j.push(Math.floor((b.y + ie) / V) + 1);
        break;
      case "arc":
        j.push(Math.floor((b.y + ie - b.radius) / V) + 1), j.push(Math.floor((b.y + ie + b.radius) / V) + 1);
        break;
      case "qct":
        var ue = oe(this.ctx.lastPoint.x, this.ctx.lastPoint.y, b.x1, b.y1, b.x, b.y);
        j.push(Math.floor((ue.y + ie) / V) + 1), j.push(Math.floor((ue.y + ue.h + ie) / V) + 1);
        break;
      case "bct":
        var fe = ne(this.ctx.lastPoint.x, this.ctx.lastPoint.y, b.x1, b.y1, b.x2, b.y2, b.x, b.y);
        j.push(Math.floor((fe.y + ie) / V) + 1), j.push(Math.floor((fe.y + fe.h + ie) / V) + 1);
        break;
      case "rect":
        j.push(Math.floor((b.y + ie) / V) + 1), j.push(Math.floor((b.y + b.h + ie) / V) + 1);
    }
    for (var ee = 0; ee < j.length; ee += 1)
      for (; this.pdf.internal.getNumberOfPages() < j[ee]; )
        v.call(this);
    return j;
  }, v = function() {
    var b = this.fillStyle, H = this.strokeStyle, V = this.font, j = this.lineCap, ie = this.lineWidth, ue = this.lineJoin;
    this.pdf.addPage(), this.fillStyle = b, this.strokeStyle = H, this.font = V, this.lineCap = j, this.lineWidth = ie, this.lineJoin = ue;
  }, w = function(b, H, V) {
    for (var j = 0; j < b.length; j++)
      switch (b[j].type) {
        case "bct":
          b[j].x2 += H, b[j].y2 += V;
        case "qct":
          b[j].x1 += H, b[j].y1 += V;
        case "mt":
        case "lt":
        case "arc":
        default:
          b[j].x += H, b[j].y += V;
      }
    return b;
  }, C = function(b) {
    return b.sort(function(H, V) {
      return H - V;
    });
  }, E = function(b, H) {
    for (var V, j, ie = this.fillStyle, ue = this.strokeStyle, fe = this.lineCap, ee = this.lineWidth, xe = Math.abs(ee * this.ctx.transform.scaleX), Ee = this.lineJoin, Ue = JSON.parse(JSON.stringify(this.path)), ke = JSON.parse(JSON.stringify(this.path)), We = [], ve = 0; ve < ke.length; ve++)
      if (ke[ve].x !== void 0)
        for (var Y = y.call(this, ke[ve]), mt = 0; mt < Y.length; mt += 1)
          We.indexOf(Y[mt]) === -1 && We.push(Y[mt]);
    for (var Ze = 0; Ze < We.length; Ze++)
      for (; this.pdf.internal.getNumberOfPages() < We[Ze]; )
        v.call(this);
    if (C(We), this.autoPaging)
      for (var Fe = We[0], Re = We[We.length - 1], De = Fe; De < Re + 1; De++) {
        this.pdf.setPage(De), this.fillStyle = ie, this.strokeStyle = ue, this.lineCap = fe, this.lineWidth = xe, this.lineJoin = Ee;
        var Le = this.pdf.internal.pageSize.width - this.margin[3] - this.margin[1], Ge = De === 1 ? this.posY + this.margin[0] : this.margin[0], ze = this.pdf.internal.pageSize.height - this.posY - this.margin[0] - this.margin[2], ft = this.pdf.internal.pageSize.height - this.margin[0] - this.margin[2], Et = De === 1 ? 0 : ze + (De - 2) * ft;
        if (this.ctx.clip_path.length !== 0) {
          var Mt = this.path;
          V = JSON.parse(JSON.stringify(this.ctx.clip_path)), this.path = w(V, this.posX + this.margin[3], -Et + Ge + this.ctx.prevPageLastElemOffset), S.call(this, b, !0), this.path = Mt;
        }
        if (j = JSON.parse(JSON.stringify(Ue)), this.path = w(j, this.posX + this.margin[3], -Et + Ge + this.ctx.prevPageLastElemOffset), H === !1 || De === 0) {
          var Ut = (De > Fe || De < Re) && p.call(this);
          Ut && (this.pdf.saveGraphicsState(), this.pdf.rect(this.margin[3], this.margin[0], Le, ft, null).clip().discardPath()), S.call(this, b, H), Ut && this.pdf.restoreGraphicsState();
        }
        this.lineWidth = ee;
      }
    else
      this.lineWidth = xe, S.call(this, b, H), this.lineWidth = ee;
    this.path = Ue;
  }, S = function(b, H) {
    if ((b !== "stroke" || H || !g.call(this)) && (b === "stroke" || H || !f.call(this))) {
      for (var V, j, ie = [], ue = this.path, fe = 0; fe < ue.length; fe++) {
        var ee = ue[fe];
        switch (ee.type) {
          case "begin":
            ie.push({ begin: !0 });
            break;
          case "close":
            ie.push({ close: !0 });
            break;
          case "mt":
            ie.push({ start: ee, deltas: [], abs: [] });
            break;
          case "lt":
            var xe = ie.length;
            if (ue[fe - 1] && !isNaN(ue[fe - 1].x) && (V = [ee.x - ue[fe - 1].x, ee.y - ue[fe - 1].y], xe > 0)) {
              for (; xe >= 0; xe--)
                if (ie[xe - 1].close !== !0 && ie[xe - 1].begin !== !0) {
                  ie[xe - 1].deltas.push(V), ie[xe - 1].abs.push(ee);
                  break;
                }
            }
            break;
          case "bct":
            V = [ee.x1 - ue[fe - 1].x, ee.y1 - ue[fe - 1].y, ee.x2 - ue[fe - 1].x, ee.y2 - ue[fe - 1].y, ee.x - ue[fe - 1].x, ee.y - ue[fe - 1].y], ie[ie.length - 1].deltas.push(V);
            break;
          case "qct":
            var Ee = ue[fe - 1].x + 2 / 3 * (ee.x1 - ue[fe - 1].x), Ue = ue[fe - 1].y + 2 / 3 * (ee.y1 - ue[fe - 1].y), ke = ee.x + 2 / 3 * (ee.x1 - ee.x), We = ee.y + 2 / 3 * (ee.y1 - ee.y), ve = ee.x, Y = ee.y;
            V = [Ee - ue[fe - 1].x, Ue - ue[fe - 1].y, ke - ue[fe - 1].x, We - ue[fe - 1].y, ve - ue[fe - 1].x, Y - ue[fe - 1].y], ie[ie.length - 1].deltas.push(V);
            break;
          case "arc":
            ie.push({ deltas: [], abs: [], arc: !0 }), Array.isArray(ie[ie.length - 1].abs) && ie[ie.length - 1].abs.push(ee);
        }
      }
      j = H ? null : b === "stroke" ? "stroke" : "fill";
      for (var mt = !1, Ze = 0; Ze < ie.length; Ze++)
        if (ie[Ze].arc)
          for (var Fe = ie[Ze].abs, Re = 0; Re < Fe.length; Re++) {
            var De = Fe[Re];
            De.type === "arc" ? F.call(this, De.x, De.y, De.radius, De.startAngle, De.endAngle, De.counterclockwise, void 0, H, !mt) : P.call(this, De.x, De.y), mt = !0;
          }
        else if (ie[Ze].close === !0)
          this.pdf.internal.out("h"), mt = !1;
        else if (ie[Ze].begin !== !0) {
          var Le = ie[Ze].start.x, Ge = ie[Ze].start.y;
          Q.call(this, ie[Ze].deltas, Le, Ge), mt = !0;
        }
      j && k.call(this, j), H && $.call(this);
    }
  }, M = function(b) {
    var H = this.pdf.internal.getFontSize() / this.pdf.internal.scaleFactor, V = H * (this.pdf.internal.getLineHeightFactor() - 1);
    switch (this.ctx.textBaseline) {
      case "bottom":
        return b - V;
      case "top":
        return b + H - V;
      case "hanging":
        return b + H - 2 * V;
      case "middle":
        return b + H / 2 - V;
      case "ideographic":
        return b;
      case "alphabetic":
      default:
        return b;
    }
  }, T = function(b) {
    return b + this.pdf.internal.getFontSize() / this.pdf.internal.scaleFactor * (this.pdf.internal.getLineHeightFactor() - 1);
  };
  c.prototype.createLinearGradient = function() {
    var b = function() {
    };
    return b.colorStops = [], b.addColorStop = function(H, V) {
      this.colorStops.push([H, V]);
    }, b.getColor = function() {
      return this.colorStops.length === 0 ? "#000000" : this.colorStops[0][1];
    }, b.isCanvasGradient = !0, b;
  }, c.prototype.createPattern = function() {
    return this.createLinearGradient();
  }, c.prototype.createRadialGradient = function() {
    return this.createLinearGradient();
  };
  var F = function(b, H, V, j, ie, ue, fe, ee, xe) {
    for (var Ee = W.call(this, V, j, ie, ue), Ue = 0; Ue < Ee.length; Ue++) {
      var ke = Ee[Ue];
      Ue === 0 && (xe ? I.call(this, ke.x1 + b, ke.y1 + H) : P.call(this, ke.x1 + b, ke.y1 + H)), X.call(this, b, H, ke.x2, ke.y2, ke.x3, ke.y3, ke.x4, ke.y4);
    }
    ee ? $.call(this) : k.call(this, fe);
  }, k = function(b) {
    switch (b) {
      case "stroke":
        this.pdf.internal.out("S");
        break;
      case "fill":
        this.pdf.internal.out("f");
    }
  }, $ = function() {
    this.pdf.clip(), this.pdf.discardPath();
  }, I = function(b, H) {
    this.pdf.internal.out(t(b) + " " + r(H) + " m");
  }, L = function(b) {
    var H;
    switch (b.align) {
      case "right":
      case "end":
        H = "right";
        break;
      case "center":
        H = "center";
        break;
      case "left":
      case "start":
      default:
        H = "left";
    }
    var V = this.pdf.getTextDimensions(b.text), j = M.call(this, b.y), ie = T.call(this, j) - V.h, ue = this.ctx.transform.applyToPoint(new a(b.x, j)), fe = this.ctx.transform.decompose(), ee = new A();
    ee = (ee = (ee = ee.multiply(fe.translate)).multiply(fe.skew)).multiply(fe.scale);
    for (var xe, Ee, Ue, ke = this.ctx.transform.applyToRectangle(new o(b.x, j, V.w, V.h)), We = ee.applyToRectangle(new o(b.x, ie, V.w, V.h)), ve = y.call(this, We), Y = [], mt = 0; mt < ve.length; mt += 1)
      Y.indexOf(ve[mt]) === -1 && Y.push(ve[mt]);
    if (C(Y), this.autoPaging)
      for (var Ze = Y[0], Fe = Y[Y.length - 1], Re = Ze; Re < Fe + 1; Re++) {
        this.pdf.setPage(Re);
        var De = Re === 1 ? this.posY + this.margin[0] : this.margin[0], Le = this.pdf.internal.pageSize.height - this.posY - this.margin[0] - this.margin[2], Ge = this.pdf.internal.pageSize.height - this.margin[2], ze = Ge - this.margin[0], ft = this.pdf.internal.pageSize.width - this.margin[1], Et = ft - this.margin[3], Mt = Re === 1 ? 0 : Le + (Re - 2) * ze;
        if (this.ctx.clip_path.length !== 0) {
          var Ut = this.path;
          xe = JSON.parse(JSON.stringify(this.ctx.clip_path)), this.path = w(xe, this.posX + this.margin[3], -1 * Mt + De), S.call(this, "fill", !0), this.path = Ut;
        }
        var At = w([JSON.parse(JSON.stringify(We))], this.posX + this.margin[3], -Mt + De + this.ctx.prevPageLastElemOffset)[0];
        b.scale >= 0.01 && (Ee = this.pdf.internal.getFontSize(), this.pdf.setFontSize(Ee * b.scale), Ue = this.lineWidth, this.lineWidth = Ue * b.scale);
        var vt = this.autoPaging !== "text";
        if (vt || At.y + At.h <= Ge) {
          if (vt || At.y >= De && At.x <= ft) {
            var Ne = vt ? b.text : this.pdf.splitTextToSize(b.text, b.maxWidth || ft - At.x)[0], Qr = w([JSON.parse(JSON.stringify(ke))], this.posX + this.margin[3], -Mt + De + this.ctx.prevPageLastElemOffset)[0], kt = vt && (Re > Ze || Re < Fe) && p.call(this);
            kt && (this.pdf.saveGraphicsState(), this.pdf.rect(this.margin[3], this.margin[0], Et, ze, null).clip().discardPath()), this.pdf.text(Ne, Qr.x, Qr.y, { angle: b.angle, align: H, renderingMode: b.renderingMode }), kt && this.pdf.restoreGraphicsState();
          }
        } else
          At.y < Ge && (this.ctx.prevPageLastElemOffset += Ge - At.y);
        b.scale >= 0.01 && (this.pdf.setFontSize(Ee), this.lineWidth = Ue);
      }
    else
      b.scale >= 0.01 && (Ee = this.pdf.internal.getFontSize(), this.pdf.setFontSize(Ee * b.scale), Ue = this.lineWidth, this.lineWidth = Ue * b.scale), this.pdf.text(b.text, ue.x + this.posX, ue.y + this.posY, { angle: b.angle, align: H, renderingMode: b.renderingMode, maxWidth: b.maxWidth }), b.scale >= 0.01 && (this.pdf.setFontSize(Ee), this.lineWidth = Ue);
  }, P = function(b, H, V, j) {
    V = V || 0, j = j || 0, this.pdf.internal.out(t(b + V) + " " + r(H + j) + " l");
  }, Q = function(b, H, V) {
    return this.pdf.lines(b, H, V, null, null);
  }, X = function(b, H, V, j, ie, ue, fe, ee) {
    this.pdf.internal.out([e(n(V + b)), e(s(j + H)), e(n(ie + b)), e(s(ue + H)), e(n(fe + b)), e(s(ee + H)), "c"].join(" "));
  }, W = function(b, H, V, j) {
    for (var ie = 2 * Math.PI, ue = Math.PI / 2; H > V; )
      H -= ie;
    var fe = Math.abs(V - H);
    fe < ie && j && (fe = ie - fe);
    for (var ee = [], xe = j ? -1 : 1, Ee = H; fe > 1e-5; ) {
      var Ue = Ee + xe * Math.min(fe, ue);
      ee.push(q.call(this, b, Ee, Ue)), fe -= Math.abs(Ue - Ee), Ee = Ue;
    }
    return ee;
  }, q = function(b, H, V) {
    var j = (V - H) / 2, ie = b * Math.cos(j), ue = b * Math.sin(j), fe = ie, ee = -ue, xe = fe * fe + ee * ee, Ee = xe + fe * ie + ee * ue, Ue = 4 / 3 * (Math.sqrt(2 * xe * Ee) - Ee) / (fe * ue - ee * ie), ke = fe - Ue * ee, We = ee + Ue * fe, ve = ke, Y = -We, mt = j + H, Ze = Math.cos(mt), Fe = Math.sin(mt);
    return { x1: b * Math.cos(H), y1: b * Math.sin(H), x2: ke * Ze - We * Fe, y2: ke * Fe + We * Ze, x3: ve * Ze - Y * Fe, y3: ve * Fe + Y * Ze, x4: b * Math.cos(V), y4: b * Math.sin(V) };
  }, Z = function(b) {
    return 180 * b / Math.PI;
  }, oe = function(b, H, V, j, ie, ue) {
    var fe = b + 0.5 * (V - b), ee = H + 0.5 * (j - H), xe = ie + 0.5 * (V - ie), Ee = ue + 0.5 * (j - ue), Ue = Math.min(b, ie, fe, xe), ke = Math.max(b, ie, fe, xe), We = Math.min(H, ue, ee, Ee), ve = Math.max(H, ue, ee, Ee);
    return new o(Ue, We, ke - Ue, ve - We);
  }, ne = function(b, H, V, j, ie, ue, fe, ee) {
    var xe, Ee, Ue, ke, We, ve, Y, mt, Ze, Fe, Re, De, Le, Ge, ze = V - b, ft = j - H, Et = ie - V, Mt = ue - j, Ut = fe - ie, At = ee - ue;
    for (Ee = 0; Ee < 41; Ee++)
      Ze = (Y = (Ue = b + (xe = Ee / 40) * ze) + xe * ((We = V + xe * Et) - Ue)) + xe * (We + xe * (ie + xe * Ut - We) - Y), Fe = (mt = (ke = H + xe * ft) + xe * ((ve = j + xe * Mt) - ke)) + xe * (ve + xe * (ue + xe * At - ve) - mt), Ee == 0 ? (Re = Ze, De = Fe, Le = Ze, Ge = Fe) : (Re = Math.min(Re, Ze), De = Math.min(De, Fe), Le = Math.max(Le, Ze), Ge = Math.max(Ge, Fe));
    return new o(Math.round(Re), Math.round(De), Math.round(Le - Re), Math.round(Ge - De));
  }, me = function() {
    if (this.prevLineDash || this.ctx.lineDash.length || this.ctx.lineDashOffset) {
      var b, H, V = (b = this.ctx.lineDash, H = this.ctx.lineDashOffset, JSON.stringify({ lineDash: b, lineDashOffset: H }));
      this.prevLineDash !== V && (this.pdf.setLineDash(this.ctx.lineDash, this.ctx.lineDashOffset), this.prevLineDash = V);
    }
  };
})(Lt.API), /**
 * @license
 * jsPDF filters PlugIn
 * Copyright (c) 2014 Aras Abbasi
 *
 * Licensed under the MIT License.
 * http://opensource.org/licenses/mit-license
 */
function(i) {
  var e = function(s) {
    var a, o, A, l, h, c, u, f, g, p;
    for (o = [], A = 0, l = (s += a = "\0\0\0\0".slice(s.length % 4 || 4)).length; l > A; A += 4)
      (h = (s.charCodeAt(A) << 24) + (s.charCodeAt(A + 1) << 16) + (s.charCodeAt(A + 2) << 8) + s.charCodeAt(A + 3)) !== 0 ? (c = (h = ((h = ((h = ((h = (h - (p = h % 85)) / 85) - (g = h % 85)) / 85) - (f = h % 85)) / 85) - (u = h % 85)) / 85) % 85, o.push(c + 33, u + 33, f + 33, g + 33, p + 33)) : o.push(122);
    return function(y, v) {
      for (var w = v; w > 0; w--)
        y.pop();
    }(o, a.length), String.fromCharCode.apply(String, o) + "~>";
  }, t = function(s) {
    var a, o, A, l, h, c = String, u = "length", f = 255, g = "charCodeAt", p = "slice", y = "replace";
    for (s[p](-2), s = s[p](0, -2)[y](/\s/g, "")[y]("z", "!!!!!"), A = [], l = 0, h = (s += a = "uuuuu"[p](s[u] % 5 || 5))[u]; h > l; l += 5)
      o = 52200625 * (s[g](l) - 33) + 614125 * (s[g](l + 1) - 33) + 7225 * (s[g](l + 2) - 33) + 85 * (s[g](l + 3) - 33) + (s[g](l + 4) - 33), A.push(f & o >> 24, f & o >> 16, f & o >> 8, f & o);
    return function(v, w) {
      for (var C = w; C > 0; C--)
        v.pop();
    }(A, a[u]), c.fromCharCode.apply(c, A);
  }, r = function(s) {
    var a = new RegExp(/^([0-9A-Fa-f]{2})+$/);
    if ((s = s.replace(/\s/g, "")).indexOf(">") !== -1 && (s = s.substr(0, s.indexOf(">"))), s.length % 2 && (s += "0"), a.test(s) === !1)
      return "";
    for (var o = "", A = 0; A < s.length; A += 2)
      o += String.fromCharCode("0x" + (s[A] + s[A + 1]));
    return o;
  }, n = function(s) {
    for (var a = new Uint8Array(s.length), o = s.length; o--; )
      a[o] = s.charCodeAt(o);
    return s = (a = Z2(a)).reduce(function(A, l) {
      return A + String.fromCharCode(l);
    }, "");
  };
  i.processDataByFilters = function(s, a) {
    var o = 0, A = s || "", l = [];
    for (typeof (a = a || []) == "string" && (a = [a]), o = 0; o < a.length; o += 1)
      switch (a[o]) {
        case "ASCII85Decode":
        case "/ASCII85Decode":
          A = t(A), l.push("/ASCII85Encode");
          break;
        case "ASCII85Encode":
        case "/ASCII85Encode":
          A = e(A), l.push("/ASCII85Decode");
          break;
        case "ASCIIHexDecode":
        case "/ASCIIHexDecode":
          A = r(A), l.push("/ASCIIHexEncode");
          break;
        case "ASCIIHexEncode":
        case "/ASCIIHexEncode":
          A = A.split("").map(function(h) {
            return ("0" + h.charCodeAt().toString(16)).slice(-2);
          }).join("") + ">", l.push("/ASCIIHexDecode");
          break;
        case "FlateEncode":
        case "/FlateEncode":
          A = n(A), l.push("/FlateDecode");
          break;
        default:
          throw new Error('The filter: "' + a[o] + '" is not implemented');
      }
    return { data: A, reverseChain: l.reverse().join(" ") };
  };
}(Lt.API), /**
 * @license
 * jsPDF fileloading PlugIn
 * Copyright (c) 2018 Aras Abbasi (aras.abbasi@gmail.com)
 *
 * Licensed under the MIT License.
 * http://opensource.org/licenses/mit-license
 */
function(i) {
  i.loadFile = function(e, t, r) {
    return function(n, s, a) {
      s = s !== !1, a = typeof a == "function" ? a : function() {
      };
      var o = void 0;
      try {
        o = function(A, l, h) {
          var c = new XMLHttpRequest(), u = 0, f = function(g) {
            var p = g.length, y = [], v = String.fromCharCode;
            for (u = 0; u < p; u += 1)
              y.push(v(255 & g.charCodeAt(u)));
            return y.join("");
          };
          if (c.open("GET", A, !l), c.overrideMimeType("text/plain; charset=x-user-defined"), l === !1 && (c.onload = function() {
            c.status === 200 ? h(f(this.responseText)) : h(void 0);
          }), c.send(null), l && c.status === 200)
            return f(c.responseText);
        }(n, s, a);
      } catch {
      }
      return o;
    }(e, t, r);
  }, i.loadImageFile = i.loadFile;
}(Lt.API), function(i) {
  function e() {
    return (It.html2canvas ? Promise.resolve(It.html2canvas) : Promise.resolve().then(() => lle)).catch(function(a) {
      return Promise.reject(new Error("Could not load html2canvas: " + a));
    }).then(function(a) {
      return a.default ? a.default : a;
    });
  }
  function t() {
    return (It.DOMPurify ? Promise.resolve(It.DOMPurify) : Promise.resolve().then(() => Rle)).catch(function(a) {
      return Promise.reject(new Error("Could not load dompurify: " + a));
    }).then(function(a) {
      return a.default ? a.default : a;
    });
  }
  var r = function(a) {
    var o = $r(a);
    return o === "undefined" ? "undefined" : o === "string" || a instanceof String ? "string" : o === "number" || a instanceof Number ? "number" : o === "function" || a instanceof Function ? "function" : a && a.constructor === Array ? "array" : a && a.nodeType === 1 ? "element" : o === "object" ? "object" : "unknown";
  }, n = function(a, o) {
    var A = document.createElement(a);
    for (var l in o.className && (A.className = o.className), o.innerHTML && o.dompurify && (A.innerHTML = o.dompurify.sanitize(o.innerHTML)), o.style)
      A.style[l] = o.style[l];
    return A;
  }, s = function a(o) {
    var A = Object.assign(a.convert(Promise.resolve()), JSON.parse(JSON.stringify(a.template))), l = a.convert(Promise.resolve(), A);
    return l = (l = l.setProgress(1, a, 1, [a])).set(o);
  };
  (s.prototype = Object.create(Promise.prototype)).constructor = s, s.convert = function(a, o) {
    return a.__proto__ = o || s.prototype, a;
  }, s.template = { prop: { src: null, container: null, overlay: null, canvas: null, img: null, pdf: null, pageSize: null, callback: function() {
  } }, progress: { val: 0, state: null, n: 0, stack: [] }, opt: { filename: "file.pdf", margin: [0, 0, 0, 0], enableLinks: !0, x: 0, y: 0, html2canvas: {}, jsPDF: {}, backgroundColor: "transparent" } }, s.prototype.from = function(a, o) {
    return this.then(function() {
      switch (o = o || function(A) {
        switch (r(A)) {
          case "string":
            return "string";
          case "element":
            return A.nodeName.toLowerCase() === "canvas" ? "canvas" : "element";
          default:
            return "unknown";
        }
      }(a)) {
        case "string":
          return this.then(t).then(function(A) {
            return this.set({ src: n("div", { innerHTML: a, dompurify: A }) });
          });
        case "element":
          return this.set({ src: a });
        case "canvas":
          return this.set({ canvas: a });
        case "img":
          return this.set({ img: a });
        default:
          return this.error("Unknown source type.");
      }
    });
  }, s.prototype.to = function(a) {
    switch (a) {
      case "container":
        return this.toContainer();
      case "canvas":
        return this.toCanvas();
      case "img":
        return this.toImg();
      case "pdf":
        return this.toPdf();
      default:
        return this.error("Invalid target.");
    }
  }, s.prototype.toContainer = function() {
    return this.thenList([function() {
      return this.prop.src || this.error("Cannot duplicate - no source HTML.");
    }, function() {
      return this.prop.pageSize || this.setPageSize();
    }]).then(function() {
      var a = { position: "relative", display: "inline-block", width: (typeof this.opt.width != "number" || isNaN(this.opt.width) || typeof this.opt.windowWidth != "number" || isNaN(this.opt.windowWidth) ? Math.max(this.prop.src.clientWidth, this.prop.src.scrollWidth, this.prop.src.offsetWidth) : this.opt.windowWidth) + "px", left: 0, right: 0, top: 0, margin: "auto", backgroundColor: this.opt.backgroundColor }, o = function A(l, h) {
        for (var c = l.nodeType === 3 ? document.createTextNode(l.nodeValue) : l.cloneNode(!1), u = l.firstChild; u; u = u.nextSibling)
          h !== !0 && u.nodeType === 1 && u.nodeName === "SCRIPT" || c.appendChild(A(u, h));
        return l.nodeType === 1 && (l.nodeName === "CANVAS" ? (c.width = l.width, c.height = l.height, c.getContext("2d").drawImage(l, 0, 0)) : l.nodeName !== "TEXTAREA" && l.nodeName !== "SELECT" || (c.value = l.value), c.addEventListener("load", function() {
          c.scrollTop = l.scrollTop, c.scrollLeft = l.scrollLeft;
        }, !0)), c;
      }(this.prop.src, this.opt.html2canvas.javascriptEnabled);
      o.tagName === "BODY" && (a.height = Math.max(document.body.scrollHeight, document.body.offsetHeight, document.documentElement.clientHeight, document.documentElement.scrollHeight, document.documentElement.offsetHeight) + "px"), this.prop.overlay = n("div", { className: "html2pdf__overlay", style: { position: "fixed", overflow: "hidden", zIndex: 1e3, left: "-100000px", right: 0, bottom: 0, top: 0 } }), this.prop.container = n("div", { className: "html2pdf__container", style: a }), this.prop.container.appendChild(o), this.prop.container.firstChild.appendChild(n("div", { style: { clear: "both", border: "0 none transparent", margin: 0, padding: 0, height: 0 } })), this.prop.container.style.float = "none", this.prop.overlay.appendChild(this.prop.container), document.body.appendChild(this.prop.overlay), this.prop.container.firstChild.style.position = "relative", this.prop.container.height = Math.max(this.prop.container.firstChild.clientHeight, this.prop.container.firstChild.scrollHeight, this.prop.container.firstChild.offsetHeight) + "px";
    });
  }, s.prototype.toCanvas = function() {
    var a = [function() {
      return document.body.contains(this.prop.container) || this.toContainer();
    }];
    return this.thenList(a).then(e).then(function(o) {
      var A = Object.assign({}, this.opt.html2canvas);
      return delete A.onrendered, o(this.prop.container, A);
    }).then(function(o) {
      (this.opt.html2canvas.onrendered || function() {
      })(o), this.prop.canvas = o, document.body.removeChild(this.prop.overlay);
    });
  }, s.prototype.toContext2d = function() {
    var a = [function() {
      return document.body.contains(this.prop.container) || this.toContainer();
    }];
    return this.thenList(a).then(e).then(function(o) {
      var A = this.opt.jsPDF, l = this.opt.fontFaces, h = typeof this.opt.width != "number" || isNaN(this.opt.width) || typeof this.opt.windowWidth != "number" || isNaN(this.opt.windowWidth) ? 1 : this.opt.width / this.opt.windowWidth, c = Object.assign({ async: !0, allowTaint: !0, scale: h, scrollX: this.opt.scrollX || 0, scrollY: this.opt.scrollY || 0, backgroundColor: "#ffffff", imageTimeout: 15e3, logging: !0, proxy: null, removeContainer: !0, foreignObjectRendering: !1, useCORS: !1 }, this.opt.html2canvas);
      if (delete c.onrendered, A.context2d.autoPaging = this.opt.autoPaging === void 0 || this.opt.autoPaging, A.context2d.posX = this.opt.x, A.context2d.posY = this.opt.y, A.context2d.margin = this.opt.margin, A.context2d.fontFaces = l, l)
        for (var u = 0; u < l.length; ++u) {
          var f = l[u], g = f.src.find(function(p) {
            return p.format === "truetype";
          });
          g && A.addFont(g.url, f.ref.name, f.ref.style);
        }
      return c.windowHeight = c.windowHeight || 0, c.windowHeight = c.windowHeight == 0 ? Math.max(this.prop.container.clientHeight, this.prop.container.scrollHeight, this.prop.container.offsetHeight) : c.windowHeight, A.context2d.save(!0), o(this.prop.container, c);
    }).then(function(o) {
      this.opt.jsPDF.context2d.restore(!0), (this.opt.html2canvas.onrendered || function() {
      })(o), this.prop.canvas = o, document.body.removeChild(this.prop.overlay);
    });
  }, s.prototype.toImg = function() {
    return this.thenList([function() {
      return this.prop.canvas || this.toCanvas();
    }]).then(function() {
      var a = this.prop.canvas.toDataURL("image/" + this.opt.image.type, this.opt.image.quality);
      this.prop.img = document.createElement("img"), this.prop.img.src = a;
    });
  }, s.prototype.toPdf = function() {
    return this.thenList([function() {
      return this.toContext2d();
    }]).then(function() {
      this.prop.pdf = this.prop.pdf || this.opt.jsPDF;
    });
  }, s.prototype.output = function(a, o, A) {
    return (A = A || "pdf").toLowerCase() === "img" || A.toLowerCase() === "image" ? this.outputImg(a, o) : this.outputPdf(a, o);
  }, s.prototype.outputPdf = function(a, o) {
    return this.thenList([function() {
      return this.prop.pdf || this.toPdf();
    }]).then(function() {
      return this.prop.pdf.output(a, o);
    });
  }, s.prototype.outputImg = function(a) {
    return this.thenList([function() {
      return this.prop.img || this.toImg();
    }]).then(function() {
      switch (a) {
        case void 0:
        case "img":
          return this.prop.img;
        case "datauristring":
        case "dataurlstring":
          return this.prop.img.src;
        case "datauri":
        case "dataurl":
          return document.location.href = this.prop.img.src;
        default:
          throw 'Image output type "' + a + '" is not supported.';
      }
    });
  }, s.prototype.save = function(a) {
    return this.thenList([function() {
      return this.prop.pdf || this.toPdf();
    }]).set(a ? { filename: a } : null).then(function() {
      this.prop.pdf.save(this.opt.filename);
    });
  }, s.prototype.doCallback = function() {
    return this.thenList([function() {
      return this.prop.pdf || this.toPdf();
    }]).then(function() {
      this.prop.callback(this.prop.pdf);
    });
  }, s.prototype.set = function(a) {
    if (r(a) !== "object")
      return this;
    var o = Object.keys(a || {}).map(function(A) {
      if (A in s.template.prop)
        return function() {
          this.prop[A] = a[A];
        };
      switch (A) {
        case "margin":
          return this.setMargin.bind(this, a.margin);
        case "jsPDF":
          return function() {
            return this.opt.jsPDF = a.jsPDF, this.setPageSize();
          };
        case "pageSize":
          return this.setPageSize.bind(this, a.pageSize);
        default:
          return function() {
            this.opt[A] = a[A];
          };
      }
    }, this);
    return this.then(function() {
      return this.thenList(o);
    });
  }, s.prototype.get = function(a, o) {
    return this.then(function() {
      var A = a in s.template.prop ? this.prop[a] : this.opt[a];
      return o ? o(A) : A;
    });
  }, s.prototype.setMargin = function(a) {
    return this.then(function() {
      switch (r(a)) {
        case "number":
          a = [a, a, a, a];
        case "array":
          if (a.length === 2 && (a = [a[0], a[1], a[0], a[1]]), a.length === 4)
            break;
        default:
          return this.error("Invalid margin array.");
      }
      this.opt.margin = a;
    }).then(this.setPageSize);
  }, s.prototype.setPageSize = function(a) {
    function o(A, l) {
      return Math.floor(A * l / 72 * 96);
    }
    return this.then(function() {
      (a = a || Lt.getPageSize(this.opt.jsPDF)).hasOwnProperty("inner") || (a.inner = { width: a.width - this.opt.margin[1] - this.opt.margin[3], height: a.height - this.opt.margin[0] - this.opt.margin[2] }, a.inner.px = { width: o(a.inner.width, a.k), height: o(a.inner.height, a.k) }, a.inner.ratio = a.inner.height / a.inner.width), this.prop.pageSize = a;
    });
  }, s.prototype.setProgress = function(a, o, A, l) {
    return a != null && (this.progress.val = a), o != null && (this.progress.state = o), A != null && (this.progress.n = A), l != null && (this.progress.stack = l), this.progress.ratio = this.progress.val / this.progress.state, this;
  }, s.prototype.updateProgress = function(a, o, A, l) {
    return this.setProgress(a ? this.progress.val + a : null, o || null, A ? this.progress.n + A : null, l ? this.progress.stack.concat(l) : null);
  }, s.prototype.then = function(a, o) {
    var A = this;
    return this.thenCore(a, o, function(l, h) {
      return A.updateProgress(null, null, 1, [l]), Promise.prototype.then.call(this, function(c) {
        return A.updateProgress(null, l), c;
      }).then(l, h).then(function(c) {
        return A.updateProgress(1), c;
      });
    });
  }, s.prototype.thenCore = function(a, o, A) {
    A = A || Promise.prototype.then, a && (a = a.bind(this)), o && (o = o.bind(this));
    var l = Promise.toString().indexOf("[native code]") !== -1 && Promise.name === "Promise" ? this : s.convert(Object.assign({}, this), Promise.prototype), h = A.call(l, a, o);
    return s.convert(h, this.__proto__);
  }, s.prototype.thenExternal = function(a, o) {
    return Promise.prototype.then.call(this, a, o);
  }, s.prototype.thenList = function(a) {
    var o = this;
    return a.forEach(function(A) {
      o = o.thenCore(A);
    }), o;
  }, s.prototype.catch = function(a) {
    a && (a = a.bind(this));
    var o = Promise.prototype.catch.call(this, a);
    return s.convert(o, this);
  }, s.prototype.catchExternal = function(a) {
    return Promise.prototype.catch.call(this, a);
  }, s.prototype.error = function(a) {
    return this.then(function() {
      throw new Error(a);
    });
  }, s.prototype.using = s.prototype.set, s.prototype.saveAs = s.prototype.save, s.prototype.export = s.prototype.output, s.prototype.run = s.prototype.then, Lt.getPageSize = function(a, o, A) {
    if ($r(a) === "object") {
      var l = a;
      a = l.orientation, o = l.unit || o, A = l.format || A;
    }
    o = o || "mm", A = A || "a4", a = ("" + (a || "P")).toLowerCase();
    var h, c = ("" + A).toLowerCase(), u = { a0: [2383.94, 3370.39], a1: [1683.78, 2383.94], a2: [1190.55, 1683.78], a3: [841.89, 1190.55], a4: [595.28, 841.89], a5: [419.53, 595.28], a6: [297.64, 419.53], a7: [209.76, 297.64], a8: [147.4, 209.76], a9: [104.88, 147.4], a10: [73.7, 104.88], b0: [2834.65, 4008.19], b1: [2004.09, 2834.65], b2: [1417.32, 2004.09], b3: [1000.63, 1417.32], b4: [708.66, 1000.63], b5: [498.9, 708.66], b6: [354.33, 498.9], b7: [249.45, 354.33], b8: [175.75, 249.45], b9: [124.72, 175.75], b10: [87.87, 124.72], c0: [2599.37, 3676.54], c1: [1836.85, 2599.37], c2: [1298.27, 1836.85], c3: [918.43, 1298.27], c4: [649.13, 918.43], c5: [459.21, 649.13], c6: [323.15, 459.21], c7: [229.61, 323.15], c8: [161.57, 229.61], c9: [113.39, 161.57], c10: [79.37, 113.39], dl: [311.81, 623.62], letter: [612, 792], "government-letter": [576, 756], legal: [612, 1008], "junior-legal": [576, 360], ledger: [1224, 792], tabloid: [792, 1224], "credit-card": [153, 243] };
    switch (o) {
      case "pt":
        h = 1;
        break;
      case "mm":
        h = 72 / 25.4;
        break;
      case "cm":
        h = 72 / 2.54;
        break;
      case "in":
        h = 72;
        break;
      case "px":
        h = 0.75;
        break;
      case "pc":
      case "em":
        h = 12;
        break;
      case "ex":
        h = 6;
        break;
      default:
        throw "Invalid unit: " + o;
    }
    var f, g = 0, p = 0;
    if (u.hasOwnProperty(c))
      g = u[c][1] / h, p = u[c][0] / h;
    else
      try {
        g = A[1], p = A[0];
      } catch {
        throw new Error("Invalid format: " + A);
      }
    if (a === "p" || a === "portrait")
      a = "p", p > g && (f = p, p = g, g = f);
    else {
      if (a !== "l" && a !== "landscape")
        throw "Invalid orientation: " + a;
      a = "l", g > p && (f = p, p = g, g = f);
    }
    return { width: p, height: g, unit: o, k: h, orientation: a };
  }, i.html = function(a, o) {
    (o = o || {}).callback = o.callback || function() {
    }, o.html2canvas = o.html2canvas || {}, o.html2canvas.canvas = o.html2canvas.canvas || this.canvas, o.jsPDF = o.jsPDF || this, o.fontFaces = o.fontFaces ? o.fontFaces.map(nx) : null;
    var A = new s(o);
    return o.worker ? A : A.from(a).doCallback();
  };
}(Lt.API), Lt.API.addJS = function(i) {
  return rT = i, this.internal.events.subscribe("postPutResources", function() {
    Hp = this.internal.newObject(), this.internal.out("<<"), this.internal.out("/Names [(EmbeddedJS) " + (Hp + 1) + " 0 R]"), this.internal.out(">>"), this.internal.out("endobj"), tT = this.internal.newObject(), this.internal.out("<<"), this.internal.out("/S /JavaScript"), this.internal.out("/JS (" + rT + ")"), this.internal.out(">>"), this.internal.out("endobj");
  }), this.internal.events.subscribe("putCatalog", function() {
    Hp !== void 0 && tT !== void 0 && this.internal.out("/Names <</JavaScript " + Hp + " 0 R>>");
  }), this;
}, /**
 * @license
 * Copyright (c) 2014 Steven Spungin (TwelveTone LLC)  steven@twelvetone.tv
 *
 * Licensed under the MIT License.
 * http://opensource.org/licenses/mit-license
 */
function(i) {
  var e;
  i.events.push(["postPutResources", function() {
    var t = this, r = /^(\d+) 0 obj$/;
    if (this.outline.root.children.length > 0)
      for (var n = t.outline.render().split(/\r\n/), s = 0; s < n.length; s++) {
        var a = n[s], o = r.exec(a);
        if (o != null) {
          var A = o[1];
          t.internal.newObjectDeferredBegin(A, !1);
        }
        t.internal.write(a);
      }
    if (this.outline.createNamedDestinations) {
      var l = this.internal.pages.length, h = [];
      for (s = 0; s < l; s++) {
        var c = t.internal.newObject();
        h.push(c);
        var u = t.internal.getPageInfo(s + 1);
        t.internal.write("<< /D[" + u.objId + " 0 R /XYZ null null null]>> endobj");
      }
      var f = t.internal.newObject();
      for (t.internal.write("<< /Names [ "), s = 0; s < h.length; s++)
        t.internal.write("(page_" + (s + 1) + ")" + h[s] + " 0 R");
      t.internal.write(" ] >>", "endobj"), e = t.internal.newObject(), t.internal.write("<< /Dests " + f + " 0 R"), t.internal.write(">>", "endobj");
    }
  }]), i.events.push(["putCatalog", function() {
    this.outline.root.children.length > 0 && (this.internal.write("/Outlines", this.outline.makeRef(this.outline.root)), this.outline.createNamedDestinations && this.internal.write("/Names " + e + " 0 R"));
  }]), i.events.push(["initialized", function() {
    var t = this;
    t.outline = { createNamedDestinations: !1, root: { children: [] } }, t.outline.add = function(r, n, s) {
      var a = { title: n, options: s, children: [] };
      return r == null && (r = this.root), r.children.push(a), a;
    }, t.outline.render = function() {
      return this.ctx = {}, this.ctx.val = "", this.ctx.pdf = t, this.genIds_r(this.root), this.renderRoot(this.root), this.renderItems(this.root), this.ctx.val;
    }, t.outline.genIds_r = function(r) {
      r.id = t.internal.newObjectDeferred();
      for (var n = 0; n < r.children.length; n++)
        this.genIds_r(r.children[n]);
    }, t.outline.renderRoot = function(r) {
      this.objStart(r), this.line("/Type /Outlines"), r.children.length > 0 && (this.line("/First " + this.makeRef(r.children[0])), this.line("/Last " + this.makeRef(r.children[r.children.length - 1]))), this.line("/Count " + this.count_r({ count: 0 }, r)), this.objEnd();
    }, t.outline.renderItems = function(r) {
      for (var n = this.ctx.pdf.internal.getVerticalCoordinateString, s = 0; s < r.children.length; s++) {
        var a = r.children[s];
        this.objStart(a), this.line("/Title " + this.makeString(a.title)), this.line("/Parent " + this.makeRef(r)), s > 0 && this.line("/Prev " + this.makeRef(r.children[s - 1])), s < r.children.length - 1 && this.line("/Next " + this.makeRef(r.children[s + 1])), a.children.length > 0 && (this.line("/First " + this.makeRef(a.children[0])), this.line("/Last " + this.makeRef(a.children[a.children.length - 1])));
        var o = this.count = this.count_r({ count: 0 }, a);
        if (o > 0 && this.line("/Count " + o), a.options && a.options.pageNumber) {
          var A = t.internal.getPageInfo(a.options.pageNumber);
          this.line("/Dest [" + A.objId + " 0 R /XYZ 0 " + n(0) + " 0]");
        }
        this.objEnd();
      }
      for (var l = 0; l < r.children.length; l++)
        this.renderItems(r.children[l]);
    }, t.outline.line = function(r) {
      this.ctx.val += r + `\r
`;
    }, t.outline.makeRef = function(r) {
      return r.id + " 0 R";
    }, t.outline.makeString = function(r) {
      return "(" + t.internal.pdfEscape(r) + ")";
    }, t.outline.objStart = function(r) {
      this.ctx.val += `\r
` + r.id + ` 0 obj\r
<<\r
`;
    }, t.outline.objEnd = function() {
      this.ctx.val += `>> \r
endobj\r
`;
    }, t.outline.count_r = function(r, n) {
      for (var s = 0; s < n.children.length; s++)
        r.count++, this.count_r(r, n.children[s]);
      return r.count;
    };
  }]);
}(Lt.API), /**
 * @license
 *
 * Licensed under the MIT License.
 * http://opensource.org/licenses/mit-license
 */
function(i) {
  var e = [192, 193, 194, 195, 196, 197, 198, 199];
  i.processJPEG = function(t, r, n, s, a, o) {
    var A, l = this.decode.DCT_DECODE, h = null;
    if (typeof t == "string" || this.__addimage__.isArrayBuffer(t) || this.__addimage__.isArrayBufferView(t)) {
      switch (t = a || t, t = this.__addimage__.isArrayBuffer(t) ? new Uint8Array(t) : t, (A = function(c) {
        for (var u, f = 256 * c.charCodeAt(4) + c.charCodeAt(5), g = c.length, p = { width: 0, height: 0, numcomponents: 1 }, y = 4; y < g; y += 2) {
          if (y += f, e.indexOf(c.charCodeAt(y + 1)) !== -1) {
            u = 256 * c.charCodeAt(y + 5) + c.charCodeAt(y + 6), p = { width: 256 * c.charCodeAt(y + 7) + c.charCodeAt(y + 8), height: u, numcomponents: c.charCodeAt(y + 9) };
            break;
          }
          f = 256 * c.charCodeAt(y + 2) + c.charCodeAt(y + 3);
        }
        return p;
      }(t = this.__addimage__.isArrayBufferView(t) ? this.__addimage__.arrayBufferToBinaryString(t) : t)).numcomponents) {
        case 1:
          o = this.color_spaces.DEVICE_GRAY;
          break;
        case 4:
          o = this.color_spaces.DEVICE_CMYK;
          break;
        case 3:
          o = this.color_spaces.DEVICE_RGB;
      }
      h = { data: t, width: A.width, height: A.height, colorSpace: o, bitsPerComponent: 8, filter: l, index: r, alias: n };
    }
    return h;
  };
}(Lt.API);
var lc, Gp, iT, nT, sT, HX = function() {
  var i, e, t;
  function r(s) {
    var a, o, A, l, h, c, u, f, g, p, y, v, w, C;
    for (this.data = s, this.pos = 8, this.palette = [], this.imgData = [], this.transparency = {}, this.animation = null, this.text = {}, c = null; ; ) {
      switch (a = this.readUInt32(), g = function() {
        var E, S;
        for (S = [], E = 0; E < 4; ++E)
          S.push(String.fromCharCode(this.data[this.pos++]));
        return S;
      }.call(this).join("")) {
        case "IHDR":
          this.width = this.readUInt32(), this.height = this.readUInt32(), this.bits = this.data[this.pos++], this.colorType = this.data[this.pos++], this.compressionMethod = this.data[this.pos++], this.filterMethod = this.data[this.pos++], this.interlaceMethod = this.data[this.pos++];
          break;
        case "acTL":
          this.animation = { numFrames: this.readUInt32(), numPlays: this.readUInt32() || 1 / 0, frames: [] };
          break;
        case "PLTE":
          this.palette = this.read(a);
          break;
        case "fcTL":
          c && this.animation.frames.push(c), this.pos += 4, c = { width: this.readUInt32(), height: this.readUInt32(), xOffset: this.readUInt32(), yOffset: this.readUInt32() }, h = this.readUInt16(), l = this.readUInt16() || 100, c.delay = 1e3 * h / l, c.disposeOp = this.data[this.pos++], c.blendOp = this.data[this.pos++], c.data = [];
          break;
        case "IDAT":
        case "fdAT":
          for (g === "fdAT" && (this.pos += 4, a -= 4), s = (c != null ? c.data : void 0) || this.imgData, v = 0; 0 <= a ? v < a : v > a; 0 <= a ? ++v : --v)
            s.push(this.data[this.pos++]);
          break;
        case "tRNS":
          switch (this.transparency = {}, this.colorType) {
            case 3:
              if (A = this.palette.length / 3, this.transparency.indexed = this.read(a), this.transparency.indexed.length > A)
                throw new Error("More transparent colors than palette size");
              if ((p = A - this.transparency.indexed.length) > 0)
                for (w = 0; 0 <= p ? w < p : w > p; 0 <= p ? ++w : --w)
                  this.transparency.indexed.push(255);
              break;
            case 0:
              this.transparency.grayscale = this.read(a)[0];
              break;
            case 2:
              this.transparency.rgb = this.read(a);
          }
          break;
        case "tEXt":
          u = (y = this.read(a)).indexOf(0), f = String.fromCharCode.apply(String, y.slice(0, u)), this.text[f] = String.fromCharCode.apply(String, y.slice(u + 1));
          break;
        case "IEND":
          return c && this.animation.frames.push(c), this.colors = function() {
            switch (this.colorType) {
              case 0:
              case 3:
              case 4:
                return 1;
              case 2:
              case 6:
                return 3;
            }
          }.call(this), this.hasAlphaChannel = (C = this.colorType) === 4 || C === 6, o = this.colors + (this.hasAlphaChannel ? 1 : 0), this.pixelBitlength = this.bits * o, this.colorSpace = function() {
            switch (this.colors) {
              case 1:
                return "DeviceGray";
              case 3:
                return "DeviceRGB";
            }
          }.call(this), void (this.imgData = new Uint8Array(this.imgData));
        default:
          this.pos += a;
      }
      if (this.pos += 4, this.pos > this.data.length)
        throw new Error("Incomplete or corrupt PNG file");
    }
  }
  r.prototype.read = function(s) {
    var a, o;
    for (o = [], a = 0; 0 <= s ? a < s : a > s; 0 <= s ? ++a : --a)
      o.push(this.data[this.pos++]);
    return o;
  }, r.prototype.readUInt32 = function() {
    return this.data[this.pos++] << 24 | this.data[this.pos++] << 16 | this.data[this.pos++] << 8 | this.data[this.pos++];
  }, r.prototype.readUInt16 = function() {
    return this.data[this.pos++] << 8 | this.data[this.pos++];
  }, r.prototype.decodePixels = function(s) {
    var a = this.pixelBitlength / 8, o = new Uint8Array(this.width * this.height * a), A = 0, l = this;
    if (s == null && (s = this.imgData), s.length === 0)
      return new Uint8Array(0);
    function h(c, u, f, g) {
      var p, y, v, w, C, E, S, M, T, F, k, $, I, L, P, Q, X, W, q, Z, oe, ne = Math.ceil((l.width - c) / f), me = Math.ceil((l.height - u) / g), b = l.width == ne && l.height == me;
      for (L = a * ne, $ = b ? o : new Uint8Array(L * me), E = s.length, I = 0, y = 0; I < me && A < E; ) {
        switch (s[A++]) {
          case 0:
            for (w = X = 0; X < L; w = X += 1)
              $[y++] = s[A++];
            break;
          case 1:
            for (w = W = 0; W < L; w = W += 1)
              p = s[A++], C = w < a ? 0 : $[y - a], $[y++] = (p + C) % 256;
            break;
          case 2:
            for (w = q = 0; q < L; w = q += 1)
              p = s[A++], v = (w - w % a) / a, P = I && $[(I - 1) * L + v * a + w % a], $[y++] = (P + p) % 256;
            break;
          case 3:
            for (w = Z = 0; Z < L; w = Z += 1)
              p = s[A++], v = (w - w % a) / a, C = w < a ? 0 : $[y - a], P = I && $[(I - 1) * L + v * a + w % a], $[y++] = (p + Math.floor((C + P) / 2)) % 256;
            break;
          case 4:
            for (w = oe = 0; oe < L; w = oe += 1)
              p = s[A++], v = (w - w % a) / a, C = w < a ? 0 : $[y - a], I === 0 ? P = Q = 0 : (P = $[(I - 1) * L + v * a + w % a], Q = v && $[(I - 1) * L + (v - 1) * a + w % a]), S = C + P - Q, M = Math.abs(S - C), F = Math.abs(S - P), k = Math.abs(S - Q), T = M <= F && M <= k ? C : F <= k ? P : Q, $[y++] = (p + T) % 256;
            break;
          default:
            throw new Error("Invalid filter algorithm: " + s[A - 1]);
        }
        if (!b) {
          var H = ((u + I * g) * l.width + c) * a, V = I * L;
          for (w = 0; w < ne; w += 1) {
            for (var j = 0; j < a; j += 1)
              o[H++] = $[V++];
            H += (f - 1) * a;
          }
        }
        I++;
      }
    }
    return s = wX(s), l.interlaceMethod == 1 ? (h(0, 0, 8, 8), h(4, 0, 8, 8), h(0, 4, 4, 8), h(2, 0, 4, 4), h(0, 2, 2, 4), h(1, 0, 2, 2), h(0, 1, 1, 2)) : h(0, 0, 1, 1), o;
  }, r.prototype.decodePalette = function() {
    var s, a, o, A, l, h, c, u, f;
    for (o = this.palette, h = this.transparency.indexed || [], l = new Uint8Array((h.length || 0) + o.length), A = 0, s = 0, a = c = 0, u = o.length; c < u; a = c += 3)
      l[A++] = o[a], l[A++] = o[a + 1], l[A++] = o[a + 2], l[A++] = (f = h[s++]) != null ? f : 255;
    return l;
  }, r.prototype.copyToImageData = function(s, a) {
    var o, A, l, h, c, u, f, g, p, y, v;
    if (A = this.colors, p = null, o = this.hasAlphaChannel, this.palette.length && (p = (v = this._decodedPalette) != null ? v : this._decodedPalette = this.decodePalette(), A = 4, o = !0), g = (l = s.data || s).length, c = p || a, h = u = 0, A === 1)
      for (; h < g; )
        f = p ? 4 * a[h / 4] : u, y = c[f++], l[h++] = y, l[h++] = y, l[h++] = y, l[h++] = o ? c[f++] : 255, u = f;
    else
      for (; h < g; )
        f = p ? 4 * a[h / 4] : u, l[h++] = c[f++], l[h++] = c[f++], l[h++] = c[f++], l[h++] = o ? c[f++] : 255, u = f;
  }, r.prototype.decode = function() {
    var s;
    return s = new Uint8Array(this.width * this.height * 4), this.copyToImageData(s, this.decodePixels()), s;
  };
  var n = function() {
    if (Object.prototype.toString.call(It) === "[object Window]") {
      try {
        e = It.document.createElement("canvas"), t = e.getContext("2d");
      } catch {
        return !1;
      }
      return !0;
    }
    return !1;
  };
  return n(), i = function(s) {
    var a;
    if (n() === !0)
      return t.width = s.width, t.height = s.height, t.clearRect(0, 0, s.width, s.height), t.putImageData(s, 0, 0), (a = new Image()).src = e.toDataURL(), a;
    throw new Error("This method requires a Browser with Canvas-capability.");
  }, r.prototype.decodeFrames = function(s) {
    var a, o, A, l, h, c, u, f;
    if (this.animation) {
      for (f = [], o = h = 0, c = (u = this.animation.frames).length; h < c; o = ++h)
        a = u[o], A = s.createImageData(a.width, a.height), l = this.decodePixels(new Uint8Array(a.data)), this.copyToImageData(A, l), a.imageData = A, f.push(a.image = i(A));
      return f;
    }
  }, r.prototype.renderFrame = function(s, a) {
    var o, A, l;
    return o = (A = this.animation.frames)[a], l = A[a - 1], a === 0 && s.clearRect(0, 0, this.width, this.height), (l != null ? l.disposeOp : void 0) === 1 ? s.clearRect(l.xOffset, l.yOffset, l.width, l.height) : (l != null ? l.disposeOp : void 0) === 2 && s.putImageData(l.imageData, l.xOffset, l.yOffset), o.blendOp === 0 && s.clearRect(o.xOffset, o.yOffset, o.width, o.height), s.drawImage(o.image, o.xOffset, o.yOffset);
  }, r.prototype.animate = function(s) {
    var a, o, A, l, h, c, u = this;
    return o = 0, c = this.animation, l = c.numFrames, A = c.frames, h = c.numPlays, (a = function() {
      var f, g;
      if (f = o++ % l, g = A[f], u.renderFrame(s, f), l > 1 && o / l < h)
        return u.animation._timeout = setTimeout(a, g.delay);
    })();
  }, r.prototype.stopAnimation = function() {
    var s;
    return clearTimeout((s = this.animation) != null ? s._timeout : void 0);
  }, r.prototype.render = function(s) {
    var a, o;
    return s._png && s._png.stopAnimation(), s._png = this, s.width = this.width, s.height = this.height, a = s.getContext("2d"), this.animation ? (this.decodeFrames(a), this.animate(a)) : (o = a.createImageData(this.width, this.height), this.copyToImageData(o, this.decodePixels()), a.putImageData(o, 0, 0));
  }, r;
}();
/**
 * @license
 *
 * Copyright (c) 2014 James Robb, https://github.com/jamesbrobb
 *
 * Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files (the
 * "Software"), to deal in the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 *
 * The above copyright notice and this permission notice shall be
 * included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
 * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
 * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
 * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 * ====================================================================
 */
/**
 * @license
 * (c) Dean McNamee <dean@gmail.com>, 2013.
 *
 * https://github.com/deanm/omggif
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to
 * deal in the Software without restriction, including without limitation the
 * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
 * sell copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
 * IN THE SOFTWARE.
 *
 * omggif is a JavaScript implementation of a GIF 89a encoder and decoder,
 * including animation and compression.  It does not rely on any specific
 * underlying system, so should run in the browser, Node, or Plask.
 */
function GX(i) {
  var e = 0;
  if (i[e++] !== 71 || i[e++] !== 73 || i[e++] !== 70 || i[e++] !== 56 || (i[e++] + 1 & 253) != 56 || i[e++] !== 97)
    throw new Error("Invalid GIF 87a/89a header.");
  var t = i[e++] | i[e++] << 8, r = i[e++] | i[e++] << 8, n = i[e++], s = n >> 7, a = 1 << (7 & n) + 1;
  i[e++], i[e++];
  var o = null, A = null;
  s && (o = e, A = a, e += 3 * a);
  var l = !0, h = [], c = 0, u = null, f = 0, g = null;
  for (this.width = t, this.height = r; l && e < i.length; )
    switch (i[e++]) {
      case 33:
        switch (i[e++]) {
          case 255:
            if (i[e] !== 11 || i[e + 1] == 78 && i[e + 2] == 69 && i[e + 3] == 84 && i[e + 4] == 83 && i[e + 5] == 67 && i[e + 6] == 65 && i[e + 7] == 80 && i[e + 8] == 69 && i[e + 9] == 50 && i[e + 10] == 46 && i[e + 11] == 48 && i[e + 12] == 3 && i[e + 13] == 1 && i[e + 16] == 0)
              e += 14, g = i[e++] | i[e++] << 8, e++;
            else
              for (e += 12; ; ) {
                if (!((I = i[e++]) >= 0))
                  throw Error("Invalid block size");
                if (I === 0)
                  break;
                e += I;
              }
            break;
          case 249:
            if (i[e++] !== 4 || i[e + 4] !== 0)
              throw new Error("Invalid graphics extension block.");
            var p = i[e++];
            c = i[e++] | i[e++] << 8, u = i[e++], !(1 & p) && (u = null), f = p >> 2 & 7, e++;
            break;
          case 254:
            for (; ; ) {
              if (!((I = i[e++]) >= 0))
                throw Error("Invalid block size");
              if (I === 0)
                break;
              e += I;
            }
            break;
          default:
            throw new Error("Unknown graphic control label: 0x" + i[e - 1].toString(16));
        }
        break;
      case 44:
        var y = i[e++] | i[e++] << 8, v = i[e++] | i[e++] << 8, w = i[e++] | i[e++] << 8, C = i[e++] | i[e++] << 8, E = i[e++], S = E >> 6 & 1, M = 1 << (7 & E) + 1, T = o, F = A, k = !1;
        E >> 7 && (k = !0, T = e, F = M, e += 3 * M);
        var $ = e;
        for (e++; ; ) {
          var I;
          if (!((I = i[e++]) >= 0))
            throw Error("Invalid block size");
          if (I === 0)
            break;
          e += I;
        }
        h.push({ x: y, y: v, width: w, height: C, has_local_palette: k, palette_offset: T, palette_size: F, data_offset: $, data_length: e - $, transparent_index: u, interlaced: !!S, delay: c, disposal: f });
        break;
      case 59:
        l = !1;
        break;
      default:
        throw new Error("Unknown gif block: 0x" + i[e - 1].toString(16));
    }
  this.numFrames = function() {
    return h.length;
  }, this.loopCount = function() {
    return g;
  }, this.frameInfo = function(L) {
    if (L < 0 || L >= h.length)
      throw new Error("Frame index out of range.");
    return h[L];
  }, this.decodeAndBlitFrameBGRA = function(L, P) {
    var Q = this.frameInfo(L), X = Q.width * Q.height, W = new Uint8Array(X);
    aT(i, Q.data_offset, W, X);
    var q = Q.palette_offset, Z = Q.transparent_index;
    Z === null && (Z = 256);
    var oe = Q.width, ne = t - oe, me = oe, b = 4 * (Q.y * t + Q.x), H = 4 * ((Q.y + Q.height) * t + Q.x), V = b, j = 4 * ne;
    Q.interlaced === !0 && (j += 4 * t * 7);
    for (var ie = 8, ue = 0, fe = W.length; ue < fe; ++ue) {
      var ee = W[ue];
      if (me === 0 && (me = oe, (V += j) >= H && (j = 4 * ne + 4 * t * (ie - 1), V = b + (oe + ne) * (ie << 1), ie >>= 1)), ee === Z)
        V += 4;
      else {
        var xe = i[q + 3 * ee], Ee = i[q + 3 * ee + 1], Ue = i[q + 3 * ee + 2];
        P[V++] = Ue, P[V++] = Ee, P[V++] = xe, P[V++] = 255;
      }
      --me;
    }
  }, this.decodeAndBlitFrameRGBA = function(L, P) {
    var Q = this.frameInfo(L), X = Q.width * Q.height, W = new Uint8Array(X);
    aT(i, Q.data_offset, W, X);
    var q = Q.palette_offset, Z = Q.transparent_index;
    Z === null && (Z = 256);
    var oe = Q.width, ne = t - oe, me = oe, b = 4 * (Q.y * t + Q.x), H = 4 * ((Q.y + Q.height) * t + Q.x), V = b, j = 4 * ne;
    Q.interlaced === !0 && (j += 4 * t * 7);
    for (var ie = 8, ue = 0, fe = W.length; ue < fe; ++ue) {
      var ee = W[ue];
      if (me === 0 && (me = oe, (V += j) >= H && (j = 4 * ne + 4 * t * (ie - 1), V = b + (oe + ne) * (ie << 1), ie >>= 1)), ee === Z)
        V += 4;
      else {
        var xe = i[q + 3 * ee], Ee = i[q + 3 * ee + 1], Ue = i[q + 3 * ee + 2];
        P[V++] = xe, P[V++] = Ee, P[V++] = Ue, P[V++] = 255;
      }
      --me;
    }
  };
}
function aT(i, e, t, r) {
  for (var n = i[e++], s = 1 << n, a = s + 1, o = a + 1, A = n + 1, l = (1 << A) - 1, h = 0, c = 0, u = 0, f = i[e++], g = new Int32Array(4096), p = null; ; ) {
    for (; h < 16 && f !== 0; )
      c |= i[e++] << h, h += 8, f === 1 ? f = i[e++] : --f;
    if (h < A)
      break;
    var y = c & l;
    if (c >>= A, h -= A, y !== s) {
      if (y === a)
        break;
      for (var v = y < o ? y : p, w = 0, C = v; C > s; )
        C = g[C] >> 8, ++w;
      var E = C;
      if (u + w + (v !== y ? 1 : 0) > r)
        return void Yr.log("Warning, gif stream longer than expected.");
      t[u++] = E;
      var S = u += w;
      for (v !== y && (t[u++] = E), C = v; w--; )
        C = g[C], t[--S] = 255 & C, C >>= 8;
      p !== null && o < 4096 && (g[o++] = p << 8 | E, o >= l + 1 && A < 12 && (++A, l = l << 1 | 1)), p = y;
    } else
      o = a + 1, l = (1 << (A = n + 1)) - 1, p = null;
  }
  return u !== r && Yr.log("Warning, gif stream shorter than expected."), t;
}
/**
 * @license
  Copyright (c) 2008, Adobe Systems Incorporated
  All rights reserved.

  Redistribution and use in source and binary forms, with or without 
  modification, are permitted provided that the following conditions are
  met:

  * Redistributions of source code must retain the above copyright notice, 
    this list of conditions and the following disclaimer.
  
  * Redistributions in binary form must reproduce the above copyright
    notice, this list of conditions and the following disclaimer in the 
    documentation and/or other materials provided with the distribution.
  
  * Neither the name of Adobe Systems Incorporated nor the names of its 
    contributors may be used to endorse or promote products derived from 
    this software without specific prior written permission.

  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
  IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
  THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
  PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR 
  CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
  EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
  PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
  LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
  SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/
function l_(i) {
  var e, t, r, n, s, a = Math.floor, o = new Array(64), A = new Array(64), l = new Array(64), h = new Array(64), c = new Array(65535), u = new Array(65535), f = new Array(64), g = new Array(64), p = [], y = 0, v = 7, w = new Array(64), C = new Array(64), E = new Array(64), S = new Array(256), M = new Array(2048), T = [0, 1, 5, 6, 14, 15, 27, 28, 2, 4, 7, 13, 16, 26, 29, 42, 3, 8, 12, 17, 25, 30, 41, 43, 9, 11, 18, 24, 31, 40, 44, 53, 10, 19, 23, 32, 39, 45, 52, 54, 20, 22, 33, 38, 46, 51, 55, 60, 21, 34, 37, 47, 50, 56, 59, 61, 35, 36, 48, 49, 57, 58, 62, 63], F = [0, 0, 1, 5, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0], k = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11], $ = [0, 0, 2, 1, 3, 3, 2, 4, 3, 5, 5, 4, 4, 0, 0, 1, 125], I = [1, 2, 3, 0, 4, 17, 5, 18, 33, 49, 65, 6, 19, 81, 97, 7, 34, 113, 20, 50, 129, 145, 161, 8, 35, 66, 177, 193, 21, 82, 209, 240, 36, 51, 98, 114, 130, 9, 10, 22, 23, 24, 25, 26, 37, 38, 39, 40, 41, 42, 52, 53, 54, 55, 56, 57, 58, 67, 68, 69, 70, 71, 72, 73, 74, 83, 84, 85, 86, 87, 88, 89, 90, 99, 100, 101, 102, 103, 104, 105, 106, 115, 116, 117, 118, 119, 120, 121, 122, 131, 132, 133, 134, 135, 136, 137, 138, 146, 147, 148, 149, 150, 151, 152, 153, 154, 162, 163, 164, 165, 166, 167, 168, 169, 170, 178, 179, 180, 181, 182, 183, 184, 185, 186, 194, 195, 196, 197, 198, 199, 200, 201, 202, 210, 211, 212, 213, 214, 215, 216, 217, 218, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250], L = [0, 0, 3, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0], P = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11], Q = [0, 0, 2, 1, 2, 4, 4, 3, 4, 7, 5, 4, 4, 0, 1, 2, 119], X = [0, 1, 2, 3, 17, 4, 5, 33, 49, 6, 18, 65, 81, 7, 97, 113, 19, 34, 50, 129, 8, 20, 66, 145, 161, 177, 193, 9, 35, 51, 82, 240, 21, 98, 114, 209, 10, 22, 36, 52, 225, 37, 241, 23, 24, 25, 26, 38, 39, 40, 41, 42, 53, 54, 55, 56, 57, 58, 67, 68, 69, 70, 71, 72, 73, 74, 83, 84, 85, 86, 87, 88, 89, 90, 99, 100, 101, 102, 103, 104, 105, 106, 115, 116, 117, 118, 119, 120, 121, 122, 130, 131, 132, 133, 134, 135, 136, 137, 138, 146, 147, 148, 149, 150, 151, 152, 153, 154, 162, 163, 164, 165, 166, 167, 168, 169, 170, 178, 179, 180, 181, 182, 183, 184, 185, 186, 194, 195, 196, 197, 198, 199, 200, 201, 202, 210, 211, 212, 213, 214, 215, 216, 217, 218, 226, 227, 228, 229, 230, 231, 232, 233, 234, 242, 243, 244, 245, 246, 247, 248, 249, 250];
  function W(b, H) {
    for (var V = 0, j = 0, ie = new Array(), ue = 1; ue <= 16; ue++) {
      for (var fe = 1; fe <= b[ue]; fe++)
        ie[H[j]] = [], ie[H[j]][0] = V, ie[H[j]][1] = ue, j++, V++;
      V *= 2;
    }
    return ie;
  }
  function q(b) {
    for (var H = b[0], V = b[1] - 1; V >= 0; )
      H & 1 << V && (y |= 1 << v), V--, --v < 0 && (y == 255 ? (Z(255), Z(0)) : Z(y), v = 7, y = 0);
  }
  function Z(b) {
    p.push(b);
  }
  function oe(b) {
    Z(b >> 8 & 255), Z(255 & b);
  }
  function ne(b, H, V, j, ie) {
    for (var ue, fe = ie[0], ee = ie[240], xe = function(Fe, Re) {
      var De, Le, Ge, ze, ft, Et, Mt, Ut, At, vt, Ne = 0;
      for (At = 0; At < 8; ++At) {
        De = Fe[Ne], Le = Fe[Ne + 1], Ge = Fe[Ne + 2], ze = Fe[Ne + 3], ft = Fe[Ne + 4], Et = Fe[Ne + 5], Mt = Fe[Ne + 6];
        var Qr = De + (Ut = Fe[Ne + 7]), kt = De - Ut, fn = Le + Mt, Ar = Le - Mt, Zt = Ge + Et, ii = Ge - Et, Jt = ze + ft, rn = ze - ft, ar = Qr + Jt, Ai = Qr - Jt, yr = fn + Zt, Lr = fn - Zt;
        Fe[Ne] = ar + yr, Fe[Ne + 4] = ar - yr;
        var bt = 0.707106781 * (Lr + Ai);
        Fe[Ne + 2] = Ai + bt, Fe[Ne + 6] = Ai - bt;
        var Ot = 0.382683433 * ((ar = rn + ii) - (Lr = Ar + kt)), li = 0.5411961 * ar + Ot, _r = 1.306562965 * Lr + Ot, di = 0.707106781 * (yr = ii + Ar), zr = kt + di, gt = kt - di;
        Fe[Ne + 5] = gt + li, Fe[Ne + 3] = gt - li, Fe[Ne + 1] = zr + _r, Fe[Ne + 7] = zr - _r, Ne += 8;
      }
      for (Ne = 0, At = 0; At < 8; ++At) {
        De = Fe[Ne], Le = Fe[Ne + 8], Ge = Fe[Ne + 16], ze = Fe[Ne + 24], ft = Fe[Ne + 32], Et = Fe[Ne + 40], Mt = Fe[Ne + 48];
        var Ci = De + (Ut = Fe[Ne + 56]), fr = De - Ut, Ir = Le + Mt, Cr = Le - Mt, ni = Ge + Et, Nn = Ge - Et, hA = ze + ft, nt = ze - ft, he = Ci + hA, Pe = Ci - hA, Ke = Ir + ni, er = Ir - ni;
        Fe[Ne] = he + Ke, Fe[Ne + 32] = he - Ke;
        var Dr = 0.707106781 * (er + Pe);
        Fe[Ne + 16] = Pe + Dr, Fe[Ne + 48] = Pe - Dr;
        var Xr = 0.382683433 * ((he = nt + Nn) - (er = Cr + fr)), si = 0.5411961 * he + Xr, ia = 1.306562965 * er + Xr, nn = 0.707106781 * (Ke = Nn + Cr), co = fr + nn, cA = fr - nn;
        Fe[Ne + 40] = cA + si, Fe[Ne + 24] = cA - si, Fe[Ne + 8] = co + ia, Fe[Ne + 56] = co - ia, Ne++;
      }
      for (At = 0; At < 64; ++At)
        vt = Fe[At] * Re[At], f[At] = vt > 0 ? vt + 0.5 | 0 : vt - 0.5 | 0;
      return f;
    }(b, H), Ee = 0; Ee < 64; ++Ee)
      g[T[Ee]] = xe[Ee];
    var Ue = g[0] - V;
    V = g[0], Ue == 0 ? q(j[0]) : (q(j[u[ue = 32767 + Ue]]), q(c[ue]));
    for (var ke = 63; ke > 0 && g[ke] == 0; )
      ke--;
    if (ke == 0)
      return q(fe), V;
    for (var We, ve = 1; ve <= ke; ) {
      for (var Y = ve; g[ve] == 0 && ve <= ke; )
        ++ve;
      var mt = ve - Y;
      if (mt >= 16) {
        We = mt >> 4;
        for (var Ze = 1; Ze <= We; ++Ze)
          q(ee);
        mt &= 15;
      }
      ue = 32767 + g[ve], q(ie[(mt << 4) + u[ue]]), q(c[ue]), ve++;
    }
    return ke != 63 && q(fe), V;
  }
  function me(b) {
    b = Math.min(Math.max(b, 1), 100), s != b && (function(H) {
      for (var V = [16, 11, 10, 16, 24, 40, 51, 61, 12, 12, 14, 19, 26, 58, 60, 55, 14, 13, 16, 24, 40, 57, 69, 56, 14, 17, 22, 29, 51, 87, 80, 62, 18, 22, 37, 56, 68, 109, 103, 77, 24, 35, 55, 64, 81, 104, 113, 92, 49, 64, 78, 87, 103, 121, 120, 101, 72, 92, 95, 98, 112, 100, 103, 99], j = 0; j < 64; j++) {
        var ie = a((V[j] * H + 50) / 100);
        ie = Math.min(Math.max(ie, 1), 255), o[T[j]] = ie;
      }
      for (var ue = [17, 18, 24, 47, 99, 99, 99, 99, 18, 21, 26, 66, 99, 99, 99, 99, 24, 26, 56, 99, 99, 99, 99, 99, 47, 66, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99], fe = 0; fe < 64; fe++) {
        var ee = a((ue[fe] * H + 50) / 100);
        ee = Math.min(Math.max(ee, 1), 255), A[T[fe]] = ee;
      }
      for (var xe = [1, 1.387039845, 1.306562965, 1.175875602, 1, 0.785694958, 0.5411961, 0.275899379], Ee = 0, Ue = 0; Ue < 8; Ue++)
        for (var ke = 0; ke < 8; ke++)
          l[Ee] = 1 / (o[T[Ee]] * xe[Ue] * xe[ke] * 8), h[Ee] = 1 / (A[T[Ee]] * xe[Ue] * xe[ke] * 8), Ee++;
    }(b < 50 ? Math.floor(5e3 / b) : Math.floor(200 - 2 * b)), s = b);
  }
  this.encode = function(b, H) {
    H && me(H), p = new Array(), y = 0, v = 7, oe(65496), oe(65504), oe(16), Z(74), Z(70), Z(73), Z(70), Z(0), Z(1), Z(1), Z(0), oe(1), oe(1), Z(0), Z(0), function() {
      oe(65499), oe(132), Z(0);
      for (var Le = 0; Le < 64; Le++)
        Z(o[Le]);
      Z(1);
      for (var Ge = 0; Ge < 64; Ge++)
        Z(A[Ge]);
    }(), function(Le, Ge) {
      oe(65472), oe(17), Z(8), oe(Ge), oe(Le), Z(3), Z(1), Z(17), Z(0), Z(2), Z(17), Z(1), Z(3), Z(17), Z(1);
    }(b.width, b.height), function() {
      oe(65476), oe(418), Z(0);
      for (var Le = 0; Le < 16; Le++)
        Z(F[Le + 1]);
      for (var Ge = 0; Ge <= 11; Ge++)
        Z(k[Ge]);
      Z(16);
      for (var ze = 0; ze < 16; ze++)
        Z($[ze + 1]);
      for (var ft = 0; ft <= 161; ft++)
        Z(I[ft]);
      Z(1);
      for (var Et = 0; Et < 16; Et++)
        Z(L[Et + 1]);
      for (var Mt = 0; Mt <= 11; Mt++)
        Z(P[Mt]);
      Z(17);
      for (var Ut = 0; Ut < 16; Ut++)
        Z(Q[Ut + 1]);
      for (var At = 0; At <= 161; At++)
        Z(X[At]);
    }(), oe(65498), oe(12), Z(3), Z(1), Z(0), Z(2), Z(17), Z(3), Z(17), Z(0), Z(63), Z(0);
    var V = 0, j = 0, ie = 0;
    y = 0, v = 7, this.encode.displayName = "_encode_";
    for (var ue, fe, ee, xe, Ee, Ue, ke, We, ve, Y = b.data, mt = b.width, Ze = b.height, Fe = 4 * mt, Re = 0; Re < Ze; ) {
      for (ue = 0; ue < Fe; ) {
        for (Ee = Fe * Re + ue, ke = -1, We = 0, ve = 0; ve < 64; ve++)
          Ue = Ee + (We = ve >> 3) * Fe + (ke = 4 * (7 & ve)), Re + We >= Ze && (Ue -= Fe * (Re + 1 + We - Ze)), ue + ke >= Fe && (Ue -= ue + ke - Fe + 4), fe = Y[Ue++], ee = Y[Ue++], xe = Y[Ue++], w[ve] = (M[fe] + M[ee + 256 >> 0] + M[xe + 512 >> 0] >> 16) - 128, C[ve] = (M[fe + 768 >> 0] + M[ee + 1024 >> 0] + M[xe + 1280 >> 0] >> 16) - 128, E[ve] = (M[fe + 1280 >> 0] + M[ee + 1536 >> 0] + M[xe + 1792 >> 0] >> 16) - 128;
        V = ne(w, l, V, e, r), j = ne(C, h, j, t, n), ie = ne(E, h, ie, t, n), ue += 32;
      }
      Re += 8;
    }
    if (v >= 0) {
      var De = [];
      De[1] = v + 1, De[0] = (1 << v + 1) - 1, q(De);
    }
    return oe(65497), new Uint8Array(p);
  }, i = i || 50, function() {
    for (var b = String.fromCharCode, H = 0; H < 256; H++)
      S[H] = b(H);
  }(), e = W(F, k), t = W(L, P), r = W($, I), n = W(Q, X), function() {
    for (var b = 1, H = 2, V = 1; V <= 15; V++) {
      for (var j = b; j < H; j++)
        u[32767 + j] = V, c[32767 + j] = [], c[32767 + j][1] = V, c[32767 + j][0] = j;
      for (var ie = -(H - 1); ie <= -b; ie++)
        u[32767 + ie] = V, c[32767 + ie] = [], c[32767 + ie][1] = V, c[32767 + ie][0] = H - 1 + ie;
      b <<= 1, H <<= 1;
    }
  }(), function() {
    for (var b = 0; b < 256; b++)
      M[b] = 19595 * b, M[b + 256 >> 0] = 38470 * b, M[b + 512 >> 0] = 7471 * b + 32768, M[b + 768 >> 0] = -11059 * b, M[b + 1024 >> 0] = -21709 * b, M[b + 1280 >> 0] = 32768 * b + 8421375, M[b + 1536 >> 0] = -27439 * b, M[b + 1792 >> 0] = -5329 * b;
  }(), me(i);
}
/**
 * @license
 * Copyright (c) 2017 Aras Abbasi
 *
 * Licensed under the MIT License.
 * http://opensource.org/licenses/mit-license
 */
function ga(i, e) {
  if (this.pos = 0, this.buffer = i, this.datav = new DataView(i.buffer), this.is_with_alpha = !!e, this.bottom_up = !0, this.flag = String.fromCharCode(this.buffer[0]) + String.fromCharCode(this.buffer[1]), this.pos += 2, ["BM", "BA", "CI", "CP", "IC", "PT"].indexOf(this.flag) === -1)
    throw new Error("Invalid BMP File");
  this.parseHeader(), this.parseBGR();
}
function oT(i) {
  function e(F) {
    if (!F)
      throw Error("assert :P");
  }
  function t(F, k, $) {
    for (var I = 0; 4 > I; I++)
      if (F[k + I] != $.charCodeAt(I))
        return !0;
    return !1;
  }
  function r(F, k, $, I, L) {
    for (var P = 0; P < L; P++)
      F[k + P] = $[I + P];
  }
  function n(F, k, $, I) {
    for (var L = 0; L < I; L++)
      F[k + L] = $;
  }
  function s(F) {
    return new Int32Array(F);
  }
  function a(F, k) {
    for (var $ = [], I = 0; I < F; I++)
      $.push(new k());
    return $;
  }
  function o(F, k) {
    var $ = [];
    return function I(L, P, Q) {
      for (var X = Q[P], W = 0; W < X && (L.push(Q.length > P + 1 ? [] : new k()), !(Q.length < P + 1)); W++)
        I(L[W], P + 1, Q);
    }($, 0, F), $;
  }
  var A = function() {
    var F = this;
    function k(d, m) {
      for (var x = 1 << m - 1 >>> 0; d & x; )
        x >>>= 1;
      return x ? (d & x - 1) + x : d;
    }
    function $(d, m, x, B, R) {
      e(!(B % x));
      do
        d[m + (B -= x)] = R;
      while (0 < B);
    }
    function I(d, m, x, B, R) {
      if (e(2328 >= R), 512 >= R)
        var O = s(512);
      else if ((O = s(R)) == null)
        return 0;
      return function(U, D, G, K, se, ge) {
        var pe, ce, be = D, ye = 1 << G, Ae = s(16), le = s(16);
        for (e(se != 0), e(K != null), e(U != null), e(0 < G), ce = 0; ce < se; ++ce) {
          if (15 < K[ce])
            return 0;
          ++Ae[K[ce]];
        }
        if (Ae[0] == se)
          return 0;
        for (le[1] = 0, pe = 1; 15 > pe; ++pe) {
          if (Ae[pe] > 1 << pe)
            return 0;
          le[pe + 1] = le[pe] + Ae[pe];
        }
        for (ce = 0; ce < se; ++ce)
          pe = K[ce], 0 < K[ce] && (ge[le[pe]++] = ce);
        if (le[15] == 1)
          return (K = new L()).g = 0, K.value = ge[0], $(U, be, 1, ye, K), ye;
        var Ce, Te = -1, Be = ye - 1, et = 0, $e = 1, Bt = 1, je = 1 << G;
        for (ce = 0, pe = 1, se = 2; pe <= G; ++pe, se <<= 1) {
          if ($e += Bt <<= 1, 0 > (Bt -= Ae[pe]))
            return 0;
          for (; 0 < Ae[pe]; --Ae[pe])
            (K = new L()).g = pe, K.value = ge[ce++], $(U, be + et, se, je, K), et = k(et, pe);
        }
        for (pe = G + 1, se = 2; 15 >= pe; ++pe, se <<= 1) {
          if ($e += Bt <<= 1, 0 > (Bt -= Ae[pe]))
            return 0;
          for (; 0 < Ae[pe]; --Ae[pe]) {
            if (K = new L(), (et & Be) != Te) {
              for (be += je, Ce = 1 << (Te = pe) - G; 15 > Te && !(0 >= (Ce -= Ae[Te])); )
                ++Te, Ce <<= 1;
              ye += je = 1 << (Ce = Te - G), U[D + (Te = et & Be)].g = Ce + G, U[D + Te].value = be - D - Te;
            }
            K.g = pe - G, K.value = ge[ce++], $(U, be + (et >> G), se, je, K), et = k(et, pe);
          }
        }
        return $e != 2 * le[15] - 1 ? 0 : ye;
      }(d, m, x, B, R, O);
    }
    function L() {
      this.value = this.g = 0;
    }
    function P() {
      this.value = this.g = 0;
    }
    function Q() {
      this.G = a(5, L), this.H = s(5), this.jc = this.Qb = this.qb = this.nd = 0, this.pd = a(os, P);
    }
    function X(d, m, x, B) {
      e(d != null), e(m != null), e(2147483648 > B), d.Ca = 254, d.I = 0, d.b = -8, d.Ka = 0, d.oa = m, d.pa = x, d.Jd = m, d.Yc = x + B, d.Zc = 4 <= B ? x + B - 4 + 1 : x, ue(d);
    }
    function W(d, m) {
      for (var x = 0; 0 < m--; )
        x |= ee(d, 128) << m;
      return x;
    }
    function q(d, m) {
      var x = W(d, m);
      return fe(d) ? -x : x;
    }
    function Z(d, m, x, B) {
      var R, O = 0;
      for (e(d != null), e(m != null), e(4294967288 > B), d.Sb = B, d.Ra = 0, d.u = 0, d.h = 0, 4 < B && (B = 4), R = 0; R < B; ++R)
        O += m[x + R] << 8 * R;
      d.Ra = O, d.bb = B, d.oa = m, d.pa = x;
    }
    function oe(d) {
      for (; 8 <= d.u && d.bb < d.Sb; )
        d.Ra >>>= 8, d.Ra += d.oa[d.pa + d.bb] << Xh - 8 >>> 0, ++d.bb, d.u -= 8;
      V(d) && (d.h = 1, d.u = 0);
    }
    function ne(d, m) {
      if (e(0 <= m), !d.h && m <= zh) {
        var x = H(d) & jh[m];
        return d.u += m, oe(d), x;
      }
      return d.h = 1, d.u = 0;
    }
    function me() {
      this.b = this.Ca = this.I = 0, this.oa = [], this.pa = 0, this.Jd = [], this.Yc = 0, this.Zc = [], this.Ka = 0;
    }
    function b() {
      this.Ra = 0, this.oa = [], this.h = this.u = this.bb = this.Sb = this.pa = 0;
    }
    function H(d) {
      return d.Ra >>> (d.u & Xh - 1) >>> 0;
    }
    function V(d) {
      return e(d.bb <= d.Sb), d.h || d.bb == d.Sb && d.u > Xh;
    }
    function j(d, m) {
      d.u = m, d.h = V(d);
    }
    function ie(d) {
      d.u >= gf && (e(d.u >= gf), oe(d));
    }
    function ue(d) {
      e(d != null && d.oa != null), d.pa < d.Zc ? (d.I = (d.oa[d.pa++] | d.I << 8) >>> 0, d.b += 8) : (e(d != null && d.oa != null), d.pa < d.Yc ? (d.b += 8, d.I = d.oa[d.pa++] | d.I << 8) : d.Ka ? d.b = 0 : (d.I <<= 8, d.b += 8, d.Ka = 1));
    }
    function fe(d) {
      return W(d, 1);
    }
    function ee(d, m) {
      var x = d.Ca;
      0 > d.b && ue(d);
      var B = d.b, R = x * m >>> 8, O = (d.I >>> B > R) + 0;
      for (O ? (x -= R, d.I -= R + 1 << B >>> 0) : x = R + 1, B = x, R = 0; 256 <= B; )
        R += 8, B >>= 8;
      return B = 7 ^ R + As[B], d.b -= B, d.Ca = (x << B) - 1, O;
    }
    function xe(d, m, x) {
      d[m + 0] = x >> 24 & 255, d[m + 1] = x >> 16 & 255, d[m + 2] = x >> 8 & 255, d[m + 3] = x >> 0 & 255;
    }
    function Ee(d, m) {
      return d[m + 0] << 0 | d[m + 1] << 8;
    }
    function Ue(d, m) {
      return Ee(d, m) | d[m + 2] << 16;
    }
    function ke(d, m) {
      return Ee(d, m) | Ee(d, m + 2) << 16;
    }
    function We(d, m) {
      var x = 1 << m;
      return e(d != null), e(0 < m), d.X = s(x), d.X == null ? 0 : (d.Mb = 32 - m, d.Xa = m, 1);
    }
    function ve(d, m) {
      e(d != null), e(m != null), e(d.Xa == m.Xa), r(m.X, 0, d.X, 0, 1 << m.Xa);
    }
    function Y() {
      this.X = [], this.Xa = this.Mb = 0;
    }
    function mt(d, m, x, B) {
      e(x != null), e(B != null);
      var R = x[0], O = B[0];
      return R == 0 && (R = (d * O + m / 2) / m), O == 0 && (O = (m * R + d / 2) / d), 0 >= R || 0 >= O ? 0 : (x[0] = R, B[0] = O, 1);
    }
    function Ze(d, m) {
      return d + (1 << m) - 1 >>> m;
    }
    function Fe(d, m) {
      return ((4278255360 & d) + (4278255360 & m) >>> 0 & 4278255360) + ((16711935 & d) + (16711935 & m) >>> 0 & 16711935) >>> 0;
    }
    function Re(d, m) {
      F[m] = function(x, B, R, O, U, D, G) {
        var K;
        for (K = 0; K < U; ++K) {
          var se = F[d](D[G + K - 1], R, O + K);
          D[G + K] = Fe(x[B + K], se);
        }
      };
    }
    function De() {
      this.ud = this.hd = this.jd = 0;
    }
    function Le(d, m) {
      return ((4278124286 & (d ^ m)) >>> 1) + (d & m) >>> 0;
    }
    function Ge(d) {
      return 0 <= d && 256 > d ? d : 0 > d ? 0 : 255 < d ? 255 : void 0;
    }
    function ze(d, m) {
      return Ge(d + (d - m + 0.5 >> 1));
    }
    function ft(d, m, x) {
      return Math.abs(m - x) - Math.abs(d - x);
    }
    function Et(d, m, x, B, R, O, U) {
      for (B = O[U - 1], x = 0; x < R; ++x)
        O[U + x] = B = Fe(d[m + x], B);
    }
    function Mt(d, m, x, B, R) {
      var O;
      for (O = 0; O < x; ++O) {
        var U = d[m + O], D = U >> 8 & 255, G = 16711935 & (G = (G = 16711935 & U) + ((D << 16) + D));
        B[R + O] = (4278255360 & U) + G >>> 0;
      }
    }
    function Ut(d, m) {
      m.jd = d >> 0 & 255, m.hd = d >> 8 & 255, m.ud = d >> 16 & 255;
    }
    function At(d, m, x, B, R, O) {
      var U;
      for (U = 0; U < B; ++U) {
        var D = m[x + U], G = D >>> 8, K = D, se = 255 & (se = (se = D >>> 16) + ((d.jd << 24 >> 24) * (G << 24 >> 24) >>> 5));
        K = 255 & (K = (K = K + ((d.hd << 24 >> 24) * (G << 24 >> 24) >>> 5)) + ((d.ud << 24 >> 24) * (se << 24 >> 24) >>> 5)), R[O + U] = (4278255360 & D) + (se << 16) + K;
      }
    }
    function vt(d, m, x, B, R) {
      F[m] = function(O, U, D, G, K, se, ge, pe, ce) {
        for (G = ge; G < pe; ++G)
          for (ge = 0; ge < ce; ++ge)
            K[se++] = R(D[B(O[U++])]);
      }, F[d] = function(O, U, D, G, K, se, ge) {
        var pe = 8 >> O.b, ce = O.Ea, be = O.K[0], ye = O.w;
        if (8 > pe)
          for (O = (1 << O.b) - 1, ye = (1 << pe) - 1; U < D; ++U) {
            var Ae, le = 0;
            for (Ae = 0; Ae < ce; ++Ae)
              Ae & O || (le = B(G[K++])), se[ge++] = R(be[le & ye]), le >>= pe;
          }
        else
          F["VP8LMapColor" + x](G, K, be, ye, se, ge, U, D, ce);
      };
    }
    function Ne(d, m, x, B, R) {
      for (x = m + x; m < x; ) {
        var O = d[m++];
        B[R++] = O >> 16 & 255, B[R++] = O >> 8 & 255, B[R++] = O >> 0 & 255;
      }
    }
    function Qr(d, m, x, B, R) {
      for (x = m + x; m < x; ) {
        var O = d[m++];
        B[R++] = O >> 16 & 255, B[R++] = O >> 8 & 255, B[R++] = O >> 0 & 255, B[R++] = O >> 24 & 255;
      }
    }
    function kt(d, m, x, B, R) {
      for (x = m + x; m < x; ) {
        var O = (U = d[m++]) >> 16 & 240 | U >> 12 & 15, U = U >> 0 & 240 | U >> 28 & 15;
        B[R++] = O, B[R++] = U;
      }
    }
    function fn(d, m, x, B, R) {
      for (x = m + x; m < x; ) {
        var O = (U = d[m++]) >> 16 & 248 | U >> 13 & 7, U = U >> 5 & 224 | U >> 3 & 31;
        B[R++] = O, B[R++] = U;
      }
    }
    function Ar(d, m, x, B, R) {
      for (x = m + x; m < x; ) {
        var O = d[m++];
        B[R++] = O >> 0 & 255, B[R++] = O >> 8 & 255, B[R++] = O >> 16 & 255;
      }
    }
    function Zt(d, m, x, B, R, O) {
      if (O == 0)
        for (x = m + x; m < x; )
          xe(B, ((O = d[m++])[0] >> 24 | O[1] >> 8 & 65280 | O[2] << 8 & 16711680 | O[3] << 24) >>> 0), R += 32;
      else
        r(B, R, d, m, x);
    }
    function ii(d, m) {
      F[m][0] = F[d + "0"], F[m][1] = F[d + "1"], F[m][2] = F[d + "2"], F[m][3] = F[d + "3"], F[m][4] = F[d + "4"], F[m][5] = F[d + "5"], F[m][6] = F[d + "6"], F[m][7] = F[d + "7"], F[m][8] = F[d + "8"], F[m][9] = F[d + "9"], F[m][10] = F[d + "10"], F[m][11] = F[d + "11"], F[m][12] = F[d + "12"], F[m][13] = F[d + "13"], F[m][14] = F[d + "0"], F[m][15] = F[d + "0"];
    }
    function Jt(d) {
      return d == g1 || d == p1 || d == cp || d == m1;
    }
    function rn() {
      this.eb = [], this.size = this.A = this.fb = 0;
    }
    function ar() {
      this.y = [], this.f = [], this.ea = [], this.F = [], this.Tc = this.Ed = this.Cd = this.Fd = this.lb = this.Db = this.Ab = this.fa = this.J = this.W = this.N = this.O = 0;
    }
    function Ai() {
      this.Rd = this.height = this.width = this.S = 0, this.f = {}, this.f.RGBA = new rn(), this.f.kb = new ar(), this.sd = null;
    }
    function yr() {
      this.width = [0], this.height = [0], this.Pd = [0], this.Qd = [0], this.format = [0];
    }
    function Lr() {
      this.Id = this.fd = this.Md = this.hb = this.ib = this.da = this.bd = this.cd = this.j = this.v = this.Da = this.Sd = this.ob = 0;
    }
    function bt(d) {
      return alert("todo:WebPSamplerProcessPlane"), d.T;
    }
    function Ot(d, m) {
      var x = d.T, B = m.ba.f.RGBA, R = B.eb, O = B.fb + d.ka * B.A, U = $s[m.ba.S], D = d.y, G = d.O, K = d.f, se = d.N, ge = d.ea, pe = d.W, ce = m.cc, be = m.dc, ye = m.Mc, Ae = m.Nc, le = d.ka, Ce = d.ka + d.T, Te = d.U, Be = Te + 1 >> 1;
      for (le == 0 ? U(D, G, null, null, K, se, ge, pe, K, se, ge, pe, R, O, null, null, Te) : (U(m.ec, m.fc, D, G, ce, be, ye, Ae, K, se, ge, pe, R, O - B.A, R, O, Te), ++x); le + 2 < Ce; le += 2)
        ce = K, be = se, ye = ge, Ae = pe, se += d.Rc, pe += d.Rc, O += 2 * B.A, U(D, (G += 2 * d.fa) - d.fa, D, G, ce, be, ye, Ae, K, se, ge, pe, R, O - B.A, R, O, Te);
      return G += d.fa, d.j + Ce < d.o ? (r(m.ec, m.fc, D, G, Te), r(m.cc, m.dc, K, se, Be), r(m.Mc, m.Nc, ge, pe, Be), x--) : 1 & Ce || U(D, G, null, null, K, se, ge, pe, K, se, ge, pe, R, O + B.A, null, null, Te), x;
    }
    function li(d, m, x) {
      var B = d.F, R = [d.J];
      if (B != null) {
        var O = d.U, U = m.ba.S, D = U == hp || U == cp;
        m = m.ba.f.RGBA;
        var G = [0], K = d.ka;
        G[0] = d.T, d.Kb && (K == 0 ? --G[0] : (--K, R[0] -= d.width), d.j + d.ka + d.T == d.o && (G[0] = d.o - d.j - K));
        var se = m.eb;
        K = m.fb + K * m.A, d = sp(B, R[0], d.width, O, G, se, K + (D ? 0 : 3), m.A), e(x == G), d && Jt(U) && _A(se, K, D, O, G, m.A);
      }
      return 0;
    }
    function _r(d) {
      var m = d.ma, x = m.ba.S, B = 11 > x, R = x == Ap || x == lp || x == hp || x == d1 || x == 12 || Jt(x);
      if (m.memory = null, m.Ib = null, m.Jb = null, m.Nd = null, !ff(m.Oa, d, R ? 11 : 12))
        return 0;
      if (R && Jt(x) && Oe(), d.da)
        alert("todo:use_scaling");
      else {
        if (B) {
          if (m.Ib = bt, d.Kb) {
            if (x = d.U + 1 >> 1, m.memory = s(d.U + 2 * x), m.memory == null)
              return 0;
            m.ec = m.memory, m.fc = 0, m.cc = m.ec, m.dc = m.fc + d.U, m.Mc = m.cc, m.Nc = m.dc + x, m.Ib = Ot, Oe();
          }
        } else
          alert("todo:EmitYUV");
        R && (m.Jb = li, B && de());
      }
      if (B && !tS) {
        for (d = 0; 256 > d; ++d)
          ZU[d] = 89858 * (d - 128) + fp >> up, tQ[d] = -22014 * (d - 128) + fp, eQ[d] = -45773 * (d - 128), JU[d] = 113618 * (d - 128) + fp >> up;
        for (d = wf; d < _1; ++d)
          m = 76283 * (d - 16) + fp >> up, rQ[d - wf] = Bs(m, 255), iQ[d - wf] = Bs(m + 8 >> 4, 15);
        tS = 1;
      }
      return 1;
    }
    function di(d) {
      var m = d.ma, x = d.U, B = d.T;
      return e(!(1 & d.ka)), 0 >= x || 0 >= B ? 0 : (x = m.Ib(d, m), m.Jb != null && m.Jb(d, m, x), m.Dc += x, 1);
    }
    function zr(d) {
      d.ma.memory = null;
    }
    function gt(d, m, x, B) {
      return ne(d, 8) != 47 ? 0 : (m[0] = ne(d, 14) + 1, x[0] = ne(d, 14) + 1, B[0] = ne(d, 1), ne(d, 3) != 0 ? 0 : !d.h);
    }
    function Ci(d, m) {
      if (4 > d)
        return d + 1;
      var x = d - 2 >> 1;
      return (2 + (1 & d) << x) + ne(m, x) + 1;
    }
    function fr(d, m) {
      return 120 < m ? m - 120 : 1 <= (x = ((x = QU[m - 1]) >> 4) * d + (8 - (15 & x))) ? x : 1;
      var x;
    }
    function Ir(d, m, x) {
      var B = H(x), R = d[m += 255 & B].g - 8;
      return 0 < R && (j(x, x.u + 8), B = H(x), m += d[m].value, m += B & (1 << R) - 1), j(x, x.u + d[m].g), d[m].value;
    }
    function Cr(d, m, x) {
      return x.g += d.g, x.value += d.value << m >>> 0, e(8 >= x.g), d.g;
    }
    function ni(d, m, x) {
      var B = d.xc;
      return e((m = B == 0 ? 0 : d.vc[d.md * (x >> B) + (m >> B)]) < d.Wb), d.Ya[m];
    }
    function Nn(d, m, x, B) {
      var R = d.ab, O = d.c * m, U = d.C;
      m = U + m;
      var D = x, G = B;
      for (B = d.Ta, x = d.Ua; 0 < R--; ) {
        var K = d.gc[R], se = U, ge = m, pe = D, ce = G, be = (G = B, D = x, K.Ea);
        switch (e(se < ge), e(ge <= K.nc), K.hc) {
          case 2:
            np(pe, ce, (ge - se) * be, G, D);
            break;
          case 0:
            var ye = se, Ae = ge, le = G, Ce = D, Te = (je = K).Ea;
            ye == 0 && (h1(pe, ce, null, null, 1, le, Ce), Et(pe, ce + 1, 0, 0, Te - 1, le, Ce + 1), ce += Te, Ce += Te, ++ye);
            for (var Be = 1 << je.b, et = Be - 1, $e = Ze(Te, je.b), Bt = je.K, je = je.w + (ye >> je.b) * $e; ye < Ae; ) {
              var br = Bt, kr = je, wr = 1;
              for (pf(pe, ce, le, Ce - Te, 1, le, Ce); wr < Te; ) {
                var lr = (wr & ~et) + Be;
                lr > Te && (lr = Te), (0, pA[br[kr++] >> 8 & 15])(pe, ce + +wr, le, Ce + wr - Te, lr - wr, le, Ce + wr), wr = lr;
              }
              ce += Te, Ce += Te, ++ye & et || (je += $e);
            }
            ge != K.nc && r(G, D - be, G, D + (ge - se - 1) * be, be);
            break;
          case 1:
            for (be = pe, Ae = ce, Te = (pe = K.Ea) - (Ce = pe & ~(le = (ce = 1 << K.b) - 1)), ye = Ze(pe, K.b), Be = K.K, K = K.w + (se >> K.b) * ye; se < ge; ) {
              for (et = Be, $e = K, Bt = new De(), je = Ae + Ce, br = Ae + pe; Ae < je; )
                Ut(et[$e++], Bt), ks(Bt, be, Ae, ce, G, D), Ae += ce, D += ce;
              Ae < br && (Ut(et[$e++], Bt), ks(Bt, be, Ae, Te, G, D), Ae += Te, D += Te), ++se & le || (K += ye);
            }
            break;
          case 3:
            if (pe == G && ce == D && 0 < K.b) {
              for (Ae = G, pe = be = D + (ge - se) * be - (Ce = (ge - se) * Ze(K.Ea, K.b)), ce = G, le = D, ye = [], Ce = (Te = Ce) - 1; 0 <= Ce; --Ce)
                ye[Ce] = ce[le + Ce];
              for (Ce = Te - 1; 0 <= Ce; --Ce)
                Ae[pe + Ce] = ye[Ce];
              oa(K, se, ge, G, be, G, D);
            } else
              oa(K, se, ge, pe, ce, G, D);
        }
        D = B, G = x;
      }
      G != x && r(B, x, D, G, O);
    }
    function hA(d, m) {
      var x = d.V, B = d.Ba + d.c * d.C, R = m - d.C;
      if (e(m <= d.l.o), e(16 >= R), 0 < R) {
        var O = d.l, U = d.Ta, D = d.Ua, G = O.width;
        if (Nn(d, R, x, B), R = D = [D], e((x = d.C) < (B = m)), e(O.v < O.va), B > O.o && (B = O.o), x < O.j) {
          var K = O.j - x;
          x = O.j, R[0] += K * G;
        }
        if (x >= B ? x = 0 : (R[0] += 4 * O.v, O.ka = x - O.j, O.U = O.va - O.v, O.T = B - x, x = 1), x) {
          if (D = D[0], 11 > (x = d.ca).S) {
            var se = x.f.RGBA, ge = (B = x.S, R = O.U, O = O.T, K = se.eb, se.A), pe = O;
            for (se = se.fb + d.Ma * se.A; 0 < pe--; ) {
              var ce = U, be = D, ye = R, Ae = K, le = se;
              switch (B) {
                case op:
                  Aa(ce, be, ye, Ae, le);
                  break;
                case Ap:
                  mA(ce, be, ye, Ae, le);
                  break;
                case g1:
                  mA(ce, be, ye, Ae, le), _A(Ae, le, 0, ye, 1, 0);
                  break;
                case Kb:
                  Wh(ce, be, ye, Ae, le);
                  break;
                case lp:
                  Zt(ce, be, ye, Ae, le, 1);
                  break;
                case p1:
                  Zt(ce, be, ye, Ae, le, 1), _A(Ae, le, 0, ye, 1, 0);
                  break;
                case hp:
                  Zt(ce, be, ye, Ae, le, 0);
                  break;
                case cp:
                  Zt(ce, be, ye, Ae, le, 0), _A(Ae, le, 1, ye, 1, 0);
                  break;
                case d1:
                  Ra(ce, be, ye, Ae, le);
                  break;
                case m1:
                  Ra(ce, be, ye, Ae, le), Zh(Ae, le, ye, 1, 0);
                  break;
                case jb:
                  po(ce, be, ye, Ae, le);
                  break;
                default:
                  e(0);
              }
              D += G, se += ge;
            }
            d.Ma += O;
          } else
            alert("todo:EmitRescaledRowsYUVA");
          e(d.Ma <= x.height);
        }
      }
      d.C = m, e(d.C <= d.i);
    }
    function nt(d) {
      var m;
      if (0 < d.ua)
        return 0;
      for (m = 0; m < d.Wb; ++m) {
        var x = d.Ya[m].G, B = d.Ya[m].H;
        if (0 < x[1][B[1] + 0].g || 0 < x[2][B[2] + 0].g || 0 < x[3][B[3] + 0].g)
          return 0;
      }
      return 1;
    }
    function he(d, m, x, B, R, O) {
      if (d.Z != 0) {
        var U = d.qd, D = d.rd;
        for (e(xA[d.Z] != null); m < x; ++m)
          xA[d.Z](U, D, B, R, B, R, O), U = B, D = R, R += O;
        d.qd = U, d.rd = D;
      }
    }
    function Pe(d, m) {
      var x = d.l.ma, B = x.Z == 0 || x.Z == 1 ? d.l.j : d.C;
      if (B = d.C < B ? B : d.C, e(m <= d.l.o), m > B) {
        var R = d.l.width, O = x.ca, U = x.tb + R * B, D = d.V, G = d.Ba + d.c * B, K = d.gc;
        e(d.ab == 1), e(K[0].hc == 3), c1(K[0], B, m, D, G, O, U), he(x, B, m, O, U, R);
      }
      d.C = d.Ma = m;
    }
    function Ke(d, m, x, B, R, O, U) {
      var D = d.$ / B, G = d.$ % B, K = d.m, se = d.s, ge = x + d.$, pe = ge;
      R = x + B * R;
      var ce = x + B * O, be = 280 + se.ua, ye = d.Pb ? D : 16777216, Ae = 0 < se.ua ? se.Wa : null, le = se.wc, Ce = ge < ce ? ni(se, G, D) : null;
      e(d.C < O), e(ce <= R);
      var Te = !1;
      e:
        for (; ; ) {
          for (; Te || ge < ce; ) {
            var Be = 0;
            if (D >= ye) {
              var et = ge - x;
              e((ye = d).Pb), ye.wd = ye.m, ye.xd = et, 0 < ye.s.ua && ve(ye.s.Wa, ye.s.vb), ye = D + kU;
            }
            if (G & le || (Ce = ni(se, G, D)), e(Ce != null), Ce.Qb && (m[ge] = Ce.qb, Te = !0), !Te)
              if (ie(K), Ce.jc) {
                Be = K, et = m;
                var $e = ge, Bt = Ce.pd[H(Be) & os - 1];
                e(Ce.jc), 256 > Bt.g ? (j(Be, Be.u + Bt.g), et[$e] = Bt.value, Be = 0) : (j(Be, Be.u + Bt.g - 256), e(256 <= Bt.value), Be = Bt.value), Be == 0 && (Te = !0);
              } else
                Be = Ir(Ce.G[0], Ce.H[0], K);
            if (K.h)
              break;
            if (Te || 256 > Be) {
              if (!Te)
                if (Ce.nd)
                  m[ge] = (Ce.qb | Be << 8) >>> 0;
                else {
                  if (ie(K), Te = Ir(Ce.G[1], Ce.H[1], K), ie(K), et = Ir(Ce.G[2], Ce.H[2], K), $e = Ir(Ce.G[3], Ce.H[3], K), K.h)
                    break;
                  m[ge] = ($e << 24 | Te << 16 | Be << 8 | et) >>> 0;
                }
              if (Te = !1, ++ge, ++G >= B && (G = 0, ++D, U != null && D <= O && !(D % 16) && U(d, D), Ae != null))
                for (; pe < ge; )
                  Be = m[pe++], Ae.X[(506832829 * Be & 4294967295) >>> Ae.Mb] = Be;
            } else if (280 > Be) {
              if (Be = Ci(Be - 256, K), et = Ir(Ce.G[4], Ce.H[4], K), ie(K), et = fr(B, et = Ci(et, K)), K.h)
                break;
              if (ge - x < et || R - ge < Be)
                break e;
              for ($e = 0; $e < Be; ++$e)
                m[ge + $e] = m[ge + $e - et];
              for (ge += Be, G += Be; G >= B; )
                G -= B, ++D, U != null && D <= O && !(D % 16) && U(d, D);
              if (e(ge <= R), G & le && (Ce = ni(se, G, D)), Ae != null)
                for (; pe < ge; )
                  Be = m[pe++], Ae.X[(506832829 * Be & 4294967295) >>> Ae.Mb] = Be;
            } else {
              if (!(Be < be))
                break e;
              for (Te = Be - 280, e(Ae != null); pe < ge; )
                Be = m[pe++], Ae.X[(506832829 * Be & 4294967295) >>> Ae.Mb] = Be;
              Be = ge, e(!(Te >>> (et = Ae).Xa)), m[Be] = et.X[Te], Te = !0;
            }
            Te || e(K.h == V(K));
          }
          if (d.Pb && K.h && ge < R)
            e(d.m.h), d.a = 5, d.m = d.wd, d.$ = d.xd, 0 < d.s.ua && ve(d.s.vb, d.s.Wa);
          else {
            if (K.h)
              break e;
            U != null && U(d, D > O ? O : D), d.a = 0, d.$ = ge - x;
          }
          return 1;
        }
      return d.a = 3, 0;
    }
    function er(d) {
      e(d != null), d.vc = null, d.yc = null, d.Ya = null;
      var m = d.Wa;
      m != null && (m.X = null), d.vb = null, e(d != null);
    }
    function Dr() {
      var d = new l1();
      return d == null ? null : (d.a = 0, d.xb = Wb, ii("Predictor", "VP8LPredictors"), ii("Predictor", "VP8LPredictors_C"), ii("PredictorAdd", "VP8LPredictorsAdd"), ii("PredictorAdd", "VP8LPredictorsAdd_C"), np = Mt, ks = At, Aa = Ne, mA = Qr, Ra = kt, po = fn, Wh = Ar, F.VP8LMapColor32b = mf, F.VP8LMapColor8b = u1, d);
    }
    function Xr(d, m, x, B, R) {
      var O = 1, U = [d], D = [m], G = B.m, K = B.s, se = null, ge = 0;
      e:
        for (; ; ) {
          if (x)
            for (; O && ne(G, 1); ) {
              var pe = U, ce = D, be = B, ye = 1, Ae = be.m, le = be.gc[be.ab], Ce = ne(Ae, 2);
              if (be.Oc & 1 << Ce)
                O = 0;
              else {
                switch (be.Oc |= 1 << Ce, le.hc = Ce, le.Ea = pe[0], le.nc = ce[0], le.K = [null], ++be.ab, e(4 >= be.ab), Ce) {
                  case 0:
                  case 1:
                    le.b = ne(Ae, 3) + 2, ye = Xr(Ze(le.Ea, le.b), Ze(le.nc, le.b), 0, be, le.K), le.K = le.K[0];
                    break;
                  case 3:
                    var Te, Be = ne(Ae, 8) + 1, et = 16 < Be ? 0 : 4 < Be ? 1 : 2 < Be ? 2 : 3;
                    if (pe[0] = Ze(le.Ea, et), le.b = et, Te = ye = Xr(Be, 1, 0, be, le.K)) {
                      var $e, Bt = Be, je = le, br = 1 << (8 >> je.b), kr = s(br);
                      if (kr == null)
                        Te = 0;
                      else {
                        var wr = je.K[0], lr = je.w;
                        for (kr[0] = je.K[0][0], $e = 1; $e < 1 * Bt; ++$e)
                          kr[$e] = Fe(wr[lr + $e], kr[$e - 1]);
                        for (; $e < 4 * br; ++$e)
                          kr[$e] = 0;
                        je.K[0] = null, je.K[0] = kr, Te = 1;
                      }
                    }
                    ye = Te;
                    break;
                  case 2:
                    break;
                  default:
                    e(0);
                }
                O = ye;
              }
            }
          if (U = U[0], D = D[0], O && ne(G, 1) && !(O = 1 <= (ge = ne(G, 4)) && 11 >= ge)) {
            B.a = 3;
            break e;
          }
          var Wr;
          if (Wr = O)
            t: {
              var Vr, jt, Vi, ls = B, Ki = U, hs = D, Hr = ge, Ss = x, Ts = ls.m, gn = ls.s, bn = [null], qn = 1, Vs = 0, Ma = DU[Hr];
              r:
                for (; ; ) {
                  if (Ss && ne(Ts, 1)) {
                    var pn = ne(Ts, 3) + 2, wo = Ze(Ki, pn), Ll = Ze(hs, pn), Jh = wo * Ll;
                    if (!Xr(wo, Ll, 0, ls, bn))
                      break r;
                    for (bn = bn[0], gn.xc = pn, Vr = 0; Vr < Jh; ++Vr) {
                      var CA = bn[Vr] >> 8 & 65535;
                      bn[Vr] = CA, CA >= qn && (qn = CA + 1);
                    }
                  }
                  if (Ts.h)
                    break r;
                  for (jt = 0; 5 > jt; ++jt) {
                    var Bi = zb[jt];
                    !jt && 0 < Hr && (Bi += 1 << Hr), Vs < Bi && (Vs = Bi);
                  }
                  var w1 = a(qn * Ma, L), nS = qn, sS = a(nS, Q);
                  if (sS == null)
                    var gp = null;
                  else
                    e(65536 >= nS), gp = sS;
                  var xf = s(Vs);
                  if (gp == null || xf == null || w1 == null) {
                    ls.a = 1;
                    break r;
                  }
                  var pp = w1;
                  for (Vr = Vi = 0; Vr < qn; ++Vr) {
                    var ua = gp[Vr], ec = ua.G, tc = ua.H, aS = 0, mp = 1, oS = 0;
                    for (jt = 0; 5 > jt; ++jt) {
                      Bi = zb[jt], ec[jt] = pp, tc[jt] = Vi, !jt && 0 < Hr && (Bi += 1 << Hr);
                      n: {
                        var vp, x1 = Bi, yp = ls, Cf = xf, aQ = pp, oQ = Vi, C1 = 0, EA = yp.m, AQ = ne(EA, 1);
                        if (n(Cf, 0, 0, x1), AQ) {
                          var lQ = ne(EA, 1) + 1, hQ = ne(EA, 1), AS = ne(EA, hQ == 0 ? 1 : 8);
                          Cf[AS] = 1, lQ == 2 && (Cf[AS = ne(EA, 8)] = 1);
                          var _p = 1;
                        } else {
                          var lS = s(19), hS = ne(EA, 4) + 4;
                          if (19 < hS) {
                            yp.a = 3;
                            var wp = 0;
                            break n;
                          }
                          for (vp = 0; vp < hS; ++vp)
                            lS[UU[vp]] = ne(EA, 3);
                          var E1 = void 0, Ef = void 0, cS = yp, cQ = lS, xp = x1, uS = Cf, B1 = 0, BA = cS.m, fS = 8, dS = a(128, L);
                          i:
                            for (; I(dS, 0, 7, cQ, 19); ) {
                              if (ne(BA, 1)) {
                                var uQ = 2 + 2 * ne(BA, 3);
                                if ((E1 = 2 + ne(BA, uQ)) > xp)
                                  break i;
                              } else
                                E1 = xp;
                              for (Ef = 0; Ef < xp && E1--; ) {
                                ie(BA);
                                var gS = dS[0 + (127 & H(BA))];
                                j(BA, BA.u + gS.g);
                                var rc = gS.value;
                                if (16 > rc)
                                  uS[Ef++] = rc, rc != 0 && (fS = rc);
                                else {
                                  var fQ = rc == 16, pS = rc - 16, dQ = PU[pS], mS = ne(BA, NU[pS]) + dQ;
                                  if (Ef + mS > xp)
                                    break i;
                                  for (var gQ = fQ ? fS : 0; 0 < mS--; )
                                    uS[Ef++] = gQ;
                                }
                              }
                              B1 = 1;
                              break i;
                            }
                          B1 || (cS.a = 3), _p = B1;
                        }
                        (_p = _p && !EA.h) && (C1 = I(aQ, oQ, 8, Cf, x1)), _p && C1 != 0 ? wp = C1 : (yp.a = 3, wp = 0);
                      }
                      if (wp == 0)
                        break r;
                      if (mp && OU[jt] == 1 && (mp = pp[Vi].g == 0), aS += pp[Vi].g, Vi += wp, 3 >= jt) {
                        var Bf, b1 = xf[0];
                        for (Bf = 1; Bf < Bi; ++Bf)
                          xf[Bf] > b1 && (b1 = xf[Bf]);
                        oS += b1;
                      }
                    }
                    if (ua.nd = mp, ua.Qb = 0, mp && (ua.qb = (ec[3][tc[3] + 0].value << 24 | ec[1][tc[1] + 0].value << 16 | ec[2][tc[2] + 0].value) >>> 0, aS == 0 && 256 > ec[0][tc[0] + 0].value && (ua.Qb = 1, ua.qb += ec[0][tc[0] + 0].value << 8)), ua.jc = !ua.Qb && 6 > oS, ua.jc) {
                      var Cp, xo = ua;
                      for (Cp = 0; Cp < os; ++Cp) {
                        var bA = Cp, SA = xo.pd[bA], Ep = xo.G[0][xo.H[0] + bA];
                        256 <= Ep.value ? (SA.g = Ep.g + 256, SA.value = Ep.value) : (SA.g = 0, SA.value = 0, bA >>= Cr(Ep, 8, SA), bA >>= Cr(xo.G[1][xo.H[1] + bA], 16, SA), bA >>= Cr(xo.G[2][xo.H[2] + bA], 0, SA), Cr(xo.G[3][xo.H[3] + bA], 24, SA));
                      }
                    }
                  }
                  gn.vc = bn, gn.Wb = qn, gn.Ya = gp, gn.yc = w1, Wr = 1;
                  break t;
                }
              Wr = 0;
            }
          if (!(O = Wr)) {
            B.a = 3;
            break e;
          }
          if (0 < ge) {
            if (K.ua = 1 << ge, !We(K.Wa, ge)) {
              B.a = 1, O = 0;
              break e;
            }
          } else
            K.ua = 0;
          var S1 = B, vS = U, pQ = D, T1 = S1.s, F1 = T1.xc;
          if (S1.c = vS, S1.i = pQ, T1.md = Ze(vS, F1), T1.wc = F1 == 0 ? -1 : (1 << F1) - 1, x) {
            B.xb = zU;
            break e;
          }
          if ((se = s(U * D)) == null) {
            B.a = 1, O = 0;
            break e;
          }
          O = (O = Ke(B, se, 0, U, D, D, null)) && !G.h;
          break e;
        }
      return O ? (R != null ? R[0] = se : (e(se == null), e(x)), B.$ = 0, x || er(K)) : er(K), O;
    }
    function si(d, m) {
      var x = d.c * d.i, B = x + m + 16 * m;
      return e(d.c <= m), d.V = s(B), d.V == null ? (d.Ta = null, d.Ua = 0, d.a = 1, 0) : (d.Ta = d.V, d.Ua = d.Ba + x + m, 1);
    }
    function ia(d, m) {
      var x = d.C, B = m - x, R = d.V, O = d.Ba + d.c * x;
      for (e(m <= d.l.o); 0 < B; ) {
        var U = 16 < B ? 16 : B, D = d.l.ma, G = d.l.width, K = G * U, se = D.ca, ge = D.tb + G * x, pe = d.Ta, ce = d.Ua;
        Nn(d, U, R, O), Db(pe, ce, se, ge, K), he(D, x, x + U, se, ge, G), B -= U, R += U * d.c, x += U;
      }
      e(x == m), d.C = d.Ma = m;
    }
    function nn() {
      this.ub = this.yd = this.td = this.Rb = 0;
    }
    function co() {
      this.Kd = this.Ld = this.Ud = this.Td = this.i = this.c = 0;
    }
    function cA() {
      this.Fb = this.Bb = this.Cb = 0, this.Zb = s(4), this.Lb = s(4);
    }
    function Wu() {
      this.Yb = function() {
        var d = [];
        return function m(x, B, R) {
          for (var O = R[B], U = 0; U < O && (x.push(R.length > B + 1 ? [] : 0), !(R.length < B + 1)); U++)
            m(x[U], B + 1, R);
        }(d, 0, [3, 11]), d;
      }();
    }
    function ky() {
      this.jb = s(3), this.Wc = o([4, 8], Wu), this.Xc = o([4, 17], Wu);
    }
    function Hy() {
      this.Pc = this.wb = this.Tb = this.zd = 0, this.vd = new s(4), this.od = new s(4);
    }
    function Nh() {
      this.ld = this.La = this.dd = this.tc = 0;
    }
    function Dg() {
      this.Na = this.la = 0;
    }
    function Gy() {
      this.Sc = [0, 0], this.Eb = [0, 0], this.Qc = [0, 0], this.ia = this.lc = 0;
    }
    function Yu() {
      this.ad = s(384), this.Za = 0, this.Ob = s(16), this.$b = this.Ad = this.ia = this.Gc = this.Hc = this.Dd = 0;
    }
    function $y() {
      this.uc = this.M = this.Nb = 0, this.wa = Array(new Nh()), this.Y = 0, this.ya = Array(new Yu()), this.aa = 0, this.l = new Ph();
    }
    function kg() {
      this.y = s(16), this.f = s(8), this.ea = s(8);
    }
    function Vy() {
      this.cb = this.a = 0, this.sc = "", this.m = new me(), this.Od = new nn(), this.Kc = new co(), this.ed = new Hy(), this.Qa = new cA(), this.Ic = this.$c = this.Aa = 0, this.D = new $y(), this.Xb = this.Va = this.Hb = this.zb = this.yb = this.Ub = this.za = 0, this.Jc = a(8, me), this.ia = 0, this.pb = a(4, Gy), this.Pa = new ky(), this.Bd = this.kc = 0, this.Ac = [], this.Bc = 0, this.zc = [0, 0, 0, 0], this.Gd = Array(new kg()), this.Hd = 0, this.rb = Array(new Dg()), this.sb = 0, this.wa = Array(new Nh()), this.Y = 0, this.oc = [], this.pc = 0, this.sa = [], this.ta = 0, this.qa = [], this.ra = 0, this.Ha = [], this.B = this.R = this.Ia = 0, this.Ec = [], this.M = this.ja = this.Vb = this.Fc = 0, this.ya = Array(new Yu()), this.L = this.aa = 0, this.gd = o([4, 2], Nh), this.ga = null, this.Fa = [], this.Cc = this.qc = this.P = 0, this.Gb = [], this.Uc = 0, this.mb = [], this.nb = 0, this.rc = [], this.Ga = this.Vc = 0;
    }
    function Ph() {
      this.T = this.U = this.ka = this.height = this.width = 0, this.y = [], this.f = [], this.ea = [], this.Rc = this.fa = this.W = this.N = this.O = 0, this.ma = "void", this.put = "VP8IoPutHook", this.ac = "VP8IoSetupHook", this.bc = "VP8IoTeardownHook", this.ha = this.Kb = 0, this.data = [], this.hb = this.ib = this.da = this.o = this.j = this.va = this.v = this.Da = this.ob = this.w = 0, this.F = [], this.J = 0;
    }
    function Ky() {
      var d = new Vy();
      return d != null && (d.a = 0, d.sc = "OK", d.cb = 0, d.Xb = 0, _f || (_f = $g)), d;
    }
    function Ri(d, m, x) {
      return d.a == 0 && (d.a = m, d.sc = x, d.cb = 0), 0;
    }
    function Hg(d, m, x) {
      return 3 <= x && d[m + 0] == 157 && d[m + 1] == 1 && d[m + 2] == 42;
    }
    function Gg(d, m) {
      if (d == null)
        return 0;
      if (d.a = 0, d.sc = "OK", m == null)
        return Ri(d, 2, "null VP8Io passed to VP8GetHeaders()");
      var x = m.data, B = m.w, R = m.ha;
      if (4 > R)
        return Ri(d, 7, "Truncated header.");
      var O = x[B + 0] | x[B + 1] << 8 | x[B + 2] << 16, U = d.Od;
      if (U.Rb = !(1 & O), U.td = O >> 1 & 7, U.yd = O >> 4 & 1, U.ub = O >> 5, 3 < U.td)
        return Ri(d, 3, "Incorrect keyframe parameters.");
      if (!U.yd)
        return Ri(d, 4, "Frame not displayable.");
      B += 3, R -= 3;
      var D = d.Kc;
      if (U.Rb) {
        if (7 > R)
          return Ri(d, 7, "cannot parse picture header");
        if (!Hg(x, B, R))
          return Ri(d, 3, "Bad code word");
        D.c = 16383 & (x[B + 4] << 8 | x[B + 3]), D.Td = x[B + 4] >> 6, D.i = 16383 & (x[B + 6] << 8 | x[B + 5]), D.Ud = x[B + 6] >> 6, B += 7, R -= 7, d.za = D.c + 15 >> 4, d.Ub = D.i + 15 >> 4, m.width = D.c, m.height = D.i, m.Da = 0, m.j = 0, m.v = 0, m.va = m.width, m.o = m.height, m.da = 0, m.ib = m.width, m.hb = m.height, m.U = m.width, m.T = m.height, n((O = d.Pa).jb, 0, 255, O.jb.length), e((O = d.Qa) != null), O.Cb = 0, O.Bb = 0, O.Fb = 1, n(O.Zb, 0, 0, O.Zb.length), n(O.Lb, 0, 0, O.Lb);
      }
      if (U.ub > R)
        return Ri(d, 7, "bad partition length");
      X(O = d.m, x, B, U.ub), B += U.ub, R -= U.ub, U.Rb && (D.Ld = fe(O), D.Kd = fe(O)), D = d.Qa;
      var G, K = d.Pa;
      if (e(O != null), e(D != null), D.Cb = fe(O), D.Cb) {
        if (D.Bb = fe(O), fe(O)) {
          for (D.Fb = fe(O), G = 0; 4 > G; ++G)
            D.Zb[G] = fe(O) ? q(O, 7) : 0;
          for (G = 0; 4 > G; ++G)
            D.Lb[G] = fe(O) ? q(O, 6) : 0;
        }
        if (D.Bb)
          for (G = 0; 3 > G; ++G)
            K.jb[G] = fe(O) ? W(O, 8) : 255;
      } else
        D.Bb = 0;
      if (O.Ka)
        return Ri(d, 3, "cannot parse segment header");
      if ((D = d.ed).zd = fe(O), D.Tb = W(O, 6), D.wb = W(O, 3), D.Pc = fe(O), D.Pc && fe(O)) {
        for (K = 0; 4 > K; ++K)
          fe(O) && (D.vd[K] = q(O, 6));
        for (K = 0; 4 > K; ++K)
          fe(O) && (D.od[K] = q(O, 6));
      }
      if (d.L = D.Tb == 0 ? 0 : D.zd ? 1 : 2, O.Ka)
        return Ri(d, 3, "cannot parse filter header");
      var se = R;
      if (R = G = B, B = G + se, D = se, d.Xb = (1 << W(d.m, 2)) - 1, se < 3 * (K = d.Xb))
        x = 7;
      else {
        for (G += 3 * K, D -= 3 * K, se = 0; se < K; ++se) {
          var ge = x[R + 0] | x[R + 1] << 8 | x[R + 2] << 16;
          ge > D && (ge = D), X(d.Jc[+se], x, G, ge), G += ge, D -= ge, R += 3;
        }
        X(d.Jc[+K], x, G, D), x = G < B ? 0 : 5;
      }
      if (x != 0)
        return Ri(d, x, "cannot parse partitions");
      for (x = W(G = d.m, 7), R = fe(G) ? q(G, 4) : 0, B = fe(G) ? q(G, 4) : 0, D = fe(G) ? q(G, 4) : 0, K = fe(G) ? q(G, 4) : 0, G = fe(G) ? q(G, 4) : 0, se = d.Qa, ge = 0; 4 > ge; ++ge) {
        if (se.Cb) {
          var pe = se.Zb[ge];
          se.Fb || (pe += x);
        } else {
          if (0 < ge) {
            d.pb[ge] = d.pb[0];
            continue;
          }
          pe = x;
        }
        var ce = d.pb[ge];
        ce.Sc[0] = v1[Bs(pe + R, 127)], ce.Sc[1] = y1[Bs(pe + 0, 127)], ce.Eb[0] = 2 * v1[Bs(pe + B, 127)], ce.Eb[1] = 101581 * y1[Bs(pe + D, 127)] >> 16, 8 > ce.Eb[1] && (ce.Eb[1] = 8), ce.Qc[0] = v1[Bs(pe + K, 117)], ce.Qc[1] = y1[Bs(pe + G, 127)], ce.lc = pe + G;
      }
      if (!U.Rb)
        return Ri(d, 4, "Not a key frame.");
      for (fe(O), U = d.Pa, x = 0; 4 > x; ++x) {
        for (R = 0; 8 > R; ++R)
          for (B = 0; 3 > B; ++B)
            for (D = 0; 11 > D; ++D)
              K = ee(O, KU[x][R][B][D]) ? W(O, 8) : $U[x][R][B][D], U.Wc[x][R].Yb[B][D] = K;
        for (R = 0; 17 > R; ++R)
          U.Xc[x][R] = U.Wc[x][jU[R]];
      }
      return d.kc = fe(O), d.kc && (d.Bd = W(O, 8)), d.cb = 1;
    }
    function $g(d, m, x, B, R, O, U) {
      var D = m[R].Yb[x];
      for (x = 0; 16 > R; ++R) {
        if (!ee(d, D[x + 0]))
          return R;
        for (; !ee(d, D[x + 1]); )
          if (D = m[++R].Yb[0], x = 0, R == 16)
            return 16;
        var G = m[R + 1].Yb;
        if (ee(d, D[x + 2])) {
          var K = d, se = 0;
          if (ee(K, (pe = D)[(ge = x) + 3]))
            if (ee(K, pe[ge + 6])) {
              for (D = 0, ge = 2 * (se = ee(K, pe[ge + 8])) + (pe = ee(K, pe[ge + 9 + se])), se = 0, pe = HU[ge]; pe[D]; ++D)
                se += se + ee(K, pe[D]);
              se += 3 + (8 << ge);
            } else
              ee(K, pe[ge + 7]) ? (se = 7 + 2 * ee(K, 165), se += ee(K, 145)) : se = 5 + ee(K, 159);
          else
            se = ee(K, pe[ge + 4]) ? 3 + ee(K, pe[ge + 5]) : 2;
          D = G[2];
        } else
          se = 1, D = G[1];
        G = U + GU[R], 0 > (K = d).b && ue(K);
        var ge, pe = K.b, ce = (ge = K.Ca >> 1) - (K.I >> pe) >> 31;
        --K.b, K.Ca += ce, K.Ca |= 1, K.I -= (ge + 1 & ce) << pe, O[G] = ((se ^ ce) - ce) * B[(0 < R) + 0];
      }
      return 16;
    }
    function qu(d) {
      var m = d.rb[d.sb - 1];
      m.la = 0, m.Na = 0, n(d.zc, 0, 0, d.zc.length), d.ja = 0;
    }
    function jy(d, m) {
      if (d == null)
        return 0;
      if (m == null)
        return Ri(d, 2, "NULL VP8Io parameter in VP8Decode().");
      if (!d.cb && !Gg(d, m))
        return 0;
      if (e(d.cb), m.ac == null || m.ac(m)) {
        m.ob && (d.L = 0);
        var x = dp[d.L];
        if (d.L == 2 ? (d.yb = 0, d.zb = 0) : (d.yb = m.v - x >> 4, d.zb = m.j - x >> 4, 0 > d.yb && (d.yb = 0), 0 > d.zb && (d.zb = 0)), d.Va = m.o + 15 + x >> 4, d.Hb = m.va + 15 + x >> 4, d.Hb > d.za && (d.Hb = d.za), d.Va > d.Ub && (d.Va = d.Ub), 0 < d.L) {
          var B = d.ed;
          for (x = 0; 4 > x; ++x) {
            var R;
            if (d.Qa.Cb) {
              var O = d.Qa.Lb[x];
              d.Qa.Fb || (O += B.Tb);
            } else
              O = B.Tb;
            for (R = 0; 1 >= R; ++R) {
              var U = d.gd[x][R], D = O;
              if (B.Pc && (D += B.vd[0], R && (D += B.od[0])), 0 < (D = 0 > D ? 0 : 63 < D ? 63 : D)) {
                var G = D;
                0 < B.wb && (G = 4 < B.wb ? G >> 2 : G >> 1) > 9 - B.wb && (G = 9 - B.wb), 1 > G && (G = 1), U.dd = G, U.tc = 2 * D + G, U.ld = 40 <= D ? 2 : 15 <= D ? 1 : 0;
              } else
                U.tc = 0;
              U.La = R;
            }
          }
        }
        x = 0;
      } else
        Ri(d, 6, "Frame setup failed"), x = d.a;
      if (x = x == 0) {
        if (x) {
          d.$c = 0, 0 < d.Aa || (d.Ic = sQ);
          e: {
            x = d.Ic, B = 4 * (G = d.za);
            var K = 32 * G, se = G + 1, ge = 0 < d.L ? G * (0 < d.Aa ? 2 : 1) : 0, pe = (d.Aa == 2 ? 2 : 1) * G;
            if ((U = B + 832 + (R = 3 * (16 * x + dp[d.L]) / 2 * K) + (O = d.Fa != null && 0 < d.Fa.length ? d.Kc.c * d.Kc.i : 0)) != U)
              x = 0;
            else {
              if (U > d.Vb) {
                if (d.Vb = 0, d.Ec = s(U), d.Fc = 0, d.Ec == null) {
                  x = Ri(d, 1, "no memory during frame initialization.");
                  break e;
                }
                d.Vb = U;
              }
              U = d.Ec, D = d.Fc, d.Ac = U, d.Bc = D, D += B, d.Gd = a(K, kg), d.Hd = 0, d.rb = a(se + 1, Dg), d.sb = 1, d.wa = ge ? a(ge, Nh) : null, d.Y = 0, d.D.Nb = 0, d.D.wa = d.wa, d.D.Y = d.Y, 0 < d.Aa && (d.D.Y += G), e(!0), d.oc = U, d.pc = D, D += 832, d.ya = a(pe, Yu), d.aa = 0, d.D.ya = d.ya, d.D.aa = d.aa, d.Aa == 2 && (d.D.aa += G), d.R = 16 * G, d.B = 8 * G, G = (K = dp[d.L]) * d.R, K = K / 2 * d.B, d.sa = U, d.ta = D + G, d.qa = d.sa, d.ra = d.ta + 16 * x * d.R + K, d.Ha = d.qa, d.Ia = d.ra + 8 * x * d.B + K, d.$c = 0, D += R, d.mb = O ? U : null, d.nb = O ? D : null, e(D + O <= d.Fc + d.Vb), qu(d), n(d.Ac, d.Bc, 0, B), x = 1;
            }
          }
          if (x) {
            if (m.ka = 0, m.y = d.sa, m.O = d.ta, m.f = d.qa, m.N = d.ra, m.ea = d.Ha, m.Vd = d.Ia, m.fa = d.R, m.Rc = d.B, m.F = null, m.J = 0, !Vb) {
              for (x = -255; 255 >= x; ++x)
                kb[255 + x] = 0 > x ? -x : x;
              for (x = -1020; 1020 >= x; ++x)
                Hb[1020 + x] = -128 > x ? -128 : 127 < x ? 127 : x;
              for (x = -112; 112 >= x; ++x)
                Gb[112 + x] = -16 > x ? -16 : 15 < x ? 15 : x;
              for (x = -255; 510 >= x; ++x)
                $b[255 + x] = 0 > x ? 0 : 255 < x ? 255 : x;
              Vb = 1;
            }
            la = Wy, Yh = zy, vA = Kg, ha = Xy, mo = jg, vf = Vg, Tl = nf, qh = bl, Fl = A1, yA = sf, yf = o1, Hs = Hh, vo = af, qr = tp, Zr = ep, Mi = fo, sn = fA, yo = a1, ca[0] = Ia, ca[1] = Yy, ca[2] = e1, ca[3] = t1, ca[4] = Wg, ca[5] = Dh, ca[6] = Yg, ca[7] = ef, ca[8] = i1, ca[9] = r1, wA[0] = zg, wA[1] = Zy, wA[2] = uo, wA[3] = Uh, wA[4] = Pn, wA[5] = Jy, wA[6] = Xg, _o[0] = uA, _o[1] = qy, _o[2] = n1, _o[3] = tf, _o[4] = Bl, _o[5] = s1, _o[6] = rf, x = 1;
          } else
            x = 0;
        }
        x && (x = function(ce, be) {
          for (ce.M = 0; ce.M < ce.Va; ++ce.M) {
            var ye, Ae = ce.Jc[ce.M & ce.Xb], le = ce.m, Ce = ce;
            for (ye = 0; ye < Ce.za; ++ye) {
              var Te = le, Be = Ce, et = Be.Ac, $e = Be.Bc + 4 * ye, Bt = Be.zc, je = Be.ya[Be.aa + ye];
              if (Be.Qa.Bb ? je.$b = ee(Te, Be.Pa.jb[0]) ? 2 + ee(Te, Be.Pa.jb[2]) : ee(Te, Be.Pa.jb[1]) : je.$b = 0, Be.kc && (je.Ad = ee(Te, Be.Bd)), je.Za = !ee(Te, 145) + 0, je.Za) {
                var br = je.Ob, kr = 0;
                for (Be = 0; 4 > Be; ++Be) {
                  var wr, lr = Bt[0 + Be];
                  for (wr = 0; 4 > wr; ++wr) {
                    lr = VU[et[$e + wr]][lr];
                    for (var Wr = Xb[ee(Te, lr[0])]; 0 < Wr; )
                      Wr = Xb[2 * Wr + ee(Te, lr[Wr])];
                    lr = -Wr, et[$e + wr] = lr;
                  }
                  r(br, kr, et, $e, 4), kr += 4, Bt[0 + Be] = lr;
                }
              } else
                lr = ee(Te, 156) ? ee(Te, 128) ? 1 : 3 : ee(Te, 163) ? 2 : 0, je.Ob[0] = lr, n(et, $e, lr, 4), n(Bt, 0, lr, 4);
              je.Dd = ee(Te, 142) ? ee(Te, 114) ? ee(Te, 183) ? 1 : 3 : 2 : 0;
            }
            if (Ce.m.Ka)
              return Ri(ce, 7, "Premature end-of-partition0 encountered.");
            for (; ce.ja < ce.za; ++ce.ja) {
              if (Ce = Ae, Te = (le = ce).rb[le.sb - 1], et = le.rb[le.sb + le.ja], ye = le.ya[le.aa + le.ja], $e = le.kc ? ye.Ad : 0)
                Te.la = et.la = 0, ye.Za || (Te.Na = et.Na = 0), ye.Hc = 0, ye.Gc = 0, ye.ia = 0;
              else {
                var Vr, jt;
                if (Te = et, et = Ce, $e = le.Pa.Xc, Bt = le.ya[le.aa + le.ja], je = le.pb[Bt.$b], Be = Bt.ad, br = 0, kr = le.rb[le.sb - 1], lr = wr = 0, n(Be, br, 0, 384), Bt.Za)
                  var Vi = 0, ls = $e[3];
                else {
                  Wr = s(16);
                  var Ki = Te.Na + kr.Na;
                  if (Ki = _f(et, $e[1], Ki, je.Eb, 0, Wr, 0), Te.Na = kr.Na = (0 < Ki) + 0, 1 < Ki)
                    la(Wr, 0, Be, br);
                  else {
                    var hs = Wr[0] + 3 >> 3;
                    for (Wr = 0; 256 > Wr; Wr += 16)
                      Be[br + Wr] = hs;
                  }
                  Vi = 1, ls = $e[0];
                }
                var Hr = 15 & Te.la, Ss = 15 & kr.la;
                for (Wr = 0; 4 > Wr; ++Wr) {
                  var Ts = 1 & Ss;
                  for (hs = jt = 0; 4 > hs; ++hs)
                    Hr = Hr >> 1 | (Ts = (Ki = _f(et, ls, Ki = Ts + (1 & Hr), je.Sc, Vi, Be, br)) > Vi) << 7, jt = jt << 2 | (3 < Ki ? 3 : 1 < Ki ? 2 : Be[br + 0] != 0), br += 16;
                  Hr >>= 4, Ss = Ss >> 1 | Ts << 7, wr = (wr << 8 | jt) >>> 0;
                }
                for (ls = Hr, Vi = Ss >> 4, Vr = 0; 4 > Vr; Vr += 2) {
                  for (jt = 0, Hr = Te.la >> 4 + Vr, Ss = kr.la >> 4 + Vr, Wr = 0; 2 > Wr; ++Wr) {
                    for (Ts = 1 & Ss, hs = 0; 2 > hs; ++hs)
                      Ki = Ts + (1 & Hr), Hr = Hr >> 1 | (Ts = 0 < (Ki = _f(et, $e[2], Ki, je.Qc, 0, Be, br))) << 3, jt = jt << 2 | (3 < Ki ? 3 : 1 < Ki ? 2 : Be[br + 0] != 0), br += 16;
                    Hr >>= 2, Ss = Ss >> 1 | Ts << 5;
                  }
                  lr |= jt << 4 * Vr, ls |= Hr << 4 << Vr, Vi |= (240 & Ss) << Vr;
                }
                Te.la = ls, kr.la = Vi, Bt.Hc = wr, Bt.Gc = lr, Bt.ia = 43690 & lr ? 0 : je.ia, $e = !(wr | lr);
              }
              if (0 < le.L && (le.wa[le.Y + le.ja] = le.gd[ye.$b][ye.Za], le.wa[le.Y + le.ja].La |= !$e), Ce.Ka)
                return Ri(ce, 7, "Premature end-of-file encountered.");
            }
            if (qu(ce), le = be, Ce = 1, ye = (Ae = ce).D, Te = 0 < Ae.L && Ae.M >= Ae.zb && Ae.M <= Ae.Va, Ae.Aa == 0)
              e: {
                if (ye.M = Ae.M, ye.uc = Te, uf(Ae, ye), Ce = 1, ye = (jt = Ae.D).Nb, Te = (lr = dp[Ae.L]) * Ae.R, et = lr / 2 * Ae.B, Wr = 16 * ye * Ae.R, hs = 8 * ye * Ae.B, $e = Ae.sa, Bt = Ae.ta - Te + Wr, je = Ae.qa, Be = Ae.ra - et + hs, br = Ae.Ha, kr = Ae.Ia - et + hs, Ss = (Hr = jt.M) == 0, wr = Hr >= Ae.Va - 1, Ae.Aa == 2 && uf(Ae, jt), jt.uc)
                  for (Ts = (Ki = Ae).D.M, e(Ki.D.uc), jt = Ki.yb; jt < Ki.Hb; ++jt) {
                    Vi = jt, ls = Ts;
                    var gn = (bn = (Bi = Ki).D).Nb;
                    Vr = Bi.R;
                    var bn = bn.wa[bn.Y + Vi], qn = Bi.sa, Vs = Bi.ta + 16 * gn * Vr + 16 * Vi, Ma = bn.dd, pn = bn.tc;
                    if (pn != 0)
                      if (e(3 <= pn), Bi.L == 1)
                        0 < Vi && Mi(qn, Vs, Vr, pn + 4), bn.La && yo(qn, Vs, Vr, pn), 0 < ls && Zr(qn, Vs, Vr, pn + 4), bn.La && sn(qn, Vs, Vr, pn);
                      else {
                        var wo = Bi.B, Ll = Bi.qa, Jh = Bi.ra + 8 * gn * wo + 8 * Vi, CA = Bi.Ha, Bi = Bi.Ia + 8 * gn * wo + 8 * Vi;
                        gn = bn.ld, 0 < Vi && (qh(qn, Vs, Vr, pn + 4, Ma, gn), yA(Ll, Jh, CA, Bi, wo, pn + 4, Ma, gn)), bn.La && (Hs(qn, Vs, Vr, pn, Ma, gn), qr(Ll, Jh, CA, Bi, wo, pn, Ma, gn)), 0 < ls && (Tl(qn, Vs, Vr, pn + 4, Ma, gn), Fl(Ll, Jh, CA, Bi, wo, pn + 4, Ma, gn)), bn.La && (yf(qn, Vs, Vr, pn, Ma, gn), vo(Ll, Jh, CA, Bi, wo, pn, Ma, gn));
                      }
                  }
                if (Ae.ia && alert("todo:DitherRow"), le.put != null) {
                  if (jt = 16 * Hr, Hr = 16 * (Hr + 1), Ss ? (le.y = Ae.sa, le.O = Ae.ta + Wr, le.f = Ae.qa, le.N = Ae.ra + hs, le.ea = Ae.Ha, le.W = Ae.Ia + hs) : (jt -= lr, le.y = $e, le.O = Bt, le.f = je, le.N = Be, le.ea = br, le.W = kr), wr || (Hr -= lr), Hr > le.o && (Hr = le.o), le.F = null, le.J = null, Ae.Fa != null && 0 < Ae.Fa.length && jt < Hr && (le.J = hf(Ae, le, jt, Hr - jt), le.F = Ae.mb, le.F == null && le.F.length == 0)) {
                    Ce = Ri(Ae, 3, "Could not decode alpha data.");
                    break e;
                  }
                  jt < le.j && (lr = le.j - jt, jt = le.j, e(!(1 & lr)), le.O += Ae.R * lr, le.N += Ae.B * (lr >> 1), le.W += Ae.B * (lr >> 1), le.F != null && (le.J += le.width * lr)), jt < Hr && (le.O += le.v, le.N += le.v >> 1, le.W += le.v >> 1, le.F != null && (le.J += le.v), le.ka = jt - le.j, le.U = le.va - le.v, le.T = Hr - jt, Ce = le.put(le));
                }
                ye + 1 != Ae.Ic || wr || (r(Ae.sa, Ae.ta - Te, $e, Bt + 16 * Ae.R, Te), r(Ae.qa, Ae.ra - et, je, Be + 8 * Ae.B, et), r(Ae.Ha, Ae.Ia - et, br, kr + 8 * Ae.B, et));
              }
            if (!Ce)
              return Ri(ce, 6, "Output aborted.");
          }
          return 1;
        }(d, m)), m.bc != null && m.bc(m), x &= 1;
      }
      return x ? (d.cb = 0, x) : 0;
    }
    function na(d, m, x, B, R) {
      R = d[m + x + 32 * B] + (R >> 3), d[m + x + 32 * B] = -256 & R ? 0 > R ? 0 : 255 : R;
    }
    function Oh(d, m, x, B, R, O) {
      na(d, m, 0, x, B + R), na(d, m, 1, x, B + O), na(d, m, 2, x, B - O), na(d, m, 3, x, B - R);
    }
    function as(d) {
      return (20091 * d >> 16) + d;
    }
    function Zu(d, m, x, B) {
      var R, O = 0, U = s(16);
      for (R = 0; 4 > R; ++R) {
        var D = d[m + 0] + d[m + 8], G = d[m + 0] - d[m + 8], K = (35468 * d[m + 4] >> 16) - as(d[m + 12]), se = as(d[m + 4]) + (35468 * d[m + 12] >> 16);
        U[O + 0] = D + se, U[O + 1] = G + K, U[O + 2] = G - K, U[O + 3] = D - se, O += 4, m++;
      }
      for (R = O = 0; 4 > R; ++R)
        D = (d = U[O + 0] + 4) + U[O + 8], G = d - U[O + 8], K = (35468 * U[O + 4] >> 16) - as(U[O + 12]), na(x, B, 0, 0, D + (se = as(U[O + 4]) + (35468 * U[O + 12] >> 16))), na(x, B, 1, 0, G + K), na(x, B, 2, 0, G - K), na(x, B, 3, 0, D - se), O++, B += 32;
    }
    function Vg(d, m, x, B) {
      var R = d[m + 0] + 4, O = 35468 * d[m + 4] >> 16, U = as(d[m + 4]), D = 35468 * d[m + 1] >> 16;
      Oh(x, B, 0, R + U, d = as(d[m + 1]), D), Oh(x, B, 1, R + O, d, D), Oh(x, B, 2, R - O, d, D), Oh(x, B, 3, R - U, d, D);
    }
    function zy(d, m, x, B, R) {
      Zu(d, m, x, B), R && Zu(d, m + 16, x, B + 4);
    }
    function Kg(d, m, x, B) {
      Yh(d, m + 0, x, B, 1), Yh(d, m + 32, x, B + 128, 1);
    }
    function Xy(d, m, x, B) {
      var R;
      for (d = d[m + 0] + 4, R = 0; 4 > R; ++R)
        for (m = 0; 4 > m; ++m)
          na(x, B, m, R, d);
    }
    function jg(d, m, x, B) {
      d[m + 0] && ha(d, m + 0, x, B), d[m + 16] && ha(d, m + 16, x, B + 4), d[m + 32] && ha(d, m + 32, x, B + 128), d[m + 48] && ha(d, m + 48, x, B + 128 + 4);
    }
    function Wy(d, m, x, B) {
      var R, O = s(16);
      for (R = 0; 4 > R; ++R) {
        var U = d[m + 0 + R] + d[m + 12 + R], D = d[m + 4 + R] + d[m + 8 + R], G = d[m + 4 + R] - d[m + 8 + R], K = d[m + 0 + R] - d[m + 12 + R];
        O[0 + R] = U + D, O[8 + R] = U - D, O[4 + R] = K + G, O[12 + R] = K - G;
      }
      for (R = 0; 4 > R; ++R)
        U = (d = O[0 + 4 * R] + 3) + O[3 + 4 * R], D = O[1 + 4 * R] + O[2 + 4 * R], G = O[1 + 4 * R] - O[2 + 4 * R], K = d - O[3 + 4 * R], x[B + 0] = U + D >> 3, x[B + 16] = K + G >> 3, x[B + 32] = U - D >> 3, x[B + 48] = K - G >> 3, B += 64;
    }
    function Ju(d, m, x) {
      var B, R = m - 32, O = bs, U = 255 - d[R - 1];
      for (B = 0; B < x; ++B) {
        var D, G = O, K = U + d[m - 1];
        for (D = 0; D < x; ++D)
          d[m + D] = G[K + d[R + D]];
        m += 32;
      }
    }
    function Yy(d, m) {
      Ju(d, m, 4);
    }
    function qy(d, m) {
      Ju(d, m, 8);
    }
    function Zy(d, m) {
      Ju(d, m, 16);
    }
    function uo(d, m) {
      var x;
      for (x = 0; 16 > x; ++x)
        r(d, m + 32 * x, d, m - 32, 16);
    }
    function Uh(d, m) {
      var x;
      for (x = 16; 0 < x; --x)
        n(d, m, d[m - 1], 16), m += 32;
    }
    function Qh(d, m, x) {
      var B;
      for (B = 0; 16 > B; ++B)
        n(m, x + 32 * B, d, 16);
    }
    function zg(d, m) {
      var x, B = 16;
      for (x = 0; 16 > x; ++x)
        B += d[m - 1 + 32 * x] + d[m + x - 32];
      Qh(B >> 5, d, m);
    }
    function Pn(d, m) {
      var x, B = 8;
      for (x = 0; 16 > x; ++x)
        B += d[m - 1 + 32 * x];
      Qh(B >> 4, d, m);
    }
    function Jy(d, m) {
      var x, B = 8;
      for (x = 0; 16 > x; ++x)
        B += d[m + x - 32];
      Qh(B >> 4, d, m);
    }
    function Xg(d, m) {
      Qh(128, d, m);
    }
    function Qt(d, m, x) {
      return d + 2 * m + x + 2 >> 2;
    }
    function e1(d, m) {
      var x, B = m - 32;
      for (B = new Uint8Array([Qt(d[B - 1], d[B + 0], d[B + 1]), Qt(d[B + 0], d[B + 1], d[B + 2]), Qt(d[B + 1], d[B + 2], d[B + 3]), Qt(d[B + 2], d[B + 3], d[B + 4])]), x = 0; 4 > x; ++x)
        r(d, m + 32 * x, B, 0, B.length);
    }
    function t1(d, m) {
      var x = d[m - 1], B = d[m - 1 + 32], R = d[m - 1 + 64], O = d[m - 1 + 96];
      xe(d, m + 0, 16843009 * Qt(d[m - 1 - 32], x, B)), xe(d, m + 32, 16843009 * Qt(x, B, R)), xe(d, m + 64, 16843009 * Qt(B, R, O)), xe(d, m + 96, 16843009 * Qt(R, O, O));
    }
    function Ia(d, m) {
      var x, B = 4;
      for (x = 0; 4 > x; ++x)
        B += d[m + x - 32] + d[m - 1 + 32 * x];
      for (B >>= 3, x = 0; 4 > x; ++x)
        n(d, m + 32 * x, B, 4);
    }
    function Wg(d, m) {
      var x = d[m - 1 + 0], B = d[m - 1 + 32], R = d[m - 1 + 64], O = d[m - 1 - 32], U = d[m + 0 - 32], D = d[m + 1 - 32], G = d[m + 2 - 32], K = d[m + 3 - 32];
      d[m + 0 + 96] = Qt(B, R, d[m - 1 + 96]), d[m + 1 + 96] = d[m + 0 + 64] = Qt(x, B, R), d[m + 2 + 96] = d[m + 1 + 64] = d[m + 0 + 32] = Qt(O, x, B), d[m + 3 + 96] = d[m + 2 + 64] = d[m + 1 + 32] = d[m + 0 + 0] = Qt(U, O, x), d[m + 3 + 64] = d[m + 2 + 32] = d[m + 1 + 0] = Qt(D, U, O), d[m + 3 + 32] = d[m + 2 + 0] = Qt(G, D, U), d[m + 3 + 0] = Qt(K, G, D);
    }
    function Yg(d, m) {
      var x = d[m + 1 - 32], B = d[m + 2 - 32], R = d[m + 3 - 32], O = d[m + 4 - 32], U = d[m + 5 - 32], D = d[m + 6 - 32], G = d[m + 7 - 32];
      d[m + 0 + 0] = Qt(d[m + 0 - 32], x, B), d[m + 1 + 0] = d[m + 0 + 32] = Qt(x, B, R), d[m + 2 + 0] = d[m + 1 + 32] = d[m + 0 + 64] = Qt(B, R, O), d[m + 3 + 0] = d[m + 2 + 32] = d[m + 1 + 64] = d[m + 0 + 96] = Qt(R, O, U), d[m + 3 + 32] = d[m + 2 + 64] = d[m + 1 + 96] = Qt(O, U, D), d[m + 3 + 64] = d[m + 2 + 96] = Qt(U, D, G), d[m + 3 + 96] = Qt(D, G, G);
    }
    function Dh(d, m) {
      var x = d[m - 1 + 0], B = d[m - 1 + 32], R = d[m - 1 + 64], O = d[m - 1 - 32], U = d[m + 0 - 32], D = d[m + 1 - 32], G = d[m + 2 - 32], K = d[m + 3 - 32];
      d[m + 0 + 0] = d[m + 1 + 64] = O + U + 1 >> 1, d[m + 1 + 0] = d[m + 2 + 64] = U + D + 1 >> 1, d[m + 2 + 0] = d[m + 3 + 64] = D + G + 1 >> 1, d[m + 3 + 0] = G + K + 1 >> 1, d[m + 0 + 96] = Qt(R, B, x), d[m + 0 + 64] = Qt(B, x, O), d[m + 0 + 32] = d[m + 1 + 96] = Qt(x, O, U), d[m + 1 + 32] = d[m + 2 + 96] = Qt(O, U, D), d[m + 2 + 32] = d[m + 3 + 96] = Qt(U, D, G), d[m + 3 + 32] = Qt(D, G, K);
    }
    function ef(d, m) {
      var x = d[m + 0 - 32], B = d[m + 1 - 32], R = d[m + 2 - 32], O = d[m + 3 - 32], U = d[m + 4 - 32], D = d[m + 5 - 32], G = d[m + 6 - 32], K = d[m + 7 - 32];
      d[m + 0 + 0] = x + B + 1 >> 1, d[m + 1 + 0] = d[m + 0 + 64] = B + R + 1 >> 1, d[m + 2 + 0] = d[m + 1 + 64] = R + O + 1 >> 1, d[m + 3 + 0] = d[m + 2 + 64] = O + U + 1 >> 1, d[m + 0 + 32] = Qt(x, B, R), d[m + 1 + 32] = d[m + 0 + 96] = Qt(B, R, O), d[m + 2 + 32] = d[m + 1 + 96] = Qt(R, O, U), d[m + 3 + 32] = d[m + 2 + 96] = Qt(O, U, D), d[m + 3 + 64] = Qt(U, D, G), d[m + 3 + 96] = Qt(D, G, K);
    }
    function r1(d, m) {
      var x = d[m - 1 + 0], B = d[m - 1 + 32], R = d[m - 1 + 64], O = d[m - 1 + 96];
      d[m + 0 + 0] = x + B + 1 >> 1, d[m + 2 + 0] = d[m + 0 + 32] = B + R + 1 >> 1, d[m + 2 + 32] = d[m + 0 + 64] = R + O + 1 >> 1, d[m + 1 + 0] = Qt(x, B, R), d[m + 3 + 0] = d[m + 1 + 32] = Qt(B, R, O), d[m + 3 + 32] = d[m + 1 + 64] = Qt(R, O, O), d[m + 3 + 64] = d[m + 2 + 64] = d[m + 0 + 96] = d[m + 1 + 96] = d[m + 2 + 96] = d[m + 3 + 96] = O;
    }
    function i1(d, m) {
      var x = d[m - 1 + 0], B = d[m - 1 + 32], R = d[m - 1 + 64], O = d[m - 1 + 96], U = d[m - 1 - 32], D = d[m + 0 - 32], G = d[m + 1 - 32], K = d[m + 2 - 32];
      d[m + 0 + 0] = d[m + 2 + 32] = x + U + 1 >> 1, d[m + 0 + 32] = d[m + 2 + 64] = B + x + 1 >> 1, d[m + 0 + 64] = d[m + 2 + 96] = R + B + 1 >> 1, d[m + 0 + 96] = O + R + 1 >> 1, d[m + 3 + 0] = Qt(D, G, K), d[m + 2 + 0] = Qt(U, D, G), d[m + 1 + 0] = d[m + 3 + 32] = Qt(x, U, D), d[m + 1 + 32] = d[m + 3 + 64] = Qt(B, x, U), d[m + 1 + 64] = d[m + 3 + 96] = Qt(R, B, x), d[m + 1 + 96] = Qt(O, R, B);
    }
    function n1(d, m) {
      var x;
      for (x = 0; 8 > x; ++x)
        r(d, m + 32 * x, d, m - 32, 8);
    }
    function tf(d, m) {
      var x;
      for (x = 0; 8 > x; ++x)
        n(d, m, d[m - 1], 8), m += 32;
    }
    function El(d, m, x) {
      var B;
      for (B = 0; 8 > B; ++B)
        n(m, x + 32 * B, d, 8);
    }
    function uA(d, m) {
      var x, B = 8;
      for (x = 0; 8 > x; ++x)
        B += d[m + x - 32] + d[m - 1 + 32 * x];
      El(B >> 4, d, m);
    }
    function s1(d, m) {
      var x, B = 4;
      for (x = 0; 8 > x; ++x)
        B += d[m + x - 32];
      El(B >> 3, d, m);
    }
    function Bl(d, m) {
      var x, B = 4;
      for (x = 0; 8 > x; ++x)
        B += d[m - 1 + 32 * x];
      El(B >> 3, d, m);
    }
    function rf(d, m) {
      El(128, d, m);
    }
    function kh(d, m, x) {
      var B = d[m - x], R = d[m + 0], O = 3 * (R - B) + f1[1020 + d[m - 2 * x] - d[m + x]], U = ap[112 + (O + 4 >> 3)];
      d[m - x] = bs[255 + B + ap[112 + (O + 3 >> 3)]], d[m + 0] = bs[255 + R - U];
    }
    function qg(d, m, x, B) {
      var R = d[m + 0], O = d[m + x];
      return Gs[255 + d[m - 2 * x] - d[m - x]] > B || Gs[255 + O - R] > B;
    }
    function Zg(d, m, x, B) {
      return 4 * Gs[255 + d[m - x] - d[m + 0]] + Gs[255 + d[m - 2 * x] - d[m + x]] <= B;
    }
    function Jg(d, m, x, B, R) {
      var O = d[m - 3 * x], U = d[m - 2 * x], D = d[m - x], G = d[m + 0], K = d[m + x], se = d[m + 2 * x], ge = d[m + 3 * x];
      return 4 * Gs[255 + D - G] + Gs[255 + U - K] > B ? 0 : Gs[255 + d[m - 4 * x] - O] <= R && Gs[255 + O - U] <= R && Gs[255 + U - D] <= R && Gs[255 + ge - se] <= R && Gs[255 + se - K] <= R && Gs[255 + K - G] <= R;
    }
    function ep(d, m, x, B) {
      var R = 2 * B + 1;
      for (B = 0; 16 > B; ++B)
        Zg(d, m + B, x, R) && kh(d, m + B, x);
    }
    function fo(d, m, x, B) {
      var R = 2 * B + 1;
      for (B = 0; 16 > B; ++B)
        Zg(d, m + B * x, 1, R) && kh(d, m + B * x, 1);
    }
    function fA(d, m, x, B) {
      var R;
      for (R = 3; 0 < R; --R)
        ep(d, m += 4 * x, x, B);
    }
    function a1(d, m, x, B) {
      var R;
      for (R = 3; 0 < R; --R)
        fo(d, m += 4, x, B);
    }
    function dA(d, m, x, B, R, O, U, D) {
      for (O = 2 * O + 1; 0 < R--; ) {
        if (Jg(d, m, x, O, U))
          if (qg(d, m, x, D))
            kh(d, m, x);
          else {
            var G = d, K = m, se = x, ge = G[K - 2 * se], pe = G[K - se], ce = G[K + 0], be = G[K + se], ye = G[K + 2 * se], Ae = 27 * (Ce = f1[1020 + 3 * (ce - pe) + f1[1020 + ge - be]]) + 63 >> 7, le = 18 * Ce + 63 >> 7, Ce = 9 * Ce + 63 >> 7;
            G[K - 3 * se] = bs[255 + G[K - 3 * se] + Ce], G[K - 2 * se] = bs[255 + ge + le], G[K - se] = bs[255 + pe + Ae], G[K + 0] = bs[255 + ce - Ae], G[K + se] = bs[255 + be - le], G[K + 2 * se] = bs[255 + ye - Ce];
          }
        m += B;
      }
    }
    function sa(d, m, x, B, R, O, U, D) {
      for (O = 2 * O + 1; 0 < R--; ) {
        if (Jg(d, m, x, O, U))
          if (qg(d, m, x, D))
            kh(d, m, x);
          else {
            var G = d, K = m, se = x, ge = G[K - se], pe = G[K + 0], ce = G[K + se], be = ap[112 + ((ye = 3 * (pe - ge)) + 4 >> 3)], ye = ap[112 + (ye + 3 >> 3)], Ae = be + 1 >> 1;
            G[K - 2 * se] = bs[255 + G[K - 2 * se] + Ae], G[K - se] = bs[255 + ge + ye], G[K + 0] = bs[255 + pe - be], G[K + se] = bs[255 + ce - Ae];
          }
        m += B;
      }
    }
    function nf(d, m, x, B, R, O) {
      dA(d, m, x, 1, 16, B, R, O);
    }
    function bl(d, m, x, B, R, O) {
      dA(d, m, 1, x, 16, B, R, O);
    }
    function o1(d, m, x, B, R, O) {
      var U;
      for (U = 3; 0 < U; --U)
        sa(d, m += 4 * x, x, 1, 16, B, R, O);
    }
    function Hh(d, m, x, B, R, O) {
      var U;
      for (U = 3; 0 < U; --U)
        sa(d, m += 4, 1, x, 16, B, R, O);
    }
    function A1(d, m, x, B, R, O, U, D) {
      dA(d, m, R, 1, 8, O, U, D), dA(x, B, R, 1, 8, O, U, D);
    }
    function sf(d, m, x, B, R, O, U, D) {
      dA(d, m, 1, R, 8, O, U, D), dA(x, B, 1, R, 8, O, U, D);
    }
    function af(d, m, x, B, R, O, U, D) {
      sa(d, m + 4 * R, R, 1, 8, O, U, D), sa(x, B + 4 * R, R, 1, 8, O, U, D);
    }
    function tp(d, m, x, B, R, O, U, D) {
      sa(d, m + 4, 1, R, 8, O, U, D), sa(x, B + 4, 1, R, 8, O, U, D);
    }
    function Gh() {
      this.ba = new Ai(), this.ec = [], this.cc = [], this.Mc = [], this.Dc = this.Nc = this.dc = this.fc = 0, this.Oa = new Lr(), this.memory = 0, this.Ib = "OutputFunc", this.Jb = "OutputAlphaFunc", this.Nd = "OutputRowFunc";
    }
    function of() {
      this.data = [], this.offset = this.kd = this.ha = this.w = 0, this.na = [], this.xa = this.gb = this.Ja = this.Sa = this.P = 0;
    }
    function Af() {
      this.nc = this.Ea = this.b = this.hc = 0, this.K = [], this.w = 0;
    }
    function rp() {
      this.ua = 0, this.Wa = new Y(), this.vb = new Y(), this.md = this.xc = this.wc = 0, this.vc = [], this.Wb = 0, this.Ya = new Q(), this.yc = new L();
    }
    function l1() {
      this.xb = this.a = 0, this.l = new Ph(), this.ca = new Ai(), this.V = [], this.Ba = 0, this.Ta = [], this.Ua = 0, this.m = new b(), this.Pb = 0, this.wd = new b(), this.Ma = this.$ = this.C = this.i = this.c = this.xd = 0, this.s = new rp(), this.ab = 0, this.gc = a(4, Af), this.Oc = 0;
    }
    function $h() {
      this.Lc = this.Z = this.$a = this.i = this.c = 0, this.l = new Ph(), this.ic = 0, this.ca = [], this.tb = 0, this.qd = null, this.rd = 0;
    }
    function Sl(d, m, x, B, R, O, U) {
      for (d = d == null ? 0 : d[m + 0], m = 0; m < U; ++m)
        R[O + m] = d + x[B + m] & 255, d = R[O + m];
    }
    function lf(d, m, x, B, R, O, U) {
      var D;
      if (d == null)
        Sl(null, null, x, B, R, O, U);
      else
        for (D = 0; D < U; ++D)
          R[O + D] = d[m + D] + x[B + D] & 255;
    }
    function gA(d, m, x, B, R, O, U) {
      if (d == null)
        Sl(null, null, x, B, R, O, U);
      else {
        var D, G = d[m + 0], K = G, se = G;
        for (D = 0; D < U; ++D)
          K = se + (G = d[m + D]) - K, se = x[B + D] + (-256 & K ? 0 > K ? 0 : 255 : K) & 255, K = G, R[O + D] = se;
      }
    }
    function hf(d, m, x, B) {
      var R = m.width, O = m.o;
      if (e(d != null && m != null), 0 > x || 0 >= B || x + B > O)
        return null;
      if (!d.Cc) {
        if (d.ga == null) {
          var U;
          if (d.ga = new $h(), (U = d.ga == null) || (U = m.width * m.o, e(d.Gb.length == 0), d.Gb = s(U), d.Uc = 0, d.Gb == null ? U = 0 : (d.mb = d.Gb, d.nb = d.Uc, d.rc = null, U = 1), U = !U), !U) {
            U = d.ga;
            var D = d.Fa, G = d.P, K = d.qc, se = d.mb, ge = d.nb, pe = G + 1, ce = K - 1, be = U.l;
            if (e(D != null && se != null && m != null), xA[0] = null, xA[1] = Sl, xA[2] = lf, xA[3] = gA, U.ca = se, U.tb = ge, U.c = m.width, U.i = m.height, e(0 < U.c && 0 < U.i), 1 >= K)
              m = 0;
            else if (U.$a = D[G + 0] >> 0 & 3, U.Z = D[G + 0] >> 2 & 3, U.Lc = D[G + 0] >> 4 & 3, G = D[G + 0] >> 6 & 3, 0 > U.$a || 1 < U.$a || 4 <= U.Z || 1 < U.Lc || G)
              m = 0;
            else if (be.put = di, be.ac = _r, be.bc = zr, be.ma = U, be.width = m.width, be.height = m.height, be.Da = m.Da, be.v = m.v, be.va = m.va, be.j = m.j, be.o = m.o, U.$a)
              e: {
                e(U.$a == 1), m = Dr();
                t:
                  for (; ; ) {
                    if (m == null) {
                      m = 0;
                      break e;
                    }
                    if (e(U != null), U.mc = m, m.c = U.c, m.i = U.i, m.l = U.l, m.l.ma = U, m.l.width = U.c, m.l.height = U.i, m.a = 0, Z(m.m, D, pe, ce), !Xr(U.c, U.i, 1, m, null) || (m.ab == 1 && m.gc[0].hc == 3 && nt(m.s) ? (U.ic = 1, D = m.c * m.i, m.Ta = null, m.Ua = 0, m.V = s(D), m.Ba = 0, m.V == null ? (m.a = 1, m = 0) : m = 1) : (U.ic = 0, m = si(m, U.c)), !m))
                      break t;
                    m = 1;
                    break e;
                  }
                U.mc = null, m = 0;
              }
            else
              m = ce >= U.c * U.i;
            U = !m;
          }
          if (U)
            return null;
          d.ga.Lc != 1 ? d.Ga = 0 : B = O - x;
        }
        e(d.ga != null), e(x + B <= O);
        e: {
          if (m = (D = d.ga).c, O = D.l.o, D.$a == 0) {
            if (pe = d.rc, ce = d.Vc, be = d.Fa, G = d.P + 1 + x * m, K = d.mb, se = d.nb + x * m, e(G <= d.P + d.qc), D.Z != 0)
              for (e(xA[D.Z] != null), U = 0; U < B; ++U)
                xA[D.Z](pe, ce, be, G, K, se, m), pe = K, ce = se, se += m, G += m;
            else
              for (U = 0; U < B; ++U)
                r(K, se, be, G, m), pe = K, ce = se, se += m, G += m;
            d.rc = pe, d.Vc = ce;
          } else {
            if (e(D.mc != null), m = x + B, e((U = D.mc) != null), e(m <= U.i), U.C >= m)
              m = 1;
            else if (D.ic || de(), D.ic) {
              D = U.V, pe = U.Ba, ce = U.c;
              var ye = U.i, Ae = (be = 1, G = U.$ / ce, K = U.$ % ce, se = U.m, ge = U.s, U.$), le = ce * ye, Ce = ce * m, Te = ge.wc, Be = Ae < Ce ? ni(ge, K, G) : null;
              e(Ae <= le), e(m <= ye), e(nt(ge));
              t:
                for (; ; ) {
                  for (; !se.h && Ae < Ce; ) {
                    if (K & Te || (Be = ni(ge, K, G)), e(Be != null), ie(se), 256 > (ye = Ir(Be.G[0], Be.H[0], se)))
                      D[pe + Ae] = ye, ++Ae, ++K >= ce && (K = 0, ++G <= m && !(G % 16) && Pe(U, G));
                    else {
                      if (!(280 > ye)) {
                        be = 0;
                        break t;
                      }
                      ye = Ci(ye - 256, se);
                      var et, $e = Ir(Be.G[4], Be.H[4], se);
                      if (ie(se), !(Ae >= ($e = fr(ce, $e = Ci($e, se))) && le - Ae >= ye)) {
                        be = 0;
                        break t;
                      }
                      for (et = 0; et < ye; ++et)
                        D[pe + Ae + et] = D[pe + Ae + et - $e];
                      for (Ae += ye, K += ye; K >= ce; )
                        K -= ce, ++G <= m && !(G % 16) && Pe(U, G);
                      Ae < Ce && K & Te && (Be = ni(ge, K, G));
                    }
                    e(se.h == V(se));
                  }
                  Pe(U, G > m ? m : G);
                  break t;
                }
              !be || se.h && Ae < le ? (be = 0, U.a = se.h ? 5 : 3) : U.$ = Ae, m = be;
            } else
              m = Ke(U, U.V, U.Ba, U.c, U.i, m, ia);
            if (!m) {
              B = 0;
              break e;
            }
          }
          x + B >= O && (d.Cc = 1), B = 1;
        }
        if (!B)
          return null;
        if (d.Cc && ((B = d.ga) != null && (B.mc = null), d.ga = null, 0 < d.Ga))
          return alert("todo:WebPDequantizeLevels"), null;
      }
      return d.nb + x * R;
    }
    function _(d, m, x, B, R, O) {
      for (; 0 < R--; ) {
        var U, D = d, G = m + (x ? 1 : 0), K = d, se = m + (x ? 0 : 3);
        for (U = 0; U < B; ++U) {
          var ge = K[se + 4 * U];
          ge != 255 && (ge *= 32897, D[G + 4 * U + 0] = D[G + 4 * U + 0] * ge >> 23, D[G + 4 * U + 1] = D[G + 4 * U + 1] * ge >> 23, D[G + 4 * U + 2] = D[G + 4 * U + 2] * ge >> 23);
        }
        m += O;
      }
    }
    function N(d, m, x, B, R) {
      for (; 0 < B--; ) {
        var O;
        for (O = 0; O < x; ++O) {
          var U = d[m + 2 * O + 0], D = 15 & (K = d[m + 2 * O + 1]), G = 4369 * D, K = (240 & K | K >> 4) * G >> 16;
          d[m + 2 * O + 0] = (240 & U | U >> 4) * G >> 16 & 240 | (15 & U | U << 4) * G >> 16 >> 4 & 15, d[m + 2 * O + 1] = 240 & K | D;
        }
        m += R;
      }
    }
    function z(d, m, x, B, R, O, U, D) {
      var G, K, se = 255;
      for (K = 0; K < R; ++K) {
        for (G = 0; G < B; ++G) {
          var ge = d[m + G];
          O[U + 4 * G] = ge, se &= ge;
        }
        m += x, U += D;
      }
      return se != 255;
    }
    function re(d, m, x, B, R) {
      var O;
      for (O = 0; O < R; ++O)
        x[B + O] = d[m + O] >> 8;
    }
    function de() {
      _A = _, Zh = N, sp = z, Db = re;
    }
    function _e(d, m, x) {
      F[d] = function(B, R, O, U, D, G, K, se, ge, pe, ce, be, ye, Ae, le, Ce, Te) {
        var Be, et = Te - 1 >> 1, $e = D[G + 0] | K[se + 0] << 16, Bt = ge[pe + 0] | ce[be + 0] << 16;
        e(B != null);
        var je = 3 * $e + Bt + 131074 >> 2;
        for (m(B[R + 0], 255 & je, je >> 16, ye, Ae), O != null && (je = 3 * Bt + $e + 131074 >> 2, m(O[U + 0], 255 & je, je >> 16, le, Ce)), Be = 1; Be <= et; ++Be) {
          var br = D[G + Be] | K[se + Be] << 16, kr = ge[pe + Be] | ce[be + Be] << 16, wr = $e + br + Bt + kr + 524296, lr = wr + 2 * (br + Bt) >> 3;
          je = lr + $e >> 1, $e = (wr = wr + 2 * ($e + kr) >> 3) + br >> 1, m(B[R + 2 * Be - 1], 255 & je, je >> 16, ye, Ae + (2 * Be - 1) * x), m(B[R + 2 * Be - 0], 255 & $e, $e >> 16, ye, Ae + (2 * Be - 0) * x), O != null && (je = wr + Bt >> 1, $e = lr + kr >> 1, m(O[U + 2 * Be - 1], 255 & je, je >> 16, le, Ce + (2 * Be - 1) * x), m(O[U + 2 * Be + 0], 255 & $e, $e >> 16, le, Ce + (2 * Be + 0) * x)), $e = br, Bt = kr;
        }
        1 & Te || (je = 3 * $e + Bt + 131074 >> 2, m(B[R + Te - 1], 255 & je, je >> 16, ye, Ae + (Te - 1) * x), O != null && (je = 3 * Bt + $e + 131074 >> 2, m(O[U + Te - 1], 255 & je, je >> 16, le, Ce + (Te - 1) * x)));
      };
    }
    function Oe() {
      $s[op] = XU, $s[Ap] = Yb, $s[Kb] = WU, $s[lp] = qb, $s[hp] = Zb, $s[d1] = Jb, $s[jb] = YU, $s[g1] = Yb, $s[p1] = qb, $s[cp] = Zb, $s[m1] = Jb;
    }
    function Je(d) {
      return d & ~qU ? 0 > d ? 0 : 255 : d >> eS;
    }
    function xt(d, m) {
      return Je((19077 * d >> 8) + (26149 * m >> 8) - 14234);
    }
    function Gt(d, m, x) {
      return Je((19077 * d >> 8) - (6419 * m >> 8) - (13320 * x >> 8) + 8708);
    }
    function Yt(d, m) {
      return Je((19077 * d >> 8) + (33050 * m >> 8) - 17685);
    }
    function vr(d, m, x, B, R) {
      B[R + 0] = xt(d, x), B[R + 1] = Gt(d, m, x), B[R + 2] = Yt(d, m);
    }
    function gi(d, m, x, B, R) {
      B[R + 0] = Yt(d, m), B[R + 1] = Gt(d, m, x), B[R + 2] = xt(d, x);
    }
    function Ei(d, m, x, B, R) {
      var O = Gt(d, m, x);
      m = O << 3 & 224 | Yt(d, m) >> 3, B[R + 0] = 248 & xt(d, x) | O >> 5, B[R + 1] = m;
    }
    function $i(d, m, x, B, R) {
      var O = 240 & Yt(d, m) | 15;
      B[R + 0] = 240 & xt(d, x) | Gt(d, m, x) >> 4, B[R + 1] = O;
    }
    function On(d, m, x, B, R) {
      B[R + 0] = 255, vr(d, m, x, B, R + 1);
    }
    function dn(d, m, x, B, R) {
      gi(d, m, x, B, R), B[R + 3] = 255;
    }
    function aa(d, m, x, B, R) {
      vr(d, m, x, B, R), B[R + 3] = 255;
    }
    function Bs(d, m) {
      return 0 > d ? 0 : d > m ? m : d;
    }
    function go(d, m, x) {
      F[d] = function(B, R, O, U, D, G, K, se, ge) {
        for (var pe = se + (-2 & ge) * x; se != pe; )
          m(B[R + 0], O[U + 0], D[G + 0], K, se), m(B[R + 1], O[U + 0], D[G + 0], K, se + x), R += 2, ++U, ++G, se += 2 * x;
        1 & ge && m(B[R + 0], O[U + 0], D[G + 0], K, se);
      };
    }
    function ip(d, m, x) {
      return x == 0 ? d == 0 ? m == 0 ? 6 : 5 : m == 0 ? 4 : 0 : x;
    }
    function cf(d, m, x, B, R) {
      switch (d >>> 30) {
        case 3:
          Yh(m, x, B, R, 0);
          break;
        case 2:
          vf(m, x, B, R);
          break;
        case 1:
          ha(m, x, B, R);
      }
    }
    function uf(d, m) {
      var x, B, R = m.M, O = m.Nb, U = d.oc, D = d.pc + 40, G = d.oc, K = d.pc + 584, se = d.oc, ge = d.pc + 600;
      for (x = 0; 16 > x; ++x)
        U[D + 32 * x - 1] = 129;
      for (x = 0; 8 > x; ++x)
        G[K + 32 * x - 1] = 129, se[ge + 32 * x - 1] = 129;
      for (0 < R ? U[D - 1 - 32] = G[K - 1 - 32] = se[ge - 1 - 32] = 129 : (n(U, D - 32 - 1, 127, 21), n(G, K - 32 - 1, 127, 9), n(se, ge - 32 - 1, 127, 9)), B = 0; B < d.za; ++B) {
        var pe = m.ya[m.aa + B];
        if (0 < B) {
          for (x = -1; 16 > x; ++x)
            r(U, D + 32 * x - 4, U, D + 32 * x + 12, 4);
          for (x = -1; 8 > x; ++x)
            r(G, K + 32 * x - 4, G, K + 32 * x + 4, 4), r(se, ge + 32 * x - 4, se, ge + 32 * x + 4, 4);
        }
        var ce = d.Gd, be = d.Hd + B, ye = pe.ad, Ae = pe.Hc;
        if (0 < R && (r(U, D - 32, ce[be].y, 0, 16), r(G, K - 32, ce[be].f, 0, 8), r(se, ge - 32, ce[be].ea, 0, 8)), pe.Za) {
          var le = U, Ce = D - 32 + 16;
          for (0 < R && (B >= d.za - 1 ? n(le, Ce, ce[be].y[15], 4) : r(le, Ce, ce[be + 1].y, 0, 4)), x = 0; 4 > x; x++)
            le[Ce + 128 + x] = le[Ce + 256 + x] = le[Ce + 384 + x] = le[Ce + 0 + x];
          for (x = 0; 16 > x; ++x, Ae <<= 2)
            le = U, Ce = D + rS[x], ca[pe.Ob[x]](le, Ce), cf(Ae, ye, 16 * +x, le, Ce);
        } else if (le = ip(B, R, pe.Ob[0]), wA[le](U, D), Ae != 0)
          for (x = 0; 16 > x; ++x, Ae <<= 2)
            cf(Ae, ye, 16 * +x, U, D + rS[x]);
        for (x = pe.Gc, le = ip(B, R, pe.Dd), _o[le](G, K), _o[le](se, ge), Ae = ye, le = G, Ce = K, 255 & (pe = x >> 0) && (170 & pe ? vA(Ae, 256, le, Ce) : mo(Ae, 256, le, Ce)), pe = se, Ae = ge, 255 & (x >>= 8) && (170 & x ? vA(ye, 320, pe, Ae) : mo(ye, 320, pe, Ae)), R < d.Ub - 1 && (r(ce[be].y, 0, U, D + 480, 16), r(ce[be].f, 0, G, K + 224, 8), r(ce[be].ea, 0, se, ge + 224, 8)), x = 8 * O * d.B, ce = d.sa, be = d.ta + 16 * B + 16 * O * d.R, ye = d.qa, pe = d.ra + 8 * B + x, Ae = d.Ha, le = d.Ia + 8 * B + x, x = 0; 16 > x; ++x)
          r(ce, be + x * d.R, U, D + 32 * x, 16);
        for (x = 0; 8 > x; ++x)
          r(ye, pe + x * d.B, G, K + 32 * x, 8), r(Ae, le + x * d.B, se, ge + 32 * x, 8);
      }
    }
    function Vh(d, m, x, B, R, O, U, D, G) {
      var K = [0], se = [0], ge = 0, pe = G != null ? G.kd : 0, ce = G ?? new of();
      if (d == null || 12 > x)
        return 7;
      ce.data = d, ce.w = m, ce.ha = x, m = [m], x = [x], ce.gb = [ce.gb];
      e: {
        var be = m, ye = x, Ae = ce.gb;
        if (e(d != null), e(ye != null), e(Ae != null), Ae[0] = 0, 12 <= ye[0] && !t(d, be[0], "RIFF")) {
          if (t(d, be[0] + 8, "WEBP")) {
            Ae = 3;
            break e;
          }
          var le = ke(d, be[0] + 4);
          if (12 > le || 4294967286 < le) {
            Ae = 3;
            break e;
          }
          if (pe && le > ye[0] - 8) {
            Ae = 7;
            break e;
          }
          Ae[0] = le, be[0] += 12, ye[0] -= 12;
        }
        Ae = 0;
      }
      if (Ae != 0)
        return Ae;
      for (le = 0 < ce.gb[0], x = x[0]; ; ) {
        e: {
          var Ce = d;
          ye = m, Ae = x;
          var Te = K, Be = se, et = be = [0];
          if ((je = ge = [ge])[0] = 0, 8 > Ae[0])
            Ae = 7;
          else {
            if (!t(Ce, ye[0], "VP8X")) {
              if (ke(Ce, ye[0] + 4) != 10) {
                Ae = 3;
                break e;
              }
              if (18 > Ae[0]) {
                Ae = 7;
                break e;
              }
              var $e = ke(Ce, ye[0] + 8), Bt = 1 + Ue(Ce, ye[0] + 12);
              if (2147483648 <= Bt * (Ce = 1 + Ue(Ce, ye[0] + 15))) {
                Ae = 3;
                break e;
              }
              et != null && (et[0] = $e), Te != null && (Te[0] = Bt), Be != null && (Be[0] = Ce), ye[0] += 18, Ae[0] -= 18, je[0] = 1;
            }
            Ae = 0;
          }
        }
        if (ge = ge[0], be = be[0], Ae != 0)
          return Ae;
        if (ye = !!(2 & be), !le && ge)
          return 3;
        if (O != null && (O[0] = !!(16 & be)), U != null && (U[0] = ye), D != null && (D[0] = 0), U = K[0], be = se[0], ge && ye && G == null) {
          Ae = 0;
          break;
        }
        if (4 > x) {
          Ae = 7;
          break;
        }
        if (le && ge || !le && !ge && !t(d, m[0], "ALPH")) {
          x = [x], ce.na = [ce.na], ce.P = [ce.P], ce.Sa = [ce.Sa];
          e: {
            $e = d, Ae = m, le = x;
            var je = ce.gb;
            Te = ce.na, Be = ce.P, et = ce.Sa, Bt = 22, e($e != null), e(le != null), Ce = Ae[0];
            var br = le[0];
            for (e(Te != null), e(et != null), Te[0] = null, Be[0] = null, et[0] = 0; ; ) {
              if (Ae[0] = Ce, le[0] = br, 8 > br) {
                Ae = 7;
                break e;
              }
              var kr = ke($e, Ce + 4);
              if (4294967286 < kr) {
                Ae = 3;
                break e;
              }
              var wr = 8 + kr + 1 & -2;
              if (Bt += wr, 0 < je && Bt > je) {
                Ae = 3;
                break e;
              }
              if (!t($e, Ce, "VP8 ") || !t($e, Ce, "VP8L")) {
                Ae = 0;
                break e;
              }
              if (br[0] < wr) {
                Ae = 7;
                break e;
              }
              t($e, Ce, "ALPH") || (Te[0] = $e, Be[0] = Ce + 8, et[0] = kr), Ce += wr, br -= wr;
            }
          }
          if (x = x[0], ce.na = ce.na[0], ce.P = ce.P[0], ce.Sa = ce.Sa[0], Ae != 0)
            break;
        }
        x = [x], ce.Ja = [ce.Ja], ce.xa = [ce.xa];
        e:
          if (je = d, Ae = m, le = x, Te = ce.gb[0], Be = ce.Ja, et = ce.xa, $e = Ae[0], Ce = !t(je, $e, "VP8 "), Bt = !t(je, $e, "VP8L"), e(je != null), e(le != null), e(Be != null), e(et != null), 8 > le[0])
            Ae = 7;
          else {
            if (Ce || Bt) {
              if (je = ke(je, $e + 4), 12 <= Te && je > Te - 12) {
                Ae = 3;
                break e;
              }
              if (pe && je > le[0] - 8) {
                Ae = 7;
                break e;
              }
              Be[0] = je, Ae[0] += 8, le[0] -= 8, et[0] = Bt;
            } else
              et[0] = 5 <= le[0] && je[$e + 0] == 47 && !(je[$e + 4] >> 5), Be[0] = le[0];
            Ae = 0;
          }
        if (x = x[0], ce.Ja = ce.Ja[0], ce.xa = ce.xa[0], m = m[0], Ae != 0)
          break;
        if (4294967286 < ce.Ja)
          return 3;
        if (D == null || ye || (D[0] = ce.xa ? 2 : 1), U = [U], be = [be], ce.xa) {
          if (5 > x) {
            Ae = 7;
            break;
          }
          D = U, pe = be, ye = O, d == null || 5 > x ? d = 0 : 5 <= x && d[m + 0] == 47 && !(d[m + 4] >> 5) ? (le = [0], je = [0], Te = [0], Z(Be = new b(), d, m, x), gt(Be, le, je, Te) ? (D != null && (D[0] = le[0]), pe != null && (pe[0] = je[0]), ye != null && (ye[0] = Te[0]), d = 1) : d = 0) : d = 0;
        } else {
          if (10 > x) {
            Ae = 7;
            break;
          }
          D = be, d == null || 10 > x || !Hg(d, m + 3, x - 3) ? d = 0 : (pe = d[m + 0] | d[m + 1] << 8 | d[m + 2] << 16, ye = 16383 & (d[m + 7] << 8 | d[m + 6]), d = 16383 & (d[m + 9] << 8 | d[m + 8]), 1 & pe || 3 < (pe >> 1 & 7) || !(pe >> 4 & 1) || pe >> 5 >= ce.Ja || !ye || !d ? d = 0 : (U && (U[0] = ye), D && (D[0] = d), d = 1));
        }
        if (!d || (U = U[0], be = be[0], ge && (K[0] != U || se[0] != be)))
          return 3;
        G != null && (G[0] = ce, G.offset = m - G.w, e(4294967286 > m - G.w), e(G.offset == G.ha - x));
        break;
      }
      return Ae == 0 || Ae == 7 && ge && G == null ? (O != null && (O[0] |= ce.na != null && 0 < ce.na.length), B != null && (B[0] = U), R != null && (R[0] = be), 0) : Ae;
    }
    function ff(d, m, x) {
      var B = m.width, R = m.height, O = 0, U = 0, D = B, G = R;
      if (m.Da = d != null && 0 < d.Da, m.Da && (D = d.cd, G = d.bd, O = d.v, U = d.j, 11 > x || (O &= -2, U &= -2), 0 > O || 0 > U || 0 >= D || 0 >= G || O + D > B || U + G > R))
        return 0;
      if (m.v = O, m.j = U, m.va = O + D, m.o = U + G, m.U = D, m.T = G, m.da = d != null && 0 < d.da, m.da) {
        if (!mt(D, G, x = [d.ib], O = [d.hb]))
          return 0;
        m.ib = x[0], m.hb = O[0];
      }
      return m.ob = d != null && d.ob, m.Kb = d == null || !d.Sd, m.da && (m.ob = m.ib < 3 * B / 4 && m.hb < 3 * R / 4, m.Kb = 0), 1;
    }
    function df(d) {
      if (d == null)
        return 2;
      if (11 > d.S) {
        var m = d.f.RGBA;
        m.fb += (d.height - 1) * m.A, m.A = -m.A;
      } else
        m = d.f.kb, d = d.height, m.O += (d - 1) * m.fa, m.fa = -m.fa, m.N += (d - 1 >> 1) * m.Ab, m.Ab = -m.Ab, m.W += (d - 1 >> 1) * m.Db, m.Db = -m.Db, m.F != null && (m.J += (d - 1) * m.lb, m.lb = -m.lb);
      return 0;
    }
    function Kh(d, m, x, B) {
      if (B == null || 0 >= d || 0 >= m)
        return 2;
      if (x != null) {
        if (x.Da) {
          var R = x.cd, O = x.bd, U = -2 & x.v, D = -2 & x.j;
          if (0 > U || 0 > D || 0 >= R || 0 >= O || U + R > d || D + O > m)
            return 2;
          d = R, m = O;
        }
        if (x.da) {
          if (!mt(d, m, R = [x.ib], O = [x.hb]))
            return 2;
          d = R[0], m = O[0];
        }
      }
      B.width = d, B.height = m;
      e: {
        var G = B.width, K = B.height;
        if (d = B.S, 0 >= G || 0 >= K || !(d >= op && 13 > d))
          d = 2;
        else {
          if (0 >= B.Rd && B.sd == null) {
            U = O = R = m = 0;
            var se = (D = G * iS[d]) * K;
            if (11 > d || (O = (K + 1) / 2 * (m = (G + 1) / 2), d == 12 && (U = (R = G) * K)), (K = s(se + 2 * O + U)) == null) {
              d = 1;
              break e;
            }
            B.sd = K, 11 > d ? ((G = B.f.RGBA).eb = K, G.fb = 0, G.A = D, G.size = se) : ((G = B.f.kb).y = K, G.O = 0, G.fa = D, G.Fd = se, G.f = K, G.N = 0 + se, G.Ab = m, G.Cd = O, G.ea = K, G.W = 0 + se + O, G.Db = m, G.Ed = O, d == 12 && (G.F = K, G.J = 0 + se + 2 * O), G.Tc = U, G.lb = R);
          }
          if (m = 1, R = B.S, O = B.width, U = B.height, R >= op && 13 > R)
            if (11 > R)
              d = B.f.RGBA, m &= (D = Math.abs(d.A)) * (U - 1) + O <= d.size, m &= D >= O * iS[R], m &= d.eb != null;
            else {
              d = B.f.kb, D = (O + 1) / 2, se = (U + 1) / 2, G = Math.abs(d.fa), K = Math.abs(d.Ab);
              var ge = Math.abs(d.Db), pe = Math.abs(d.lb), ce = pe * (U - 1) + O;
              m &= G * (U - 1) + O <= d.Fd, m &= K * (se - 1) + D <= d.Cd, m = (m &= ge * (se - 1) + D <= d.Ed) & G >= O & K >= D & ge >= D, m &= d.y != null, m &= d.f != null, m &= d.ea != null, R == 12 && (m &= pe >= O, m &= ce <= d.Tc, m &= d.F != null);
            }
          else
            m = 0;
          d = m ? 0 : 2;
        }
      }
      return d != 0 || x != null && x.fd && (d = df(B)), d;
    }
    var os = 64, jh = [0, 1, 3, 7, 15, 31, 63, 127, 255, 511, 1023, 2047, 4095, 8191, 16383, 32767, 65535, 131071, 262143, 524287, 1048575, 2097151, 4194303, 8388607, 16777215], zh = 24, Xh = 32, gf = 8, As = [0, 0, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 3, 3, 3, 3, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7];
    Re("Predictor0", "PredictorAdd0"), F.Predictor0 = function() {
      return 4278190080;
    }, F.Predictor1 = function(d) {
      return d;
    }, F.Predictor2 = function(d, m, x) {
      return m[x + 0];
    }, F.Predictor3 = function(d, m, x) {
      return m[x + 1];
    }, F.Predictor4 = function(d, m, x) {
      return m[x - 1];
    }, F.Predictor5 = function(d, m, x) {
      return Le(Le(d, m[x + 1]), m[x + 0]);
    }, F.Predictor6 = function(d, m, x) {
      return Le(d, m[x - 1]);
    }, F.Predictor7 = function(d, m, x) {
      return Le(d, m[x + 0]);
    }, F.Predictor8 = function(d, m, x) {
      return Le(m[x - 1], m[x + 0]);
    }, F.Predictor9 = function(d, m, x) {
      return Le(m[x + 0], m[x + 1]);
    }, F.Predictor10 = function(d, m, x) {
      return Le(Le(d, m[x - 1]), Le(m[x + 0], m[x + 1]));
    }, F.Predictor11 = function(d, m, x) {
      var B = m[x + 0];
      return 0 >= ft(B >> 24 & 255, d >> 24 & 255, (m = m[x - 1]) >> 24 & 255) + ft(B >> 16 & 255, d >> 16 & 255, m >> 16 & 255) + ft(B >> 8 & 255, d >> 8 & 255, m >> 8 & 255) + ft(255 & B, 255 & d, 255 & m) ? B : d;
    }, F.Predictor12 = function(d, m, x) {
      var B = m[x + 0];
      return (Ge((d >> 24 & 255) + (B >> 24 & 255) - ((m = m[x - 1]) >> 24 & 255)) << 24 | Ge((d >> 16 & 255) + (B >> 16 & 255) - (m >> 16 & 255)) << 16 | Ge((d >> 8 & 255) + (B >> 8 & 255) - (m >> 8 & 255)) << 8 | Ge((255 & d) + (255 & B) - (255 & m))) >>> 0;
    }, F.Predictor13 = function(d, m, x) {
      var B = m[x - 1];
      return (ze((d = Le(d, m[x + 0])) >> 24 & 255, B >> 24 & 255) << 24 | ze(d >> 16 & 255, B >> 16 & 255) << 16 | ze(d >> 8 & 255, B >> 8 & 255) << 8 | ze(d >> 0 & 255, B >> 0 & 255)) >>> 0;
    };
    var h1 = F.PredictorAdd0;
    F.PredictorAdd1 = Et, Re("Predictor2", "PredictorAdd2"), Re("Predictor3", "PredictorAdd3"), Re("Predictor4", "PredictorAdd4"), Re("Predictor5", "PredictorAdd5"), Re("Predictor6", "PredictorAdd6"), Re("Predictor7", "PredictorAdd7"), Re("Predictor8", "PredictorAdd8"), Re("Predictor9", "PredictorAdd9"), Re("Predictor10", "PredictorAdd10"), Re("Predictor11", "PredictorAdd11"), Re("Predictor12", "PredictorAdd12"), Re("Predictor13", "PredictorAdd13");
    var pf = F.PredictorAdd2;
    vt("ColorIndexInverseTransform", "MapARGB", "32b", function(d) {
      return d >> 8 & 255;
    }, function(d) {
      return d;
    }), vt("VP8LColorIndexInverseTransformAlpha", "MapAlpha", "8b", function(d) {
      return d;
    }, function(d) {
      return d >> 8 & 255;
    });
    var np, oa = F.ColorIndexInverseTransform, mf = F.MapARGB, c1 = F.VP8LColorIndexInverseTransformAlpha, u1 = F.MapAlpha, pA = F.VP8LPredictorsAdd = [];
    pA.length = 16, (F.VP8LPredictors = []).length = 16, (F.VP8LPredictorsAdd_C = []).length = 16, (F.VP8LPredictors_C = []).length = 16;
    var ks, Aa, mA, Ra, po, Wh, la, Yh, vf, vA, ha, mo, Tl, qh, Fl, yA, yf, Hs, vo, qr, Zr, Mi, sn, yo, _A, Zh, sp, Db, kb = s(511), Hb = s(2041), Gb = s(225), $b = s(767), Vb = 0, f1 = Hb, ap = Gb, bs = $b, Gs = kb, op = 0, Ap = 1, Kb = 2, lp = 3, hp = 4, d1 = 5, jb = 6, g1 = 7, p1 = 8, cp = 9, m1 = 10, NU = [2, 3, 7], PU = [3, 3, 11], zb = [280, 256, 256, 256, 40], OU = [0, 1, 1, 1, 0], UU = [17, 18, 0, 1, 2, 3, 4, 5, 16, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15], QU = [24, 7, 23, 25, 40, 6, 39, 41, 22, 26, 38, 42, 56, 5, 55, 57, 21, 27, 54, 58, 37, 43, 72, 4, 71, 73, 20, 28, 53, 59, 70, 74, 36, 44, 88, 69, 75, 52, 60, 3, 87, 89, 19, 29, 86, 90, 35, 45, 68, 76, 85, 91, 51, 61, 104, 2, 103, 105, 18, 30, 102, 106, 34, 46, 84, 92, 67, 77, 101, 107, 50, 62, 120, 1, 119, 121, 83, 93, 17, 31, 100, 108, 66, 78, 118, 122, 33, 47, 117, 123, 49, 63, 99, 109, 82, 94, 0, 116, 124, 65, 79, 16, 32, 98, 110, 48, 115, 125, 81, 95, 64, 114, 126, 97, 111, 80, 113, 127, 96, 112], DU = [2954, 2956, 2958, 2962, 2970, 2986, 3018, 3082, 3212, 3468, 3980, 5004], kU = 8, v1 = [4, 5, 6, 7, 8, 9, 10, 10, 11, 12, 13, 14, 15, 16, 17, 17, 18, 19, 20, 20, 21, 21, 22, 22, 23, 23, 24, 25, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 91, 93, 95, 96, 98, 100, 101, 102, 104, 106, 108, 110, 112, 114, 116, 118, 122, 124, 126, 128, 130, 132, 134, 136, 138, 140, 143, 145, 148, 151, 154, 157], y1 = [4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 60, 62, 64, 66, 68, 70, 72, 74, 76, 78, 80, 82, 84, 86, 88, 90, 92, 94, 96, 98, 100, 102, 104, 106, 108, 110, 112, 114, 116, 119, 122, 125, 128, 131, 134, 137, 140, 143, 146, 149, 152, 155, 158, 161, 164, 167, 170, 173, 177, 181, 185, 189, 193, 197, 201, 205, 209, 213, 217, 221, 225, 229, 234, 239, 245, 249, 254, 259, 264, 269, 274, 279, 284], _f = null, HU = [[173, 148, 140, 0], [176, 155, 140, 135, 0], [180, 157, 141, 134, 130, 0], [254, 254, 243, 230, 196, 177, 153, 140, 133, 130, 129, 0]], GU = [0, 1, 4, 8, 5, 2, 3, 6, 9, 12, 13, 10, 7, 11, 14, 15], Xb = [-0, 1, -1, 2, -2, 3, 4, 6, -3, 5, -4, -5, -6, 7, -7, 8, -8, -9], $U = [[[[128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128], [128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128], [128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128]], [[253, 136, 254, 255, 228, 219, 128, 128, 128, 128, 128], [189, 129, 242, 255, 227, 213, 255, 219, 128, 128, 128], [106, 126, 227, 252, 214, 209, 255, 255, 128, 128, 128]], [[1, 98, 248, 255, 236, 226, 255, 255, 128, 128, 128], [181, 133, 238, 254, 221, 234, 255, 154, 128, 128, 128], [78, 134, 202, 247, 198, 180, 255, 219, 128, 128, 128]], [[1, 185, 249, 255, 243, 255, 128, 128, 128, 128, 128], [184, 150, 247, 255, 236, 224, 128, 128, 128, 128, 128], [77, 110, 216, 255, 236, 230, 128, 128, 128, 128, 128]], [[1, 101, 251, 255, 241, 255, 128, 128, 128, 128, 128], [170, 139, 241, 252, 236, 209, 255, 255, 128, 128, 128], [37, 116, 196, 243, 228, 255, 255, 255, 128, 128, 128]], [[1, 204, 254, 255, 245, 255, 128, 128, 128, 128, 128], [207, 160, 250, 255, 238, 128, 128, 128, 128, 128, 128], [102, 103, 231, 255, 211, 171, 128, 128, 128, 128, 128]], [[1, 152, 252, 255, 240, 255, 128, 128, 128, 128, 128], [177, 135, 243, 255, 234, 225, 128, 128, 128, 128, 128], [80, 129, 211, 255, 194, 224, 128, 128, 128, 128, 128]], [[1, 1, 255, 128, 128, 128, 128, 128, 128, 128, 128], [246, 1, 255, 128, 128, 128, 128, 128, 128, 128, 128], [255, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128]]], [[[198, 35, 237, 223, 193, 187, 162, 160, 145, 155, 62], [131, 45, 198, 221, 172, 176, 220, 157, 252, 221, 1], [68, 47, 146, 208, 149, 167, 221, 162, 255, 223, 128]], [[1, 149, 241, 255, 221, 224, 255, 255, 128, 128, 128], [184, 141, 234, 253, 222, 220, 255, 199, 128, 128, 128], [81, 99, 181, 242, 176, 190, 249, 202, 255, 255, 128]], [[1, 129, 232, 253, 214, 197, 242, 196, 255, 255, 128], [99, 121, 210, 250, 201, 198, 255, 202, 128, 128, 128], [23, 91, 163, 242, 170, 187, 247, 210, 255, 255, 128]], [[1, 200, 246, 255, 234, 255, 128, 128, 128, 128, 128], [109, 178, 241, 255, 231, 245, 255, 255, 128, 128, 128], [44, 130, 201, 253, 205, 192, 255, 255, 128, 128, 128]], [[1, 132, 239, 251, 219, 209, 255, 165, 128, 128, 128], [94, 136, 225, 251, 218, 190, 255, 255, 128, 128, 128], [22, 100, 174, 245, 186, 161, 255, 199, 128, 128, 128]], [[1, 182, 249, 255, 232, 235, 128, 128, 128, 128, 128], [124, 143, 241, 255, 227, 234, 128, 128, 128, 128, 128], [35, 77, 181, 251, 193, 211, 255, 205, 128, 128, 128]], [[1, 157, 247, 255, 236, 231, 255, 255, 128, 128, 128], [121, 141, 235, 255, 225, 227, 255, 255, 128, 128, 128], [45, 99, 188, 251, 195, 217, 255, 224, 128, 128, 128]], [[1, 1, 251, 255, 213, 255, 128, 128, 128, 128, 128], [203, 1, 248, 255, 255, 128, 128, 128, 128, 128, 128], [137, 1, 177, 255, 224, 255, 128, 128, 128, 128, 128]]], [[[253, 9, 248, 251, 207, 208, 255, 192, 128, 128, 128], [175, 13, 224, 243, 193, 185, 249, 198, 255, 255, 128], [73, 17, 171, 221, 161, 179, 236, 167, 255, 234, 128]], [[1, 95, 247, 253, 212, 183, 255, 255, 128, 128, 128], [239, 90, 244, 250, 211, 209, 255, 255, 128, 128, 128], [155, 77, 195, 248, 188, 195, 255, 255, 128, 128, 128]], [[1, 24, 239, 251, 218, 219, 255, 205, 128, 128, 128], [201, 51, 219, 255, 196, 186, 128, 128, 128, 128, 128], [69, 46, 190, 239, 201, 218, 255, 228, 128, 128, 128]], [[1, 191, 251, 255, 255, 128, 128, 128, 128, 128, 128], [223, 165, 249, 255, 213, 255, 128, 128, 128, 128, 128], [141, 124, 248, 255, 255, 128, 128, 128, 128, 128, 128]], [[1, 16, 248, 255, 255, 128, 128, 128, 128, 128, 128], [190, 36, 230, 255, 236, 255, 128, 128, 128, 128, 128], [149, 1, 255, 128, 128, 128, 128, 128, 128, 128, 128]], [[1, 226, 255, 128, 128, 128, 128, 128, 128, 128, 128], [247, 192, 255, 128, 128, 128, 128, 128, 128, 128, 128], [240, 128, 255, 128, 128, 128, 128, 128, 128, 128, 128]], [[1, 134, 252, 255, 255, 128, 128, 128, 128, 128, 128], [213, 62, 250, 255, 255, 128, 128, 128, 128, 128, 128], [55, 93, 255, 128, 128, 128, 128, 128, 128, 128, 128]], [[128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128], [128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128], [128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128]]], [[[202, 24, 213, 235, 186, 191, 220, 160, 240, 175, 255], [126, 38, 182, 232, 169, 184, 228, 174, 255, 187, 128], [61, 46, 138, 219, 151, 178, 240, 170, 255, 216, 128]], [[1, 112, 230, 250, 199, 191, 247, 159, 255, 255, 128], [166, 109, 228, 252, 211, 215, 255, 174, 128, 128, 128], [39, 77, 162, 232, 172, 180, 245, 178, 255, 255, 128]], [[1, 52, 220, 246, 198, 199, 249, 220, 255, 255, 128], [124, 74, 191, 243, 183, 193, 250, 221, 255, 255, 128], [24, 71, 130, 219, 154, 170, 243, 182, 255, 255, 128]], [[1, 182, 225, 249, 219, 240, 255, 224, 128, 128, 128], [149, 150, 226, 252, 216, 205, 255, 171, 128, 128, 128], [28, 108, 170, 242, 183, 194, 254, 223, 255, 255, 128]], [[1, 81, 230, 252, 204, 203, 255, 192, 128, 128, 128], [123, 102, 209, 247, 188, 196, 255, 233, 128, 128, 128], [20, 95, 153, 243, 164, 173, 255, 203, 128, 128, 128]], [[1, 222, 248, 255, 216, 213, 128, 128, 128, 128, 128], [168, 175, 246, 252, 235, 205, 255, 255, 128, 128, 128], [47, 116, 215, 255, 211, 212, 255, 255, 128, 128, 128]], [[1, 121, 236, 253, 212, 214, 255, 255, 128, 128, 128], [141, 84, 213, 252, 201, 202, 255, 219, 128, 128, 128], [42, 80, 160, 240, 162, 185, 255, 205, 128, 128, 128]], [[1, 1, 255, 128, 128, 128, 128, 128, 128, 128, 128], [244, 1, 255, 128, 128, 128, 128, 128, 128, 128, 128], [238, 1, 255, 128, 128, 128, 128, 128, 128, 128, 128]]]], VU = [[[231, 120, 48, 89, 115, 113, 120, 152, 112], [152, 179, 64, 126, 170, 118, 46, 70, 95], [175, 69, 143, 80, 85, 82, 72, 155, 103], [56, 58, 10, 171, 218, 189, 17, 13, 152], [114, 26, 17, 163, 44, 195, 21, 10, 173], [121, 24, 80, 195, 26, 62, 44, 64, 85], [144, 71, 10, 38, 171, 213, 144, 34, 26], [170, 46, 55, 19, 136, 160, 33, 206, 71], [63, 20, 8, 114, 114, 208, 12, 9, 226], [81, 40, 11, 96, 182, 84, 29, 16, 36]], [[134, 183, 89, 137, 98, 101, 106, 165, 148], [72, 187, 100, 130, 157, 111, 32, 75, 80], [66, 102, 167, 99, 74, 62, 40, 234, 128], [41, 53, 9, 178, 241, 141, 26, 8, 107], [74, 43, 26, 146, 73, 166, 49, 23, 157], [65, 38, 105, 160, 51, 52, 31, 115, 128], [104, 79, 12, 27, 217, 255, 87, 17, 7], [87, 68, 71, 44, 114, 51, 15, 186, 23], [47, 41, 14, 110, 182, 183, 21, 17, 194], [66, 45, 25, 102, 197, 189, 23, 18, 22]], [[88, 88, 147, 150, 42, 46, 45, 196, 205], [43, 97, 183, 117, 85, 38, 35, 179, 61], [39, 53, 200, 87, 26, 21, 43, 232, 171], [56, 34, 51, 104, 114, 102, 29, 93, 77], [39, 28, 85, 171, 58, 165, 90, 98, 64], [34, 22, 116, 206, 23, 34, 43, 166, 73], [107, 54, 32, 26, 51, 1, 81, 43, 31], [68, 25, 106, 22, 64, 171, 36, 225, 114], [34, 19, 21, 102, 132, 188, 16, 76, 124], [62, 18, 78, 95, 85, 57, 50, 48, 51]], [[193, 101, 35, 159, 215, 111, 89, 46, 111], [60, 148, 31, 172, 219, 228, 21, 18, 111], [112, 113, 77, 85, 179, 255, 38, 120, 114], [40, 42, 1, 196, 245, 209, 10, 25, 109], [88, 43, 29, 140, 166, 213, 37, 43, 154], [61, 63, 30, 155, 67, 45, 68, 1, 209], [100, 80, 8, 43, 154, 1, 51, 26, 71], [142, 78, 78, 16, 255, 128, 34, 197, 171], [41, 40, 5, 102, 211, 183, 4, 1, 221], [51, 50, 17, 168, 209, 192, 23, 25, 82]], [[138, 31, 36, 171, 27, 166, 38, 44, 229], [67, 87, 58, 169, 82, 115, 26, 59, 179], [63, 59, 90, 180, 59, 166, 93, 73, 154], [40, 40, 21, 116, 143, 209, 34, 39, 175], [47, 15, 16, 183, 34, 223, 49, 45, 183], [46, 17, 33, 183, 6, 98, 15, 32, 183], [57, 46, 22, 24, 128, 1, 54, 17, 37], [65, 32, 73, 115, 28, 128, 23, 128, 205], [40, 3, 9, 115, 51, 192, 18, 6, 223], [87, 37, 9, 115, 59, 77, 64, 21, 47]], [[104, 55, 44, 218, 9, 54, 53, 130, 226], [64, 90, 70, 205, 40, 41, 23, 26, 57], [54, 57, 112, 184, 5, 41, 38, 166, 213], [30, 34, 26, 133, 152, 116, 10, 32, 134], [39, 19, 53, 221, 26, 114, 32, 73, 255], [31, 9, 65, 234, 2, 15, 1, 118, 73], [75, 32, 12, 51, 192, 255, 160, 43, 51], [88, 31, 35, 67, 102, 85, 55, 186, 85], [56, 21, 23, 111, 59, 205, 45, 37, 192], [55, 38, 70, 124, 73, 102, 1, 34, 98]], [[125, 98, 42, 88, 104, 85, 117, 175, 82], [95, 84, 53, 89, 128, 100, 113, 101, 45], [75, 79, 123, 47, 51, 128, 81, 171, 1], [57, 17, 5, 71, 102, 57, 53, 41, 49], [38, 33, 13, 121, 57, 73, 26, 1, 85], [41, 10, 67, 138, 77, 110, 90, 47, 114], [115, 21, 2, 10, 102, 255, 166, 23, 6], [101, 29, 16, 10, 85, 128, 101, 196, 26], [57, 18, 10, 102, 102, 213, 34, 20, 43], [117, 20, 15, 36, 163, 128, 68, 1, 26]], [[102, 61, 71, 37, 34, 53, 31, 243, 192], [69, 60, 71, 38, 73, 119, 28, 222, 37], [68, 45, 128, 34, 1, 47, 11, 245, 171], [62, 17, 19, 70, 146, 85, 55, 62, 70], [37, 43, 37, 154, 100, 163, 85, 160, 1], [63, 9, 92, 136, 28, 64, 32, 201, 85], [75, 15, 9, 9, 64, 255, 184, 119, 16], [86, 6, 28, 5, 64, 255, 25, 248, 1], [56, 8, 17, 132, 137, 255, 55, 116, 128], [58, 15, 20, 82, 135, 57, 26, 121, 40]], [[164, 50, 31, 137, 154, 133, 25, 35, 218], [51, 103, 44, 131, 131, 123, 31, 6, 158], [86, 40, 64, 135, 148, 224, 45, 183, 128], [22, 26, 17, 131, 240, 154, 14, 1, 209], [45, 16, 21, 91, 64, 222, 7, 1, 197], [56, 21, 39, 155, 60, 138, 23, 102, 213], [83, 12, 13, 54, 192, 255, 68, 47, 28], [85, 26, 85, 85, 128, 128, 32, 146, 171], [18, 11, 7, 63, 144, 171, 4, 4, 246], [35, 27, 10, 146, 174, 171, 12, 26, 128]], [[190, 80, 35, 99, 180, 80, 126, 54, 45], [85, 126, 47, 87, 176, 51, 41, 20, 32], [101, 75, 128, 139, 118, 146, 116, 128, 85], [56, 41, 15, 176, 236, 85, 37, 9, 62], [71, 30, 17, 119, 118, 255, 17, 18, 138], [101, 38, 60, 138, 55, 70, 43, 26, 142], [146, 36, 19, 30, 171, 255, 97, 27, 20], [138, 45, 61, 62, 219, 1, 81, 188, 64], [32, 41, 20, 117, 151, 142, 20, 21, 163], [112, 19, 12, 61, 195, 128, 48, 4, 24]]], KU = [[[[255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]], [[176, 246, 255, 255, 255, 255, 255, 255, 255, 255, 255], [223, 241, 252, 255, 255, 255, 255, 255, 255, 255, 255], [249, 253, 253, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 244, 252, 255, 255, 255, 255, 255, 255, 255, 255], [234, 254, 254, 255, 255, 255, 255, 255, 255, 255, 255], [253, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 246, 254, 255, 255, 255, 255, 255, 255, 255, 255], [239, 253, 254, 255, 255, 255, 255, 255, 255, 255, 255], [254, 255, 254, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 248, 254, 255, 255, 255, 255, 255, 255, 255, 255], [251, 255, 254, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 253, 254, 255, 255, 255, 255, 255, 255, 255, 255], [251, 254, 254, 255, 255, 255, 255, 255, 255, 255, 255], [254, 255, 254, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 254, 253, 255, 254, 255, 255, 255, 255, 255, 255], [250, 255, 254, 255, 254, 255, 255, 255, 255, 255, 255], [254, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]]], [[[217, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [225, 252, 241, 253, 255, 255, 254, 255, 255, 255, 255], [234, 250, 241, 250, 253, 255, 253, 254, 255, 255, 255]], [[255, 254, 255, 255, 255, 255, 255, 255, 255, 255, 255], [223, 254, 254, 255, 255, 255, 255, 255, 255, 255, 255], [238, 253, 254, 254, 255, 255, 255, 255, 255, 255, 255]], [[255, 248, 254, 255, 255, 255, 255, 255, 255, 255, 255], [249, 254, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 253, 255, 255, 255, 255, 255, 255, 255, 255, 255], [247, 254, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 253, 254, 255, 255, 255, 255, 255, 255, 255, 255], [252, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 254, 254, 255, 255, 255, 255, 255, 255, 255, 255], [253, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 254, 253, 255, 255, 255, 255, 255, 255, 255, 255], [250, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [254, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]]], [[[186, 251, 250, 255, 255, 255, 255, 255, 255, 255, 255], [234, 251, 244, 254, 255, 255, 255, 255, 255, 255, 255], [251, 251, 243, 253, 254, 255, 254, 255, 255, 255, 255]], [[255, 253, 254, 255, 255, 255, 255, 255, 255, 255, 255], [236, 253, 254, 255, 255, 255, 255, 255, 255, 255, 255], [251, 253, 253, 254, 254, 255, 255, 255, 255, 255, 255]], [[255, 254, 254, 255, 255, 255, 255, 255, 255, 255, 255], [254, 254, 254, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 254, 255, 255, 255, 255, 255, 255, 255, 255, 255], [254, 254, 255, 255, 255, 255, 255, 255, 255, 255, 255], [254, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [254, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]]], [[[248, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [250, 254, 252, 254, 255, 255, 255, 255, 255, 255, 255], [248, 254, 249, 253, 255, 255, 255, 255, 255, 255, 255]], [[255, 253, 253, 255, 255, 255, 255, 255, 255, 255, 255], [246, 253, 253, 255, 255, 255, 255, 255, 255, 255, 255], [252, 254, 251, 254, 254, 255, 255, 255, 255, 255, 255]], [[255, 254, 252, 255, 255, 255, 255, 255, 255, 255, 255], [248, 254, 253, 255, 255, 255, 255, 255, 255, 255, 255], [253, 255, 254, 254, 255, 255, 255, 255, 255, 255, 255]], [[255, 251, 254, 255, 255, 255, 255, 255, 255, 255, 255], [245, 251, 254, 255, 255, 255, 255, 255, 255, 255, 255], [253, 253, 254, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 251, 253, 255, 255, 255, 255, 255, 255, 255, 255], [252, 253, 254, 255, 255, 255, 255, 255, 255, 255, 255], [255, 254, 255, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 252, 255, 255, 255, 255, 255, 255, 255, 255, 255], [249, 255, 254, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 254, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 255, 253, 255, 255, 255, 255, 255, 255, 255, 255], [250, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [254, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]]]], jU = [0, 1, 2, 3, 6, 4, 5, 6, 6, 6, 6, 6, 6, 6, 6, 7, 0], wA = [], ca = [], _o = [], zU = 1, Wb = 2, xA = [], $s = [];
    _e("UpsampleRgbLinePair", vr, 3), _e("UpsampleBgrLinePair", gi, 3), _e("UpsampleRgbaLinePair", aa, 4), _e("UpsampleBgraLinePair", dn, 4), _e("UpsampleArgbLinePair", On, 4), _e("UpsampleRgba4444LinePair", $i, 2), _e("UpsampleRgb565LinePair", Ei, 2);
    var XU = F.UpsampleRgbLinePair, WU = F.UpsampleBgrLinePair, Yb = F.UpsampleRgbaLinePair, qb = F.UpsampleBgraLinePair, Zb = F.UpsampleArgbLinePair, Jb = F.UpsampleRgba4444LinePair, YU = F.UpsampleRgb565LinePair, up = 16, fp = 1 << up - 1, wf = -227, _1 = 482, eS = 6, qU = (256 << eS) - 1, tS = 0, ZU = s(256), JU = s(256), eQ = s(256), tQ = s(256), rQ = s(_1 - wf), iQ = s(_1 - wf);
    go("YuvToRgbRow", vr, 3), go("YuvToBgrRow", gi, 3), go("YuvToRgbaRow", aa, 4), go("YuvToBgraRow", dn, 4), go("YuvToArgbRow", On, 4), go("YuvToRgba4444Row", $i, 2), go("YuvToRgb565Row", Ei, 2);
    var rS = [0, 4, 8, 12, 128, 132, 136, 140, 256, 260, 264, 268, 384, 388, 392, 396], dp = [0, 2, 8], nQ = [8, 7, 6, 4, 4, 2, 2, 2, 1, 1, 1, 1], sQ = 1;
    this.WebPDecodeRGBA = function(d, m, x, B, R) {
      var O = Ap, U = new Gh(), D = new Ai();
      U.ba = D, D.S = O, D.width = [D.width], D.height = [D.height];
      var G = D.width, K = D.height, se = new yr();
      if (se == null || d == null)
        var ge = 2;
      else
        e(se != null), ge = Vh(d, m, x, se.width, se.height, se.Pd, se.Qd, se.format, null);
      if (ge != 0 ? G = 0 : (G != null && (G[0] = se.width[0]), K != null && (K[0] = se.height[0]), G = 1), G) {
        D.width = D.width[0], D.height = D.height[0], B != null && (B[0] = D.width), R != null && (R[0] = D.height);
        e: {
          if (B = new Ph(), (R = new of()).data = d, R.w = m, R.ha = x, R.kd = 1, m = [0], e(R != null), ((d = Vh(R.data, R.w, R.ha, null, null, null, m, null, R)) == 0 || d == 7) && m[0] && (d = 4), (m = d) == 0) {
            if (e(U != null), B.data = R.data, B.w = R.w + R.offset, B.ha = R.ha - R.offset, B.put = di, B.ac = _r, B.bc = zr, B.ma = U, R.xa) {
              if ((d = Dr()) == null) {
                U = 1;
                break e;
              }
              if (function(pe, ce) {
                var be = [0], ye = [0], Ae = [0];
                t:
                  for (; ; ) {
                    if (pe == null)
                      return 0;
                    if (ce == null)
                      return pe.a = 2, 0;
                    if (pe.l = ce, pe.a = 0, Z(pe.m, ce.data, ce.w, ce.ha), !gt(pe.m, be, ye, Ae)) {
                      pe.a = 3;
                      break t;
                    }
                    if (pe.xb = Wb, ce.width = be[0], ce.height = ye[0], !Xr(be[0], ye[0], 1, pe, null))
                      break t;
                    return 1;
                  }
                return e(pe.a != 0), 0;
              }(d, B)) {
                if (B = (m = Kh(B.width, B.height, U.Oa, U.ba)) == 0) {
                  t: {
                    B = d;
                    r:
                      for (; ; ) {
                        if (B == null) {
                          B = 0;
                          break t;
                        }
                        if (e(B.s.yc != null), e(B.s.Ya != null), e(0 < B.s.Wb), e((x = B.l) != null), e((R = x.ma) != null), B.xb != 0) {
                          if (B.ca = R.ba, B.tb = R.tb, e(B.ca != null), !ff(R.Oa, x, lp)) {
                            B.a = 2;
                            break r;
                          }
                          if (!si(B, x.width) || x.da)
                            break r;
                          if ((x.da || Jt(B.ca.S)) && de(), 11 > B.ca.S || (alert("todo:WebPInitConvertARGBToYUV"), B.ca.f.kb.F != null && de()), B.Pb && 0 < B.s.ua && B.s.vb.X == null && !We(B.s.vb, B.s.Wa.Xa)) {
                            B.a = 1;
                            break r;
                          }
                          B.xb = 0;
                        }
                        if (!Ke(B, B.V, B.Ba, B.c, B.i, x.o, hA))
                          break r;
                        R.Dc = B.Ma, B = 1;
                        break t;
                      }
                    e(B.a != 0), B = 0;
                  }
                  B = !B;
                }
                B && (m = d.a);
              } else
                m = d.a;
            } else {
              if ((d = new Ky()) == null) {
                U = 1;
                break e;
              }
              if (d.Fa = R.na, d.P = R.P, d.qc = R.Sa, Gg(d, B)) {
                if ((m = Kh(B.width, B.height, U.Oa, U.ba)) == 0) {
                  if (d.Aa = 0, x = U.Oa, e((R = d) != null), x != null) {
                    if (0 < (G = 0 > (G = x.Md) ? 0 : 100 < G ? 255 : 255 * G / 100)) {
                      for (K = se = 0; 4 > K; ++K)
                        12 > (ge = R.pb[K]).lc && (ge.ia = G * nQ[0 > ge.lc ? 0 : ge.lc] >> 3), se |= ge.ia;
                      se && (alert("todo:VP8InitRandom"), R.ia = 1);
                    }
                    R.Ga = x.Id, 100 < R.Ga ? R.Ga = 100 : 0 > R.Ga && (R.Ga = 0);
                  }
                  jy(d, B) || (m = d.a);
                }
              } else
                m = d.a;
            }
            m == 0 && U.Oa != null && U.Oa.fd && (m = df(U.ba));
          }
          U = m;
        }
        O = U != 0 ? null : 11 > O ? D.f.RGBA.eb : D.f.kb.y;
      } else
        O = null;
      return O;
    };
    var iS = [3, 4, 3, 4, 4, 2, 2, 4, 4, 4, 2, 1, 1];
  };
  function l(F, k) {
    for (var $ = "", I = 0; I < 4; I++)
      $ += String.fromCharCode(F[k++]);
    return $;
  }
  function h(F, k) {
    return (F[k + 0] << 0 | F[k + 1] << 8 | F[k + 2] << 16) >>> 0;
  }
  function c(F, k) {
    return (F[k + 0] << 0 | F[k + 1] << 8 | F[k + 2] << 16 | F[k + 3] << 24) >>> 0;
  }
  new A();
  var u = [0], f = [0], g = [], p = new A(), y = i, v = function(F, k) {
    var $ = {}, I = 0, L = !1, P = 0, Q = 0;
    if ($.frames = [], !/** @license
       * Copyright (c) 2017 Dominik Homberger
      Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:
      The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.
      THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
      https://webpjs.appspot.com
      WebPRiffParser dominikhlbg@gmail.com
      */
    function(H, V, j, ie) {
      for (var ue = 0; ue < ie; ue++)
        if (H[V + ue] != j.charCodeAt(ue))
          return !0;
      return !1;
    }(F, k, "RIFF", 4)) {
      var X, W;
      for (c(F, k += 4), k += 8; k < F.length; ) {
        var q = l(F, k), Z = c(F, k += 4);
        k += 4;
        var oe = Z + (1 & Z);
        switch (q) {
          case "VP8 ":
          case "VP8L":
            $.frames[I] === void 0 && ($.frames[I] = {}), (b = $.frames[I]).src_off = L ? Q : k - 8, b.src_size = P + Z + 8, I++, L && (L = !1, P = 0, Q = 0);
            break;
          case "VP8X":
            (b = $.header = {}).feature_flags = F[k];
            var ne = k + 4;
            b.canvas_width = 1 + h(F, ne), ne += 3, b.canvas_height = 1 + h(F, ne), ne += 3;
            break;
          case "ALPH":
            L = !0, P = oe + 8, Q = k - 8;
            break;
          case "ANIM":
            (b = $.header).bgcolor = c(F, k), ne = k + 4, b.loop_count = (X = F)[(W = ne) + 0] << 0 | X[W + 1] << 8, ne += 2;
            break;
          case "ANMF":
            var me, b;
            (b = $.frames[I] = {}).offset_x = 2 * h(F, k), k += 3, b.offset_y = 2 * h(F, k), k += 3, b.width = 1 + h(F, k), k += 3, b.height = 1 + h(F, k), k += 3, b.duration = h(F, k), k += 3, me = F[k++], b.dispose = 1 & me, b.blend = me >> 1 & 1;
        }
        q != "ANMF" && (k += oe);
      }
      return $;
    }
  }(y, 0);
  v.response = y, v.rgbaoutput = !0, v.dataurl = !1;
  var w = v.header ? v.header : null, C = v.frames ? v.frames : null;
  if (w) {
    w.loop_counter = w.loop_count, u = [w.canvas_height], f = [w.canvas_width];
    for (var E = 0; E < C.length && C[E].blend != 0; E++)
      ;
  }
  var S = C[0], M = p.WebPDecodeRGBA(y, S.src_off, S.src_size, f, u);
  S.rgba = M, S.imgwidth = f[0], S.imgheight = u[0];
  for (var T = 0; T < f[0] * u[0] * 4; T++)
    g[T] = M[T];
  return this.width = f, this.height = u, this.data = g, this;
}
(function(i) {
  var e = function() {
    return typeof Z2 == "function";
  }, t = function(u, f, g, p) {
    var y = 4, v = a;
    switch (p) {
      case i.image_compression.FAST:
        y = 1, v = s;
        break;
      case i.image_compression.MEDIUM:
        y = 6, v = o;
        break;
      case i.image_compression.SLOW:
        y = 9, v = A;
    }
    u = r(u, f, g, v);
    var w = Z2(u, { level: y });
    return i.__addimage__.arrayBufferToBinaryString(w);
  }, r = function(u, f, g, p) {
    for (var y, v, w, C = u.length / f, E = new Uint8Array(u.length + C), S = h(), M = 0; M < C; M += 1) {
      if (w = M * f, y = u.subarray(w, w + f), p)
        E.set(p(y, g, v), w + M);
      else {
        for (var T, F = S.length, k = []; T < F; T += 1)
          k[T] = S[T](y, g, v);
        var $ = c(k.concat());
        E.set(k[$], w + M);
      }
      v = y;
    }
    return E;
  }, n = function(u) {
    var f = Array.apply([], u);
    return f.unshift(0), f;
  }, s = function(u, f) {
    var g, p = [], y = u.length;
    p[0] = 1;
    for (var v = 0; v < y; v += 1)
      g = u[v - f] || 0, p[v + 1] = u[v] - g + 256 & 255;
    return p;
  }, a = function(u, f, g) {
    var p, y = [], v = u.length;
    y[0] = 2;
    for (var w = 0; w < v; w += 1)
      p = g && g[w] || 0, y[w + 1] = u[w] - p + 256 & 255;
    return y;
  }, o = function(u, f, g) {
    var p, y, v = [], w = u.length;
    v[0] = 3;
    for (var C = 0; C < w; C += 1)
      p = u[C - f] || 0, y = g && g[C] || 0, v[C + 1] = u[C] + 256 - (p + y >>> 1) & 255;
    return v;
  }, A = function(u, f, g) {
    var p, y, v, w, C = [], E = u.length;
    C[0] = 4;
    for (var S = 0; S < E; S += 1)
      p = u[S - f] || 0, y = g && g[S] || 0, v = g && g[S - f] || 0, w = l(p, y, v), C[S + 1] = u[S] - w + 256 & 255;
    return C;
  }, l = function(u, f, g) {
    if (u === f && f === g)
      return u;
    var p = Math.abs(f - g), y = Math.abs(u - g), v = Math.abs(u + f - g - g);
    return p <= y && p <= v ? u : y <= v ? f : g;
  }, h = function() {
    return [n, s, a, o, A];
  }, c = function(u) {
    var f = u.map(function(g) {
      return g.reduce(function(p, y) {
        return p + Math.abs(y);
      }, 0);
    });
    return f.indexOf(Math.min.apply(null, f));
  };
  i.processPNG = function(u, f, g, p) {
    var y, v, w, C, E, S, M, T, F, k, $, I, L, P, Q, X = this.decode.FLATE_DECODE, W = "";
    if (this.__addimage__.isArrayBuffer(u) && (u = new Uint8Array(u)), this.__addimage__.isArrayBufferView(u)) {
      if (u = (w = new HX(u)).imgData, v = w.bits, y = w.colorSpace, E = w.colors, [4, 6].indexOf(w.colorType) !== -1) {
        if (w.bits === 8) {
          F = (T = w.pixelBitlength == 32 ? new Uint32Array(w.decodePixels().buffer) : w.pixelBitlength == 16 ? new Uint16Array(w.decodePixels().buffer) : new Uint8Array(w.decodePixels().buffer)).length, $ = new Uint8Array(F * w.colors), k = new Uint8Array(F);
          var q, Z = w.pixelBitlength - w.bits;
          for (P = 0, Q = 0; P < F; P++) {
            for (L = T[P], q = 0; q < Z; )
              $[Q++] = L >>> q & 255, q += w.bits;
            k[P] = L >>> q & 255;
          }
        }
        if (w.bits === 16) {
          F = (T = new Uint32Array(w.decodePixels().buffer)).length, $ = new Uint8Array(F * (32 / w.pixelBitlength) * w.colors), k = new Uint8Array(F * (32 / w.pixelBitlength)), I = w.colors > 1, P = 0, Q = 0;
          for (var oe = 0; P < F; )
            L = T[P++], $[Q++] = L >>> 0 & 255, I && ($[Q++] = L >>> 16 & 255, L = T[P++], $[Q++] = L >>> 0 & 255), k[oe++] = L >>> 16 & 255;
          v = 8;
        }
        p !== i.image_compression.NONE && e() ? (u = t($, w.width * w.colors, w.colors, p), M = t(k, w.width, 1, p)) : (u = $, M = k, X = void 0);
      }
      if (w.colorType === 3 && (y = this.color_spaces.INDEXED, S = w.palette, w.transparency.indexed)) {
        var ne = w.transparency.indexed, me = 0;
        for (P = 0, F = ne.length; P < F; ++P)
          me += ne[P];
        if ((me /= 255) === F - 1 && ne.indexOf(0) !== -1)
          C = [ne.indexOf(0)];
        else if (me !== F) {
          for (T = w.decodePixels(), k = new Uint8Array(T.length), P = 0, F = T.length; P < F; P++)
            k[P] = ne[T[P]];
          M = t(k, w.width, 1);
        }
      }
      var b = function(H) {
        var V;
        switch (H) {
          case i.image_compression.FAST:
            V = 11;
            break;
          case i.image_compression.MEDIUM:
            V = 13;
            break;
          case i.image_compression.SLOW:
            V = 14;
            break;
          default:
            V = 12;
        }
        return V;
      }(p);
      return X === this.decode.FLATE_DECODE && (W = "/Predictor " + b + " "), W += "/Colors " + E + " /BitsPerComponent " + v + " /Columns " + w.width, (this.__addimage__.isArrayBuffer(u) || this.__addimage__.isArrayBufferView(u)) && (u = this.__addimage__.arrayBufferToBinaryString(u)), (M && this.__addimage__.isArrayBuffer(M) || this.__addimage__.isArrayBufferView(M)) && (M = this.__addimage__.arrayBufferToBinaryString(M)), { alias: g, data: u, index: f, filter: X, decodeParameters: W, transparency: C, palette: S, sMask: M, predictor: b, width: w.width, height: w.height, bitsPerComponent: v, colorSpace: y };
    }
  };
})(Lt.API), function(i) {
  i.processGIF89A = function(e, t, r, n) {
    var s = new GX(e), a = s.width, o = s.height, A = [];
    s.decodeAndBlitFrameRGBA(0, A);
    var l = { data: A, width: a, height: o }, h = new l_(100).encode(l, 100);
    return i.processJPEG.call(this, h, t, r, n);
  }, i.processGIF87A = i.processGIF89A;
}(Lt.API), ga.prototype.parseHeader = function() {
  if (this.fileSize = this.datav.getUint32(this.pos, !0), this.pos += 4, this.reserved = this.datav.getUint32(this.pos, !0), this.pos += 4, this.offset = this.datav.getUint32(this.pos, !0), this.pos += 4, this.headerSize = this.datav.getUint32(this.pos, !0), this.pos += 4, this.width = this.datav.getUint32(this.pos, !0), this.pos += 4, this.height = this.datav.getInt32(this.pos, !0), this.pos += 4, this.planes = this.datav.getUint16(this.pos, !0), this.pos += 2, this.bitPP = this.datav.getUint16(this.pos, !0), this.pos += 2, this.compress = this.datav.getUint32(this.pos, !0), this.pos += 4, this.rawSize = this.datav.getUint32(this.pos, !0), this.pos += 4, this.hr = this.datav.getUint32(this.pos, !0), this.pos += 4, this.vr = this.datav.getUint32(this.pos, !0), this.pos += 4, this.colors = this.datav.getUint32(this.pos, !0), this.pos += 4, this.importantColors = this.datav.getUint32(this.pos, !0), this.pos += 4, this.bitPP === 16 && this.is_with_alpha && (this.bitPP = 15), this.bitPP < 15) {
    var i = this.colors === 0 ? 1 << this.bitPP : this.colors;
    this.palette = new Array(i);
    for (var e = 0; e < i; e++) {
      var t = this.datav.getUint8(this.pos++, !0), r = this.datav.getUint8(this.pos++, !0), n = this.datav.getUint8(this.pos++, !0), s = this.datav.getUint8(this.pos++, !0);
      this.palette[e] = { red: n, green: r, blue: t, quad: s };
    }
  }
  this.height < 0 && (this.height *= -1, this.bottom_up = !1);
}, ga.prototype.parseBGR = function() {
  this.pos = this.offset;
  try {
    var i = "bit" + this.bitPP, e = this.width * this.height * 4;
    this.data = new Uint8Array(e), this[i]();
  } catch (t) {
    Yr.log("bit decode error:" + t);
  }
}, ga.prototype.bit1 = function() {
  var i, e = Math.ceil(this.width / 8), t = e % 4;
  for (i = this.height - 1; i >= 0; i--) {
    for (var r = this.bottom_up ? i : this.height - 1 - i, n = 0; n < e; n++)
      for (var s = this.datav.getUint8(this.pos++, !0), a = r * this.width * 4 + 8 * n * 4, o = 0; o < 8 && 8 * n + o < this.width; o++) {
        var A = this.palette[s >> 7 - o & 1];
        this.data[a + 4 * o] = A.blue, this.data[a + 4 * o + 1] = A.green, this.data[a + 4 * o + 2] = A.red, this.data[a + 4 * o + 3] = 255;
      }
    t !== 0 && (this.pos += 4 - t);
  }
}, ga.prototype.bit4 = function() {
  for (var i = Math.ceil(this.width / 2), e = i % 4, t = this.height - 1; t >= 0; t--) {
    for (var r = this.bottom_up ? t : this.height - 1 - t, n = 0; n < i; n++) {
      var s = this.datav.getUint8(this.pos++, !0), a = r * this.width * 4 + 2 * n * 4, o = s >> 4, A = 15 & s, l = this.palette[o];
      if (this.data[a] = l.blue, this.data[a + 1] = l.green, this.data[a + 2] = l.red, this.data[a + 3] = 255, 2 * n + 1 >= this.width)
        break;
      l = this.palette[A], this.data[a + 4] = l.blue, this.data[a + 4 + 1] = l.green, this.data[a + 4 + 2] = l.red, this.data[a + 4 + 3] = 255;
    }
    e !== 0 && (this.pos += 4 - e);
  }
}, ga.prototype.bit8 = function() {
  for (var i = this.width % 4, e = this.height - 1; e >= 0; e--) {
    for (var t = this.bottom_up ? e : this.height - 1 - e, r = 0; r < this.width; r++) {
      var n = this.datav.getUint8(this.pos++, !0), s = t * this.width * 4 + 4 * r;
      if (n < this.palette.length) {
        var a = this.palette[n];
        this.data[s] = a.red, this.data[s + 1] = a.green, this.data[s + 2] = a.blue, this.data[s + 3] = 255;
      } else
        this.data[s] = 255, this.data[s + 1] = 255, this.data[s + 2] = 255, this.data[s + 3] = 255;
    }
    i !== 0 && (this.pos += 4 - i);
  }
}, ga.prototype.bit15 = function() {
  for (var i = this.width % 3, e = parseInt("11111", 2), t = this.height - 1; t >= 0; t--) {
    for (var r = this.bottom_up ? t : this.height - 1 - t, n = 0; n < this.width; n++) {
      var s = this.datav.getUint16(this.pos, !0);
      this.pos += 2;
      var a = (s & e) / e * 255 | 0, o = (s >> 5 & e) / e * 255 | 0, A = (s >> 10 & e) / e * 255 | 0, l = s >> 15 ? 255 : 0, h = r * this.width * 4 + 4 * n;
      this.data[h] = A, this.data[h + 1] = o, this.data[h + 2] = a, this.data[h + 3] = l;
    }
    this.pos += i;
  }
}, ga.prototype.bit16 = function() {
  for (var i = this.width % 3, e = parseInt("11111", 2), t = parseInt("111111", 2), r = this.height - 1; r >= 0; r--) {
    for (var n = this.bottom_up ? r : this.height - 1 - r, s = 0; s < this.width; s++) {
      var a = this.datav.getUint16(this.pos, !0);
      this.pos += 2;
      var o = (a & e) / e * 255 | 0, A = (a >> 5 & t) / t * 255 | 0, l = (a >> 11) / e * 255 | 0, h = n * this.width * 4 + 4 * s;
      this.data[h] = l, this.data[h + 1] = A, this.data[h + 2] = o, this.data[h + 3] = 255;
    }
    this.pos += i;
  }
}, ga.prototype.bit24 = function() {
  for (var i = this.height - 1; i >= 0; i--) {
    for (var e = this.bottom_up ? i : this.height - 1 - i, t = 0; t < this.width; t++) {
      var r = this.datav.getUint8(this.pos++, !0), n = this.datav.getUint8(this.pos++, !0), s = this.datav.getUint8(this.pos++, !0), a = e * this.width * 4 + 4 * t;
      this.data[a] = s, this.data[a + 1] = n, this.data[a + 2] = r, this.data[a + 3] = 255;
    }
    this.pos += this.width % 4;
  }
}, ga.prototype.bit32 = function() {
  for (var i = this.height - 1; i >= 0; i--)
    for (var e = this.bottom_up ? i : this.height - 1 - i, t = 0; t < this.width; t++) {
      var r = this.datav.getUint8(this.pos++, !0), n = this.datav.getUint8(this.pos++, !0), s = this.datav.getUint8(this.pos++, !0), a = this.datav.getUint8(this.pos++, !0), o = e * this.width * 4 + 4 * t;
      this.data[o] = s, this.data[o + 1] = n, this.data[o + 2] = r, this.data[o + 3] = a;
    }
}, ga.prototype.getData = function() {
  return this.data;
}, /**
 * @license
 * Copyright (c) 2018 Aras Abbasi
 *
 * Licensed under the MIT License.
 * http://opensource.org/licenses/mit-license
 */
function(i) {
  i.processBMP = function(e, t, r, n) {
    var s = new ga(e, !1), a = s.width, o = s.height, A = { data: s.getData(), width: a, height: o }, l = new l_(100).encode(A, 100);
    return i.processJPEG.call(this, l, t, r, n);
  };
}(Lt.API), oT.prototype.getData = function() {
  return this.data;
}, /**
 * @license
 * Copyright (c) 2019 Aras Abbasi
 *
 * Licensed under the MIT License.
 * http://opensource.org/licenses/mit-license
 */
function(i) {
  i.processWEBP = function(e, t, r, n) {
    var s = new oT(e), a = s.width, o = s.height, A = { data: s.getData(), width: a, height: o }, l = new l_(100).encode(A, 100);
    return i.processJPEG.call(this, l, t, r, n);
  };
}(Lt.API), Lt.API.processRGBA = function(i, e, t) {
  for (var r = i.data, n = r.length, s = new Uint8Array(n / 4 * 3), a = new Uint8Array(n / 4), o = 0, A = 0, l = 0; l < n; l += 4) {
    var h = r[l], c = r[l + 1], u = r[l + 2], f = r[l + 3];
    s[o++] = h, s[o++] = c, s[o++] = u, a[A++] = f;
  }
  var g = this.__addimage__.arrayBufferToBinaryString(s);
  return { alpha: this.__addimage__.arrayBufferToBinaryString(a), data: g, index: e, alias: t, colorSpace: "DeviceRGB", bitsPerComponent: 8, width: i.width, height: i.height };
}, Lt.API.setLanguage = function(i) {
  return this.internal.languageSettings === void 0 && (this.internal.languageSettings = {}, this.internal.languageSettings.isSubscribed = !1), { af: "Afrikaans", sq: "Albanian", ar: "Arabic (Standard)", "ar-DZ": "Arabic (Algeria)", "ar-BH": "Arabic (Bahrain)", "ar-EG": "Arabic (Egypt)", "ar-IQ": "Arabic (Iraq)", "ar-JO": "Arabic (Jordan)", "ar-KW": "Arabic (Kuwait)", "ar-LB": "Arabic (Lebanon)", "ar-LY": "Arabic (Libya)", "ar-MA": "Arabic (Morocco)", "ar-OM": "Arabic (Oman)", "ar-QA": "Arabic (Qatar)", "ar-SA": "Arabic (Saudi Arabia)", "ar-SY": "Arabic (Syria)", "ar-TN": "Arabic (Tunisia)", "ar-AE": "Arabic (U.A.E.)", "ar-YE": "Arabic (Yemen)", an: "Aragonese", hy: "Armenian", as: "Assamese", ast: "Asturian", az: "Azerbaijani", eu: "Basque", be: "Belarusian", bn: "Bengali", bs: "Bosnian", br: "Breton", bg: "Bulgarian", my: "Burmese", ca: "Catalan", ch: "Chamorro", ce: "Chechen", zh: "Chinese", "zh-HK": "Chinese (Hong Kong)", "zh-CN": "Chinese (PRC)", "zh-SG": "Chinese (Singapore)", "zh-TW": "Chinese (Taiwan)", cv: "Chuvash", co: "Corsican", cr: "Cree", hr: "Croatian", cs: "Czech", da: "Danish", nl: "Dutch (Standard)", "nl-BE": "Dutch (Belgian)", en: "English", "en-AU": "English (Australia)", "en-BZ": "English (Belize)", "en-CA": "English (Canada)", "en-IE": "English (Ireland)", "en-JM": "English (Jamaica)", "en-NZ": "English (New Zealand)", "en-PH": "English (Philippines)", "en-ZA": "English (South Africa)", "en-TT": "English (Trinidad & Tobago)", "en-GB": "English (United Kingdom)", "en-US": "English (United States)", "en-ZW": "English (Zimbabwe)", eo: "Esperanto", et: "Estonian", fo: "Faeroese", fj: "Fijian", fi: "Finnish", fr: "French (Standard)", "fr-BE": "French (Belgium)", "fr-CA": "French (Canada)", "fr-FR": "French (France)", "fr-LU": "French (Luxembourg)", "fr-MC": "French (Monaco)", "fr-CH": "French (Switzerland)", fy: "Frisian", fur: "Friulian", gd: "Gaelic (Scots)", "gd-IE": "Gaelic (Irish)", gl: "Galacian", ka: "Georgian", de: "German (Standard)", "de-AT": "German (Austria)", "de-DE": "German (Germany)", "de-LI": "German (Liechtenstein)", "de-LU": "German (Luxembourg)", "de-CH": "German (Switzerland)", el: "Greek", gu: "Gujurati", ht: "Haitian", he: "Hebrew", hi: "Hindi", hu: "Hungarian", is: "Icelandic", id: "Indonesian", iu: "Inuktitut", ga: "Irish", it: "Italian (Standard)", "it-CH": "Italian (Switzerland)", ja: "Japanese", kn: "Kannada", ks: "Kashmiri", kk: "Kazakh", km: "Khmer", ky: "Kirghiz", tlh: "Klingon", ko: "Korean", "ko-KP": "Korean (North Korea)", "ko-KR": "Korean (South Korea)", la: "Latin", lv: "Latvian", lt: "Lithuanian", lb: "Luxembourgish", mk: "North Macedonia", ms: "Malay", ml: "Malayalam", mt: "Maltese", mi: "Maori", mr: "Marathi", mo: "Moldavian", nv: "Navajo", ng: "Ndonga", ne: "Nepali", no: "Norwegian", nb: "Norwegian (Bokmal)", nn: "Norwegian (Nynorsk)", oc: "Occitan", or: "Oriya", om: "Oromo", fa: "Persian", "fa-IR": "Persian/Iran", pl: "Polish", pt: "Portuguese", "pt-BR": "Portuguese (Brazil)", pa: "Punjabi", "pa-IN": "Punjabi (India)", "pa-PK": "Punjabi (Pakistan)", qu: "Quechua", rm: "Rhaeto-Romanic", ro: "Romanian", "ro-MO": "Romanian (Moldavia)", ru: "Russian", "ru-MO": "Russian (Moldavia)", sz: "Sami (Lappish)", sg: "Sango", sa: "Sanskrit", sc: "Sardinian", sd: "Sindhi", si: "Singhalese", sr: "Serbian", sk: "Slovak", sl: "Slovenian", so: "Somani", sb: "Sorbian", es: "Spanish", "es-AR": "Spanish (Argentina)", "es-BO": "Spanish (Bolivia)", "es-CL": "Spanish (Chile)", "es-CO": "Spanish (Colombia)", "es-CR": "Spanish (Costa Rica)", "es-DO": "Spanish (Dominican Republic)", "es-EC": "Spanish (Ecuador)", "es-SV": "Spanish (El Salvador)", "es-GT": "Spanish (Guatemala)", "es-HN": "Spanish (Honduras)", "es-MX": "Spanish (Mexico)", "es-NI": "Spanish (Nicaragua)", "es-PA": "Spanish (Panama)", "es-PY": "Spanish (Paraguay)", "es-PE": "Spanish (Peru)", "es-PR": "Spanish (Puerto Rico)", "es-ES": "Spanish (Spain)", "es-UY": "Spanish (Uruguay)", "es-VE": "Spanish (Venezuela)", sx: "Sutu", sw: "Swahili", sv: "Swedish", "sv-FI": "Swedish (Finland)", "sv-SV": "Swedish (Sweden)", ta: "Tamil", tt: "Tatar", te: "Teluga", th: "Thai", tig: "Tigre", ts: "Tsonga", tn: "Tswana", tr: "Turkish", tk: "Turkmen", uk: "Ukrainian", hsb: "Upper Sorbian", ur: "Urdu", ve: "Venda", vi: "Vietnamese", vo: "Volapuk", wa: "Walloon", cy: "Welsh", xh: "Xhosa", ji: "Yiddish", zu: "Zulu" }[i] !== void 0 && (this.internal.languageSettings.languageCode = i, this.internal.languageSettings.isSubscribed === !1 && (this.internal.events.subscribe("putCatalog", function() {
    this.internal.write("/Lang (" + this.internal.languageSettings.languageCode + ")");
  }), this.internal.languageSettings.isSubscribed = !0)), this;
}, lc = Lt.API, Gp = lc.getCharWidthsArray = function(i, e) {
  var t, r, n = (e = e || {}).font || this.internal.getFont(), s = e.fontSize || this.internal.getFontSize(), a = e.charSpace || this.internal.getCharSpace(), o = e.widths ? e.widths : n.metadata.Unicode.widths, A = o.fof ? o.fof : 1, l = e.kerning ? e.kerning : n.metadata.Unicode.kerning, h = l.fof ? l.fof : 1, c = e.doKerning !== !1, u = 0, f = i.length, g = 0, p = o[0] || A, y = [];
  for (t = 0; t < f; t++)
    r = i.charCodeAt(t), typeof n.metadata.widthOfString == "function" ? y.push((n.metadata.widthOfGlyph(n.metadata.characterToGlyph(r)) + a * (1e3 / s) || 0) / 1e3) : (u = c && $r(l[r]) === "object" && !isNaN(parseInt(l[r][g], 10)) ? l[r][g] / h : 0, y.push((o[r] || p) / A + u)), g = r;
  return y;
}, iT = lc.getStringUnitWidth = function(i, e) {
  var t = (e = e || {}).fontSize || this.internal.getFontSize(), r = e.font || this.internal.getFont(), n = e.charSpace || this.internal.getCharSpace();
  return lc.processArabic && (i = lc.processArabic(i)), typeof r.metadata.widthOfString == "function" ? r.metadata.widthOfString(i, t, n) / t : Gp.apply(this, arguments).reduce(function(s, a) {
    return s + a;
  }, 0);
}, nT = function(i, e, t, r) {
  for (var n = [], s = 0, a = i.length, o = 0; s !== a && o + e[s] < t; )
    o += e[s], s++;
  n.push(i.slice(0, s));
  var A = s;
  for (o = 0; s !== a; )
    o + e[s] > r && (n.push(i.slice(A, s)), o = 0, A = s), o += e[s], s++;
  return A !== s && n.push(i.slice(A, s)), n;
}, sT = function(i, e, t) {
  t || (t = {});
  var r, n, s, a, o, A, l, h = [], c = [h], u = t.textIndent || 0, f = 0, g = 0, p = i.split(" "), y = Gp.apply(this, [" ", t])[0];
  if (A = t.lineIndent === -1 ? p[0].length + 2 : t.lineIndent || 0) {
    var v = Array(A).join(" "), w = [];
    p.map(function(E) {
      (E = E.split(/\s*\n/)).length > 1 ? w = w.concat(E.map(function(S, M) {
        return (M && S.length ? `
` : "") + S;
      })) : w.push(E[0]);
    }), p = w, A = iT.apply(this, [v, t]);
  }
  for (s = 0, a = p.length; s < a; s++) {
    var C = 0;
    if (r = p[s], A && r[0] == `
` && (r = r.substr(1), C = 1), u + f + (g = (n = Gp.apply(this, [r, t])).reduce(function(E, S) {
      return E + S;
    }, 0)) > e || C) {
      if (g > e) {
        for (o = nT.apply(this, [r, n, e - (u + f), e]), h.push(o.shift()), h = [o.pop()]; o.length; )
          c.push([o.shift()]);
        g = n.slice(r.length - (h[0] ? h[0].length : 0)).reduce(function(E, S) {
          return E + S;
        }, 0);
      } else
        h = [r];
      c.push(h), u = g + A, f = y;
    } else
      h.push(r), u += f + g, f = y;
  }
  return l = A ? function(E, S) {
    return (S ? v : "") + E.join(" ");
  } : function(E) {
    return E.join(" ");
  }, c.map(l);
}, lc.splitTextToSize = function(i, e, t) {
  var r, n = (t = t || {}).fontSize || this.internal.getFontSize(), s = function(h) {
    if (h.widths && h.kerning)
      return { widths: h.widths, kerning: h.kerning };
    var c = this.internal.getFont(h.fontName, h.fontStyle);
    return c.metadata.Unicode ? { widths: c.metadata.Unicode.widths || { 0: 1 }, kerning: c.metadata.Unicode.kerning || {} } : { font: c.metadata, fontSize: this.internal.getFontSize(), charSpace: this.internal.getCharSpace() };
  }.call(this, t);
  r = Array.isArray(i) ? i : String(i).split(/\r?\n/);
  var a = 1 * this.internal.scaleFactor * e / n;
  s.textIndent = t.textIndent ? 1 * t.textIndent * this.internal.scaleFactor / n : 0, s.lineIndent = t.lineIndent;
  var o, A, l = [];
  for (o = 0, A = r.length; o < A; o++)
    l = l.concat(sT.apply(this, [r[o], a, s]));
  return l;
}, function(i) {
  i.__fontmetrics__ = i.__fontmetrics__ || {};
  for (var e = "klmnopqrstuvwxyz", t = {}, r = {}, n = 0; n < e.length; n++)
    t[e[n]] = "0123456789abcdef"[n], r["0123456789abcdef"[n]] = e[n];
  var s = function(c) {
    return "0x" + parseInt(c, 10).toString(16);
  }, a = i.__fontmetrics__.compress = function(c) {
    var u, f, g, p, y = ["{"];
    for (var v in c) {
      if (u = c[v], isNaN(parseInt(v, 10)) ? f = "'" + v + "'" : (v = parseInt(v, 10), f = (f = s(v).slice(2)).slice(0, -1) + r[f.slice(-1)]), typeof u == "number")
        u < 0 ? (g = s(u).slice(3), p = "-") : (g = s(u).slice(2), p = ""), g = p + g.slice(0, -1) + r[g.slice(-1)];
      else {
        if ($r(u) !== "object")
          throw new Error("Don't know what to do with value type " + $r(u) + ".");
        g = a(u);
      }
      y.push(f + g);
    }
    return y.push("}"), y.join("");
  }, o = i.__fontmetrics__.uncompress = function(c) {
    if (typeof c != "string")
      throw new Error("Invalid argument passed to uncompress.");
    for (var u, f, g, p, y = {}, v = 1, w = y, C = [], E = "", S = "", M = c.length - 1, T = 1; T < M; T += 1)
      (p = c[T]) == "'" ? u ? (g = u.join(""), u = void 0) : u = [] : u ? u.push(p) : p == "{" ? (C.push([w, g]), w = {}, g = void 0) : p == "}" ? ((f = C.pop())[0][f[1]] = w, g = void 0, w = f[0]) : p == "-" ? v = -1 : g === void 0 ? t.hasOwnProperty(p) ? (E += t[p], g = parseInt(E, 16) * v, v = 1, E = "") : E += p : t.hasOwnProperty(p) ? (S += t[p], w[g] = parseInt(S, 16) * v, v = 1, g = void 0, S = "") : S += p;
    return y;
  }, A = { codePages: ["WinAnsiEncoding"], WinAnsiEncoding: o("{19m8n201n9q201o9r201s9l201t9m201u8m201w9n201x9o201y8o202k8q202l8r202m9p202q8p20aw8k203k8t203t8v203u9v2cq8s212m9t15m8w15n9w2dw9s16k8u16l9u17s9z17x8y17y9y}") }, l = { Unicode: { Courier: A, "Courier-Bold": A, "Courier-BoldOblique": A, "Courier-Oblique": A, Helvetica: A, "Helvetica-Bold": A, "Helvetica-BoldOblique": A, "Helvetica-Oblique": A, "Times-Roman": A, "Times-Bold": A, "Times-BoldItalic": A, "Times-Italic": A } }, h = { Unicode: { "Courier-Oblique": o("{'widths'{k3w'fof'6o}'kerning'{'fof'-6o}}"), "Times-BoldItalic": o("{'widths'{k3o2q4ycx2r201n3m201o6o201s2l201t2l201u2l201w3m201x3m201y3m2k1t2l2r202m2n2n3m2o3m2p5n202q6o2r1w2s2l2t2l2u3m2v3t2w1t2x2l2y1t2z1w3k3m3l3m3m3m3n3m3o3m3p3m3q3m3r3m3s3m203t2l203u2l3v2l3w3t3x3t3y3t3z3m4k5n4l4m4m4m4n4m4o4s4p4m4q4m4r4s4s4y4t2r4u3m4v4m4w3x4x5t4y4s4z4s5k3x5l4s5m4m5n3r5o3x5p4s5q4m5r5t5s4m5t3x5u3x5v2l5w1w5x2l5y3t5z3m6k2l6l3m6m3m6n2w6o3m6p2w6q2l6r3m6s3r6t1w6u1w6v3m6w1w6x4y6y3r6z3m7k3m7l3m7m2r7n2r7o1w7p3r7q2w7r4m7s3m7t2w7u2r7v2n7w1q7x2n7y3t202l3mcl4mal2ram3man3mao3map3mar3mas2lat4uau1uav3maw3way4uaz2lbk2sbl3t'fof'6obo2lbp3tbq3mbr1tbs2lbu1ybv3mbz3mck4m202k3mcm4mcn4mco4mcp4mcq5ycr4mcs4mct4mcu4mcv4mcw2r2m3rcy2rcz2rdl4sdm4sdn4sdo4sdp4sdq4sds4sdt4sdu4sdv4sdw4sdz3mek3mel3mem3men3meo3mep3meq4ser2wes2wet2weu2wev2wew1wex1wey1wez1wfl3rfm3mfn3mfo3mfp3mfq3mfr3tfs3mft3rfu3rfv3rfw3rfz2w203k6o212m6o2dw2l2cq2l3t3m3u2l17s3x19m3m}'kerning'{cl{4qu5kt5qt5rs17ss5ts}201s{201ss}201t{cks4lscmscnscoscpscls2wu2yu201ts}201x{2wu2yu}2k{201ts}2w{4qx5kx5ou5qx5rs17su5tu}2x{17su5tu5ou}2y{4qx5kx5ou5qx5rs17ss5ts}'fof'-6ofn{17sw5tw5ou5qw5rs}7t{cksclscmscnscoscps4ls}3u{17su5tu5os5qs}3v{17su5tu5os5qs}7p{17su5tu}ck{4qu5kt5qt5rs17ss5ts}4l{4qu5kt5qt5rs17ss5ts}cm{4qu5kt5qt5rs17ss5ts}cn{4qu5kt5qt5rs17ss5ts}co{4qu5kt5qt5rs17ss5ts}cp{4qu5kt5qt5rs17ss5ts}6l{4qu5ou5qw5rt17su5tu}5q{ckuclucmucnucoucpu4lu}5r{ckuclucmucnucoucpu4lu}7q{cksclscmscnscoscps4ls}6p{4qu5ou5qw5rt17sw5tw}ek{4qu5ou5qw5rt17su5tu}el{4qu5ou5qw5rt17su5tu}em{4qu5ou5qw5rt17su5tu}en{4qu5ou5qw5rt17su5tu}eo{4qu5ou5qw5rt17su5tu}ep{4qu5ou5qw5rt17su5tu}es{17ss5ts5qs4qu}et{4qu5ou5qw5rt17sw5tw}eu{4qu5ou5qw5rt17ss5ts}ev{17ss5ts5qs4qu}6z{17sw5tw5ou5qw5rs}fm{17sw5tw5ou5qw5rs}7n{201ts}fo{17sw5tw5ou5qw5rs}fp{17sw5tw5ou5qw5rs}fq{17sw5tw5ou5qw5rs}7r{cksclscmscnscoscps4ls}fs{17sw5tw5ou5qw5rs}ft{17su5tu}fu{17su5tu}fv{17su5tu}fw{17su5tu}fz{cksclscmscnscoscps4ls}}}"), "Helvetica-Bold": o("{'widths'{k3s2q4scx1w201n3r201o6o201s1w201t1w201u1w201w3m201x3m201y3m2k1w2l2l202m2n2n3r2o3r2p5t202q6o2r1s2s2l2t2l2u2r2v3u2w1w2x2l2y1w2z1w3k3r3l3r3m3r3n3r3o3r3p3r3q3r3r3r3s3r203t2l203u2l3v2l3w3u3x3u3y3u3z3x4k6l4l4s4m4s4n4s4o4s4p4m4q3x4r4y4s4s4t1w4u3r4v4s4w3x4x5n4y4s4z4y5k4m5l4y5m4s5n4m5o3x5p4s5q4m5r5y5s4m5t4m5u3x5v2l5w1w5x2l5y3u5z3r6k2l6l3r6m3x6n3r6o3x6p3r6q2l6r3x6s3x6t1w6u1w6v3r6w1w6x5t6y3x6z3x7k3x7l3x7m2r7n3r7o2l7p3x7q3r7r4y7s3r7t3r7u3m7v2r7w1w7x2r7y3u202l3rcl4sal2lam3ran3rao3rap3rar3ras2lat4tau2pav3raw3uay4taz2lbk2sbl3u'fof'6obo2lbp3xbq3rbr1wbs2lbu2obv3rbz3xck4s202k3rcm4scn4sco4scp4scq6ocr4scs4mct4mcu4mcv4mcw1w2m2zcy1wcz1wdl4sdm4ydn4ydo4ydp4ydq4yds4ydt4sdu4sdv4sdw4sdz3xek3rel3rem3ren3reo3rep3req5ter3res3ret3reu3rev3rew1wex1wey1wez1wfl3xfm3xfn3xfo3xfp3xfq3xfr3ufs3xft3xfu3xfv3xfw3xfz3r203k6o212m6o2dw2l2cq2l3t3r3u2l17s4m19m3r}'kerning'{cl{4qs5ku5ot5qs17sv5tv}201t{2ww4wy2yw}201w{2ks}201x{2ww4wy2yw}2k{201ts201xs}2w{7qs4qu5kw5os5qw5rs17su5tu7tsfzs}2x{5ow5qs}2y{7qs4qu5kw5os5qw5rs17su5tu7tsfzs}'fof'-6o7p{17su5tu5ot}ck{4qs5ku5ot5qs17sv5tv}4l{4qs5ku5ot5qs17sv5tv}cm{4qs5ku5ot5qs17sv5tv}cn{4qs5ku5ot5qs17sv5tv}co{4qs5ku5ot5qs17sv5tv}cp{4qs5ku5ot5qs17sv5tv}6l{17st5tt5os}17s{2kwclvcmvcnvcovcpv4lv4wwckv}5o{2kucltcmtcntcotcpt4lt4wtckt}5q{2ksclscmscnscoscps4ls4wvcks}5r{2ks4ws}5t{2kwclvcmvcnvcovcpv4lv4wwckv}eo{17st5tt5os}fu{17su5tu5ot}6p{17ss5ts}ek{17st5tt5os}el{17st5tt5os}em{17st5tt5os}en{17st5tt5os}6o{201ts}ep{17st5tt5os}es{17ss5ts}et{17ss5ts}eu{17ss5ts}ev{17ss5ts}6z{17su5tu5os5qt}fm{17su5tu5os5qt}fn{17su5tu5os5qt}fo{17su5tu5os5qt}fp{17su5tu5os5qt}fq{17su5tu5os5qt}fs{17su5tu5os5qt}ft{17su5tu5ot}7m{5os}fv{17su5tu5ot}fw{17su5tu5ot}}}"), Courier: o("{'widths'{k3w'fof'6o}'kerning'{'fof'-6o}}"), "Courier-BoldOblique": o("{'widths'{k3w'fof'6o}'kerning'{'fof'-6o}}"), "Times-Bold": o("{'widths'{k3q2q5ncx2r201n3m201o6o201s2l201t2l201u2l201w3m201x3m201y3m2k1t2l2l202m2n2n3m2o3m2p6o202q6o2r1w2s2l2t2l2u3m2v3t2w1t2x2l2y1t2z1w3k3m3l3m3m3m3n3m3o3m3p3m3q3m3r3m3s3m203t2l203u2l3v2l3w3t3x3t3y3t3z3m4k5x4l4s4m4m4n4s4o4s4p4m4q3x4r4y4s4y4t2r4u3m4v4y4w4m4x5y4y4s4z4y5k3x5l4y5m4s5n3r5o4m5p4s5q4s5r6o5s4s5t4s5u4m5v2l5w1w5x2l5y3u5z3m6k2l6l3m6m3r6n2w6o3r6p2w6q2l6r3m6s3r6t1w6u2l6v3r6w1w6x5n6y3r6z3m7k3r7l3r7m2w7n2r7o2l7p3r7q3m7r4s7s3m7t3m7u2w7v2r7w1q7x2r7y3o202l3mcl4sal2lam3man3mao3map3mar3mas2lat4uau1yav3maw3tay4uaz2lbk2sbl3t'fof'6obo2lbp3rbr1tbs2lbu2lbv3mbz3mck4s202k3mcm4scn4sco4scp4scq6ocr4scs4mct4mcu4mcv4mcw2r2m3rcy2rcz2rdl4sdm4ydn4ydo4ydp4ydq4yds4ydt4sdu4sdv4sdw4sdz3rek3mel3mem3men3meo3mep3meq4ser2wes2wet2weu2wev2wew1wex1wey1wez1wfl3rfm3mfn3mfo3mfp3mfq3mfr3tfs3mft3rfu3rfv3rfw3rfz3m203k6o212m6o2dw2l2cq2l3t3m3u2l17s4s19m3m}'kerning'{cl{4qt5ks5ot5qy5rw17sv5tv}201t{cks4lscmscnscoscpscls4wv}2k{201ts}2w{4qu5ku7mu5os5qx5ru17su5tu}2x{17su5tu5ou5qs}2y{4qv5kv7mu5ot5qz5ru17su5tu}'fof'-6o7t{cksclscmscnscoscps4ls}3u{17su5tu5os5qu}3v{17su5tu5os5qu}fu{17su5tu5ou5qu}7p{17su5tu5ou5qu}ck{4qt5ks5ot5qy5rw17sv5tv}4l{4qt5ks5ot5qy5rw17sv5tv}cm{4qt5ks5ot5qy5rw17sv5tv}cn{4qt5ks5ot5qy5rw17sv5tv}co{4qt5ks5ot5qy5rw17sv5tv}cp{4qt5ks5ot5qy5rw17sv5tv}6l{17st5tt5ou5qu}17s{ckuclucmucnucoucpu4lu4wu}5o{ckuclucmucnucoucpu4lu4wu}5q{ckzclzcmzcnzcozcpz4lz4wu}5r{ckxclxcmxcnxcoxcpx4lx4wu}5t{ckuclucmucnucoucpu4lu4wu}7q{ckuclucmucnucoucpu4lu}6p{17sw5tw5ou5qu}ek{17st5tt5qu}el{17st5tt5ou5qu}em{17st5tt5qu}en{17st5tt5qu}eo{17st5tt5qu}ep{17st5tt5ou5qu}es{17ss5ts5qu}et{17sw5tw5ou5qu}eu{17sw5tw5ou5qu}ev{17ss5ts5qu}6z{17sw5tw5ou5qu5rs}fm{17sw5tw5ou5qu5rs}fn{17sw5tw5ou5qu5rs}fo{17sw5tw5ou5qu5rs}fp{17sw5tw5ou5qu5rs}fq{17sw5tw5ou5qu5rs}7r{cktcltcmtcntcotcpt4lt5os}fs{17sw5tw5ou5qu5rs}ft{17su5tu5ou5qu}7m{5os}fv{17su5tu5ou5qu}fw{17su5tu5ou5qu}fz{cksclscmscnscoscps4ls}}}"), Symbol: o("{'widths'{k3uaw4r19m3m2k1t2l2l202m2y2n3m2p5n202q6o3k3m2s2l2t2l2v3r2w1t3m3m2y1t2z1wbk2sbl3r'fof'6o3n3m3o3m3p3m3q3m3r3m3s3m3t3m3u1w3v1w3w3r3x3r3y3r3z2wbp3t3l3m5v2l5x2l5z3m2q4yfr3r7v3k7w1o7x3k}'kerning'{'fof'-6o}}"), Helvetica: o("{'widths'{k3p2q4mcx1w201n3r201o6o201s1q201t1q201u1q201w2l201x2l201y2l2k1w2l1w202m2n2n3r2o3r2p5t202q6o2r1n2s2l2t2l2u2r2v3u2w1w2x2l2y1w2z1w3k3r3l3r3m3r3n3r3o3r3p3r3q3r3r3r3s3r203t2l203u2l3v1w3w3u3x3u3y3u3z3r4k6p4l4m4m4m4n4s4o4s4p4m4q3x4r4y4s4s4t1w4u3m4v4m4w3r4x5n4y4s4z4y5k4m5l4y5m4s5n4m5o3x5p4s5q4m5r5y5s4m5t4m5u3x5v1w5w1w5x1w5y2z5z3r6k2l6l3r6m3r6n3m6o3r6p3r6q1w6r3r6s3r6t1q6u1q6v3m6w1q6x5n6y3r6z3r7k3r7l3r7m2l7n3m7o1w7p3r7q3m7r4s7s3m7t3m7u3m7v2l7w1u7x2l7y3u202l3rcl4mal2lam3ran3rao3rap3rar3ras2lat4tau2pav3raw3uay4taz2lbk2sbl3u'fof'6obo2lbp3rbr1wbs2lbu2obv3rbz3xck4m202k3rcm4mcn4mco4mcp4mcq6ocr4scs4mct4mcu4mcv4mcw1w2m2ncy1wcz1wdl4sdm4ydn4ydo4ydp4ydq4yds4ydt4sdu4sdv4sdw4sdz3xek3rel3rem3ren3reo3rep3req5ter3mes3ret3reu3rev3rew1wex1wey1wez1wfl3rfm3rfn3rfo3rfp3rfq3rfr3ufs3xft3rfu3rfv3rfw3rfz3m203k6o212m6o2dw2l2cq2l3t3r3u1w17s4m19m3r}'kerning'{5q{4wv}cl{4qs5kw5ow5qs17sv5tv}201t{2wu4w1k2yu}201x{2wu4wy2yu}17s{2ktclucmucnu4otcpu4lu4wycoucku}2w{7qs4qz5k1m17sy5ow5qx5rsfsu5ty7tufzu}2x{17sy5ty5oy5qs}2y{7qs4qz5k1m17sy5ow5qx5rsfsu5ty7tufzu}'fof'-6o7p{17sv5tv5ow}ck{4qs5kw5ow5qs17sv5tv}4l{4qs5kw5ow5qs17sv5tv}cm{4qs5kw5ow5qs17sv5tv}cn{4qs5kw5ow5qs17sv5tv}co{4qs5kw5ow5qs17sv5tv}cp{4qs5kw5ow5qs17sv5tv}6l{17sy5ty5ow}do{17st5tt}4z{17st5tt}7s{fst}dm{17st5tt}dn{17st5tt}5o{ckwclwcmwcnwcowcpw4lw4wv}dp{17st5tt}dq{17st5tt}7t{5ow}ds{17st5tt}5t{2ktclucmucnu4otcpu4lu4wycoucku}fu{17sv5tv5ow}6p{17sy5ty5ow5qs}ek{17sy5ty5ow}el{17sy5ty5ow}em{17sy5ty5ow}en{5ty}eo{17sy5ty5ow}ep{17sy5ty5ow}es{17sy5ty5qs}et{17sy5ty5ow5qs}eu{17sy5ty5ow5qs}ev{17sy5ty5ow5qs}6z{17sy5ty5ow5qs}fm{17sy5ty5ow5qs}fn{17sy5ty5ow5qs}fo{17sy5ty5ow5qs}fp{17sy5ty5qs}fq{17sy5ty5ow5qs}7r{5ow}fs{17sy5ty5ow5qs}ft{17sv5tv5ow}7m{5ow}fv{17sv5tv5ow}fw{17sv5tv5ow}}}"), "Helvetica-BoldOblique": o("{'widths'{k3s2q4scx1w201n3r201o6o201s1w201t1w201u1w201w3m201x3m201y3m2k1w2l2l202m2n2n3r2o3r2p5t202q6o2r1s2s2l2t2l2u2r2v3u2w1w2x2l2y1w2z1w3k3r3l3r3m3r3n3r3o3r3p3r3q3r3r3r3s3r203t2l203u2l3v2l3w3u3x3u3y3u3z3x4k6l4l4s4m4s4n4s4o4s4p4m4q3x4r4y4s4s4t1w4u3r4v4s4w3x4x5n4y4s4z4y5k4m5l4y5m4s5n4m5o3x5p4s5q4m5r5y5s4m5t4m5u3x5v2l5w1w5x2l5y3u5z3r6k2l6l3r6m3x6n3r6o3x6p3r6q2l6r3x6s3x6t1w6u1w6v3r6w1w6x5t6y3x6z3x7k3x7l3x7m2r7n3r7o2l7p3x7q3r7r4y7s3r7t3r7u3m7v2r7w1w7x2r7y3u202l3rcl4sal2lam3ran3rao3rap3rar3ras2lat4tau2pav3raw3uay4taz2lbk2sbl3u'fof'6obo2lbp3xbq3rbr1wbs2lbu2obv3rbz3xck4s202k3rcm4scn4sco4scp4scq6ocr4scs4mct4mcu4mcv4mcw1w2m2zcy1wcz1wdl4sdm4ydn4ydo4ydp4ydq4yds4ydt4sdu4sdv4sdw4sdz3xek3rel3rem3ren3reo3rep3req5ter3res3ret3reu3rev3rew1wex1wey1wez1wfl3xfm3xfn3xfo3xfp3xfq3xfr3ufs3xft3xfu3xfv3xfw3xfz3r203k6o212m6o2dw2l2cq2l3t3r3u2l17s4m19m3r}'kerning'{cl{4qs5ku5ot5qs17sv5tv}201t{2ww4wy2yw}201w{2ks}201x{2ww4wy2yw}2k{201ts201xs}2w{7qs4qu5kw5os5qw5rs17su5tu7tsfzs}2x{5ow5qs}2y{7qs4qu5kw5os5qw5rs17su5tu7tsfzs}'fof'-6o7p{17su5tu5ot}ck{4qs5ku5ot5qs17sv5tv}4l{4qs5ku5ot5qs17sv5tv}cm{4qs5ku5ot5qs17sv5tv}cn{4qs5ku5ot5qs17sv5tv}co{4qs5ku5ot5qs17sv5tv}cp{4qs5ku5ot5qs17sv5tv}6l{17st5tt5os}17s{2kwclvcmvcnvcovcpv4lv4wwckv}5o{2kucltcmtcntcotcpt4lt4wtckt}5q{2ksclscmscnscoscps4ls4wvcks}5r{2ks4ws}5t{2kwclvcmvcnvcovcpv4lv4wwckv}eo{17st5tt5os}fu{17su5tu5ot}6p{17ss5ts}ek{17st5tt5os}el{17st5tt5os}em{17st5tt5os}en{17st5tt5os}6o{201ts}ep{17st5tt5os}es{17ss5ts}et{17ss5ts}eu{17ss5ts}ev{17ss5ts}6z{17su5tu5os5qt}fm{17su5tu5os5qt}fn{17su5tu5os5qt}fo{17su5tu5os5qt}fp{17su5tu5os5qt}fq{17su5tu5os5qt}fs{17su5tu5os5qt}ft{17su5tu5ot}7m{5os}fv{17su5tu5ot}fw{17su5tu5ot}}}"), ZapfDingbats: o("{'widths'{k4u2k1w'fof'6o}'kerning'{'fof'-6o}}"), "Courier-Bold": o("{'widths'{k3w'fof'6o}'kerning'{'fof'-6o}}"), "Times-Italic": o("{'widths'{k3n2q4ycx2l201n3m201o5t201s2l201t2l201u2l201w3r201x3r201y3r2k1t2l2l202m2n2n3m2o3m2p5n202q5t2r1p2s2l2t2l2u3m2v4n2w1t2x2l2y1t2z1w3k3m3l3m3m3m3n3m3o3m3p3m3q3m3r3m3s3m203t2l203u2l3v2l3w4n3x4n3y4n3z3m4k5w4l3x4m3x4n4m4o4s4p3x4q3x4r4s4s4s4t2l4u2w4v4m4w3r4x5n4y4m4z4s5k3x5l4s5m3x5n3m5o3r5p4s5q3x5r5n5s3x5t3r5u3r5v2r5w1w5x2r5y2u5z3m6k2l6l3m6m3m6n2w6o3m6p2w6q1w6r3m6s3m6t1w6u1w6v2w6w1w6x4s6y3m6z3m7k3m7l3m7m2r7n2r7o1w7p3m7q2w7r4m7s2w7t2w7u2r7v2s7w1v7x2s7y3q202l3mcl3xal2ram3man3mao3map3mar3mas2lat4wau1vav3maw4nay4waz2lbk2sbl4n'fof'6obo2lbp3mbq3obr1tbs2lbu1zbv3mbz3mck3x202k3mcm3xcn3xco3xcp3xcq5tcr4mcs3xct3xcu3xcv3xcw2l2m2ucy2lcz2ldl4mdm4sdn4sdo4sdp4sdq4sds4sdt4sdu4sdv4sdw4sdz3mek3mel3mem3men3meo3mep3meq4mer2wes2wet2weu2wev2wew1wex1wey1wez1wfl3mfm3mfn3mfo3mfp3mfq3mfr4nfs3mft3mfu3mfv3mfw3mfz2w203k6o212m6m2dw2l2cq2l3t3m3u2l17s3r19m3m}'kerning'{cl{5kt4qw}201s{201sw}201t{201tw2wy2yy6q-t}201x{2wy2yy}2k{201tw}2w{7qs4qy7rs5ky7mw5os5qx5ru17su5tu}2x{17ss5ts5os}2y{7qs4qy7rs5ky7mw5os5qx5ru17su5tu}'fof'-6o6t{17ss5ts5qs}7t{5os}3v{5qs}7p{17su5tu5qs}ck{5kt4qw}4l{5kt4qw}cm{5kt4qw}cn{5kt4qw}co{5kt4qw}cp{5kt4qw}6l{4qs5ks5ou5qw5ru17su5tu}17s{2ks}5q{ckvclvcmvcnvcovcpv4lv}5r{ckuclucmucnucoucpu4lu}5t{2ks}6p{4qs5ks5ou5qw5ru17su5tu}ek{4qs5ks5ou5qw5ru17su5tu}el{4qs5ks5ou5qw5ru17su5tu}em{4qs5ks5ou5qw5ru17su5tu}en{4qs5ks5ou5qw5ru17su5tu}eo{4qs5ks5ou5qw5ru17su5tu}ep{4qs5ks5ou5qw5ru17su5tu}es{5ks5qs4qs}et{4qs5ks5ou5qw5ru17su5tu}eu{4qs5ks5qw5ru17su5tu}ev{5ks5qs4qs}ex{17ss5ts5qs}6z{4qv5ks5ou5qw5ru17su5tu}fm{4qv5ks5ou5qw5ru17su5tu}fn{4qv5ks5ou5qw5ru17su5tu}fo{4qv5ks5ou5qw5ru17su5tu}fp{4qv5ks5ou5qw5ru17su5tu}fq{4qv5ks5ou5qw5ru17su5tu}7r{5os}fs{4qv5ks5ou5qw5ru17su5tu}ft{17su5tu5qs}fu{17su5tu5qs}fv{17su5tu5qs}fw{17su5tu5qs}}}"), "Times-Roman": o("{'widths'{k3n2q4ycx2l201n3m201o6o201s2l201t2l201u2l201w2w201x2w201y2w2k1t2l2l202m2n2n3m2o3m2p5n202q6o2r1m2s2l2t2l2u3m2v3s2w1t2x2l2y1t2z1w3k3m3l3m3m3m3n3m3o3m3p3m3q3m3r3m3s3m203t2l203u2l3v1w3w3s3x3s3y3s3z2w4k5w4l4s4m4m4n4m4o4s4p3x4q3r4r4s4s4s4t2l4u2r4v4s4w3x4x5t4y4s4z4s5k3r5l4s5m4m5n3r5o3x5p4s5q4s5r5y5s4s5t4s5u3x5v2l5w1w5x2l5y2z5z3m6k2l6l2w6m3m6n2w6o3m6p2w6q2l6r3m6s3m6t1w6u1w6v3m6w1w6x4y6y3m6z3m7k3m7l3m7m2l7n2r7o1w7p3m7q3m7r4s7s3m7t3m7u2w7v3k7w1o7x3k7y3q202l3mcl4sal2lam3man3mao3map3mar3mas2lat4wau1vav3maw3say4waz2lbk2sbl3s'fof'6obo2lbp3mbq2xbr1tbs2lbu1zbv3mbz2wck4s202k3mcm4scn4sco4scp4scq5tcr4mcs3xct3xcu3xcv3xcw2l2m2tcy2lcz2ldl4sdm4sdn4sdo4sdp4sdq4sds4sdt4sdu4sdv4sdw4sdz3mek2wel2wem2wen2weo2wep2weq4mer2wes2wet2weu2wev2wew1wex1wey1wez1wfl3mfm3mfn3mfo3mfp3mfq3mfr3sfs3mft3mfu3mfv3mfw3mfz3m203k6o212m6m2dw2l2cq2l3t3m3u1w17s4s19m3m}'kerning'{cl{4qs5ku17sw5ou5qy5rw201ss5tw201ws}201s{201ss}201t{ckw4lwcmwcnwcowcpwclw4wu201ts}2k{201ts}2w{4qs5kw5os5qx5ru17sx5tx}2x{17sw5tw5ou5qu}2y{4qs5kw5os5qx5ru17sx5tx}'fof'-6o7t{ckuclucmucnucoucpu4lu5os5rs}3u{17su5tu5qs}3v{17su5tu5qs}7p{17sw5tw5qs}ck{4qs5ku17sw5ou5qy5rw201ss5tw201ws}4l{4qs5ku17sw5ou5qy5rw201ss5tw201ws}cm{4qs5ku17sw5ou5qy5rw201ss5tw201ws}cn{4qs5ku17sw5ou5qy5rw201ss5tw201ws}co{4qs5ku17sw5ou5qy5rw201ss5tw201ws}cp{4qs5ku17sw5ou5qy5rw201ss5tw201ws}6l{17su5tu5os5qw5rs}17s{2ktclvcmvcnvcovcpv4lv4wuckv}5o{ckwclwcmwcnwcowcpw4lw4wu}5q{ckyclycmycnycoycpy4ly4wu5ms}5r{cktcltcmtcntcotcpt4lt4ws}5t{2ktclvcmvcnvcovcpv4lv4wuckv}7q{cksclscmscnscoscps4ls}6p{17su5tu5qw5rs}ek{5qs5rs}el{17su5tu5os5qw5rs}em{17su5tu5os5qs5rs}en{17su5qs5rs}eo{5qs5rs}ep{17su5tu5os5qw5rs}es{5qs}et{17su5tu5qw5rs}eu{17su5tu5qs5rs}ev{5qs}6z{17sv5tv5os5qx5rs}fm{5os5qt5rs}fn{17sv5tv5os5qx5rs}fo{17sv5tv5os5qx5rs}fp{5os5qt5rs}fq{5os5qt5rs}7r{ckuclucmucnucoucpu4lu5os}fs{17sv5tv5os5qx5rs}ft{17ss5ts5qs}fu{17sw5tw5qs}fv{17sw5tw5qs}fw{17ss5ts5qs}fz{ckuclucmucnucoucpu4lu5os5rs}}}"), "Helvetica-Oblique": o("{'widths'{k3p2q4mcx1w201n3r201o6o201s1q201t1q201u1q201w2l201x2l201y2l2k1w2l1w202m2n2n3r2o3r2p5t202q6o2r1n2s2l2t2l2u2r2v3u2w1w2x2l2y1w2z1w3k3r3l3r3m3r3n3r3o3r3p3r3q3r3r3r3s3r203t2l203u2l3v1w3w3u3x3u3y3u3z3r4k6p4l4m4m4m4n4s4o4s4p4m4q3x4r4y4s4s4t1w4u3m4v4m4w3r4x5n4y4s4z4y5k4m5l4y5m4s5n4m5o3x5p4s5q4m5r5y5s4m5t4m5u3x5v1w5w1w5x1w5y2z5z3r6k2l6l3r6m3r6n3m6o3r6p3r6q1w6r3r6s3r6t1q6u1q6v3m6w1q6x5n6y3r6z3r7k3r7l3r7m2l7n3m7o1w7p3r7q3m7r4s7s3m7t3m7u3m7v2l7w1u7x2l7y3u202l3rcl4mal2lam3ran3rao3rap3rar3ras2lat4tau2pav3raw3uay4taz2lbk2sbl3u'fof'6obo2lbp3rbr1wbs2lbu2obv3rbz3xck4m202k3rcm4mcn4mco4mcp4mcq6ocr4scs4mct4mcu4mcv4mcw1w2m2ncy1wcz1wdl4sdm4ydn4ydo4ydp4ydq4yds4ydt4sdu4sdv4sdw4sdz3xek3rel3rem3ren3reo3rep3req5ter3mes3ret3reu3rev3rew1wex1wey1wez1wfl3rfm3rfn3rfo3rfp3rfq3rfr3ufs3xft3rfu3rfv3rfw3rfz3m203k6o212m6o2dw2l2cq2l3t3r3u1w17s4m19m3r}'kerning'{5q{4wv}cl{4qs5kw5ow5qs17sv5tv}201t{2wu4w1k2yu}201x{2wu4wy2yu}17s{2ktclucmucnu4otcpu4lu4wycoucku}2w{7qs4qz5k1m17sy5ow5qx5rsfsu5ty7tufzu}2x{17sy5ty5oy5qs}2y{7qs4qz5k1m17sy5ow5qx5rsfsu5ty7tufzu}'fof'-6o7p{17sv5tv5ow}ck{4qs5kw5ow5qs17sv5tv}4l{4qs5kw5ow5qs17sv5tv}cm{4qs5kw5ow5qs17sv5tv}cn{4qs5kw5ow5qs17sv5tv}co{4qs5kw5ow5qs17sv5tv}cp{4qs5kw5ow5qs17sv5tv}6l{17sy5ty5ow}do{17st5tt}4z{17st5tt}7s{fst}dm{17st5tt}dn{17st5tt}5o{ckwclwcmwcnwcowcpw4lw4wv}dp{17st5tt}dq{17st5tt}7t{5ow}ds{17st5tt}5t{2ktclucmucnu4otcpu4lu4wycoucku}fu{17sv5tv5ow}6p{17sy5ty5ow5qs}ek{17sy5ty5ow}el{17sy5ty5ow}em{17sy5ty5ow}en{5ty}eo{17sy5ty5ow}ep{17sy5ty5ow}es{17sy5ty5qs}et{17sy5ty5ow5qs}eu{17sy5ty5ow5qs}ev{17sy5ty5ow5qs}6z{17sy5ty5ow5qs}fm{17sy5ty5ow5qs}fn{17sy5ty5ow5qs}fo{17sy5ty5ow5qs}fp{17sy5ty5qs}fq{17sy5ty5ow5qs}7r{5ow}fs{17sy5ty5ow5qs}ft{17sv5tv5ow}7m{5ow}fv{17sv5tv5ow}fw{17sv5tv5ow}}}") } };
  i.events.push(["addFont", function(c) {
    var u = c.font, f = h.Unicode[u.postScriptName];
    f && (u.metadata.Unicode = {}, u.metadata.Unicode.widths = f.widths, u.metadata.Unicode.kerning = f.kerning);
    var g = l.Unicode[u.postScriptName];
    g && (u.metadata.Unicode.encoding = g, u.encoding = g.codePages[0]);
  }]);
}(Lt.API), /**
 * @license
 * Licensed under the MIT License.
 * http://opensource.org/licenses/mit-license
 */
function(i) {
  var e = function(t) {
    for (var r = t.length, n = new Uint8Array(r), s = 0; s < r; s++)
      n[s] = t.charCodeAt(s);
    return n;
  };
  i.API.events.push(["addFont", function(t) {
    var r = void 0, n = t.font, s = t.instance;
    if (!n.isStandardFont) {
      if (s === void 0)
        throw new Error("Font does not exist in vFS, import fonts or remove declaration doc.addFont('" + n.postScriptName + "').");
      if (typeof (r = s.existsFileInVFS(n.postScriptName) === !1 ? s.loadFile(n.postScriptName) : s.getFileFromVFS(n.postScriptName)) != "string")
        throw new Error("Font is not stored as string-data in vFS, import fonts or remove declaration doc.addFont('" + n.postScriptName + "').");
      (function(a, o) {
        o = /^\x00\x01\x00\x00/.test(o) ? e(o) : e(dd(o)), a.metadata = i.API.TTFFont.open(o), a.metadata.Unicode = a.metadata.Unicode || { encoding: {}, kerning: {}, widths: [] }, a.metadata.glyIdsUsed = [0];
      })(n, r);
    }
  }]);
}(Lt), /** @license
 * Copyright (c) 2012 Willow Systems Corporation, https://github.com/willowsystems
 *
 * Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files (the
 * "Software"), to deal in the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 *
 * The above copyright notice and this permission notice shall be
 * included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
 * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
 * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
 * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 * ====================================================================
 */
function(i) {
  function e() {
    return (It.canvg ? Promise.resolve(It.canvg) : Promise.resolve().then(() => $ye)).catch(function(t) {
      return Promise.reject(new Error("Could not load canvg: " + t));
    }).then(function(t) {
      return t.default ? t.default : t;
    });
  }
  Lt.API.addSvgAsImage = function(t, r, n, s, a, o, A, l) {
    if (isNaN(r) || isNaN(n))
      throw Yr.error("jsPDF.addSvgAsImage: Invalid coordinates", arguments), new Error("Invalid coordinates passed to jsPDF.addSvgAsImage");
    if (isNaN(s) || isNaN(a))
      throw Yr.error("jsPDF.addSvgAsImage: Invalid measurements", arguments), new Error("Invalid measurements (width and/or height) passed to jsPDF.addSvgAsImage");
    var h = document.createElement("canvas");
    h.width = s, h.height = a;
    var c = h.getContext("2d");
    c.fillStyle = "#fff", c.fillRect(0, 0, h.width, h.height);
    var u = { ignoreMouse: !0, ignoreAnimation: !0, ignoreDimensions: !0 }, f = this;
    return e().then(function(g) {
      return g.fromString(c, t, u);
    }, function() {
      return Promise.reject(new Error("Could not load canvg."));
    }).then(function(g) {
      return g.render(u);
    }).then(function() {
      f.addImage(h.toDataURL("image/jpeg", 1), r, n, s, a, A, l);
    });
  };
}(), Lt.API.putTotalPages = function(i) {
  var e, t = 0;
  parseInt(this.internal.getFont().id.substr(1), 10) < 15 ? (e = new RegExp(i, "g"), t = this.internal.getNumberOfPages()) : (e = new RegExp(this.pdfEscape16(i, this.internal.getFont()), "g"), t = this.pdfEscape16(this.internal.getNumberOfPages() + "", this.internal.getFont()));
  for (var r = 1; r <= this.internal.getNumberOfPages(); r++)
    for (var n = 0; n < this.internal.pages[r].length; n++)
      this.internal.pages[r][n] = this.internal.pages[r][n].replace(e, t);
  return this;
}, Lt.API.viewerPreferences = function(i, e) {
  var t;
  i = i || {}, e = e || !1;
  var r, n, s, a = { HideToolbar: { defaultValue: !1, value: !1, type: "boolean", explicitSet: !1, valueSet: [!0, !1], pdfVersion: 1.3 }, HideMenubar: { defaultValue: !1, value: !1, type: "boolean", explicitSet: !1, valueSet: [!0, !1], pdfVersion: 1.3 }, HideWindowUI: { defaultValue: !1, value: !1, type: "boolean", explicitSet: !1, valueSet: [!0, !1], pdfVersion: 1.3 }, FitWindow: { defaultValue: !1, value: !1, type: "boolean", explicitSet: !1, valueSet: [!0, !1], pdfVersion: 1.3 }, CenterWindow: { defaultValue: !1, value: !1, type: "boolean", explicitSet: !1, valueSet: [!0, !1], pdfVersion: 1.3 }, DisplayDocTitle: { defaultValue: !1, value: !1, type: "boolean", explicitSet: !1, valueSet: [!0, !1], pdfVersion: 1.4 }, NonFullScreenPageMode: { defaultValue: "UseNone", value: "UseNone", type: "name", explicitSet: !1, valueSet: ["UseNone", "UseOutlines", "UseThumbs", "UseOC"], pdfVersion: 1.3 }, Direction: { defaultValue: "L2R", value: "L2R", type: "name", explicitSet: !1, valueSet: ["L2R", "R2L"], pdfVersion: 1.3 }, ViewArea: { defaultValue: "CropBox", value: "CropBox", type: "name", explicitSet: !1, valueSet: ["MediaBox", "CropBox", "TrimBox", "BleedBox", "ArtBox"], pdfVersion: 1.4 }, ViewClip: { defaultValue: "CropBox", value: "CropBox", type: "name", explicitSet: !1, valueSet: ["MediaBox", "CropBox", "TrimBox", "BleedBox", "ArtBox"], pdfVersion: 1.4 }, PrintArea: { defaultValue: "CropBox", value: "CropBox", type: "name", explicitSet: !1, valueSet: ["MediaBox", "CropBox", "TrimBox", "BleedBox", "ArtBox"], pdfVersion: 1.4 }, PrintClip: { defaultValue: "CropBox", value: "CropBox", type: "name", explicitSet: !1, valueSet: ["MediaBox", "CropBox", "TrimBox", "BleedBox", "ArtBox"], pdfVersion: 1.4 }, PrintScaling: { defaultValue: "AppDefault", value: "AppDefault", type: "name", explicitSet: !1, valueSet: ["AppDefault", "None"], pdfVersion: 1.6 }, Duplex: { defaultValue: "", value: "none", type: "name", explicitSet: !1, valueSet: ["Simplex", "DuplexFlipShortEdge", "DuplexFlipLongEdge", "none"], pdfVersion: 1.7 }, PickTrayByPDFSize: { defaultValue: !1, value: !1, type: "boolean", explicitSet: !1, valueSet: [!0, !1], pdfVersion: 1.7 }, PrintPageRange: { defaultValue: "", value: "", type: "array", explicitSet: !1, valueSet: null, pdfVersion: 1.7 }, NumCopies: { defaultValue: 1, value: 1, type: "integer", explicitSet: !1, valueSet: null, pdfVersion: 1.7 } }, o = Object.keys(a), A = [], l = 0, h = 0, c = 0;
  function u(g, p) {
    var y, v = !1;
    for (y = 0; y < g.length; y += 1)
      g[y] === p && (v = !0);
    return v;
  }
  if (this.internal.viewerpreferences === void 0 && (this.internal.viewerpreferences = {}, this.internal.viewerpreferences.configuration = JSON.parse(JSON.stringify(a)), this.internal.viewerpreferences.isSubscribed = !1), t = this.internal.viewerpreferences.configuration, i === "reset" || e === !0) {
    var f = o.length;
    for (c = 0; c < f; c += 1)
      t[o[c]].value = t[o[c]].defaultValue, t[o[c]].explicitSet = !1;
  }
  if ($r(i) === "object") {
    for (n in i)
      if (s = i[n], u(o, n) && s !== void 0) {
        if (t[n].type === "boolean" && typeof s == "boolean")
          t[n].value = s;
        else if (t[n].type === "name" && u(t[n].valueSet, s))
          t[n].value = s;
        else if (t[n].type === "integer" && Number.isInteger(s))
          t[n].value = s;
        else if (t[n].type === "array") {
          for (l = 0; l < s.length; l += 1)
            if (r = !0, s[l].length === 1 && typeof s[l][0] == "number")
              A.push(String(s[l] - 1));
            else if (s[l].length > 1) {
              for (h = 0; h < s[l].length; h += 1)
                typeof s[l][h] != "number" && (r = !1);
              r === !0 && A.push([s[l][0] - 1, s[l][1] - 1].join(" "));
            }
          t[n].value = "[" + A.join(" ") + "]";
        } else
          t[n].value = t[n].defaultValue;
        t[n].explicitSet = !0;
      }
  }
  return this.internal.viewerpreferences.isSubscribed === !1 && (this.internal.events.subscribe("putCatalog", function() {
    var g, p = [];
    for (g in t)
      t[g].explicitSet === !0 && (t[g].type === "name" ? p.push("/" + g + " /" + t[g].value) : p.push("/" + g + " " + t[g].value));
    p.length !== 0 && this.internal.write(`/ViewerPreferences
<<
` + p.join(`
`) + `
>>`);
  }), this.internal.viewerpreferences.isSubscribed = !0), this.internal.viewerpreferences.configuration = t, this;
}, /** ====================================================================
 * @license
 * jsPDF XMP metadata plugin
 * Copyright (c) 2016 Jussi Utunen, u-jussi@suomi24.fi
 *
 * Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files (the
 * "Software"), to deal in the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 *
 * The above copyright notice and this permission notice shall be
 * included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
 * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
 * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
 * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 * ====================================================================
 */
function(i) {
  var e = function() {
    var r = '<rdf:RDF xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"><rdf:Description rdf:about="" xmlns:jspdf="' + this.internal.__metadata__.namespaceuri + '"><jspdf:metadata>', n = unescape(encodeURIComponent('<x:xmpmeta xmlns:x="adobe:ns:meta/">')), s = unescape(encodeURIComponent(r)), a = unescape(encodeURIComponent(this.internal.__metadata__.metadata)), o = unescape(encodeURIComponent("</jspdf:metadata></rdf:Description></rdf:RDF>")), A = unescape(encodeURIComponent("</x:xmpmeta>")), l = s.length + a.length + o.length + n.length + A.length;
    this.internal.__metadata__.metadata_object_number = this.internal.newObject(), this.internal.write("<< /Type /Metadata /Subtype /XML /Length " + l + " >>"), this.internal.write("stream"), this.internal.write(n + s + a + o + A), this.internal.write("endstream"), this.internal.write("endobj");
  }, t = function() {
    this.internal.__metadata__.metadata_object_number && this.internal.write("/Metadata " + this.internal.__metadata__.metadata_object_number + " 0 R");
  };
  i.addMetadata = function(r, n) {
    return this.internal.__metadata__ === void 0 && (this.internal.__metadata__ = { metadata: r, namespaceuri: n || "http://jspdf.default.namespaceuri/" }, this.internal.events.subscribe("putCatalog", t), this.internal.events.subscribe("postPutResources", e)), this;
  };
}(Lt.API), function(i) {
  var e = i.API, t = e.pdfEscape16 = function(s, a) {
    for (var o, A = a.metadata.Unicode.widths, l = ["", "0", "00", "000", "0000"], h = [""], c = 0, u = s.length; c < u; ++c) {
      if (o = a.metadata.characterToGlyph(s.charCodeAt(c)), a.metadata.glyIdsUsed.push(o), a.metadata.toUnicode[o] = s.charCodeAt(c), A.indexOf(o) == -1 && (A.push(o), A.push([parseInt(a.metadata.widthOfGlyph(o), 10)])), o == "0")
        return h.join("");
      o = o.toString(16), h.push(l[4 - o.length], o);
    }
    return h.join("");
  }, r = function(s) {
    var a, o, A, l, h, c, u;
    for (h = `/CIDInit /ProcSet findresource begin
12 dict begin
begincmap
/CIDSystemInfo <<
  /Registry (Adobe)
  /Ordering (UCS)
  /Supplement 0
>> def
/CMapName /Adobe-Identity-UCS def
/CMapType 2 def
1 begincodespacerange
<0000><ffff>
endcodespacerange`, A = [], c = 0, u = (o = Object.keys(s).sort(function(f, g) {
      return f - g;
    })).length; c < u; c++)
      a = o[c], A.length >= 100 && (h += `
` + A.length + ` beginbfchar
` + A.join(`
`) + `
endbfchar`, A = []), s[a] !== void 0 && s[a] !== null && typeof s[a].toString == "function" && (l = ("0000" + s[a].toString(16)).slice(-4), a = ("0000" + (+a).toString(16)).slice(-4), A.push("<" + a + "><" + l + ">"));
    return A.length && (h += `
` + A.length + ` beginbfchar
` + A.join(`
`) + `
endbfchar
`), h += `endcmap
CMapName currentdict /CMap defineresource pop
end
end`;
  };
  e.events.push(["putFont", function(s) {
    (function(a) {
      var o = a.font, A = a.out, l = a.newObject, h = a.putStream;
      if (o.metadata instanceof i.API.TTFFont && o.encoding === "Identity-H") {
        for (var c = o.metadata.Unicode.widths, u = o.metadata.subset.encode(o.metadata.glyIdsUsed, 1), f = "", g = 0; g < u.length; g++)
          f += String.fromCharCode(u[g]);
        var p = l();
        h({ data: f, addLength1: !0, objectId: p }), A("endobj");
        var y = l();
        h({ data: r(o.metadata.toUnicode), addLength1: !0, objectId: y }), A("endobj");
        var v = l();
        A("<<"), A("/Type /FontDescriptor"), A("/FontName /" + Lc(o.fontName)), A("/FontFile2 " + p + " 0 R"), A("/FontBBox " + i.API.PDFObject.convert(o.metadata.bbox)), A("/Flags " + o.metadata.flags), A("/StemV " + o.metadata.stemV), A("/ItalicAngle " + o.metadata.italicAngle), A("/Ascent " + o.metadata.ascender), A("/Descent " + o.metadata.decender), A("/CapHeight " + o.metadata.capHeight), A(">>"), A("endobj");
        var w = l();
        A("<<"), A("/Type /Font"), A("/BaseFont /" + Lc(o.fontName)), A("/FontDescriptor " + v + " 0 R"), A("/W " + i.API.PDFObject.convert(c)), A("/CIDToGIDMap /Identity"), A("/DW 1000"), A("/Subtype /CIDFontType2"), A("/CIDSystemInfo"), A("<<"), A("/Supplement 0"), A("/Registry (Adobe)"), A("/Ordering (" + o.encoding + ")"), A(">>"), A(">>"), A("endobj"), o.objectNumber = l(), A("<<"), A("/Type /Font"), A("/Subtype /Type0"), A("/ToUnicode " + y + " 0 R"), A("/BaseFont /" + Lc(o.fontName)), A("/Encoding /" + o.encoding), A("/DescendantFonts [" + w + " 0 R]"), A(">>"), A("endobj"), o.isAlreadyPutted = !0;
      }
    })(s);
  }]), e.events.push(["putFont", function(s) {
    (function(a) {
      var o = a.font, A = a.out, l = a.newObject, h = a.putStream;
      if (o.metadata instanceof i.API.TTFFont && o.encoding === "WinAnsiEncoding") {
        for (var c = o.metadata.rawData, u = "", f = 0; f < c.length; f++)
          u += String.fromCharCode(c[f]);
        var g = l();
        h({ data: u, addLength1: !0, objectId: g }), A("endobj");
        var p = l();
        h({ data: r(o.metadata.toUnicode), addLength1: !0, objectId: p }), A("endobj");
        var y = l();
        A("<<"), A("/Descent " + o.metadata.decender), A("/CapHeight " + o.metadata.capHeight), A("/StemV " + o.metadata.stemV), A("/Type /FontDescriptor"), A("/FontFile2 " + g + " 0 R"), A("/Flags 96"), A("/FontBBox " + i.API.PDFObject.convert(o.metadata.bbox)), A("/FontName /" + Lc(o.fontName)), A("/ItalicAngle " + o.metadata.italicAngle), A("/Ascent " + o.metadata.ascender), A(">>"), A("endobj"), o.objectNumber = l();
        for (var v = 0; v < o.metadata.hmtx.widths.length; v++)
          o.metadata.hmtx.widths[v] = parseInt(o.metadata.hmtx.widths[v] * (1e3 / o.metadata.head.unitsPerEm));
        A("<</Subtype/TrueType/Type/Font/ToUnicode " + p + " 0 R/BaseFont/" + Lc(o.fontName) + "/FontDescriptor " + y + " 0 R/Encoding/" + o.encoding + " /FirstChar 29 /LastChar 255 /Widths " + i.API.PDFObject.convert(o.metadata.hmtx.widths) + ">>"), A("endobj"), o.isAlreadyPutted = !0;
      }
    })(s);
  }]);
  var n = function(s) {
    var a, o = s.text || "", A = s.x, l = s.y, h = s.options || {}, c = s.mutex || {}, u = c.pdfEscape, f = c.activeFontKey, g = c.fonts, p = f, y = "", v = 0, w = "", C = g[p].encoding;
    if (g[p].encoding !== "Identity-H")
      return { text: o, x: A, y: l, options: h, mutex: c };
    for (w = o, p = f, Array.isArray(o) && (w = o[0]), v = 0; v < w.length; v += 1)
      g[p].metadata.hasOwnProperty("cmap") && (a = g[p].metadata.cmap.unicode.codeMap[w[v].charCodeAt(0)]), a || w[v].charCodeAt(0) < 256 && g[p].metadata.hasOwnProperty("Unicode") ? y += w[v] : y += "";
    var E = "";
    return parseInt(p.slice(1)) < 14 || C === "WinAnsiEncoding" ? E = u(y, p).split("").map(function(S) {
      return S.charCodeAt(0).toString(16);
    }).join("") : C === "Identity-H" && (E = t(y, g[p])), c.isHex = !0, { text: E, x: A, y: l, options: h, mutex: c };
  };
  e.events.push(["postProcessText", function(s) {
    var a = s.text || "", o = [], A = { text: a, x: s.x, y: s.y, options: s.options, mutex: s.mutex };
    if (Array.isArray(a)) {
      var l = 0;
      for (l = 0; l < a.length; l += 1)
        Array.isArray(a[l]) && a[l].length === 3 ? o.push([n(Object.assign({}, A, { text: a[l][0] })).text, a[l][1], a[l][2]]) : o.push(n(Object.assign({}, A, { text: a[l] })).text);
      s.text = o;
    } else
      s.text = n(Object.assign({}, A, { text: a })).text;
  }]);
}(Lt), /**
 * @license
 * jsPDF virtual FileSystem functionality
 *
 * Licensed under the MIT License.
 * http://opensource.org/licenses/mit-license
 */
function(i) {
  var e = function() {
    return this.internal.vFS === void 0 && (this.internal.vFS = {}), !0;
  };
  i.existsFileInVFS = function(t) {
    return e.call(this), this.internal.vFS[t] !== void 0;
  }, i.addFileToVFS = function(t, r) {
    return e.call(this), this.internal.vFS[t] = r, this;
  }, i.getFileFromVFS = function(t) {
    return e.call(this), this.internal.vFS[t] !== void 0 ? this.internal.vFS[t] : null;
  };
}(Lt.API), /**
 * @license
 * Unicode Bidi Engine based on the work of Alex Shensis (@asthensis)
 * MIT License
 */
function(i) {
  i.__bidiEngine__ = i.prototype.__bidiEngine__ = function(r) {
    var n, s, a, o, A, l, h, c = e, u = [[0, 3, 0, 1, 0, 0, 0], [0, 3, 0, 1, 2, 2, 0], [0, 3, 0, 17, 2, 0, 1], [0, 3, 5, 5, 4, 1, 0], [0, 3, 21, 21, 4, 0, 1], [0, 3, 5, 5, 4, 2, 0]], f = [[2, 0, 1, 1, 0, 1, 0], [2, 0, 1, 1, 0, 2, 0], [2, 0, 2, 1, 3, 2, 0], [2, 0, 2, 33, 3, 1, 1]], g = { L: 0, R: 1, EN: 2, AN: 3, N: 4, B: 5, S: 6 }, p = { 0: 0, 5: 1, 6: 2, 7: 3, 32: 4, 251: 5, 254: 6, 255: 7 }, y = ["(", ")", "(", "<", ">", "<", "[", "]", "[", "{", "}", "{", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], v = new RegExp(/^([1-4|9]|1[0-9]|2[0-9]|3[0168]|4[04589]|5[012]|7[78]|159|16[0-9]|17[0-2]|21[569]|22[03489]|250)$/), w = !1, C = 0;
    this.__bidiEngine__ = {};
    var E = function(I) {
      var L = I.charCodeAt(), P = L >> 8, Q = p[P];
      return Q !== void 0 ? c[256 * Q + (255 & L)] : P === 252 || P === 253 ? "AL" : v.test(P) ? "L" : P === 8 ? "R" : "N";
    }, S = function(I) {
      for (var L, P = 0; P < I.length; P++) {
        if ((L = E(I.charAt(P))) === "L")
          return !1;
        if (L === "R")
          return !0;
      }
      return !1;
    }, M = function(I, L, P, Q) {
      var X, W, q, Z, oe = L[Q];
      switch (oe) {
        case "L":
        case "R":
          w = !1;
          break;
        case "N":
        case "AN":
          break;
        case "EN":
          w && (oe = "AN");
          break;
        case "AL":
          w = !0, oe = "R";
          break;
        case "WS":
          oe = "N";
          break;
        case "CS":
          Q < 1 || Q + 1 >= L.length || (X = P[Q - 1]) !== "EN" && X !== "AN" || (W = L[Q + 1]) !== "EN" && W !== "AN" ? oe = "N" : w && (W = "AN"), oe = W === X ? W : "N";
          break;
        case "ES":
          oe = (X = Q > 0 ? P[Q - 1] : "B") === "EN" && Q + 1 < L.length && L[Q + 1] === "EN" ? "EN" : "N";
          break;
        case "ET":
          if (Q > 0 && P[Q - 1] === "EN") {
            oe = "EN";
            break;
          }
          if (w) {
            oe = "N";
            break;
          }
          for (q = Q + 1, Z = L.length; q < Z && L[q] === "ET"; )
            q++;
          oe = q < Z && L[q] === "EN" ? "EN" : "N";
          break;
        case "NSM":
          if (a && !o) {
            for (Z = L.length, q = Q + 1; q < Z && L[q] === "NSM"; )
              q++;
            if (q < Z) {
              var ne = I[Q], me = ne >= 1425 && ne <= 2303 || ne === 64286;
              if (X = L[q], me && (X === "R" || X === "AL")) {
                oe = "R";
                break;
              }
            }
          }
          oe = Q < 1 || (X = L[Q - 1]) === "B" ? "N" : P[Q - 1];
          break;
        case "B":
          w = !1, n = !0, oe = C;
          break;
        case "S":
          s = !0, oe = "N";
          break;
        case "LRE":
        case "RLE":
        case "LRO":
        case "RLO":
        case "PDF":
          w = !1;
          break;
        case "BN":
          oe = "N";
      }
      return oe;
    }, T = function(I, L, P) {
      var Q = I.split("");
      return P && F(Q, P, { hiLevel: C }), Q.reverse(), L && L.reverse(), Q.join("");
    }, F = function(I, L, P) {
      var Q, X, W, q, Z, oe = -1, ne = I.length, me = 0, b = [], H = C ? f : u, V = [];
      for (w = !1, n = !1, s = !1, X = 0; X < ne; X++)
        V[X] = E(I[X]);
      for (W = 0; W < ne; W++) {
        if (Z = me, b[W] = M(I, V, b, W), Q = 240 & (me = H[Z][g[b[W]]]), me &= 15, L[W] = q = H[me][5], Q > 0)
          if (Q === 16) {
            for (X = oe; X < W; X++)
              L[X] = 1;
            oe = -1;
          } else
            oe = -1;
        if (H[me][6])
          oe === -1 && (oe = W);
        else if (oe > -1) {
          for (X = oe; X < W; X++)
            L[X] = q;
          oe = -1;
        }
        V[W] === "B" && (L[W] = 0), P.hiLevel |= q;
      }
      s && function(j, ie, ue) {
        for (var fe = 0; fe < ue; fe++)
          if (j[fe] === "S") {
            ie[fe] = C;
            for (var ee = fe - 1; ee >= 0 && j[ee] === "WS"; ee--)
              ie[ee] = C;
          }
      }(V, L, ne);
    }, k = function(I, L, P, Q, X) {
      if (!(X.hiLevel < I)) {
        if (I === 1 && C === 1 && !n)
          return L.reverse(), void (P && P.reverse());
        for (var W, q, Z, oe, ne = L.length, me = 0; me < ne; ) {
          if (Q[me] >= I) {
            for (Z = me + 1; Z < ne && Q[Z] >= I; )
              Z++;
            for (oe = me, q = Z - 1; oe < q; oe++, q--)
              W = L[oe], L[oe] = L[q], L[q] = W, P && (W = P[oe], P[oe] = P[q], P[q] = W);
            me = Z;
          }
          me++;
        }
      }
    }, $ = function(I, L, P) {
      var Q = I.split(""), X = { hiLevel: C };
      return P || (P = []), F(Q, P, X), function(W, q, Z) {
        if (Z.hiLevel !== 0 && h)
          for (var oe, ne = 0; ne < W.length; ne++)
            q[ne] === 1 && (oe = y.indexOf(W[ne])) >= 0 && (W[ne] = y[oe + 1]);
      }(Q, P, X), k(2, Q, L, P, X), k(1, Q, L, P, X), Q.join("");
    };
    return this.__bidiEngine__.doBidiReorder = function(I, L, P) {
      if (function(X, W) {
        if (W)
          for (var q = 0; q < X.length; q++)
            W[q] = q;
        o === void 0 && (o = S(X)), l === void 0 && (l = S(X));
      }(I, L), a || !A || l)
        if (a && A && o ^ l)
          C = o ? 1 : 0, I = T(I, L, P);
        else if (!a && A && l)
          C = o ? 1 : 0, I = $(I, L, P), I = T(I, L);
        else if (!a || o || A || l) {
          if (a && !A && o ^ l)
            I = T(I, L), o ? (C = 0, I = $(I, L, P)) : (C = 1, I = $(I, L, P), I = T(I, L));
          else if (a && o && !A && l)
            C = 1, I = $(I, L, P), I = T(I, L);
          else if (!a && !A && o ^ l) {
            var Q = h;
            o ? (C = 1, I = $(I, L, P), C = 0, h = !1, I = $(I, L, P), h = Q) : (C = 0, I = $(I, L, P), I = T(I, L), C = 1, h = !1, I = $(I, L, P), h = Q, I = T(I, L));
          }
        } else
          C = 0, I = $(I, L, P);
      else
        C = o ? 1 : 0, I = $(I, L, P);
      return I;
    }, this.__bidiEngine__.setOptions = function(I) {
      I && (a = I.isInputVisual, A = I.isOutputVisual, o = I.isInputRtl, l = I.isOutputRtl, h = I.isSymmetricSwapping);
    }, this.__bidiEngine__.setOptions(r), this.__bidiEngine__;
  };
  var e = ["BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "S", "B", "S", "WS", "B", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "B", "B", "B", "S", "WS", "N", "N", "ET", "ET", "ET", "N", "N", "N", "N", "N", "ES", "CS", "ES", "CS", "CS", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "CS", "N", "N", "N", "N", "N", "N", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "N", "N", "N", "N", "N", "N", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "N", "N", "N", "N", "BN", "BN", "BN", "BN", "BN", "BN", "B", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "CS", "N", "ET", "ET", "ET", "ET", "N", "N", "N", "N", "L", "N", "N", "BN", "N", "N", "ET", "ET", "EN", "EN", "N", "L", "N", "N", "N", "EN", "L", "N", "N", "N", "N", "N", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "N", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "N", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "N", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "N", "N", "L", "L", "L", "L", "L", "L", "L", "N", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "N", "L", "N", "N", "N", "N", "N", "ET", "N", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "R", "NSM", "R", "NSM", "NSM", "R", "NSM", "NSM", "R", "NSM", "N", "N", "N", "N", "N", "N", "N", "N", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "N", "N", "N", "N", "N", "R", "R", "R", "R", "R", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "AN", "AN", "AN", "AN", "AN", "AN", "N", "N", "AL", "ET", "ET", "AL", "CS", "AL", "N", "N", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "AL", "AL", "N", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "AN", "AN", "AN", "AN", "AN", "AN", "AN", "AN", "AN", "AN", "ET", "AN", "AN", "AL", "AL", "AL", "NSM", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "AN", "N", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "AL", "AL", "NSM", "NSM", "N", "NSM", "NSM", "NSM", "NSM", "AL", "AL", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "N", "AL", "AL", "NSM", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "N", "N", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "AL", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "R", "R", "N", "N", "N", "N", "R", "N", "N", "N", "N", "N", "WS", "WS", "WS", "WS", "WS", "WS", "WS", "WS", "WS", "WS", "WS", "BN", "BN", "BN", "L", "R", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "WS", "B", "LRE", "RLE", "PDF", "LRO", "RLO", "CS", "ET", "ET", "ET", "ET", "ET", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "CS", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "WS", "BN", "BN", "BN", "BN", "BN", "N", "LRI", "RLI", "FSI", "PDI", "BN", "BN", "BN", "BN", "BN", "BN", "EN", "L", "N", "N", "EN", "EN", "EN", "EN", "EN", "EN", "ES", "ES", "N", "N", "N", "L", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "ES", "ES", "N", "N", "N", "N", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "N", "N", "N", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "L", "L", "L", "L", "L", "L", "L", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "L", "L", "L", "L", "L", "N", "N", "N", "N", "N", "R", "NSM", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "ES", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "N", "R", "R", "R", "R", "R", "N", "R", "N", "R", "R", "N", "R", "R", "N", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "CS", "N", "CS", "N", "N", "CS", "N", "N", "N", "N", "N", "N", "N", "N", "N", "ET", "N", "N", "ES", "ES", "N", "N", "N", "N", "N", "ET", "ET", "N", "N", "N", "N", "N", "AL", "AL", "AL", "AL", "AL", "N", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "N", "N", "BN", "N", "N", "N", "ET", "ET", "ET", "N", "N", "N", "N", "N", "ES", "CS", "ES", "CS", "CS", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "CS", "N", "N", "N", "N", "N", "N", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "N", "N", "N", "N", "N", "N", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "N", "N", "N", "L", "L", "L", "L", "L", "L", "N", "N", "L", "L", "L", "L", "L", "L", "N", "N", "L", "L", "L", "L", "L", "L", "N", "N", "L", "L", "L", "N", "N", "N", "ET", "ET", "N", "N", "N", "ET", "ET", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N"], t = new i.__bidiEngine__({ isInputVisual: !0 });
  i.API.events.push(["postProcessText", function(r) {
    var n = r.text, s = (r.x, r.y, r.options || {}), a = (r.mutex, s.lang, []);
    if (s.isInputVisual = typeof s.isInputVisual != "boolean" || s.isInputVisual, t.setOptions(s), Object.prototype.toString.call(n) === "[object Array]") {
      var o = 0;
      for (a = [], o = 0; o < n.length; o += 1)
        Object.prototype.toString.call(n[o]) === "[object Array]" ? a.push([t.doBidiReorder(n[o][0]), n[o][1], n[o][2]]) : a.push([t.doBidiReorder(n[o])]);
      r.text = a;
    } else
      r.text = t.doBidiReorder(n);
    t.setOptions({ isInputVisual: !0 });
  }]);
}(Lt), Lt.API.TTFFont = function() {
  function i(e) {
    var t;
    if (this.rawData = e, t = this.contents = new gl(e), this.contents.pos = 4, t.readString(4) === "ttcf")
      throw new Error("TTCF not supported.");
    t.pos = 0, this.parse(), this.subset = new iW(this), this.registerTTF();
  }
  return i.open = function(e) {
    return new i(e);
  }, i.prototype.parse = function() {
    return this.directory = new $X(this.contents), this.head = new KX(this), this.name = new YX(this), this.cmap = new AN(this), this.toUnicode = {}, this.hhea = new jX(this), this.maxp = new qX(this), this.hmtx = new ZX(this), this.post = new XX(this), this.os2 = new zX(this), this.loca = new rW(this), this.glyf = new JX(this), this.ascender = this.os2.exists && this.os2.ascender || this.hhea.ascender, this.decender = this.os2.exists && this.os2.decender || this.hhea.decender, this.lineGap = this.os2.exists && this.os2.lineGap || this.hhea.lineGap, this.bbox = [this.head.xMin, this.head.yMin, this.head.xMax, this.head.yMax];
  }, i.prototype.registerTTF = function() {
    var e, t, r, n, s;
    if (this.scaleFactor = 1e3 / this.head.unitsPerEm, this.bbox = function() {
      var a, o, A, l;
      for (l = [], a = 0, o = (A = this.bbox).length; a < o; a++)
        e = A[a], l.push(Math.round(e * this.scaleFactor));
      return l;
    }.call(this), this.stemV = 0, this.post.exists ? (r = 255 & (n = this.post.italic_angle), 32768 & (t = n >> 16) && (t = -(1 + (65535 ^ t))), this.italicAngle = +(t + "." + r)) : this.italicAngle = 0, this.ascender = Math.round(this.ascender * this.scaleFactor), this.decender = Math.round(this.decender * this.scaleFactor), this.lineGap = Math.round(this.lineGap * this.scaleFactor), this.capHeight = this.os2.exists && this.os2.capHeight || this.ascender, this.xHeight = this.os2.exists && this.os2.xHeight || 0, this.familyClass = (this.os2.exists && this.os2.familyClass || 0) >> 8, this.isSerif = (s = this.familyClass) === 1 || s === 2 || s === 3 || s === 4 || s === 5 || s === 7, this.isScript = this.familyClass === 10, this.flags = 0, this.post.isFixedPitch && (this.flags |= 1), this.isSerif && (this.flags |= 2), this.isScript && (this.flags |= 8), this.italicAngle !== 0 && (this.flags |= 64), this.flags |= 32, !this.cmap.unicode)
      throw new Error("No unicode cmap for font");
  }, i.prototype.characterToGlyph = function(e) {
    var t;
    return ((t = this.cmap.unicode) != null ? t.codeMap[e] : void 0) || 0;
  }, i.prototype.widthOfGlyph = function(e) {
    var t;
    return t = 1e3 / this.head.unitsPerEm, this.hmtx.forGlyph(e).advance * t;
  }, i.prototype.widthOfString = function(e, t, r) {
    var n, s, a, o;
    for (a = 0, s = 0, o = (e = "" + e).length; 0 <= o ? s < o : s > o; s = 0 <= o ? ++s : --s)
      n = e.charCodeAt(s), a += this.widthOfGlyph(this.characterToGlyph(n)) + r * (1e3 / t) || 0;
    return a * (t / 1e3);
  }, i.prototype.lineHeight = function(e, t) {
    var r;
    return t == null && (t = !1), r = t ? this.lineGap : 0, (this.ascender + r - this.decender) / 1e3 * e;
  }, i;
}();
var Fa, gl = function() {
  function i(e) {
    this.data = e ?? [], this.pos = 0, this.length = this.data.length;
  }
  return i.prototype.readByte = function() {
    return this.data[this.pos++];
  }, i.prototype.writeByte = function(e) {
    return this.data[this.pos++] = e;
  }, i.prototype.readUInt32 = function() {
    return 16777216 * this.readByte() + (this.readByte() << 16) + (this.readByte() << 8) + this.readByte();
  }, i.prototype.writeUInt32 = function(e) {
    return this.writeByte(e >>> 24 & 255), this.writeByte(e >> 16 & 255), this.writeByte(e >> 8 & 255), this.writeByte(255 & e);
  }, i.prototype.readInt32 = function() {
    var e;
    return (e = this.readUInt32()) >= 2147483648 ? e - 4294967296 : e;
  }, i.prototype.writeInt32 = function(e) {
    return e < 0 && (e += 4294967296), this.writeUInt32(e);
  }, i.prototype.readUInt16 = function() {
    return this.readByte() << 8 | this.readByte();
  }, i.prototype.writeUInt16 = function(e) {
    return this.writeByte(e >> 8 & 255), this.writeByte(255 & e);
  }, i.prototype.readInt16 = function() {
    var e;
    return (e = this.readUInt16()) >= 32768 ? e - 65536 : e;
  }, i.prototype.writeInt16 = function(e) {
    return e < 0 && (e += 65536), this.writeUInt16(e);
  }, i.prototype.readString = function(e) {
    var t, r;
    for (r = [], t = 0; 0 <= e ? t < e : t > e; t = 0 <= e ? ++t : --t)
      r[t] = String.fromCharCode(this.readByte());
    return r.join("");
  }, i.prototype.writeString = function(e) {
    var t, r, n;
    for (n = [], t = 0, r = e.length; 0 <= r ? t < r : t > r; t = 0 <= r ? ++t : --t)
      n.push(this.writeByte(e.charCodeAt(t)));
    return n;
  }, i.prototype.readShort = function() {
    return this.readInt16();
  }, i.prototype.writeShort = function(e) {
    return this.writeInt16(e);
  }, i.prototype.readLongLong = function() {
    var e, t, r, n, s, a, o, A;
    return e = this.readByte(), t = this.readByte(), r = this.readByte(), n = this.readByte(), s = this.readByte(), a = this.readByte(), o = this.readByte(), A = this.readByte(), 128 & e ? -1 * (72057594037927940 * (255 ^ e) + 281474976710656 * (255 ^ t) + 1099511627776 * (255 ^ r) + 4294967296 * (255 ^ n) + 16777216 * (255 ^ s) + 65536 * (255 ^ a) + 256 * (255 ^ o) + (255 ^ A) + 1) : 72057594037927940 * e + 281474976710656 * t + 1099511627776 * r + 4294967296 * n + 16777216 * s + 65536 * a + 256 * o + A;
  }, i.prototype.writeLongLong = function(e) {
    var t, r;
    return t = Math.floor(e / 4294967296), r = 4294967295 & e, this.writeByte(t >> 24 & 255), this.writeByte(t >> 16 & 255), this.writeByte(t >> 8 & 255), this.writeByte(255 & t), this.writeByte(r >> 24 & 255), this.writeByte(r >> 16 & 255), this.writeByte(r >> 8 & 255), this.writeByte(255 & r);
  }, i.prototype.readInt = function() {
    return this.readInt32();
  }, i.prototype.writeInt = function(e) {
    return this.writeInt32(e);
  }, i.prototype.read = function(e) {
    var t, r;
    for (t = [], r = 0; 0 <= e ? r < e : r > e; r = 0 <= e ? ++r : --r)
      t.push(this.readByte());
    return t;
  }, i.prototype.write = function(e) {
    var t, r, n, s;
    for (s = [], r = 0, n = e.length; r < n; r++)
      t = e[r], s.push(this.writeByte(t));
    return s;
  }, i;
}(), $X = function() {
  var i;
  function e(t) {
    var r, n, s;
    for (this.scalarType = t.readInt(), this.tableCount = t.readShort(), this.searchRange = t.readShort(), this.entrySelector = t.readShort(), this.rangeShift = t.readShort(), this.tables = {}, n = 0, s = this.tableCount; 0 <= s ? n < s : n > s; n = 0 <= s ? ++n : --n)
      r = { tag: t.readString(4), checksum: t.readInt(), offset: t.readInt(), length: t.readInt() }, this.tables[r.tag] = r;
  }
  return e.prototype.encode = function(t) {
    var r, n, s, a, o, A, l, h, c, u, f, g, p;
    for (p in f = Object.keys(t).length, A = Math.log(2), c = 16 * Math.floor(Math.log(f) / A), a = Math.floor(c / A), h = 16 * f - c, (n = new gl()).writeInt(this.scalarType), n.writeShort(f), n.writeShort(c), n.writeShort(a), n.writeShort(h), s = 16 * f, l = n.pos + s, o = null, g = [], t)
      for (u = t[p], n.writeString(p), n.writeInt(i(u)), n.writeInt(l), n.writeInt(u.length), g = g.concat(u), p === "head" && (o = l), l += u.length; l % 4; )
        g.push(0), l++;
    return n.write(g), r = 2981146554 - i(n.data), n.pos = o + 8, n.writeUInt32(r), n.data;
  }, i = function(t) {
    var r, n, s, a;
    for (t = lN.call(t); t.length % 4; )
      t.push(0);
    for (s = new gl(t), n = 0, r = 0, a = t.length; r < a; r = r += 4)
      n += s.readUInt32();
    return 4294967295 & n;
  }, e;
}(), VX = {}.hasOwnProperty, ro = function(i, e) {
  for (var t in e)
    VX.call(e, t) && (i[t] = e[t]);
  function r() {
    this.constructor = i;
  }
  return r.prototype = e.prototype, i.prototype = new r(), i.__super__ = e.prototype, i;
};
Fa = function() {
  function i(e) {
    var t;
    this.file = e, t = this.file.directory.tables[this.tag], this.exists = !!t, t && (this.offset = t.offset, this.length = t.length, this.parse(this.file.contents));
  }
  return i.prototype.parse = function() {
  }, i.prototype.encode = function() {
  }, i.prototype.raw = function() {
    return this.exists ? (this.file.contents.pos = this.offset, this.file.contents.read(this.length)) : null;
  }, i;
}();
var KX = function(i) {
  function e() {
    return e.__super__.constructor.apply(this, arguments);
  }
  return ro(e, Fa), e.prototype.tag = "head", e.prototype.parse = function(t) {
    return t.pos = this.offset, this.version = t.readInt(), this.revision = t.readInt(), this.checkSumAdjustment = t.readInt(), this.magicNumber = t.readInt(), this.flags = t.readShort(), this.unitsPerEm = t.readShort(), this.created = t.readLongLong(), this.modified = t.readLongLong(), this.xMin = t.readShort(), this.yMin = t.readShort(), this.xMax = t.readShort(), this.yMax = t.readShort(), this.macStyle = t.readShort(), this.lowestRecPPEM = t.readShort(), this.fontDirectionHint = t.readShort(), this.indexToLocFormat = t.readShort(), this.glyphDataFormat = t.readShort();
  }, e.prototype.encode = function(t) {
    var r;
    return (r = new gl()).writeInt(this.version), r.writeInt(this.revision), r.writeInt(this.checkSumAdjustment), r.writeInt(this.magicNumber), r.writeShort(this.flags), r.writeShort(this.unitsPerEm), r.writeLongLong(this.created), r.writeLongLong(this.modified), r.writeShort(this.xMin), r.writeShort(this.yMin), r.writeShort(this.xMax), r.writeShort(this.yMax), r.writeShort(this.macStyle), r.writeShort(this.lowestRecPPEM), r.writeShort(this.fontDirectionHint), r.writeShort(t), r.writeShort(this.glyphDataFormat), r.data;
  }, e;
}(), AT = function() {
  function i(e, t) {
    var r, n, s, a, o, A, l, h, c, u, f, g, p, y, v, w, C;
    switch (this.platformID = e.readUInt16(), this.encodingID = e.readShort(), this.offset = t + e.readInt(), c = e.pos, e.pos = this.offset, this.format = e.readUInt16(), this.length = e.readUInt16(), this.language = e.readUInt16(), this.isUnicode = this.platformID === 3 && this.encodingID === 1 && this.format === 4 || this.platformID === 0 && this.format === 4, this.codeMap = {}, this.format) {
      case 0:
        for (A = 0; A < 256; ++A)
          this.codeMap[A] = e.readByte();
        break;
      case 4:
        for (f = e.readUInt16(), u = f / 2, e.pos += 6, s = function() {
          var E, S;
          for (S = [], A = E = 0; 0 <= u ? E < u : E > u; A = 0 <= u ? ++E : --E)
            S.push(e.readUInt16());
          return S;
        }(), e.pos += 2, p = function() {
          var E, S;
          for (S = [], A = E = 0; 0 <= u ? E < u : E > u; A = 0 <= u ? ++E : --E)
            S.push(e.readUInt16());
          return S;
        }(), l = function() {
          var E, S;
          for (S = [], A = E = 0; 0 <= u ? E < u : E > u; A = 0 <= u ? ++E : --E)
            S.push(e.readUInt16());
          return S;
        }(), h = function() {
          var E, S;
          for (S = [], A = E = 0; 0 <= u ? E < u : E > u; A = 0 <= u ? ++E : --E)
            S.push(e.readUInt16());
          return S;
        }(), n = (this.length - e.pos + this.offset) / 2, o = function() {
          var E, S;
          for (S = [], A = E = 0; 0 <= n ? E < n : E > n; A = 0 <= n ? ++E : --E)
            S.push(e.readUInt16());
          return S;
        }(), A = v = 0, C = s.length; v < C; A = ++v)
          for (y = s[A], r = w = g = p[A]; g <= y ? w <= y : w >= y; r = g <= y ? ++w : --w)
            h[A] === 0 ? a = r + l[A] : (a = o[h[A] / 2 + (r - g) - (u - A)] || 0) !== 0 && (a += l[A]), this.codeMap[r] = 65535 & a;
    }
    e.pos = c;
  }
  return i.encode = function(e, t) {
    var r, n, s, a, o, A, l, h, c, u, f, g, p, y, v, w, C, E, S, M, T, F, k, $, I, L, P, Q, X, W, q, Z, oe, ne, me, b, H, V, j, ie, ue, fe, ee, xe, Ee, Ue;
    switch (Q = new gl(), a = Object.keys(e).sort(function(ke, We) {
      return ke - We;
    }), t) {
      case "macroman":
        for (p = 0, y = function() {
          var ke = [];
          for (g = 0; g < 256; ++g)
            ke.push(0);
          return ke;
        }(), w = { 0: 0 }, s = {}, X = 0, oe = a.length; X < oe; X++)
          w[ee = e[n = a[X]]] == null && (w[ee] = ++p), s[n] = { old: e[n], new: w[e[n]] }, y[n] = w[e[n]];
        return Q.writeUInt16(1), Q.writeUInt16(0), Q.writeUInt32(12), Q.writeUInt16(0), Q.writeUInt16(262), Q.writeUInt16(0), Q.write(y), { charMap: s, subtable: Q.data, maxGlyphID: p + 1 };
      case "unicode":
        for (L = [], c = [], C = 0, w = {}, r = {}, v = l = null, W = 0, ne = a.length; W < ne; W++)
          w[S = e[n = a[W]]] == null && (w[S] = ++C), r[n] = { old: S, new: w[S] }, o = w[S] - n, v != null && o === l || (v && c.push(v), L.push(n), l = o), v = n;
        for (v && c.push(v), c.push(65535), L.push(65535), $ = 2 * (k = L.length), F = 2 * Math.pow(Math.log(k) / Math.LN2, 2), u = Math.log(F / 2) / Math.LN2, T = 2 * k - F, A = [], M = [], f = [], g = q = 0, me = L.length; q < me; g = ++q) {
          if (I = L[g], h = c[g], I === 65535) {
            A.push(0), M.push(0);
            break;
          }
          if (I - (P = r[I].new) >= 32768)
            for (A.push(0), M.push(2 * (f.length + k - g)), n = Z = I; I <= h ? Z <= h : Z >= h; n = I <= h ? ++Z : --Z)
              f.push(r[n].new);
          else
            A.push(P - I), M.push(0);
        }
        for (Q.writeUInt16(3), Q.writeUInt16(1), Q.writeUInt32(12), Q.writeUInt16(4), Q.writeUInt16(16 + 8 * k + 2 * f.length), Q.writeUInt16(0), Q.writeUInt16($), Q.writeUInt16(F), Q.writeUInt16(u), Q.writeUInt16(T), ue = 0, b = c.length; ue < b; ue++)
          n = c[ue], Q.writeUInt16(n);
        for (Q.writeUInt16(0), fe = 0, H = L.length; fe < H; fe++)
          n = L[fe], Q.writeUInt16(n);
        for (xe = 0, V = A.length; xe < V; xe++)
          o = A[xe], Q.writeUInt16(o);
        for (Ee = 0, j = M.length; Ee < j; Ee++)
          E = M[Ee], Q.writeUInt16(E);
        for (Ue = 0, ie = f.length; Ue < ie; Ue++)
          p = f[Ue], Q.writeUInt16(p);
        return { charMap: r, subtable: Q.data, maxGlyphID: C + 1 };
    }
  }, i;
}(), AN = function(i) {
  function e() {
    return e.__super__.constructor.apply(this, arguments);
  }
  return ro(e, Fa), e.prototype.tag = "cmap", e.prototype.parse = function(t) {
    var r, n, s;
    for (t.pos = this.offset, this.version = t.readUInt16(), s = t.readUInt16(), this.tables = [], this.unicode = null, n = 0; 0 <= s ? n < s : n > s; n = 0 <= s ? ++n : --n)
      r = new AT(t, this.offset), this.tables.push(r), r.isUnicode && this.unicode == null && (this.unicode = r);
    return !0;
  }, e.encode = function(t, r) {
    var n, s;
    return r == null && (r = "macroman"), n = AT.encode(t, r), (s = new gl()).writeUInt16(0), s.writeUInt16(1), n.table = s.data.concat(n.subtable), n;
  }, e;
}(), jX = function(i) {
  function e() {
    return e.__super__.constructor.apply(this, arguments);
  }
  return ro(e, Fa), e.prototype.tag = "hhea", e.prototype.parse = function(t) {
    return t.pos = this.offset, this.version = t.readInt(), this.ascender = t.readShort(), this.decender = t.readShort(), this.lineGap = t.readShort(), this.advanceWidthMax = t.readShort(), this.minLeftSideBearing = t.readShort(), this.minRightSideBearing = t.readShort(), this.xMaxExtent = t.readShort(), this.caretSlopeRise = t.readShort(), this.caretSlopeRun = t.readShort(), this.caretOffset = t.readShort(), t.pos += 8, this.metricDataFormat = t.readShort(), this.numberOfMetrics = t.readUInt16();
  }, e;
}(), zX = function(i) {
  function e() {
    return e.__super__.constructor.apply(this, arguments);
  }
  return ro(e, Fa), e.prototype.tag = "OS/2", e.prototype.parse = function(t) {
    if (t.pos = this.offset, this.version = t.readUInt16(), this.averageCharWidth = t.readShort(), this.weightClass = t.readUInt16(), this.widthClass = t.readUInt16(), this.type = t.readShort(), this.ySubscriptXSize = t.readShort(), this.ySubscriptYSize = t.readShort(), this.ySubscriptXOffset = t.readShort(), this.ySubscriptYOffset = t.readShort(), this.ySuperscriptXSize = t.readShort(), this.ySuperscriptYSize = t.readShort(), this.ySuperscriptXOffset = t.readShort(), this.ySuperscriptYOffset = t.readShort(), this.yStrikeoutSize = t.readShort(), this.yStrikeoutPosition = t.readShort(), this.familyClass = t.readShort(), this.panose = function() {
      var r, n;
      for (n = [], r = 0; r < 10; ++r)
        n.push(t.readByte());
      return n;
    }(), this.charRange = function() {
      var r, n;
      for (n = [], r = 0; r < 4; ++r)
        n.push(t.readInt());
      return n;
    }(), this.vendorID = t.readString(4), this.selection = t.readShort(), this.firstCharIndex = t.readShort(), this.lastCharIndex = t.readShort(), this.version > 0 && (this.ascent = t.readShort(), this.descent = t.readShort(), this.lineGap = t.readShort(), this.winAscent = t.readShort(), this.winDescent = t.readShort(), this.codePageRange = function() {
      var r, n;
      for (n = [], r = 0; r < 2; r = ++r)
        n.push(t.readInt());
      return n;
    }(), this.version > 1))
      return this.xHeight = t.readShort(), this.capHeight = t.readShort(), this.defaultChar = t.readShort(), this.breakChar = t.readShort(), this.maxContext = t.readShort();
  }, e;
}(), XX = function(i) {
  function e() {
    return e.__super__.constructor.apply(this, arguments);
  }
  return ro(e, Fa), e.prototype.tag = "post", e.prototype.parse = function(t) {
    var r, n, s;
    switch (t.pos = this.offset, this.format = t.readInt(), this.italicAngle = t.readInt(), this.underlinePosition = t.readShort(), this.underlineThickness = t.readShort(), this.isFixedPitch = t.readInt(), this.minMemType42 = t.readInt(), this.maxMemType42 = t.readInt(), this.minMemType1 = t.readInt(), this.maxMemType1 = t.readInt(), this.format) {
      case 65536:
        break;
      case 131072:
        var a;
        for (n = t.readUInt16(), this.glyphNameIndex = [], a = 0; 0 <= n ? a < n : a > n; a = 0 <= n ? ++a : --a)
          this.glyphNameIndex.push(t.readUInt16());
        for (this.names = [], s = []; t.pos < this.offset + this.length; )
          r = t.readByte(), s.push(this.names.push(t.readString(r)));
        return s;
      case 151552:
        return n = t.readUInt16(), this.offsets = t.read(n);
      case 196608:
        break;
      case 262144:
        return this.map = function() {
          var o, A, l;
          for (l = [], a = o = 0, A = this.file.maxp.numGlyphs; 0 <= A ? o < A : o > A; a = 0 <= A ? ++o : --o)
            l.push(t.readUInt32());
          return l;
        }.call(this);
    }
  }, e;
}(), WX = function(i, e) {
  this.raw = i, this.length = i.length, this.platformID = e.platformID, this.encodingID = e.encodingID, this.languageID = e.languageID;
}, YX = function(i) {
  function e() {
    return e.__super__.constructor.apply(this, arguments);
  }
  return ro(e, Fa), e.prototype.tag = "name", e.prototype.parse = function(t) {
    var r, n, s, a, o, A, l, h, c, u, f;
    for (t.pos = this.offset, t.readShort(), r = t.readShort(), A = t.readShort(), n = [], a = 0; 0 <= r ? a < r : a > r; a = 0 <= r ? ++a : --a)
      n.push({ platformID: t.readShort(), encodingID: t.readShort(), languageID: t.readShort(), nameID: t.readShort(), length: t.readShort(), offset: this.offset + A + t.readShort() });
    for (l = {}, a = c = 0, u = n.length; c < u; a = ++c)
      s = n[a], t.pos = s.offset, h = t.readString(s.length), o = new WX(h, s), l[f = s.nameID] == null && (l[f] = []), l[s.nameID].push(o);
    this.strings = l, this.copyright = l[0], this.fontFamily = l[1], this.fontSubfamily = l[2], this.uniqueSubfamily = l[3], this.fontName = l[4], this.version = l[5];
    try {
      this.postscriptName = l[6][0].raw.replace(/[\x00-\x19\x80-\xff]/g, "");
    } catch {
      this.postscriptName = l[4][0].raw.replace(/[\x00-\x19\x80-\xff]/g, "");
    }
    return this.trademark = l[7], this.manufacturer = l[8], this.designer = l[9], this.description = l[10], this.vendorUrl = l[11], this.designerUrl = l[12], this.license = l[13], this.licenseUrl = l[14], this.preferredFamily = l[15], this.preferredSubfamily = l[17], this.compatibleFull = l[18], this.sampleText = l[19];
  }, e;
}(), qX = function(i) {
  function e() {
    return e.__super__.constructor.apply(this, arguments);
  }
  return ro(e, Fa), e.prototype.tag = "maxp", e.prototype.parse = function(t) {
    return t.pos = this.offset, this.version = t.readInt(), this.numGlyphs = t.readUInt16(), this.maxPoints = t.readUInt16(), this.maxContours = t.readUInt16(), this.maxCompositePoints = t.readUInt16(), this.maxComponentContours = t.readUInt16(), this.maxZones = t.readUInt16(), this.maxTwilightPoints = t.readUInt16(), this.maxStorage = t.readUInt16(), this.maxFunctionDefs = t.readUInt16(), this.maxInstructionDefs = t.readUInt16(), this.maxStackElements = t.readUInt16(), this.maxSizeOfInstructions = t.readUInt16(), this.maxComponentElements = t.readUInt16(), this.maxComponentDepth = t.readUInt16();
  }, e;
}(), ZX = function(i) {
  function e() {
    return e.__super__.constructor.apply(this, arguments);
  }
  return ro(e, Fa), e.prototype.tag = "hmtx", e.prototype.parse = function(t) {
    var r, n, s, a, o, A, l;
    for (t.pos = this.offset, this.metrics = [], r = 0, A = this.file.hhea.numberOfMetrics; 0 <= A ? r < A : r > A; r = 0 <= A ? ++r : --r)
      this.metrics.push({ advance: t.readUInt16(), lsb: t.readInt16() });
    for (s = this.file.maxp.numGlyphs - this.file.hhea.numberOfMetrics, this.leftSideBearings = function() {
      var h, c;
      for (c = [], r = h = 0; 0 <= s ? h < s : h > s; r = 0 <= s ? ++h : --h)
        c.push(t.readInt16());
      return c;
    }(), this.widths = function() {
      var h, c, u, f;
      for (f = [], h = 0, c = (u = this.metrics).length; h < c; h++)
        a = u[h], f.push(a.advance);
      return f;
    }.call(this), n = this.widths[this.widths.length - 1], l = [], r = o = 0; 0 <= s ? o < s : o > s; r = 0 <= s ? ++o : --o)
      l.push(this.widths.push(n));
    return l;
  }, e.prototype.forGlyph = function(t) {
    return t in this.metrics ? this.metrics[t] : { advance: this.metrics[this.metrics.length - 1].advance, lsb: this.leftSideBearings[t - this.metrics.length] };
  }, e;
}(), lN = [].slice, JX = function(i) {
  function e() {
    return e.__super__.constructor.apply(this, arguments);
  }
  return ro(e, Fa), e.prototype.tag = "glyf", e.prototype.parse = function() {
    return this.cache = {};
  }, e.prototype.glyphFor = function(t) {
    var r, n, s, a, o, A, l, h, c, u;
    return t in this.cache ? this.cache[t] : (a = this.file.loca, r = this.file.contents, n = a.indexOf(t), (s = a.lengthOf(t)) === 0 ? this.cache[t] = null : (r.pos = this.offset + n, o = (A = new gl(r.read(s))).readShort(), h = A.readShort(), u = A.readShort(), l = A.readShort(), c = A.readShort(), this.cache[t] = o === -1 ? new tW(A, h, u, l, c) : new eW(A, o, h, u, l, c), this.cache[t]));
  }, e.prototype.encode = function(t, r, n) {
    var s, a, o, A, l;
    for (o = [], a = [], A = 0, l = r.length; A < l; A++)
      s = t[r[A]], a.push(o.length), s && (o = o.concat(s.encode(n)));
    return a.push(o.length), { table: o, offsets: a };
  }, e;
}(), eW = function() {
  function i(e, t, r, n, s, a) {
    this.raw = e, this.numberOfContours = t, this.xMin = r, this.yMin = n, this.xMax = s, this.yMax = a, this.compound = !1;
  }
  return i.prototype.encode = function() {
    return this.raw.data;
  }, i;
}(), tW = function() {
  function i(e, t, r, n, s) {
    var a, o;
    for (this.raw = e, this.xMin = t, this.yMin = r, this.xMax = n, this.yMax = s, this.compound = !0, this.glyphIDs = [], this.glyphOffsets = [], a = this.raw; o = a.readShort(), this.glyphOffsets.push(a.pos), this.glyphIDs.push(a.readUInt16()), 32 & o; )
      a.pos += 1 & o ? 4 : 2, 128 & o ? a.pos += 8 : 64 & o ? a.pos += 4 : 8 & o && (a.pos += 2);
  }
  return i.prototype.encode = function() {
    var e, t, r;
    for (t = new gl(lN.call(this.raw.data)), e = 0, r = this.glyphIDs.length; e < r; ++e)
      t.pos = this.glyphOffsets[e];
    return t.data;
  }, i;
}(), rW = function(i) {
  function e() {
    return e.__super__.constructor.apply(this, arguments);
  }
  return ro(e, Fa), e.prototype.tag = "loca", e.prototype.parse = function(t) {
    var r, n;
    return t.pos = this.offset, r = this.file.head.indexToLocFormat, this.offsets = r === 0 ? function() {
      var s, a;
      for (a = [], n = 0, s = this.length; n < s; n += 2)
        a.push(2 * t.readUInt16());
      return a;
    }.call(this) : function() {
      var s, a;
      for (a = [], n = 0, s = this.length; n < s; n += 4)
        a.push(t.readUInt32());
      return a;
    }.call(this);
  }, e.prototype.indexOf = function(t) {
    return this.offsets[t];
  }, e.prototype.lengthOf = function(t) {
    return this.offsets[t + 1] - this.offsets[t];
  }, e.prototype.encode = function(t, r) {
    for (var n = new Uint32Array(this.offsets.length), s = 0, a = 0, o = 0; o < n.length; ++o)
      if (n[o] = s, a < r.length && r[a] == o) {
        ++a, n[o] = s;
        var A = this.offsets[o], l = this.offsets[o + 1] - A;
        l > 0 && (s += l);
      }
    for (var h = new Array(4 * n.length), c = 0; c < n.length; ++c)
      h[4 * c + 3] = 255 & n[c], h[4 * c + 2] = (65280 & n[c]) >> 8, h[4 * c + 1] = (16711680 & n[c]) >> 16, h[4 * c] = (4278190080 & n[c]) >> 24;
    return h;
  }, e;
}(), iW = function() {
  function i(e) {
    this.font = e, this.subset = {}, this.unicodes = {}, this.next = 33;
  }
  return i.prototype.generateCmap = function() {
    var e, t, r, n, s;
    for (t in n = this.font.cmap.tables[0].codeMap, e = {}, s = this.subset)
      r = s[t], e[t] = n[r];
    return e;
  }, i.prototype.glyphsFor = function(e) {
    var t, r, n, s, a, o, A;
    for (n = {}, a = 0, o = e.length; a < o; a++)
      n[s = e[a]] = this.font.glyf.glyphFor(s);
    for (s in t = [], n)
      (r = n[s]) != null && r.compound && t.push.apply(t, r.glyphIDs);
    if (t.length > 0)
      for (s in A = this.glyphsFor(t))
        r = A[s], n[s] = r;
    return n;
  }, i.prototype.encode = function(e, t) {
    var r, n, s, a, o, A, l, h, c, u, f, g, p, y, v;
    for (n in r = AN.encode(this.generateCmap(), "unicode"), a = this.glyphsFor(e), f = { 0: 0 }, v = r.charMap)
      f[(A = v[n]).old] = A.new;
    for (g in u = r.maxGlyphID, a)
      g in f || (f[g] = u++);
    return h = function(w) {
      var C, E;
      for (C in E = {}, w)
        E[w[C]] = C;
      return E;
    }(f), c = Object.keys(h).sort(function(w, C) {
      return w - C;
    }), p = function() {
      var w, C, E;
      for (E = [], w = 0, C = c.length; w < C; w++)
        o = c[w], E.push(h[o]);
      return E;
    }(), s = this.font.glyf.encode(a, p, f), l = this.font.loca.encode(s.offsets, p), y = { cmap: this.font.cmap.raw(), glyf: s.table, loca: l, hmtx: this.font.hmtx.raw(), hhea: this.font.hhea.raw(), maxp: this.font.maxp.raw(), post: this.font.post.raw(), name: this.font.name.raw(), head: this.font.head.encode(t) }, this.font.os2.exists && (y["OS/2"] = this.font.os2.raw()), this.font.directory.encode(y);
  }, i;
}();
Lt.API.PDFObject = function() {
  var i;
  function e() {
  }
  return i = function(t, r) {
    return (Array(r + 1).join("0") + t).slice(-r);
  }, e.convert = function(t) {
    var r, n, s, a;
    if (Array.isArray(t))
      return "[" + function() {
        var o, A, l;
        for (l = [], o = 0, A = t.length; o < A; o++)
          r = t[o], l.push(e.convert(r));
        return l;
      }().join(" ") + "]";
    if (typeof t == "string")
      return "/" + t;
    if (t != null && t.isString)
      return "(" + t + ")";
    if (t instanceof Date)
      return "(D:" + i(t.getUTCFullYear(), 4) + i(t.getUTCMonth(), 2) + i(t.getUTCDate(), 2) + i(t.getUTCHours(), 2) + i(t.getUTCMinutes(), 2) + i(t.getUTCSeconds(), 2) + "Z)";
    if ({}.toString.call(t) === "[object Object]") {
      for (n in s = ["<<"], t)
        a = t[n], s.push("/" + n + " " + e.convert(a));
      return s.push(">>"), s.join(`
`);
    }
    return "" + t;
  }, e;
}();
const nW = {
  name: "ol-control-printdialog",
  setup(i, e) {
    const { control: t } = cn(Fh, i, e);
    return t.value.on(["print", "error"], function(r) {
      if (r.image)
        if (r.pdf) {
          const n = new Lt({
            orientation: r.print.orientation,
            unit: r.print.unit,
            format: r.print.size
          });
          n.addImage(
            r.image,
            "JPEG",
            r.print.position[0],
            r.print.position[0],
            r.print.imageWidth,
            r.print.imageHeight
          ), n.save(r.print.legend ? "legend.pdf" : "map.pdf");
        } else
          r.canvas.toBlob(
            function(n) {
              const s = (r.print.legend ? "legend." : "map.") + r.imageType.replace("image/", "");
              j4.saveAs(n, s);
            },
            r.imageType,
            r.quality
          );
      else
        console.warn("No canvas to export");
    }), {
      control: t
    };
  },
  props: {
    lang: {
      type: String
    }
  }
};
function sW(i, e, t, r, n, s) {
  return ur("", !0);
}
const sx = /* @__PURE__ */ qe(nW, [["render", sW]]);
var aW = class extends hn {
  constructor(e) {
    e = e || {};
    var t = ae.create("DIV", {
      className: (e.className || "ol-videorec") + " ol-unselectable ol-control"
    });
    super({
      element: t,
      target: e.target
    }), ae.create("BUTTON", {
      type: "button",
      className: "ol-start",
      title: "start",
      click: function() {
        this.start();
      }.bind(this),
      parent: t
    }), ae.create("BUTTON", {
      type: "button",
      className: "ol-stop",
      title: "stop",
      click: function() {
        this.stop();
      }.bind(this),
      parent: t
    }), ae.create("BUTTON", {
      type: "button",
      className: "ol-pause",
      title: "pause",
      click: function() {
        this.pause();
      }.bind(this),
      parent: t
    }), ae.create("BUTTON", {
      type: "button",
      className: "ol-resume",
      title: "resume",
      click: function() {
        this.resume();
      }.bind(this),
      parent: t
    }), this.set("framerate", 30), this.set("videoBitsPerSecond", 5e6), e.videoTarget === "DIALOG" ? (this._dialog = new V4({
      className: "ol-fullscreen-dialog",
      target: document.body,
      closeBox: !0
    }), this._videoTarget = this._dialog.getContentElement()) : this._videoTarget = e.videoTarget, this._printCtrl = new K4({
      target: ae.create("DIV")
    });
  }
  /**
   * Remove the control from its current map and attach it to the new map.
   * Subclasses may set up event handlers to get notified about changes to
   * the map here.
   * @param {ol.Map} map Map.
   * @api stable
   */
  setMap(e) {
    this.getMap() && (this.getMap().removeControl(this._printCtrl), this._dialog && this.getMap().removeControl(this._dialog)), super.setMap(e), this.getMap() && (this.getMap().addControl(this._printCtrl), this._dialog && this.getMap().addControl(this._dialog));
  }
  /** Start recording */
  start() {
    var e = this._printCtrl, t = !1;
    function r(n) {
      t || e.fastPrint({
        canvas: n
      }, r);
    }
    e.fastPrint({}, function(n) {
      var s;
      try {
        s = n.captureStream(this.get("framerate") || 30);
      } catch (o) {
        this.dispatchEvent({
          type: "error",
          error: o
        });
        return;
      }
      this._mediaRecorder = new MediaRecorder(s, {
        videoBitsPerSecond: this.get("videoBitsPerSecond") || 5e6
      });
      var a = [];
      this._mediaRecorder.ondataavailable = function(o) {
        a.push(o.data);
      }, this._mediaRecorder.onstop = function() {
        t = !0;
        var o = new Blob(a, { type: "video/mp4" });
        if (a = [], this._videoTarget instanceof Element) {
          var A;
          this._videoTarget.tagName === "VIDEO" ? A = this._videoTarget : (A = this._videoTarget.querySelector("video"), A || (A = ae.create("VIDEO", {
            controls: "",
            parent: this._videoTarget
          }))), this._dialog && this._dialog.show(), A.src = URL.createObjectURL(o), this.dispatchEvent({ type: "stop", videoURL: A.src });
        } else
          this.dispatchEvent({ type: "stop", videoURL: URL.createObjectURL(o) });
      }.bind(this), this._mediaRecorder.onpause = function() {
        t = !0, this.dispatchEvent({ type: "pause" });
      }.bind(this), this._mediaRecorder.onresume = function() {
        t = !1, r(n), this.dispatchEvent({ type: "resume" });
      }.bind(this), this._mediaRecorder.onerror = function(o) {
        this.dispatchEvent({ type: "error", error: o });
      }.bind(this), t = !1, r(n), this._mediaRecorder.start(), this.dispatchEvent({ type: "start", canvas: n }), this.element.setAttribute("data-state", "rec");
    }.bind(this));
  }
  /** Stop recording */
  stop() {
    this._mediaRecorder && (this._mediaRecorder.stop(), this._mediaRecorder = null, this.element.setAttribute("data-state", "inactive"));
  }
  /** Pause recording */
  pause() {
    this._mediaRecorder && (this._mediaRecorder.pause(), this.element.setAttribute("data-state", "pause"));
  }
  /** Resume recording after pause */
  resume() {
    this._mediaRecorder && (this._mediaRecorder.resume(), this.element.setAttribute("data-state", "rec"));
  }
};
const oW = {
  name: "ol-control-videorecorder",
  emits: ["start", "stop"],
  setup(i, e) {
    const { control: t } = cn(aW, i, e), { downloadName: r } = uh(i);
    return t.value.on("start", (n) => {
      e.emit("start", n);
    }), t.value.on("stop", (n) => {
      e.emit("stop", n), j4.saveAs(n.videoURL, r.value);
    }), {
      control: t
    };
  },
  props: {
    className: {
      type: String
    },
    framerate: {
      type: Number,
      default: 30
    },
    videoBitsPerSecond: {
      type: Number,
      default: 5e6
    },
    videoTarget: {
      type: String
    },
    downloadName: {
      type: String,
      default: "mapVideo.mp4"
    }
  }
};
function AW(i, e, t, r, n, s) {
  return ur("", !0);
}
const ax = /* @__PURE__ */ qe(oW, [["render", AW]]), lW = {
  image: ["Polygon", "Circle", "LineString", "Image", "Text"],
  hybrid: ["Polygon", "LineString"],
  vector: []
}, hW = {
  hybrid: ["Image", "Text", "Default"],
  vector: ["Polygon", "Circle", "LineString", "Image", "Text", "Default"]
};
class cW extends GM {
  /**
   * @param {import("../../layer/VectorTile.js").default} layer VectorTile layer.
   */
  constructor(e) {
    super(e), this.boundHandleStyleImageChange_ = this.handleStyleImageChange_.bind(this), this.renderedLayerRevision_, this.renderedPixelToCoordinateTransform_ = null, this.renderedRotation_, this.tmpTransform_ = qi();
  }
  /**
   * @param {import("../../VectorRenderTile.js").default} tile Tile.
   * @param {number} pixelRatio Pixel ratio.
   * @param {import("../../proj/Projection").default} projection Projection.
   * @return {boolean|undefined} Tile needs to be rendered.
   */
  prepareTile(e, t, r) {
    let n;
    const s = e.getState();
    return (s === He.LOADED || s === He.ERROR) && (this.updateExecutorGroup_(e, t, r), this.tileImageNeedsRender_(e) && (n = !0)), n;
  }
  /**
   * @param {number} z Tile coordinate z.
   * @param {number} x Tile coordinate x.
   * @param {number} y Tile coordinate y.
   * @param {import("../../Map.js").FrameState} frameState Frame state.
   * @return {!import("../../Tile.js").default} Tile.
   */
  getTile(e, t, r, n) {
    const s = n.pixelRatio, a = n.viewState, o = a.resolution, A = a.projection, l = this.getLayer(), h = l.getSource().getTile(e, t, r, s, A), c = n.viewHints, u = !(c[ei.ANIMATING] || c[ei.INTERACTING]);
    return (u || !h.wantedResolution) && (h.wantedResolution = o), this.prepareTile(h, s, A) && (u || Date.now() - n.time < 8) && l.getRenderMode() !== "vector" && this.renderTileImage_(h, n), super.getTile(e, t, r, n);
  }
  /**
   * @param {import("../../VectorRenderTile.js").default} tile Tile.
   * @return {boolean} Tile is drawable.
   */
  isDrawableTile(e) {
    const t = this.getLayer();
    return super.isDrawableTile(e) && (t.getRenderMode() === "vector" ? st(t) in e.executorGroups : e.hasContext(t));
  }
  /**
   * @inheritDoc
   */
  getTileImage(e) {
    return e.getImage(this.getLayer());
  }
  /**
   * Determine whether render should be called.
   * @param {import("../../Map.js").FrameState} frameState Frame state.
   * @return {boolean} Layer is ready to be rendered.
   */
  prepareFrame(e) {
    const t = this.getLayer().getRevision();
    return this.renderedLayerRevision_ !== t && (this.renderedLayerRevision_ = t, this.renderedTiles.length = 0), super.prepareFrame(e);
  }
  /**
   * @param {import("../../VectorRenderTile.js").default} tile Tile.
   * @param {number} pixelRatio Pixel ratio.
   * @param {import("../../proj/Projection.js").default} projection Projection.
   * @private
   */
  updateExecutorGroup_(e, t, r) {
    const n = (
      /** @type {import("../../layer/VectorTile.js").default} */
      this.getLayer()
    ), s = n.getRevision(), a = n.getRenderOrder() || null, o = e.wantedResolution, A = e.getReplayState(n);
    if (!A.dirty && A.renderedResolution === o && A.renderedRevision == s && A.renderedRenderOrder == a)
      return;
    const l = n.getSource(), h = n.getDeclutter(), c = l.getTileGrid(), f = l.getTileGridForProjection(r).getTileCoordExtent(e.wrappedTileCoord), g = l.getSourceTiles(t, r, e), p = st(n);
    delete e.hitDetectionImageData[p], e.executorGroups[p] = [], h && (e.declutterExecutorGroups[p] = []), A.dirty = !1;
    for (let y = 0, v = g.length; y < v; ++y) {
      const w = g[y];
      if (w.getState() != He.LOADED)
        continue;
      const C = w.tileCoord, E = c.getTileCoordExtent(C), S = jn(f, E), M = zn(
        S,
        n.getRenderBuffer() * o,
        this.tmpExtent
      ), T = Xa(E, S) ? null : M, F = new Qm(
        0,
        M,
        o,
        t
      ), k = h ? new Qm(0, S, o, t) : void 0, $ = w4(
        o,
        t
      ), I = function(W) {
        let q;
        const Z = W.getStyleFunction() || n.getStyleFunction();
        if (Z && (q = Z(W, o)), q) {
          const oe = this.renderFeature(
            W,
            $,
            q,
            F,
            k
          );
          A.dirty = A.dirty || oe;
        }
      }, L = w.getFeatures();
      a && a !== A.renderedRenderOrder && L.sort(a);
      for (let W = 0, q = L.length; W < q; ++W) {
        const Z = L[W];
        (!T || ci(T, Z.getGeometry().getExtent())) && I.call(this, Z);
      }
      const P = F.finish(), Q = n.getRenderMode() !== "vector" && h && g.length === 1 ? null : S, X = new Dm(
        Q,
        o,
        t,
        l.getOverlaps(),
        P,
        n.getRenderBuffer()
      );
      if (e.executorGroups[p].push(X), k) {
        const W = new Dm(
          null,
          o,
          t,
          l.getOverlaps(),
          k.finish(),
          n.getRenderBuffer()
        );
        e.declutterExecutorGroups[p].push(W);
      }
    }
    A.renderedRevision = s, A.renderedRenderOrder = a, A.renderedResolution = o;
  }
  /**
   * @param {import("../../coordinate.js").Coordinate} coordinate Coordinate.
   * @param {import("../../Map.js").FrameState} frameState Frame state.
   * @param {number} hitTolerance Hit tolerance in pixels.
   * @param {import("../vector.js").FeatureCallback<T>} callback Feature callback.
   * @param {Array<import("../Map.js").HitMatch<T>>} matches The hit detected matches with tolerance.
   * @return {T|undefined} Callback result.
   * @template T
   */
  forEachFeatureAtCoordinate(e, t, r, n, s) {
    const a = t.viewState.resolution, o = t.viewState.rotation;
    r = r ?? 0;
    const A = this.getLayer(), h = A.getSource().getTileGridForProjection(
      t.viewState.projection
    ), c = Xi([e]);
    zn(c, a * r, c);
    const u = {}, f = function(y, v, w) {
      let C = y.getId();
      C === void 0 && (C = st(y));
      const E = u[C];
      if (E) {
        if (E !== !0 && w < E.distanceSq) {
          if (w === 0)
            return u[C] = !0, s.splice(s.lastIndexOf(E), 1), n(y, A, v);
          E.geometry = v, E.distanceSq = w;
        }
      } else {
        if (w === 0)
          return u[C] = !0, n(y, A, v);
        s.push(
          u[C] = {
            feature: y,
            layer: A,
            geometry: v,
            distanceSq: w,
            callback: n
          }
        );
      }
    }, g = (
      /** @type {Array<import("../../VectorRenderTile.js").default>} */
      this.renderedTiles
    );
    let p;
    for (let y = 0, v = g.length; !p && y < v; ++y) {
      const w = g[y], C = h.getTileCoordExtent(w.wrappedTileCoord);
      if (!ci(C, c))
        continue;
      const E = st(A), S = [w.executorGroups[E]], M = w.declutterExecutorGroups[E];
      M && S.push(M), S.some((T) => {
        const F = T === M ? t.declutterTree.all().map((k) => k.value) : null;
        for (let k = 0, $ = T.length; k < $; ++k)
          if (p = T[k].forEachFeatureAtCoordinate(
            e,
            a,
            o,
            r,
            f,
            F
          ), p)
            return !0;
      });
    }
    return p;
  }
  /**
   * Asynchronous layer level hit detection.
   * @param {import("../../pixel.js").Pixel} pixel Pixel.
   * @return {Promise<Array<import("../../Feature.js").FeatureLike>>} Promise that resolves with an array of features.
   */
  getFeatures(e) {
    return new Promise((t, r) => {
      const n = this.getLayer(), s = st(n), a = n.getSource(), o = this.renderedProjection, A = o.getExtent(), l = this.renderedResolution, h = a.getTileGridForProjection(o), c = vi(
        this.renderedPixelToCoordinateTransform_,
        e.slice()
      ), u = h.getTileCoordForCoordAndResolution(
        c,
        l
      );
      let f;
      for (let C = 0, E = this.renderedTiles.length; C < E; ++C)
        if (u.toString() === this.renderedTiles[C].tileCoord.toString()) {
          if (f = /** @type {import("../../VectorRenderTile.js").default} */
          this.renderedTiles[C], f.getState() === He.LOADED) {
            const S = h.getTileCoordExtent(f.tileCoord);
            a.getWrapX() && o.canWrapX() && !Ps(A, S) && Nv(c, o);
            break;
          }
          f = void 0;
        }
      if (!f || f.loadingSourceTiles > 0) {
        t([]);
        return;
      }
      const g = h.getTileCoordExtent(f.wrappedTileCoord), p = Sa(g), y = [
        (c[0] - p[0]) / l,
        (p[1] - c[1]) / l
      ], v = f.getSourceTiles().reduce(function(C, E) {
        return C.concat(E.getFeatures());
      }, []);
      let w = f.hitDetectionImageData[s];
      if (!w) {
        const C = An(
          h.getTileSize(
            h.getZForResolution(l, a.zDirection)
          )
        ), E = this.renderedRotation_, S = [
          this.getRenderTransform(
            h.getTileCoordCenter(f.wrappedTileCoord),
            l,
            0,
            Ns,
            C[0] * Ns,
            C[1] * Ns,
            0
          )
        ];
        w = v4(
          C,
          S,
          v,
          n.getStyleFunction(),
          h.getTileCoordExtent(f.wrappedTileCoord),
          f.getReplayState(n).renderedResolution,
          E
        ), f.hitDetectionImageData[s] = w;
      }
      t(y4(y, v, w));
    });
  }
  /**
   * Perform action necessary to get the layer rendered after new fonts have loaded
   */
  handleFontsChanged() {
    const e = this.getLayer();
    e.getVisible() && this.renderedLayerRevision_ !== void 0 && e.changed();
  }
  /**
   * Handle changes in image style state.
   * @param {import("../../events/Event.js").default} event Image style change event.
   * @private
   */
  handleStyleImageChange_(e) {
    this.renderIfReadyAndVisible();
  }
  /**
   * Render declutter items for this layer
   * @param {import("../../Map.js").FrameState} frameState Frame state.
   */
  renderDeclutter(e) {
    const t = this.context, r = t.globalAlpha;
    t.globalAlpha = this.getLayer().getOpacity();
    const n = e.viewHints, s = !(n[ei.ANIMATING] || n[ei.INTERACTING]), a = (
      /** @type {Array<import("../../VectorRenderTile.js").default>} */
      this.renderedTiles
    );
    for (let o = 0, A = a.length; o < A; ++o) {
      const l = a[o], h = l.declutterExecutorGroups[st(this.getLayer())];
      if (h)
        for (let c = h.length - 1; c >= 0; --c)
          h[c].execute(
            this.context,
            1,
            this.getTileRenderTransform(l, e),
            e.viewState.rotation,
            s,
            void 0,
            e.declutterTree
          );
    }
    t.globalAlpha = r;
  }
  getTileRenderTransform(e, t) {
    const r = t.pixelRatio, n = t.viewState, s = n.center, a = n.resolution, o = n.rotation, A = t.size, l = Math.round(A[0] * r), h = Math.round(A[1] * r), u = this.getLayer().getSource().getTileGridForProjection(
      t.viewState.projection
    ), f = e.tileCoord, g = u.getTileCoordExtent(e.wrappedTileCoord), p = u.getTileCoordExtent(f, this.tmpExtent)[0] - g[0];
    return gh(
      Yc(this.inversePixelTransform.slice(), 1 / r, 1 / r),
      this.getRenderTransform(
        s,
        a,
        o,
        r,
        l,
        h,
        p
      )
    );
  }
  /**
   * Render the vectors for this layer.
   * @param {CanvasRenderingContext2D} context Target context.
   * @param {import("../../Map.js").FrameState} frameState Frame state.
   */
  postRender(e, t) {
    const r = t.viewHints, n = !(r[ei.ANIMATING] || r[ei.INTERACTING]);
    this.renderedPixelToCoordinateTransform_ = t.pixelToCoordinateTransform.slice(), this.renderedRotation_ = t.viewState.rotation;
    const s = (
      /** @type {import("../../layer/VectorTile.js").default} */
      this.getLayer()
    ), a = s.getRenderMode(), o = e.globalAlpha;
    e.globalAlpha = s.getOpacity();
    const A = hW[a], l = t.viewState, h = l.rotation, c = s.getSource(), f = c.getTileGridForProjection(l.projection).getZForResolution(
      l.resolution,
      c.zDirection
    ), g = this.renderedTiles, p = [], y = [];
    let v = !0;
    for (let w = g.length - 1; w >= 0; --w) {
      const C = (
        /** @type {import("../../VectorRenderTile.js").default} */
        g[w]
      );
      v = v && !C.getReplayState(s).dirty;
      const E = C.executorGroups[st(s)].filter(
        (k) => k.hasExecutors(A)
      );
      if (E.length === 0)
        continue;
      const S = this.getTileRenderTransform(C, t), M = C.tileCoord[0];
      let T = !1;
      const F = E[0].getClipCoords(S);
      if (F) {
        for (let k = 0, $ = p.length; k < $; ++k)
          if (f !== M && M < y[k]) {
            const I = p[k];
            ci(
              [
                F[0],
                F[3],
                F[4],
                F[7]
              ],
              [I[0], I[3], I[4], I[7]]
            ) && (T || (e.save(), T = !0), e.beginPath(), e.moveTo(F[0], F[1]), e.lineTo(F[2], F[3]), e.lineTo(F[4], F[5]), e.lineTo(F[6], F[7]), e.moveTo(I[6], I[7]), e.lineTo(I[4], I[5]), e.lineTo(I[2], I[3]), e.lineTo(I[0], I[1]), e.clip());
          }
        p.push(F), y.push(M);
      }
      for (let k = 0, $ = E.length; k < $; ++k)
        E[k].execute(
          e,
          1,
          S,
          h,
          n,
          A
        );
      T && e.restore();
    }
    e.globalAlpha = o, this.ready = v, super.postRender(e, t);
  }
  /**
   * @param {import("../../Feature.js").FeatureLike} feature Feature.
   * @param {number} squaredTolerance Squared tolerance.
   * @param {import("../../style/Style.js").default|Array<import("../../style/Style.js").default>} styles The style or array of styles.
   * @param {import("../../render/canvas/BuilderGroup.js").default} builderGroup Replay group.
   * @param {import("../../render/canvas/BuilderGroup.js").default} [declutterBuilderGroup] Builder group for decluttering.
   * @return {boolean} `true` if an image is loading.
   */
  renderFeature(e, t, r, n, s) {
    if (!r)
      return !1;
    let a = !1;
    if (Array.isArray(r))
      for (let o = 0, A = r.length; o < A; ++o)
        a = km(
          n,
          e,
          r[o],
          t,
          this.boundHandleStyleImageChange_,
          void 0,
          s
        ) || a;
    else
      a = km(
        n,
        e,
        r,
        t,
        this.boundHandleStyleImageChange_,
        void 0,
        s
      );
    return a;
  }
  /**
   * @param {import("../../VectorRenderTile.js").default} tile Tile.
   * @return {boolean} A new tile image was rendered.
   * @private
   */
  tileImageNeedsRender_(e) {
    const t = (
      /** @type {import("../../layer/VectorTile.js").default} */
      this.getLayer()
    );
    if (t.getRenderMode() === "vector")
      return !1;
    const r = e.getReplayState(t), n = t.getRevision(), s = e.wantedResolution;
    return r.renderedTileResolution !== s || r.renderedTileRevision !== n;
  }
  /**
   * @param {import("../../VectorRenderTile.js").default} tile Tile.
   * @param {import("../../Map").FrameState} frameState Frame state.
   * @private
   */
  renderTileImage_(e, t) {
    const r = (
      /** @type {import("../../layer/VectorTile.js").default} */
      this.getLayer()
    ), n = e.getReplayState(r), s = r.getRevision(), a = e.executorGroups[st(r)];
    n.renderedTileRevision = s;
    const o = e.wrappedTileCoord, A = o[0], l = r.getSource();
    let h = t.pixelRatio;
    const u = t.viewState.projection, f = l.getTileGridForProjection(u), g = f.getResolution(e.tileCoord[0]), p = t.pixelRatio / e.wantedResolution * g, y = f.getResolution(A), v = e.getContext(r);
    h = Math.round(
      Math.max(h, p / h)
    );
    const w = l.getTilePixelSize(A, h, u);
    v.canvas.width = w[0], v.canvas.height = w[1];
    const C = h / p;
    if (C !== 1) {
      const T = Wc(this.tmpTransform_);
      Yc(T, C, C), v.setTransform.apply(v, T);
    }
    const E = f.getTileCoordExtent(o, this.tmpExtent), S = p / y, M = Wc(this.tmpTransform_);
    Yc(M, S, -S), hm(M, -E[0], -E[3]);
    for (let T = 0, F = a.length; T < F; ++T)
      a[T].execute(
        v,
        C,
        M,
        0,
        !0,
        lW[r.getRenderMode()]
      );
    n.renderedTileResolution = e.wantedResolution;
  }
}
const uW = cW;
class fW extends zv {
  /**
   * @param {Options} [options] Options.
   */
  constructor(e) {
    e = e || {};
    const t = (
      /** @type {Object} */
      Object.assign({}, e)
    );
    delete t.preload, delete t.useInterimTilesOnError, super(
      /** @type {import("./BaseVector.js").Options<import("../source/VectorTile.js").default>} */
      t
    ), this.on, this.once, this.un;
    const r = e.renderMode || "hybrid";
    lt(r == "hybrid" || r == "vector", 28), this.renderMode_ = r, this.setPreload(e.preload ? e.preload : 0), this.setUseInterimTilesOnError(
      e.useInterimTilesOnError !== void 0 ? e.useInterimTilesOnError : !0
    ), this.getBackground, this.setBackground;
  }
  createRenderer() {
    return new uW(this);
  }
  /**
   * Get the topmost feature that intersects the given pixel on the viewport. Returns a promise
   * that resolves with an array of features. The array will either contain the topmost feature
   * when a hit was detected, or it will be empty.
   *
   * The hit detection algorithm used for this method is optimized for performance, but is less
   * accurate than the one used in [map.getFeaturesAtPixel()]{@link import("../Map.js").default#getFeaturesAtPixel}.
   * Text is not considered, and icons are only represented by their bounding box instead of the exact
   * image.
   *
   * @param {import("../pixel.js").Pixel} pixel Pixel.
   * @return {Promise<Array<import("../Feature").FeatureLike>>} Promise that resolves with an array of features.
   * @api
   */
  getFeatures(e) {
    return super.getFeatures(e);
  }
  /**
   * @return {VectorTileRenderType} The render mode.
   */
  getRenderMode() {
    return this.renderMode_;
  }
  /**
   * Return the level as number to which we will preload tiles up to.
   * @return {number} The level to preload tiles up to.
   * @observable
   * @api
   */
  getPreload() {
    return (
      /** @type {number} */
      this.get(zA.PRELOAD)
    );
  }
  /**
   * Whether we use interim tiles on error.
   * @return {boolean} Use interim tiles on error.
   * @observable
   * @api
   */
  getUseInterimTilesOnError() {
    return (
      /** @type {boolean} */
      this.get(zA.USE_INTERIM_TILES_ON_ERROR)
    );
  }
  /**
   * Set the level as number to which we will preload tiles up to.
   * @param {number} preload The level to preload tiles up to.
   * @observable
   * @api
   */
  setPreload(e) {
    this.set(zA.PRELOAD, e);
  }
  /**
   * Set whether we use interim tiles on error.
   * @param {boolean} useInterimTilesOnError Use interim tiles on error.
   * @observable
   * @api
   */
  setUseInterimTilesOnError(e) {
    this.set(zA.USE_INTERIM_TILES_ON_ERROR, e);
  }
}
const dW = fW;
var dB = class extends hn {
  constructor(e) {
    e = e || {};
    var t = ae.create("DIV", {
      className: e.switcherClass || "ol-layerswitcher"
    });
    super({
      element: t,
      target: e.target
    });
    var r = this;
    this.dcount = 0, this.show_progress = e.show_progress, this.oninfo = typeof e.oninfo == "function" ? e.oninfo : null, this.onextent = typeof e.onextent == "function" ? e.onextent : null, this.hasextent = e.extent || e.onextent, this.hastrash = e.trash, this.reordering = e.reordering !== !1, this._layers = [], this._layerGroup = e.layerGroup && e.layerGroup.getLayers ? e.layerGroup : null, this.onchangeCheck = typeof e.onchangeCheck == "function" ? e.onchangeCheck : null, typeof e.displayInLayerSwitcher == "function" && (this.displayInLayerSwitcher = e.displayInLayerSwitcher), e.target || (t.classList.add("ol-unselectable"), t.classList.add("ol-control"), t.classList.add(e.collapsed !== !1 ? "ol-collapsed" : "ol-forceopen"), this.button = ae.create("BUTTON", {
      type: "button",
      parent: t
    }), this.button.addEventListener("touchstart", function(n) {
      t.classList.toggle("ol-forceopen"), t.classList.add("ol-collapsed"), r.dispatchEvent({ type: "toggle", collapsed: t.classList.contains("ol-collapsed") }), n.preventDefault(), r.overflow();
    }), this.button.addEventListener("click", function() {
      t.classList.toggle("ol-forceopen"), t.classList.add("ol-collapsed"), r.dispatchEvent({ type: "toggle", collapsed: !t.classList.contains("ol-forceopen") }), r.overflow();
    }), e.mouseover && (t.addEventListener("mouseleave", function() {
      t.classList.add("ol-collapsed"), r.dispatchEvent({ type: "toggle", collapsed: !0 });
    }), t.addEventListener("mouseover", function() {
      t.classList.remove("ol-collapsed"), r.dispatchEvent({ type: "toggle", collapsed: !1 });
    })), e.minibar && (e.noScroll = !0), e.noScroll || (this.topv = ae.create("DIV", {
      className: "ol-switchertopdiv",
      parent: t,
      click: function() {
        r.overflow("+50%");
      }
    }), this.botv = ae.create("DIV", {
      className: "ol-switcherbottomdiv",
      parent: t,
      click: function() {
        r.overflow("-50%");
      }
    })), this._noScroll = e.noScroll), this.panel_ = ae.create("UL", {
      className: "panel"
    }), this.panelContainer_ = ae.create("DIV", {
      className: "panel-container",
      html: this.panel_,
      parent: t
    }), !e.target && !e.noScroll && ae.addListener(this.panel_, "mousewheel DOMMouseScroll onmousewheel", function(n) {
      r.overflow(Math.max(-1, Math.min(1, n.wheelDelta || -n.detail))) && (n.stopPropagation(), n.preventDefault());
    }), this.header_ = ae.create("LI", {
      className: "ol-header",
      parent: this.panel_
    }), this.set("drawDelay", e.drawDelay || 0), this.set("selection", e.selection), e.minibar && setTimeout(function() {
      var n = ae.scrollDiv(this.panelContainer_, {
        mousewheel: !0,
        vertical: !0,
        minibar: !0
      });
      this.on(["drawlist", "toggle"], function() {
        n.refresh();
      });
    }.bind(this));
  }
  /** Test if a layer should be displayed in the switcher
   * @param {ol.layer} layer
   * @return {boolean} true if the layer is displayed
   */
  displayInLayerSwitcher(e) {
    return e.get("displayInLayerSwitcher") !== !1;
  }
  /**
   * Set the map instance the control is associated with.
   * @param {_ol_Map_} map The map instance.
   */
  setMap(e) {
    if (super.setMap(e), this.drawPanel(), this._listener)
      for (var t in this._listener)
        Js(this._listener[t]);
    this._listener = null, e && (this._listener = {
      moveend: e.on("moveend", this.viewChange.bind(this)),
      size: e.on("change:size", this.overflow.bind(this))
    }, this._layerGroup ? this._listener.change = this._layerGroup.getLayers().on("change:length", this.drawPanel.bind(this)) : this._listener.change = e.getLayerGroup().getLayers().on("change:length", this.drawPanel.bind(this)));
  }
  /** Show control
   */
  show() {
    this.element.classList.add("ol-forceopen"), this.overflow(), this.dispatchEvent({ type: "toggle", collapsed: !1 });
  }
  /** Hide control
   */
  hide() {
    this.element.classList.remove("ol-forceopen"), this.overflow(), this.dispatchEvent({ type: "toggle", collapsed: !0 });
  }
  /** Toggle control
   */
  toggle() {
    this.element.classList.toggle("ol-forceopen"), this.overflow(), this.dispatchEvent({ type: "toggle", collapsed: !this.isOpen() });
  }
  /** Is control open
   * @return {boolean}
   */
  isOpen() {
    return this.element.classList.contains("ol-forceopen");
  }
  /** Add a custom header
   * @param {Element|string} html content html
   */
  setHeader(e) {
    ae.setHTML(this.header_, e);
  }
  /** Calculate overflow and add scrolls
   * @param {Number} dir scroll direction -1|0|1|'+50%'|'-50%'
   * @private
   */
  overflow(e) {
    if (this.button && !this._noScroll) {
      if (ae.hidden(this.panel_)) {
        ae.setStyle(this.element, { height: "auto" });
        return;
      }
      var t = ae.outerHeight(this.element), r = ae.outerHeight(this.panel_), n = this.button.offsetTop + ae.outerHeight(this.button), s = this.panel_.offsetTop - n;
      if (r > t - n) {
        ae.setStyle(this.element, { height: "100%" });
        var a = this.panel_.querySelectorAll("li.ol-visible .li-content")[0], o = a ? 2 * ae.getStyle(a, "height") : 0;
        switch (e) {
          case 1:
            s += o;
            break;
          case -1:
            s -= o;
            break;
          case "+50%":
            s += Math.round(t / 2);
            break;
          case "-50%":
            s -= Math.round(t / 2);
            break;
        }
        return s + r <= t - 3 * n / 2 ? (s = t - 3 * n / 2 - r, ae.hide(this.botv)) : ae.show(this.botv), s >= 0 ? (s = 0, ae.hide(this.topv)) : ae.show(this.topv), ae.setStyle(this.panel_, { top: s + "px" }), !0;
      } else
        return ae.setStyle(this.element, { height: "auto" }), ae.setStyle(this.panel_, { top: 0 }), ae.hide(this.botv), ae.hide(this.topv), !1;
    } else
      return !1;
  }
  /** Set the layer associated with a li
   * @param {Element} li
   * @param {ol.layer} layer
   * @private
   */
  _setLayerForLI(e, t) {
    var r = [];
    t.getLayers && r.push(t.getLayers().on("change:length", this.drawPanel.bind(this))), e && (r.push(t.on("change:opacity", function() {
      this.setLayerOpacity(t, e);
    }.bind(this))), r.push(t.on("change:visible", function() {
      this.setLayerVisibility(t, e);
    }.bind(this)))), r.push(t.on("propertychange", function(n) {
      (n.key === "displayInLayerSwitcher" || n.key === "openInLayerSwitcher" || n.key === "title" || n.key === "name") && this.drawPanel(n);
    }.bind(this))), this._layers.push({ li: e, layer: t, listeners: r });
  }
  /** Set opacity for a layer
   * @param {ol.layer.Layer} layer
   * @param {Element} li the list element
   * @private
   */
  setLayerOpacity(e, t) {
    var r = t.querySelector(".layerswitcher-opacity-cursor");
    r && (r.style.left = e.getOpacity() * 100 + "%"), this.dispatchEvent({ type: "layer:opacity", layer: e });
  }
  /** Set visibility for a layer
   * @param {ol.layer.Layer} layer
   * @param {Element} li the list element
   * @api
   */
  setLayerVisibility(e, t) {
    var r = t.querySelector(".ol-visibility");
    r && (r.checked = e.getVisible()), e.getVisible() ? t.classList.add("ol-visible") : t.classList.remove("ol-visible"), this.dispatchEvent({ type: "layer:visible", layer: e });
  }
  /** Clear layers associated with li
   * @private
   */
  _clearLayerForLI() {
    this._layers.forEach(function(e) {
      e.listeners.forEach(function(t) {
        Js(t);
      });
    }), this._layers = [];
  }
  /** Get the layer associated with a li
   * @param {Element} li
   * @return {ol.layer}
   * @private
   */
  _getLayerForLI(e) {
    for (var t = 0, r; r = this._layers[t]; t++)
      if (r.li === e)
        return r.layer;
    return null;
  }
  /**
   * On view change hide layer depending on resolution / extent
   * @private
   */
  viewChange() {
    this.panel_.querySelectorAll("li").forEach(function(e) {
      var t = this._getLayerForLI(e);
      t && (this.testLayerVisibility(t) ? e.classList.remove("ol-layer-hidden") : e.classList.add("ol-layer-hidden"));
    }.bind(this));
  }
  /** Get control panel
   * @api
   */
  getPanel() {
    return this.panelContainer_;
  }
  /** Draw the panel control (prevent multiple draw due to layers manipulation on the map with a delay function)
   * @api
   */
  drawPanel() {
    if (this.getMap()) {
      var e = this;
      this.dcount++, setTimeout(function() {
        e.drawPanel_();
      }, this.get("drawDelay") || 0);
    }
  }
  /** Delayed draw panel control
   * @private
   */
  drawPanel_() {
    if (!(--this.dcount || this.dragging_)) {
      var e = this.panelContainer_.scrollTop;
      this._clearLayerForLI(), this.panel_.querySelectorAll("li").forEach(function(t) {
        t.classList.contains("ol-header") || t.remove();
      }.bind(this)), this._layerGroup ? this.drawList(this.panel_, this._layerGroup.getLayers()) : this.getMap() && this.drawList(this.panel_, this.getMap().getLayers()), this.panelContainer_.scrollTop = e;
    }
  }
  /** Change layer visibility according to the baselayer option
   * @param {ol.layer}
   * @param {Array<ol.layer>} related layers
   * @private
   */
  switchLayerVisibility(e, t) {
    e.get("baseLayer") ? (e.getVisible() || e.setVisible(!0), t.forEach(function(r) {
      e !== r && r.get("baseLayer") && r.getVisible() && r.setVisible(!1);
    })) : e.setVisible(!e.getVisible());
  }
  /** Check if layer is on the map (depending on resolution / zoom and extent)
   * @param {ol.layer}
   * @return {boolean}
   * @private
   */
  testLayerVisibility(e) {
    if (!this.getMap())
      return !0;
    var t = this.getMap().getView().getResolution(), r = this.getMap().getView().getZoom();
    if (e.getMaxResolution() <= t || e.getMinResolution() >= t)
      return !1;
    if (e.getMinZoom && (e.getMinZoom() >= r || e.getMaxZoom() < r))
      return !1;
    var n = e.getExtent();
    if (n) {
      var s = this.getMap().getView().calculateExtent(this.getMap().getSize());
      return ci(s, n);
    }
    return !0;
  }
  /** Start ordering the list
  *	@param {event} e drag event
  *	@private
  */
  dragOrdering_(e) {
    e.stopPropagation(), e.preventDefault();
    var t = this, r = e.currentTarget.parentNode.parentNode, n = !0, s = this.panel_, a, o = e.pageY || e.touches && e.touches.length && e.touches[0].pageY || e.changedTouches && e.changedTouches.length && e.changedTouches[0].pageY, A, l, h, c;
    r.parentNode.classList.add("drag");
    function u() {
      if (A) {
        var g = h, p = t.getSelection() === g;
        if (g && A) {
          var y;
          c ? y = c.getLayers() : y = t._layerGroup ? t._layerGroup.getLayers() : t.getMap().getLayers();
          for (var v = y.getArray(), w = 0; w < v.length; w++)
            if (v[w] == g) {
              y.removeAt(w);
              break;
            }
          for (var C = 0; C < v.length; C++)
            if (v[C] === A) {
              w > C ? y.insertAt(C, g) : y.insertAt(C + 1, g);
              break;
            }
        }
        p && t.selectLayer(g), t.dispatchEvent({ type: "reorder-end", layer: g, group: c });
      }
      r.parentNode.querySelectorAll("li").forEach(function(E) {
        E.classList.remove("dropover"), E.classList.remove("dropover-after"), E.classList.remove("dropover-before");
      }), r.classList.remove("drag"), r.parentNode.classList.remove("drag"), t.element.classList.remove("drag"), l && l.remove(), ae.removeListener(document, "mousemove touchmove", f), ae.removeListener(document, "mouseup touchend touchcancel", u);
    }
    function f(g) {
      if (a = g.pageY || g.touches && g.touches.length && g.touches[0].pageY || g.changedTouches && g.changedTouches.length && g.changedTouches[0].pageY, n && Math.abs(o - a) > 2 && (n = !1, r.classList.add("drag"), h = t._getLayerForLI(r), A = !1, c = t._getLayerForLI(r.parentNode.parentNode), l = ae.create("LI", {
        className: "ol-dragover",
        html: r.innerHTML,
        style: {
          position: "absolute",
          "z-index": 1e4,
          left: r.offsetLeft,
          opacity: 0.5,
          width: ae.outerWidth(r),
          height: ae.getStyle(r, "height")
        },
        parent: s
      }), t.element.classList.add("drag"), t.dispatchEvent({ type: "reorder-start", layer: h, group: c })), !n) {
        g.preventDefault(), g.stopPropagation(), ae.setStyle(l, { top: a - ae.offsetRect(s).top + s.scrollTop + 5 });
        var p;
        for (g.touches ? p = document.elementFromPoint(g.touches[0].clientX, g.touches[0].clientY) : p = g.target, p.classList.contains("ol-switcherbottomdiv") ? t.overflow(-1) : p.classList.contains("ol-switchertopdiv") && t.overflow(1); p && p.tagName !== "LI"; )
          p = p.parentNode;
        (!p || !p.classList.contains("dropover")) && r.parentNode.querySelectorAll("li").forEach(function(y) {
          y.classList.remove("dropover"), y.classList.remove("dropover-after"), y.classList.remove("dropover-before");
        }), p && p.parentNode.classList.contains("drag") && p !== r ? (A = t._getLayerForLI(p), A && !A.get("allwaysOnTop") == !h.get("allwaysOnTop") ? (p.classList.add("dropover"), p.classList.add(r.offsetTop < p.offsetTop ? "dropover-after" : "dropover-before")) : A = !1, ae.show(l)) : (A = !1, p === r ? ae.hide(l) : ae.show(l)), A ? l.classList.remove("forbidden") : l.classList.add("forbidden");
      }
    }
    ae.addListener(document, "mousemove touchmove", f), ae.addListener(document, "mouseup touchend touchcancel", u);
  }
  /** Change opacity on drag
  *	@param {event} e drag event
  *	@private
  */
  dragOpacity_(e) {
    e.stopPropagation(), e.preventDefault();
    var t = this, r = e.target, n = this._getLayerForLI(r.parentNode.parentNode.parentNode);
    if (!n)
      return;
    var s = e.pageX || e.touches && e.touches.length && e.touches[0].pageX || e.changedTouches && e.changedTouches.length && e.changedTouches[0].pageX, a = ae.getStyle(r, "left") - s;
    t.dragging_ = !0;
    function o() {
      ae.removeListener(document, "mouseup touchend touchcancel", o), ae.removeListener(document, "mousemove touchmove", A), t.dragging_ = !1;
    }
    function A(l) {
      var h = l.pageX || l.touches && l.touches.length && l.touches[0].pageX || l.changedTouches && l.changedTouches.length && l.changedTouches[0].pageX, c = (a + h) / ae.getStyle(r.parentNode, "width"), u = Math.max(0, Math.min(1, c));
      ae.setStyle(r, { left: u * 100 + "%" }), r.parentNode.nextElementSibling.innerHTML = Math.round(u * 100), n.setOpacity(u);
    }
    ae.addListener(document, "mouseup touchend touchcancel", o), ae.addListener(document, "mousemove touchmove", A);
  }
  /** Render a list of layer
   * @param {Elemen} element to render
   * @layers {Array{ol.layer}} list of layer to show
   * @api stable
   * @private
   */
  drawList(e, t) {
    var r = this, n = t.getArray(), s = function(c) {
      c.stopPropagation(), c.preventDefault();
      var u = r._getLayerForLI(this.parentNode.parentNode);
      r.switchLayerVisibility(u, t), r.get("selection") && u.getVisible() && r.selectLayer(u), r.onchangeCheck && r.onchangeCheck(u);
    };
    function a(c) {
      c.stopPropagation(), c.preventDefault();
      var u = r._getLayerForLI(this.parentNode.parentNode);
      r.oninfo(u), r.dispatchEvent({ type: "info", layer: u });
    }
    function o(c) {
      c.stopPropagation(), c.preventDefault();
      var u = r._getLayerForLI(this.parentNode.parentNode);
      r.onextent ? r.onextent(u) : r.getMap().getView().fit(u.getExtent(), r.getMap().getSize()), r.dispatchEvent({ type: "extent", layer: u });
    }
    function A(c) {
      c.stopPropagation(), c.preventDefault();
      var u = this.parentNode.parentNode.parentNode.parentNode, f, g = r._getLayerForLI(u);
      g ? (f = r._getLayerForLI(this.parentNode.parentNode), g.getLayers().remove(f), g.getLayers().getLength() == 0 && !g.get("noSwitcherDelete") && A.call(u.querySelectorAll(".layerTrash")[0], c)) : (u = this.parentNode.parentNode, r.getMap().removeLayer(r._getLayerForLI(u)));
    }
    function l(c) {
      if (!this.displayInLayerSwitcher(c)) {
        this._setLayerForLI(null, c);
        return;
      }
      var u = ae.create("LI", {
        className: (c.getVisible() ? "ol-visible " : " ") + (c.get("baseLayer") ? "baselayer" : ""),
        parent: e
      });
      this._setLayerForLI(u, c), this._selectedLayer === c && u.classList.add("ol-layer-select");
      var f = ae.create("DIV", {
        className: "ol-layerswitcher-buttons",
        parent: u
      }), g = ae.create("DIV", {
        className: "li-content",
        parent: u
      });
      ae.create("INPUT", {
        type: c.get("baseLayer") ? "radio" : "checkbox",
        className: "ol-visibility",
        checked: c.getVisible(),
        click: s,
        parent: g
      });
      var p = ae.create("LABEL", {
        title: c.get("title") || c.get("name"),
        click: s,
        style: {
          userSelect: "none"
        },
        parent: g
      });
      if (p.addEventListener("selectstart", function() {
        return !1;
      }), ae.create("SPAN", {
        html: c.get("title") || c.get("name"),
        click: function(S) {
          this.get("selection") && (S.stopPropagation(), this.selectLayer(c));
        }.bind(this),
        parent: p
      }), this.reordering && (h < n.length - 1 && (c.get("allwaysOnTop") || !n[h + 1].get("allwaysOnTop")) || h > 0 && (!c.get("allwaysOnTop") || n[h - 1].get("allwaysOnTop"))) && ae.create("DIV", {
        className: "layerup ol-noscroll",
        title: this.tip.up,
        on: { "mousedown touchstart": function(S) {
          r.dragOrdering_(S);
        } },
        parent: f
      }), c.getLayers) {
        var y = 0;
        c.getLayers().forEach(function(S) {
          r.displayInLayerSwitcher(S) && y++;
        }), y && ae.create("DIV", {
          className: c.get("openInLayerSwitcher") ? "collapse-layers" : "expend-layers",
          title: this.tip.plus,
          click: function() {
            var S = r._getLayerForLI(this.parentNode.parentNode);
            S.set("openInLayerSwitcher", !S.get("openInLayerSwitcher"));
          },
          parent: f
        });
      }
      if (this.oninfo && ae.create("DIV", {
        className: "layerInfo",
        title: this.tip.info,
        click: a,
        parent: f
      }), this.hastrash && !c.get("noSwitcherDelete") && ae.create("DIV", {
        className: "layerTrash",
        title: this.tip.trash,
        click: A,
        parent: f
      }), this.hasextent && n[h].getExtent()) {
        var v = n[h].getExtent();
        v.length == 4 && v[0] < v[2] && v[1] < v[3] && ae.create("DIV", {
          className: "layerExtent",
          title: this.tip.extent,
          click: o,
          parent: f
        });
      }
      if (this.show_progress && c instanceof t2) {
        var w = ae.create("DIV", {
          className: "layerswitcher-progress",
          parent: g
        });
        this.setprogress_(c), c.layerswitcher_progress = ae.create("DIV", { parent: w });
      }
      var C = ae.create("DIV", {
        className: "layerswitcher-opacity",
        // Click on the opacity line
        click: function(S) {
          if (S.target === this) {
            S.stopPropagation(), S.preventDefault();
            var M = Math.max(0, Math.min(1, S.offsetX / ae.getStyle(this, "width")));
            r._getLayerForLI(this.parentNode.parentNode).setOpacity(M), this.parentNode.querySelectorAll(".layerswitcher-opacity-label")[0].innerHTML = Math.round(M * 100);
          }
        },
        parent: g
      });
      if (ae.create("DIV", {
        className: "layerswitcher-opacity-cursor ol-noscroll",
        style: { left: c.getOpacity() * 100 + "%" },
        on: {
          "mousedown touchstart": function(S) {
            r.dragOpacity_(S);
          }
        },
        parent: C
      }), ae.create("DIV", {
        className: "layerswitcher-opacity-label",
        html: Math.round(c.getOpacity() * 100),
        parent: g
      }), c.getLayers && (u.classList.add("ol-layer-group"), c.get("openInLayerSwitcher") === !0)) {
        var E = ae.create("UL", {
          parent: u
        });
        this.drawList(E, c.getLayers());
      }
      u.classList.add(this.getLayerClass(c)), this.dispatchEvent({ type: "drawlist", layer: c, li: u });
    }
    for (var h = n.length - 1; h >= 0; h--)
      l.call(this, n[h]);
    this.viewChange(), e === this.panel_ && this.overflow();
  }
  /** Select a layer
   * @param {ol.layer.Layer} layer
   * @returns {string} the layer classname
   * @api
   */
  getLayerClass(e) {
    return e ? e.getLayers ? "ol-layer-group" : e instanceof nA ? "ol-layer-vector" : e instanceof dW ? "ol-layer-vectortile" : e instanceof t2 ? "ol-layer-tile" : e instanceof a4 ? "ol-layer-image" : e instanceof k4 ? "ol-layer-heatmap" : e.getFeatures ? "ol-layer-vectorimage" : "unknown" : "none";
  }
  /** Select a layer
   * @param {ol.layer.Layer} layer
   * @api
   */
  selectLayer(e, t) {
    if (!e) {
      if (!this.getMap())
        return;
      e = this.getMap().getLayers().item(this.getMap().getLayers().getLength() - 1);
    }
    this._selectedLayer = e, this.drawPanel(), t || this.dispatchEvent({ type: "select", layer: e });
  }
  /** Get selected layer
   * @returns {ol.layer.Layer}
   */
  getSelection() {
    return this._selectedLayer;
  }
  /** Handle progress bar for a layer
  *	@private
  */
  setprogress_(e) {
    if (!e.layerswitcher_progress) {
      var t = 0, r = 0, n = function() {
        r === t ? (r = t = 0, ae.setStyle(e.layerswitcher_progress, { width: 0 })) : ae.setStyle(e.layerswitcher_progress, { width: (t / r * 100).toFixed(1) + "%" });
      };
      e.getSource().on("tileloadstart", function() {
        r++, n();
      }), e.getSource().on("tileloadend", function() {
        t++, n();
      }), e.getSource().on("tileloaderror", function() {
        t++, n();
      });
    }
  }
};
dB.prototype.tip = {
  up: "up/down",
  down: "down",
  info: "informations...",
  extent: "zoom to extent",
  trash: "remove layer",
  plus: "expand/shrink"
};
const gW = {
  name: "ol-layerswitcher-control",
  setup(i, e) {
    const { control: t } = cn(dB, i, e);
    return {
      control: t
    };
  },
  props: {
    selection: {
      type: Boolean
    },
    displayInLayerSwitcher: {
      type: Function
    },
    show_progress: {
      type: Boolean,
      default: !1
    },
    mouseover: {
      type: Boolean,
      default: !1
    },
    reordering: {
      type: Boolean,
      default: !0
    },
    trash: {
      type: Boolean,
      default: !1
    },
    oninfo: {
      type: Function
    },
    extent: {
      type: Boolean
    },
    onextent: {
      type: Function
    },
    drawDelay: {
      type: Number
    },
    collapsed: {
      type: Boolean,
      default: !0
    },
    layerGroup: {
      type: Object
    },
    noScroll: {
      type: Boolean,
      default: !1
    }
  }
};
function pW(i, e, t, r, n, s) {
  return ur("", !0);
}
const qm = /* @__PURE__ */ qe(gW, [["render", pW]]);
Xv.prototype.getPreview = function() {
  return "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAEAAAABACAYAAACqaXHeAAAABHNCSVQICAgIfAhkiAAAAAlwSFlzAAAk6QAAJOkBUCTn+AAAABl0RVh0U29mdHdhcmUAd3d3Lmlua3NjYXBlLm9yZ5vuPBoAAANeSURBVHic7ZpPiE1RHMc/780MBhkik79JSUlIUbOxI+wkI2yRhYSUlJLNpJF/xcpiJBmZGBZsNM1CkmhKITGkGbH0/BuPmXnP4rxbb/TOn3fvOffeec6nfqvb/b7f93fveeec37ng8Xg8Ho/nf6Uu4d+fDswFssCvhHOJhaXAMeApMAQUyyIPPAdOAiuTStAVy4EHjDWsix5gdRLJ2mY34ulWYz6IEeA4kIk9awtkgTOEM/5vdAKT4k0/Ou3YMR/ELcbRm9AKFLBbgCJwNE4TYZkJfMG++SIwDCyLz0o4bI17WdyJz0r1TAZ+oDcxCBwAFgIzEIuhvcBbg3sLwOK4DFXLFvQGniCGSSUagS4DjUPOHESkA3XiOWCORqMR6Nfo9DjI3QqPUSd+ylBnv0Zn0GrWFvmIOvGNhjqrNDp/EAutyFgRKUM2tgO+Gur81FxvAKYZaimxXYBvmuuLDHWWaK4X0RfJCNsF6NdcbzXU2a65PohYFKWOc+jn8PUajbWIXaBKp9NB7lZYh34OzwFbFfd/NtDYYSth27urLGIm0M31AL3APWAAmIooymaDnPIl/Vz4NN1yHrd7gcvxWQnHAuA3bsyPop8hUsE13BSgK04TUViBeFo2zedJ8S6wElexW4D2eNOPTjNi6WvD/DtEr8E6tk6GGoAmxFY2iFHE9NZiQf8gogiB9gTEH23izAZuE77vHyU+ANucO1QwD3hD/MbLowAcdm20EmkwXx4n3NodS9rMB2HabYpEWs0HcRqHp0fNwAvJD+eBTZr7p6BvmQVxUaEzEbiruNfJekH15L8jtrEm7JJolEcOmKXRqQOuKDQuY7HZY8s8iNfzkSLxIuI43FTrkkLnOlBfRW4VsWk+oAX5weknxFAxJQNckGgVgZuIRVoomoGXEmGTMa+iQ6K7M4SW7k24QYgiuDQPYinbhugiF4H3RGtzZYCzyIvQXfpNI1ybLyeLpf5+iTbkRbiP2EcocTHm4+YI8iI8RFHwWjAfsA95Q+YZFU6wasl8wB7kReijtNbIILa0vcg/PRlGfPQwHmlCviDqAzaA+OREtzqr1ejOIDorxlNEjTGUBV4nnUWCvAJxGDlA8q9j3DEArAn2zvXAfOwfl6eVAmJrPpJ0Ih6Px+PxeJLjLwPul3vj5d0eAAAAAElFTkSuQmCC";
};
S4.prototype.getPreview = function(i, e) {
  i || (i = [21020, 6355964]), e || (e = 150);
  var t = this.getTileGrid().getTileCoordForCoordAndResolution(i, e), r = this.getTileUrlFunction();
  return r.call(this, t, this.getProjection());
};
N4.prototype.getPreview = function(i, e) {
  i || (i = [21020, 6355964]), e || (e = 150);
  var t = this.getTileUrlFunction();
  if (t) {
    var r = this.getTileGrid() || this.getTileGridForProjection(this.getProjection()), n = r.getTileCoordForCoordAndResolution(i, e);
    return t.call(this, n, 1, this.getProjection());
  }
  var s = this.getGetFeatureInfoUrl ? this.getGetFeatureInfoUrl(i, e, this.getProjection() || "EPSG:3857", {}) : this.getFeatureInfoUrl(i, e, this.getProjection() || "EPSG:3857", {});
  return s = s.replace(/getfeatureinfo/i, "GetMap"), s;
};
bh.prototype.getPreview = function(i, e, t) {
  if (this.get("preview"))
    return [this.get("preview")];
  if (e || (e = 150), e < this.getMinResolution() || e > this.getMaxResolution()) {
    var r = this.getMinResolution(), n = this.getMaxResolution();
    for (n > 1e5 && (n = 156543), r < 0.15 && (r = 0.15), e = n; n > r; )
      r *= 2, n /= 2, e = r;
  }
  var s = this.getExtent();
  if (i || (i = [21020, 6355964]), s && !Wo(s, i) && (i = [(s[0] + s[2]) / 2, (s[1] + s[3]) / 2]), t && (i = cl(i, t, this.getSource().getProjection())), this.getSource && this.getSource())
    try {
      return [this.getSource().getPreview(i, e)];
    } catch {
    }
  return [];
};
pg.prototype.getPreview = function(i, e) {
  if (this.get("preview"))
    return [this.get("preview")];
  var t = [];
  if (this.getLayers)
    for (var r = this.getLayers().getArray(), n = 0; n < r.length; n++)
      t = t.concat(r[n].getPreview(i, e));
  return t;
};
var mW = class extends dB {
  constructor(e) {
    e = e || {}, e.switcherClass = ((e.switcherClass || "") + " ol-layerswitcher-image").trim(), e.mouseover = e.mouseover !== !1, super(e);
  }
  /** Render a list of layer
   * @param {elt} element to render
   * @layers {Array{ol.layer}} list of layer to show
   * @api stable
   */
  drawList(e, t) {
    var r = this, n = function(s) {
      s.preventDefault();
      var a = r._getLayerForLI(this);
      r.switchLayerVisibility(a, t), s.type == "touchstart" && r.element.classList.add("ol-collapsed");
    };
    ae.setStyle(e, { height: "auto" }), t.forEach(function(s) {
      if (r.displayInLayerSwitcher(s)) {
        var a = s.getPreview ? s.getPreview() : ["none"], o = ae.create("LI", {
          className: "ol-imgcontainer" + (s.getVisible() ? " ol-visible" : ""),
          on: { "touchstart click": n },
          parent: e
        });
        r._setLayerForLI(o, s), a.forEach(function(A) {
          ae.create("IMG", {
            src: A,
            parent: o
          });
        }), ae.create("p", {
          html: s.get("title") || s.get("name"),
          parent: o
        }), r.testLayerVisibility(s) && o.classList.add("ol-layer-hidden");
      }
    });
  }
  /** Disable overflow
  */
  overflow() {
  }
};
const vW = {
  name: "ol-layerswitcherimage-control",
  extends: qm,
  setup(i, e) {
    const { control: t } = cn(mW, i, e);
    return {
      control: t
    };
  }
};
function yW(i, e, t, r, n, s) {
  return ur("", !0);
}
const ox = /* @__PURE__ */ qe(vW, [["render", yW]]);
var sh = class extends hn {
  constructor(e) {
    e = e || {};
    var t = t = ae.create("DIV", {
      className: e.className || "ol-mapzone"
    });
    if (super({
      element: t,
      target: e.target
    }), !e.target) {
      ["ol-unselectable", "ol-control", "ol-collapsed"].forEach(function(s) {
        t.classList.add(s);
      });
      var r = ae.create("BUTTON", {
        type: "button",
        on: {
          click: function() {
            t.classList.toggle("ol-collapsed"), n.forEach(function(s) {
              s.updateSize();
            });
          }.bind(this)
        },
        parent: t
      });
      ae.create("I", {
        parent: r
      });
    }
    this.set("centerOnClick", e.centerOnClick);
    var n = this._maps = [];
    this._projection = e.projection, this._layer = e.layer, e.zones.forEach(this.addZone.bind(this)), setTimeout(function() {
      n.forEach(function(s) {
        s.updateSize();
      });
    });
  }
  /** Collapse the control
   * @param {boolean} b
   */
  setCollapsed(e) {
    e ? (this.element.classList.remove("ol-collapsed"), this.getMaps().forEach(function(t) {
      t.updateSize();
    })) : this.element.classList.add("ol-collapsed");
  }
  /** Show the control
   * @param {boolean} b
   */
  setVisible(e) {
    this.setCollapsed(!e);
  }
  /** Get control collapsed
   * @return {boolean}
   */
  getCollapsed() {
    return this.element.classList.contains("ol-collapsed");
  }
  /** Get associated maps
   * @return {ol.Map}
   */
  getMaps() {
    return this._maps;
  }
  /** Get nb zone */
  getLength() {
    return this._maps.length;
  }
  /** Add a new zone to the control
   * @param {Object} z
   *  @param {string} title
   *  @param {ol.extent} extent if map is not defined
   *  @param {ol.Map} map if map is defined use the map extent
   *  @param {ol.layer.Layer} [layer] layer of the zone, default use default control layer
   */
  addZone(e) {
    var t = new Ys({ zoom: 6, center: [0, 0], projection: this._projection }), r;
    e.map ? r = mm(e.map.getView().calculateExtent(), e.map.getView().getProjection(), t.getProjection()) : r = mm(e.extent, "EPSG:4326", t.getProjection());
    var n = ae.create("DIV", {
      className: "ol-mapzonezone",
      parent: this.element,
      click: function() {
        var o = -1;
        this._maps.forEach(function(A, l) {
          A.get("zone") === e && (o = l);
        }), this.dispatchEvent({
          type: "select",
          zone: e,
          index: o,
          coordinate: Xn(r),
          extent: r
        }), this.get("centerOnClick") !== !1 && this.getMap().getView().fit(r), this.setVisible(!1);
      }.bind(this)
    }), s;
    e.layer ? s = e.layer : typeof this._layer == "function" ? s = this._layer(e) : s = new this._layer.constructor({
      source: this._layer.getSource()
    });
    var a = new vg({
      target: n,
      view: t,
      controls: [],
      interactions: [],
      layers: [s]
    });
    a.set("zone", e), this._maps.push(a), t.fit(r), ae.create("P", {
      html: e.title,
      parent: n
    });
  }
  /** Remove a zone from the control
   * @param {number} index
   */
  removeZone(e) {
    var t = this.element.querySelectorAll(".ol-mapzonezone")[e];
    t && (t.remove(), this._maps.splice(e, 1));
  }
};
sh.zones = {};
sh.zones.DOM = [{
  title: "Guadeloupe",
  extent: [-61.898594315312444, 15.75623038647845, -60.957887532935324, 16.575317670979473]
}, {
  title: "Guyane",
  extent: [-54.72525931072715, 2.1603763430019, -51.528236062921344, 5.7984307809552575]
}, {
  title: "Martinique",
  extent: [-61.257556528564756, 14.387506317407514, -60.76934912110432, 14.895067461729951]
}, {
  title: "Mayotte",
  extent: [44.959844536967815, -13.01674138212816, 45.35328866510648, -12.65521942207829]
}, {
  title: "La runion",
  extent: [55.17059012967656, -21.407680069231688, 55.88195702001797, -20.85560221637526]
}];
sh.zones.TOM = [{
  title: "Polynsie Franaise",
  extent: [206.23664226630862, -22.189040615809787, 221.85920743981987, -10.835039595040698]
}, {
  title: "Nouvelle Caldonie",
  extent: [163.76420580160925, -22.581641092751838, 167.66984709498706, -19.816411635668445]
}, {
  title: "St-Pierre et Miquelon",
  extent: [-56.453698765748676, 46.74449858188555, -56.0980198121544, 47.14669874229787]
}, {
  title: "Wallis et Futuna",
  extent: [181.7588623143665, -14.7341169873267, 183.95612353301715, -13.134720799175085]
}, {
  title: "St-Martin St-Barthlemy",
  extent: [-63.1726389501678, 17.806097291313506, -62.7606535945649, 18.13267688837938]
}];
sh.zones.DOMTOM = [{
  title: "Mtropole",
  extent: [-5.318421740712579, 41.16082274292913, 9.73284186155716, 51.21957336557702]
}].concat(sh.zones.DOM, sh.zones.TOM);
const _W = {
  name: "ol-zone-control",
  setup(i, e) {
    const { control: t } = cn(sh, i, e);
    return {
      control: t
    };
  },
  props: {
    className: {
      type: String
    },
    zones: {
      type: Array
    },
    layer: {
      type: [Object, Function]
    },
    projection: {
      type: String,
      default: "EPSG:3857"
    },
    centerOnClick: {
      type: Boolean,
      default: !0
    }
  }
};
function wW(i, e, t, r, n, s) {
  return ur("", !0);
}
const Ax = /* @__PURE__ */ qe(_W, [["render", wW]]);
function Zm(i) {
  Zm.installed || (Zm.installed = !0, i.component(T2.name, T2), i.component(F2.name, F2), i.component(L2.name, L2), i.component(I2.name, I2), i.component(R2.name, R2), i.component(M2.name, M2), i.component(N2.name, N2), i.component(P2.name, P2), i.component(P5.name, P5), i.component(k2.name, k2), i.component(H2.name, H2), i.component(G2.name, G2), i.component($2.name, $2), i.component(V2.name, V2), i.component(sx.name, sx), i.component(ax.name, ax), i.component(qm.name, qm), i.component(ox.name, ox), i.component(Ax.name, Ax));
}
const xW = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  AttributionControl: L2,
  ButtonControl: V2,
  ContextMenuControl: k2,
  ControlBar: G2,
  FullScreenControl: T2,
  LayerSwitcherControl: qm,
  LayerSwitcherImageControl: ox,
  MousePositionControl: F2,
  OverviewMapControl: I2,
  PrintDialog: sx,
  ScaleLineControl: R2,
  SwipeControl: H2,
  ToggleControl: $2,
  VideoRecorderControl: ax,
  ZoneControl: Ax,
  ZoomControl: M2,
  ZoomSliderControl: N2,
  ZoomToExtentControl: P2,
  default: Zm,
  install: Zm
}, Symbol.toStringTag, { value: "Module" }));
function Nu(i, e) {
  const t = _t("feature"), { properties: r } = sr(e), n = cr(
    () => new i(...Object.values(r))
  );
  return at(r, () => {
    t.value.setGeometry(n.value), t.value.changed();
  }), at(t, () => {
    t.value.setGeometry(n.value);
  }), tr(() => {
    t.value.setGeometry(n.value);
  }), nr(() => {
    t.value.setGeometry(null);
  }), {
    geometry: n
  };
}
const CW = {
  name: "ol-geom-point",
  setup(i) {
    const { geometry: e } = Nu(gr, i);
    return {
      geometry: e
    };
  },
  props: {
    coordinates: {
      type: Array
    },
    opt_layout: {
      type: String,
      default: "XY"
    }
  }
};
function EW(i, e, t, r, n, s) {
  return ur("", !0);
}
const lx = /* @__PURE__ */ qe(CW, [["render", EW]]), BW = {
  name: "ol-geom-line-string",
  setup(i) {
    const { geometry: e } = Nu(Gr, i);
    return {
      geometry: e
    };
  },
  props: {
    coordinates: {
      type: Array
    },
    opt_layout: {
      type: String,
      default: "XY"
    }
  }
};
function bW(i, e, t, r, n, s) {
  return ur("", !0);
}
const hx = /* @__PURE__ */ qe(BW, [["render", bW]]), SW = {
  name: "ol-geom-polygon",
  setup(i) {
    const { geometry: e } = Nu(Li, i);
    return {
      geometry: e
    };
  },
  props: {
    coordinates: {
      type: Array
    },
    opt_layout: {
      type: String,
      default: "XY"
    }
  }
};
function TW(i, e, t, r, n, s) {
  return ur("", !0);
}
const cx = /* @__PURE__ */ qe(SW, [["render", TW]]);
let FW = class hN extends Ea {
  /**
   * @param {Array<import("../coordinate.js").Coordinate>|Array<number>} coordinates Coordinates.
   *     For internal use, flat coordinates in combination with `layout` are also accepted.
   * @param {import("./Geometry.js").GeometryLayout} [layout] Layout.
   */
  constructor(e, t) {
    super(), t && !Array.isArray(e[0]) ? this.setFlatCoordinates(
      t,
      /** @type {Array<number>} */
      e
    ) : this.setCoordinates(
      /** @type {Array<import("../coordinate.js").Coordinate>} */
      e,
      t
    );
  }
  /**
   * Append the passed point to this multipoint.
   * @param {Point} point Point.
   * @api
   */
  appendPoint(e) {
    this.flatCoordinates ? Er(this.flatCoordinates, e.getFlatCoordinates()) : this.flatCoordinates = e.getFlatCoordinates().slice(), this.changed();
  }
  /**
   * Make a complete copy of the geometry.
   * @return {!MultiPoint} Clone.
   * @api
   */
  clone() {
    const e = new hN(
      this.flatCoordinates.slice(),
      this.layout
    );
    return e.applyProperties(this), e;
  }
  /**
   * @param {number} x X.
   * @param {number} y Y.
   * @param {import("../coordinate.js").Coordinate} closestPoint Closest point.
   * @param {number} minSquaredDistance Minimum squared distance.
   * @return {number} Minimum squared distance.
   */
  closestPointXY(e, t, r, n) {
    if (n < yl(this.getExtent(), e, t))
      return n;
    const s = this.flatCoordinates, a = this.stride;
    for (let o = 0, A = s.length; o < A; o += a) {
      const l = ko(
        e,
        t,
        s[o],
        s[o + 1]
      );
      if (l < n) {
        n = l;
        for (let h = 0; h < a; ++h)
          r[h] = s[o + h];
        r.length = a;
      }
    }
    return n;
  }
  /**
   * Return the coordinates of the multipoint.
   * @return {Array<import("../coordinate.js").Coordinate>} Coordinates.
   * @api
   */
  getCoordinates() {
    return Qo(
      this.flatCoordinates,
      0,
      this.flatCoordinates.length,
      this.stride
    );
  }
  /**
   * Return the point at the specified index.
   * @param {number} index Index.
   * @return {Point} Point.
   * @api
   */
  getPoint(e) {
    const t = this.flatCoordinates ? this.flatCoordinates.length / this.stride : 0;
    return e < 0 || t <= e ? null : new gr(
      this.flatCoordinates.slice(
        e * this.stride,
        (e + 1) * this.stride
      ),
      this.layout
    );
  }
  /**
   * Return the points of this multipoint.
   * @return {Array<Point>} Points.
   * @api
   */
  getPoints() {
    const e = this.flatCoordinates, t = this.layout, r = this.stride, n = [];
    for (let s = 0, a = e.length; s < a; s += r) {
      const o = new gr(e.slice(s, s + r), t);
      n.push(o);
    }
    return n;
  }
  /**
   * Get the type of this geometry.
   * @return {import("./Geometry.js").Type} Geometry type.
   * @api
   */
  getType() {
    return "MultiPoint";
  }
  /**
   * Test if the geometry and the passed extent intersect.
   * @param {import("../extent.js").Extent} extent Extent.
   * @return {boolean} `true` if the geometry and the extent intersect.
   * @api
   */
  intersectsExtent(e) {
    const t = this.flatCoordinates, r = this.stride;
    for (let n = 0, s = t.length; n < s; n += r) {
      const a = t[n], o = t[n + 1];
      if (Iv(e, a, o))
        return !0;
    }
    return !1;
  }
  /**
   * Set the coordinates of the multipoint.
   * @param {!Array<import("../coordinate.js").Coordinate>} coordinates Coordinates.
   * @param {import("./Geometry.js").GeometryLayout} [layout] Layout.
   * @api
   */
  setCoordinates(e, t) {
    this.setLayout(t, e, 1), this.flatCoordinates || (this.flatCoordinates = []), this.flatCoordinates.length = gg(
      this.flatCoordinates,
      0,
      e,
      this.stride
    ), this.changed();
  }
};
const ta = FW, LW = {
  name: "ol-geom-multi-point",
  setup(i) {
    const { geometry: e } = Nu(ta, i);
    return {
      geometry: e
    };
  },
  props: {
    coordinates: {
      type: Array
    },
    opt_layout: {
      type: String,
      default: "XY"
    }
  }
};
function IW(i, e, t, r, n, s) {
  return ur("", !0);
}
const ux = /* @__PURE__ */ qe(LW, [["render", IW]]);
let RW = class fx extends Ea {
  /**
   * @param {Array<Array<import("../coordinate.js").Coordinate>|LineString>|Array<number>} coordinates
   *     Coordinates or LineString geometries. (For internal use, flat coordinates in
   *     combination with `layout` and `ends` are also accepted.)
   * @param {import("./Geometry.js").GeometryLayout} [layout] Layout.
   * @param {Array<number>} [ends] Flat coordinate ends for internal use.
   */
  constructor(e, t, r) {
    if (super(), this.ends_ = [], this.maxDelta_ = -1, this.maxDeltaRevision_ = -1, Array.isArray(e[0]))
      this.setCoordinates(
        /** @type {Array<Array<import("../coordinate.js").Coordinate>>} */
        e,
        t
      );
    else if (t !== void 0 && r)
      this.setFlatCoordinates(
        t,
        /** @type {Array<number>} */
        e
      ), this.ends_ = r;
    else {
      let n = this.getLayout();
      const s = (
        /** @type {Array<LineString>} */
        e
      ), a = [], o = [];
      for (let A = 0, l = s.length; A < l; ++A) {
        const h = s[A];
        A === 0 && (n = h.getLayout()), Er(a, h.getFlatCoordinates()), o.push(a.length);
      }
      this.setFlatCoordinates(n, a), this.ends_ = o;
    }
  }
  /**
   * Append the passed linestring to the multilinestring.
   * @param {LineString} lineString LineString.
   * @api
   */
  appendLineString(e) {
    this.flatCoordinates ? Er(this.flatCoordinates, e.getFlatCoordinates().slice()) : this.flatCoordinates = e.getFlatCoordinates().slice(), this.ends_.push(this.flatCoordinates.length), this.changed();
  }
  /**
   * Make a complete copy of the geometry.
   * @return {!MultiLineString} Clone.
   * @api
   */
  clone() {
    const e = new fx(
      this.flatCoordinates.slice(),
      this.layout,
      this.ends_.slice()
    );
    return e.applyProperties(this), e;
  }
  /**
   * @param {number} x X.
   * @param {number} y Y.
   * @param {import("../coordinate.js").Coordinate} closestPoint Closest point.
   * @param {number} minSquaredDistance Minimum squared distance.
   * @return {number} Minimum squared distance.
   */
  closestPointXY(e, t, r, n) {
    return n < yl(this.getExtent(), e, t) ? n : (this.maxDeltaRevision_ != this.getRevision() && (this.maxDelta_ = Math.sqrt(
      CE(
        this.flatCoordinates,
        0,
        this.ends_,
        this.stride,
        0
      )
    ), this.maxDeltaRevision_ = this.getRevision()), BE(
      this.flatCoordinates,
      0,
      this.ends_,
      this.stride,
      this.maxDelta_,
      !1,
      e,
      t,
      r,
      n
    ));
  }
  /**
   * Returns the coordinate at `m` using linear interpolation, or `null` if no
   * such coordinate exists.
   *
   * `extrapolate` controls extrapolation beyond the range of Ms in the
   * MultiLineString. If `extrapolate` is `true` then Ms less than the first
   * M will return the first coordinate and Ms greater than the last M will
   * return the last coordinate.
   *
   * `interpolate` controls interpolation between consecutive LineStrings
   * within the MultiLineString. If `interpolate` is `true` the coordinates
   * will be linearly interpolated between the last coordinate of one LineString
   * and the first coordinate of the next LineString.  If `interpolate` is
   * `false` then the function will return `null` for Ms falling between
   * LineStrings.
   *
   * @param {number} m M.
   * @param {boolean} [extrapolate] Extrapolate. Default is `false`.
   * @param {boolean} [interpolate] Interpolate. Default is `false`.
   * @return {import("../coordinate.js").Coordinate|null} Coordinate.
   * @api
   */
  getCoordinateAtM(e, t, r) {
    return this.layout != "XYM" && this.layout != "XYZM" || this.flatCoordinates.length === 0 ? null : (t = t !== void 0 ? t : !1, r = r !== void 0 ? r : !1, tX(
      this.flatCoordinates,
      0,
      this.ends_,
      this.stride,
      e,
      t,
      r
    ));
  }
  /**
   * Return the coordinates of the multilinestring.
   * @return {Array<Array<import("../coordinate.js").Coordinate>>} Coordinates.
   * @api
   */
  getCoordinates() {
    return Ld(
      this.flatCoordinates,
      0,
      this.ends_,
      this.stride
    );
  }
  /**
   * @return {Array<number>} Ends.
   */
  getEnds() {
    return this.ends_;
  }
  /**
   * Return the linestring at the specified index.
   * @param {number} index Index.
   * @return {LineString} LineString.
   * @api
   */
  getLineString(e) {
    return e < 0 || this.ends_.length <= e ? null : new Gr(
      this.flatCoordinates.slice(
        e === 0 ? 0 : this.ends_[e - 1],
        this.ends_[e]
      ),
      this.layout
    );
  }
  /**
   * Return the linestrings of this multilinestring.
   * @return {Array<LineString>} LineStrings.
   * @api
   */
  getLineStrings() {
    const e = this.flatCoordinates, t = this.ends_, r = this.layout, n = [];
    let s = 0;
    for (let a = 0, o = t.length; a < o; ++a) {
      const A = t[a], l = new Gr(
        e.slice(s, A),
        r
      );
      n.push(l), s = A;
    }
    return n;
  }
  /**
   * @return {Array<number>} Flat midpoints.
   */
  getFlatMidpoints() {
    const e = [], t = this.flatCoordinates;
    let r = 0;
    const n = this.ends_, s = this.stride;
    for (let a = 0, o = n.length; a < o; ++a) {
      const A = n[a], l = Xm(
        t,
        r,
        A,
        s,
        0.5
      );
      Er(e, l), r = A;
    }
    return e;
  }
  /**
   * @param {number} squaredTolerance Squared tolerance.
   * @return {MultiLineString} Simplified MultiLineString.
   * @protected
   */
  getSimplifiedGeometryInternal(e) {
    const t = [], r = [];
    return t.length = UD(
      this.flatCoordinates,
      0,
      this.ends_,
      this.stride,
      e,
      t,
      0,
      r
    ), new fx(t, "XY", r);
  }
  /**
   * Get the type of this geometry.
   * @return {import("./Geometry.js").Type} Geometry type.
   * @api
   */
  getType() {
    return "MultiLineString";
  }
  /**
   * Test if the geometry and the passed extent intersect.
   * @param {import("../extent.js").Extent} extent Extent.
   * @return {boolean} `true` if the geometry and the extent intersect.
   * @api
   */
  intersectsExtent(e) {
    return VD(
      this.flatCoordinates,
      0,
      this.ends_,
      this.stride,
      e
    );
  }
  /**
   * Set the coordinates of the multilinestring.
   * @param {!Array<Array<import("../coordinate.js").Coordinate>>} coordinates Coordinates.
   * @param {import("./Geometry.js").GeometryLayout} [layout] Layout.
   * @api
   */
  setCoordinates(e, t) {
    this.setLayout(t, e, 2), this.flatCoordinates || (this.flatCoordinates = []);
    const r = bE(
      this.flatCoordinates,
      0,
      e,
      this.stride,
      this.ends_
    );
    this.flatCoordinates.length = r.length === 0 ? 0 : r[r.length - 1], this.changed();
  }
};
const In = RW, MW = {
  name: "ol-geom-multi-line-string",
  setup(i) {
    const { geometry: e } = Nu(In, i);
    return {
      geometry: e
    };
  },
  props: {
    coordinates: {
      type: Array
    },
    opt_layout: {
      type: String,
      default: "XY"
    }
  }
};
function NW(i, e, t, r, n, s) {
  return ur("", !0);
}
const dx = /* @__PURE__ */ qe(MW, [["render", NW]]);
function cN(i, e, t, r) {
  const n = [];
  let s = Ji();
  for (let a = 0, o = t.length; a < o; ++a) {
    const A = t[a];
    s = Rv(
      i,
      e,
      A[0],
      r
    ), n.push((s[0] + s[2]) / 2, (s[1] + s[3]) / 2), e = A[A.length - 1];
  }
  return n;
}
let PW = class gx extends Ea {
  /**
   * @param {Array<Array<Array<import("../coordinate.js").Coordinate>>|Polygon>|Array<number>} coordinates Coordinates.
   *     For internal use, flat coordinates in combination with `layout` and `endss` are also accepted.
   * @param {import("./Geometry.js").GeometryLayout} [layout] Layout.
   * @param {Array<Array<number>>} [endss] Array of ends for internal use with flat coordinates.
   */
  constructor(e, t, r) {
    if (super(), this.endss_ = [], this.flatInteriorPointsRevision_ = -1, this.flatInteriorPoints_ = null, this.maxDelta_ = -1, this.maxDeltaRevision_ = -1, this.orientedRevision_ = -1, this.orientedFlatCoordinates_ = null, !r && !Array.isArray(e[0])) {
      let n = this.getLayout();
      const s = (
        /** @type {Array<Polygon>} */
        e
      ), a = [], o = [];
      for (let A = 0, l = s.length; A < l; ++A) {
        const h = s[A];
        A === 0 && (n = h.getLayout());
        const c = a.length, u = h.getEnds();
        for (let f = 0, g = u.length; f < g; ++f)
          u[f] += c;
        Er(a, h.getFlatCoordinates()), o.push(u);
      }
      t = n, e = a, r = o;
    }
    t !== void 0 && r ? (this.setFlatCoordinates(
      t,
      /** @type {Array<number>} */
      e
    ), this.endss_ = r) : this.setCoordinates(
      /** @type {Array<Array<Array<import("../coordinate.js").Coordinate>>>} */
      e,
      t
    );
  }
  /**
   * Append the passed polygon to this multipolygon.
   * @param {Polygon} polygon Polygon.
   * @api
   */
  appendPolygon(e) {
    let t;
    if (!this.flatCoordinates)
      this.flatCoordinates = e.getFlatCoordinates().slice(), t = e.getEnds().slice(), this.endss_.push();
    else {
      const r = this.flatCoordinates.length;
      Er(this.flatCoordinates, e.getFlatCoordinates()), t = e.getEnds().slice();
      for (let n = 0, s = t.length; n < s; ++n)
        t[n] += r;
    }
    this.endss_.push(t), this.changed();
  }
  /**
   * Make a complete copy of the geometry.
   * @return {!MultiPolygon} Clone.
   * @api
   */
  clone() {
    const e = this.endss_.length, t = new Array(e);
    for (let n = 0; n < e; ++n)
      t[n] = this.endss_[n].slice();
    const r = new gx(
      this.flatCoordinates.slice(),
      this.layout,
      t
    );
    return r.applyProperties(this), r;
  }
  /**
   * @param {number} x X.
   * @param {number} y Y.
   * @param {import("../coordinate.js").Coordinate} closestPoint Closest point.
   * @param {number} minSquaredDistance Minimum squared distance.
   * @return {number} Minimum squared distance.
   */
  closestPointXY(e, t, r, n) {
    return n < yl(this.getExtent(), e, t) ? n : (this.maxDeltaRevision_ != this.getRevision() && (this.maxDelta_ = Math.sqrt(
      ND(
        this.flatCoordinates,
        0,
        this.endss_,
        this.stride,
        0
      )
    ), this.maxDeltaRevision_ = this.getRevision()), PD(
      this.getOrientedFlatCoordinates(),
      0,
      this.endss_,
      this.stride,
      this.maxDelta_,
      !0,
      e,
      t,
      r,
      n
    ));
  }
  /**
   * @param {number} x X.
   * @param {number} y Y.
   * @return {boolean} Contains (x, y).
   */
  containsXY(e, t) {
    return $D(
      this.getOrientedFlatCoordinates(),
      0,
      this.endss_,
      this.stride,
      e,
      t
    );
  }
  /**
   * Return the area of the multipolygon on projected plane.
   * @return {number} Area (on projected plane).
   * @api
   */
  getArea() {
    return kD(
      this.getOrientedFlatCoordinates(),
      0,
      this.endss_,
      this.stride
    );
  }
  /**
   * Get the coordinate array for this geometry.  This array has the structure
   * of a GeoJSON coordinate array for multi-polygons.
   *
   * @param {boolean} [right] Orient coordinates according to the right-hand
   *     rule (counter-clockwise for exterior and clockwise for interior rings).
   *     If `false`, coordinates will be oriented according to the left-hand rule
   *     (clockwise for exterior and counter-clockwise for interior rings).
   *     By default, coordinate orientation will depend on how the geometry was
   *     constructed.
   * @return {Array<Array<Array<import("../coordinate.js").Coordinate>>>} Coordinates.
   * @api
   */
  getCoordinates(e) {
    let t;
    return e !== void 0 ? (t = this.getOrientedFlatCoordinates().slice(), OS(
      t,
      0,
      this.endss_,
      this.stride,
      e
    )) : t = this.flatCoordinates, Qw(
      t,
      0,
      this.endss_,
      this.stride
    );
  }
  /**
   * @return {Array<Array<number>>} Endss.
   */
  getEndss() {
    return this.endss_;
  }
  /**
   * @return {Array<number>} Flat interior points.
   */
  getFlatInteriorPoints() {
    if (this.flatInteriorPointsRevision_ != this.getRevision()) {
      const e = cN(
        this.flatCoordinates,
        0,
        this.endss_,
        this.stride
      );
      this.flatInteriorPoints_ = zR(
        this.getOrientedFlatCoordinates(),
        0,
        this.endss_,
        this.stride,
        e
      ), this.flatInteriorPointsRevision_ = this.getRevision();
    }
    return this.flatInteriorPoints_;
  }
  /**
   * Return the interior points as {@link module:ol/geom/MultiPoint~MultiPoint multipoint}.
   * @return {MultiPoint} Interior points as XYM coordinates, where M is
   * the length of the horizontal intersection that the point belongs to.
   * @api
   */
  getInteriorPoints() {
    return new ta(this.getFlatInteriorPoints().slice(), "XYM");
  }
  /**
   * @return {Array<number>} Oriented flat coordinates.
   */
  getOrientedFlatCoordinates() {
    if (this.orientedRevision_ != this.getRevision()) {
      const e = this.flatCoordinates;
      zD(e, 0, this.endss_, this.stride) ? this.orientedFlatCoordinates_ = e : (this.orientedFlatCoordinates_ = e.slice(), this.orientedFlatCoordinates_.length = OS(
        this.orientedFlatCoordinates_,
        0,
        this.endss_,
        this.stride
      )), this.orientedRevision_ = this.getRevision();
    }
    return this.orientedFlatCoordinates_;
  }
  /**
   * @param {number} squaredTolerance Squared tolerance.
   * @return {MultiPolygon} Simplified MultiPolygon.
   * @protected
   */
  getSimplifiedGeometryInternal(e) {
    const t = [], r = [];
    return t.length = DD(
      this.flatCoordinates,
      0,
      this.endss_,
      this.stride,
      Math.sqrt(e),
      t,
      0,
      r
    ), new gx(t, "XY", r);
  }
  /**
   * Return the polygon at the specified index.
   * @param {number} index Index.
   * @return {Polygon} Polygon.
   * @api
   */
  getPolygon(e) {
    if (e < 0 || this.endss_.length <= e)
      return null;
    let t;
    if (e === 0)
      t = 0;
    else {
      const s = this.endss_[e - 1];
      t = s[s.length - 1];
    }
    const r = this.endss_[e].slice(), n = r[r.length - 1];
    if (t !== 0)
      for (let s = 0, a = r.length; s < a; ++s)
        r[s] -= t;
    return new Li(
      this.flatCoordinates.slice(t, n),
      this.layout,
      r
    );
  }
  /**
   * Return the polygons of this multipolygon.
   * @return {Array<Polygon>} Polygons.
   * @api
   */
  getPolygons() {
    const e = this.layout, t = this.flatCoordinates, r = this.endss_, n = [];
    let s = 0;
    for (let a = 0, o = r.length; a < o; ++a) {
      const A = r[a].slice(), l = A[A.length - 1];
      if (s !== 0)
        for (let c = 0, u = A.length; c < u; ++c)
          A[c] -= s;
      const h = new Li(
        t.slice(s, l),
        e,
        A
      );
      n.push(h), s = l;
    }
    return n;
  }
  /**
   * Get the type of this geometry.
   * @return {import("./Geometry.js").Type} Geometry type.
   * @api
   */
  getType() {
    return "MultiPolygon";
  }
  /**
   * Test if the geometry and the passed extent intersect.
   * @param {import("../extent.js").Extent} extent Extent.
   * @return {boolean} `true` if the geometry and the extent intersect.
   * @api
   */
  intersectsExtent(e) {
    return KD(
      this.getOrientedFlatCoordinates(),
      0,
      this.endss_,
      this.stride,
      e
    );
  }
  /**
   * Set the coordinates of the multipolygon.
   * @param {!Array<Array<Array<import("../coordinate.js").Coordinate>>>} coordinates Coordinates.
   * @param {import("./Geometry.js").GeometryLayout} [layout] Layout.
   * @api
   */
  setCoordinates(e, t) {
    this.setLayout(t, e, 3), this.flatCoordinates || (this.flatCoordinates = []);
    const r = OD(
      this.flatCoordinates,
      0,
      e,
      this.stride,
      this.endss_
    );
    if (r.length === 0)
      this.flatCoordinates.length = 0;
    else {
      const n = r[r.length - 1];
      this.flatCoordinates.length = n.length === 0 ? 0 : n[n.length - 1];
    }
    this.changed();
  }
};
const Rn = PW, OW = {
  name: "ol-geom-multi-polygon",
  setup(i) {
    const { geometry: e } = Nu(Rn, i);
    return {
      geometry: e
    };
  },
  props: {
    coordinates: {
      type: Array
    },
    opt_layout: {
      type: String,
      default: "XY"
    }
  }
};
function UW(i, e, t, r, n, s) {
  return ur("", !0);
}
const px = /* @__PURE__ */ qe(OW, [["render", UW]]);
function Jm(i) {
  Jm.installed || (Jm.installed = !0, i.component(lx.name, lx), i.component(hx.name, hx), i.component(cx.name, cx), i.component(ux.name, ux), i.component(dx.name, dx), i.component(px.name, px));
}
const QW = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  LineString: hx,
  MultiLineString: dx,
  MultiPoint: ux,
  MultiPolygon: px,
  Point: lx,
  Polygon: cx,
  default: Jm,
  install: Jm
}, Symbol.toStringTag, { value: "Module" }));
let uN = class fN extends Ea {
  /**
   * @param {!import("../coordinate.js").Coordinate} center Center.
   *     For internal use, flat coordinates in combination with `layout` and no
   *     `radius` are also accepted.
   * @param {number} [radius] Radius.
   * @param {import("./Geometry.js").GeometryLayout} [layout] Layout.
   */
  constructor(e, t, r) {
    super(), r !== void 0 && t === void 0 ? this.setFlatCoordinates(r, e) : (t = t || 0, this.setCenterAndRadius(e, t, r));
  }
  /**
   * Make a complete copy of the geometry.
   * @return {!Circle} Clone.
   * @api
   */
  clone() {
    const e = new fN(
      this.flatCoordinates.slice(),
      void 0,
      this.layout
    );
    return e.applyProperties(this), e;
  }
  /**
   * @param {number} x X.
   * @param {number} y Y.
   * @param {import("../coordinate.js").Coordinate} closestPoint Closest point.
   * @param {number} minSquaredDistance Minimum squared distance.
   * @return {number} Minimum squared distance.
   */
  closestPointXY(e, t, r, n) {
    const s = this.flatCoordinates, a = e - s[0], o = t - s[1], A = a * a + o * o;
    if (A < n) {
      if (A === 0)
        for (let l = 0; l < this.stride; ++l)
          r[l] = s[l];
      else {
        const l = this.getRadius() / Math.sqrt(A);
        r[0] = s[0] + l * a, r[1] = s[1] + l * o;
        for (let h = 2; h < this.stride; ++h)
          r[h] = s[h];
      }
      return r.length = this.stride, A;
    }
    return n;
  }
  /**
   * @param {number} x X.
   * @param {number} y Y.
   * @return {boolean} Contains (x, y).
   */
  containsXY(e, t) {
    const r = this.flatCoordinates, n = e - r[0], s = t - r[1];
    return n * n + s * s <= this.getRadiusSquared_();
  }
  /**
   * Return the center of the circle as {@link module:ol/coordinate~Coordinate coordinate}.
   * @return {import("../coordinate.js").Coordinate} Center.
   * @api
   */
  getCenter() {
    return this.flatCoordinates.slice(0, this.stride);
  }
  /**
   * @param {import("../extent.js").Extent} extent Extent.
   * @protected
   * @return {import("../extent.js").Extent} extent Extent.
   */
  computeExtent(e) {
    const t = this.flatCoordinates, r = t[this.stride] - t[0];
    return ms(
      t[0] - r,
      t[1] - r,
      t[0] + r,
      t[1] + r,
      e
    );
  }
  /**
   * Return the radius of the circle.
   * @return {number} Radius.
   * @api
   */
  getRadius() {
    return Math.sqrt(this.getRadiusSquared_());
  }
  /**
   * @private
   * @return {number} Radius squared.
   */
  getRadiusSquared_() {
    const e = this.flatCoordinates[this.stride] - this.flatCoordinates[0], t = this.flatCoordinates[this.stride + 1] - this.flatCoordinates[1];
    return e * e + t * t;
  }
  /**
   * Get the type of this geometry.
   * @return {import("./Geometry.js").Type} Geometry type.
   * @api
   */
  getType() {
    return "Circle";
  }
  /**
   * Test if the geometry and the passed extent intersect.
   * @param {import("../extent.js").Extent} extent Extent.
   * @return {boolean} `true` if the geometry and the extent intersect.
   * @api
   */
  intersectsExtent(e) {
    const t = this.getExtent();
    if (ci(e, t)) {
      const r = this.getCenter();
      return e[0] <= r[0] && e[2] >= r[0] || e[1] <= r[1] && e[3] >= r[1] ? !0 : Mv(e, this.intersectsCoordinate.bind(this));
    }
    return !1;
  }
  /**
   * Set the center of the circle as {@link module:ol/coordinate~Coordinate coordinate}.
   * @param {import("../coordinate.js").Coordinate} center Center.
   * @api
   */
  setCenter(e) {
    const t = this.stride, r = this.flatCoordinates[t] - this.flatCoordinates[0], n = e.slice();
    n[t] = n[0] + r;
    for (let s = 1; s < t; ++s)
      n[t + s] = e[s];
    this.setFlatCoordinates(this.layout, n), this.changed();
  }
  /**
   * Set the center (as {@link module:ol/coordinate~Coordinate coordinate}) and the radius (as
   * number) of the circle.
   * @param {!import("../coordinate.js").Coordinate} center Center.
   * @param {number} radius Radius.
   * @param {import("./Geometry.js").GeometryLayout} [layout] Layout.
   * @api
   */
  setCenterAndRadius(e, t, r) {
    this.setLayout(r, e, 0), this.flatCoordinates || (this.flatCoordinates = []);
    const n = this.flatCoordinates;
    let s = GR(n, 0, e, this.stride);
    n[s++] = n[0] + t;
    for (let a = 1, o = this.stride; a < o; ++a)
      n[s++] = n[a];
    n.length = s, this.changed();
  }
  getCoordinates() {
    return null;
  }
  setCoordinates(e, t) {
  }
  /**
   * Set the radius of the circle. The radius is in the units of the projection.
   * @param {number} radius Radius.
   * @api
   */
  setRadius(e) {
    this.flatCoordinates[this.stride] = this.flatCoordinates[0] + e, this.changed();
  }
  /**
   * Rotate the geometry around a given coordinate. This modifies the geometry
   * coordinates in place.
   * @param {number} angle Rotation angle in counter-clockwise radians.
   * @param {import("../coordinate.js").Coordinate} anchor The rotation center.
   * @api
   */
  rotate(e, t) {
    const r = this.getCenter(), n = this.getStride();
    this.setCenter(
      wE(r, 0, r.length, n, e, t, r)
    ), this.changed();
  }
  /**
   * Translate the geometry.  This modifies the geometry coordinates in place.  If
   * instead you want a new geometry, first `clone()` this geometry.
   * @param {number} deltaX Delta X.
   * @param {number} deltaY Delta Y.
   * @api
   */
  translate(e, t) {
    const r = this.getCenter(), n = this.getStride();
    this.setCenter(
      HR(r, 0, r.length, n, e, t, r)
    ), this.changed();
  }
};
uN.prototype.transform;
const gB = uN;
class ev extends dg {
  /**
   * @param {Array<Geometry>} [geometries] Geometries.
   */
  constructor(e) {
    super(), this.geometries_ = e || null, this.changeEventsKeys_ = [], this.listenGeometriesChange_();
  }
  /**
   * @private
   */
  unlistenGeometriesChange_() {
    this.changeEventsKeys_.forEach(pr), this.changeEventsKeys_.length = 0;
  }
  /**
   * @private
   */
  listenGeometriesChange_() {
    if (this.geometries_)
      for (let e = 0, t = this.geometries_.length; e < t; ++e)
        this.changeEventsKeys_.push(
          St(this.geometries_[e], ut.CHANGE, this.changed, this)
        );
  }
  /**
   * Make a complete copy of the geometry.
   * @return {!GeometryCollection} Clone.
   * @api
   */
  clone() {
    const e = new ev(null);
    return e.setGeometries(this.geometries_), e.applyProperties(this), e;
  }
  /**
   * @param {number} x X.
   * @param {number} y Y.
   * @param {import("../coordinate.js").Coordinate} closestPoint Closest point.
   * @param {number} minSquaredDistance Minimum squared distance.
   * @return {number} Minimum squared distance.
   */
  closestPointXY(e, t, r, n) {
    if (n < yl(this.getExtent(), e, t))
      return n;
    const s = this.geometries_;
    for (let a = 0, o = s.length; a < o; ++a)
      n = s[a].closestPointXY(
        e,
        t,
        r,
        n
      );
    return n;
  }
  /**
   * @param {number} x X.
   * @param {number} y Y.
   * @return {boolean} Contains (x, y).
   */
  containsXY(e, t) {
    const r = this.geometries_;
    for (let n = 0, s = r.length; n < s; ++n)
      if (r[n].containsXY(e, t))
        return !0;
    return !1;
  }
  /**
   * @param {import("../extent.js").Extent} extent Extent.
   * @protected
   * @return {import("../extent.js").Extent} extent Extent.
   */
  computeExtent(e) {
    _l(e);
    const t = this.geometries_;
    for (let r = 0, n = t.length; r < n; ++r)
      Jl(e, t[r].getExtent());
    return e;
  }
  /**
   * Return the geometries that make up this geometry collection.
   * @return {Array<Geometry>} Geometries.
   * @api
   */
  getGeometries() {
    return lT(this.geometries_);
  }
  /**
   * @return {Array<Geometry>} Geometries.
   */
  getGeometriesArray() {
    return this.geometries_;
  }
  /**
   * @return {Array<Geometry>} Geometries.
   */
  getGeometriesArrayRecursive() {
    let e = [];
    const t = this.geometries_;
    for (let r = 0, n = t.length; r < n; ++r)
      t[r].getType() === this.getType() ? e = e.concat(
        /** @type {GeometryCollection} */
        t[r].getGeometriesArrayRecursive()
      ) : e.push(t[r]);
    return e;
  }
  /**
   * Create a simplified version of this geometry using the Douglas Peucker algorithm.
   * @param {number} squaredTolerance Squared tolerance.
   * @return {GeometryCollection} Simplified GeometryCollection.
   */
  getSimplifiedGeometry(e) {
    if (this.simplifiedGeometryRevision !== this.getRevision() && (this.simplifiedGeometryMaxMinSquaredTolerance = 0, this.simplifiedGeometryRevision = this.getRevision()), e < 0 || this.simplifiedGeometryMaxMinSquaredTolerance !== 0 && e < this.simplifiedGeometryMaxMinSquaredTolerance)
      return this;
    const t = [], r = this.geometries_;
    let n = !1;
    for (let s = 0, a = r.length; s < a; ++s) {
      const o = r[s], A = o.getSimplifiedGeometry(e);
      t.push(A), A !== o && (n = !0);
    }
    if (n) {
      const s = new ev(null);
      return s.setGeometriesArray(t), s;
    }
    return this.simplifiedGeometryMaxMinSquaredTolerance = e, this;
  }
  /**
   * Get the type of this geometry.
   * @return {import("./Geometry.js").Type} Geometry type.
   * @api
   */
  getType() {
    return "GeometryCollection";
  }
  /**
   * Test if the geometry and the passed extent intersect.
   * @param {import("../extent.js").Extent} extent Extent.
   * @return {boolean} `true` if the geometry and the extent intersect.
   * @api
   */
  intersectsExtent(e) {
    const t = this.geometries_;
    for (let r = 0, n = t.length; r < n; ++r)
      if (t[r].intersectsExtent(e))
        return !0;
    return !1;
  }
  /**
   * @return {boolean} Is empty.
   */
  isEmpty() {
    return this.geometries_.length === 0;
  }
  /**
   * Rotate the geometry around a given coordinate. This modifies the geometry
   * coordinates in place.
   * @param {number} angle Rotation angle in radians.
   * @param {import("../coordinate.js").Coordinate} anchor The rotation center.
   * @api
   */
  rotate(e, t) {
    const r = this.geometries_;
    for (let n = 0, s = r.length; n < s; ++n)
      r[n].rotate(e, t);
    this.changed();
  }
  /**
   * Scale the geometry (with an optional origin).  This modifies the geometry
   * coordinates in place.
   * @abstract
   * @param {number} sx The scaling factor in the x-direction.
   * @param {number} [sy] The scaling factor in the y-direction (defaults to sx).
   * @param {import("../coordinate.js").Coordinate} [anchor] The scale origin (defaults to the center
   *     of the geometry extent).
   * @api
   */
  scale(e, t, r) {
    r || (r = Xn(this.getExtent()));
    const n = this.geometries_;
    for (let s = 0, a = n.length; s < a; ++s)
      n[s].scale(e, t, r);
    this.changed();
  }
  /**
   * Set the geometries that make up this geometry collection.
   * @param {Array<Geometry>} geometries Geometries.
   * @api
   */
  setGeometries(e) {
    this.setGeometriesArray(lT(e));
  }
  /**
   * @param {Array<Geometry>} geometries Geometries.
   */
  setGeometriesArray(e) {
    this.unlistenGeometriesChange_(), this.geometries_ = e, this.listenGeometriesChange_(), this.changed();
  }
  /**
   * Apply a transform function to the coordinates of the geometry.
   * The geometry is modified in place.
   * If you do not want the geometry modified in place, first `clone()` it and
   * then use this function on the clone.
   * @param {import("../proj.js").TransformFunction} transformFn Transform function.
   * Called with a flat array of geometry coordinates.
   * @api
   */
  applyTransform(e) {
    const t = this.geometries_;
    for (let r = 0, n = t.length; r < n; ++r)
      t[r].applyTransform(e);
    this.changed();
  }
  /**
   * Translate the geometry.  This modifies the geometry coordinates in place.  If
   * instead you want a new geometry, first `clone()` this geometry.
   * @param {number} deltaX Delta X.
   * @param {number} deltaY Delta Y.
   * @api
   */
  translate(e, t) {
    const r = this.geometries_;
    for (let n = 0, s = r.length; n < s; ++n)
      r[n].translate(e, t);
    this.changed();
  }
  /**
   * Clean up.
   */
  disposeInternal() {
    this.unlistenGeometriesChange_(), super.disposeInternal();
  }
}
function lT(i) {
  const e = [];
  for (let t = 0, r = i.length; t < r; ++t)
    e.push(i[t].clone());
  return e;
}
const _n = ev, $p = {
  /**
   * Triggered upon feature draw start
   * @event DrawEvent#drawstart
   * @api
   */
  DRAWSTART: "drawstart",
  /**
   * Triggered upon feature draw end
   * @event DrawEvent#drawend
   * @api
   */
  DRAWEND: "drawend",
  /**
   * Triggered upon feature draw abortion
   * @event DrawEvent#drawabort
   * @api
   */
  DRAWABORT: "drawabort"
};
class Vp extends _s {
  /**
   * @param {DrawEventType} type Type.
   * @param {Feature} feature The feature drawn.
   */
  constructor(e, t) {
    super(e), this.feature = t;
  }
}
function DW(i, e) {
  const t = [];
  for (let r = 0; r < e.length; ++r) {
    const s = e[r].getGeometry();
    dN(i, s, t);
  }
  return t;
}
function Kp(i, e) {
  return ko(i[0], i[1], e[0], e[1]);
}
function $c(i, e) {
  const t = i.length;
  return e < 0 ? i[e + t] : e >= t ? i[e - t] : i[e];
}
function jp(i, e, t) {
  let r, n;
  e < t ? (r = e, n = t) : (r = t, n = e);
  const s = Math.ceil(r), a = Math.floor(n);
  if (s > a) {
    const A = Vc(i, r), l = Vc(i, n);
    return Kp(A, l);
  }
  let o = 0;
  if (r < s) {
    const A = Vc(i, r), l = $c(i, s);
    o += Kp(A, l);
  }
  if (a < n) {
    const A = $c(i, a), l = Vc(i, n);
    o += Kp(A, l);
  }
  for (let A = s; A < a - 1; ++A) {
    const l = $c(i, A), h = $c(i, A + 1);
    o += Kp(l, h);
  }
  return o;
}
function dN(i, e, t) {
  if (e instanceof Gr) {
    zp(i, e.getCoordinates(), !1, t);
    return;
  }
  if (e instanceof In) {
    const r = e.getCoordinates();
    for (let n = 0, s = r.length; n < s; ++n)
      zp(i, r[n], !1, t);
    return;
  }
  if (e instanceof Li) {
    const r = e.getCoordinates();
    for (let n = 0, s = r.length; n < s; ++n)
      zp(i, r[n], !0, t);
    return;
  }
  if (e instanceof Rn) {
    const r = e.getCoordinates();
    for (let n = 0, s = r.length; n < s; ++n) {
      const a = r[n];
      for (let o = 0, A = a.length; o < A; ++o)
        zp(i, a[o], !0, t);
    }
    return;
  }
  if (e instanceof _n) {
    const r = e.getGeometries();
    for (let n = 0; n < r.length; ++n)
      dN(i, r[n], t);
    return;
  }
}
const h_ = { index: -1, endIndex: NaN };
function kW(i, e, t, r) {
  const n = i[0], s = i[1];
  let a = 1 / 0, o = -1, A = NaN;
  for (let c = 0; c < e.targets.length; ++c) {
    const u = e.targets[c], f = u.coordinates;
    let g = 1 / 0, p;
    for (let y = 0; y < f.length - 1; ++y) {
      const v = f[y], w = f[y + 1], C = gN(n, s, v, w);
      C.squaredDistance < g && (g = C.squaredDistance, p = y + C.along);
    }
    g < a && (a = g, u.ring && e.targetIndex === c && (u.endIndex > u.startIndex ? p < u.startIndex && (p += f.length) : u.endIndex < u.startIndex && p > u.startIndex && (p -= f.length)), A = p, o = c);
  }
  const l = e.targets[o];
  let h = l.ring;
  if (e.targetIndex === o && h) {
    const c = Vc(
      l.coordinates,
      A
    ), u = t.getPixelFromCoordinate(c);
    dm(u, e.startPx) > r && (h = !1);
  }
  if (h) {
    const c = l.coordinates, u = c.length, f = l.startIndex, g = A;
    if (f < g) {
      const p = jp(
        c,
        f,
        g
      );
      jp(
        c,
        f,
        g - u
      ) < p && (A -= u);
    } else {
      const p = jp(
        c,
        f,
        g
      );
      jp(
        c,
        f,
        g + u
      ) < p && (A += u);
    }
  }
  return h_.index = o, h_.endIndex = A, h_;
}
function zp(i, e, t, r) {
  const n = i[0], s = i[1];
  for (let a = 0, o = e.length - 1; a < o; ++a) {
    const A = e[a], l = e[a + 1], h = gN(n, s, A, l);
    if (h.squaredDistance === 0) {
      const c = a + h.along;
      r.push({
        coordinates: e,
        ring: t,
        startIndex: c,
        endIndex: c
      });
      return;
    }
  }
}
const c_ = { along: 0, squaredDistance: 0 };
function gN(i, e, t, r) {
  const n = t[0], s = t[1], a = r[0], o = r[1], A = a - n, l = o - s;
  let h = 0, c = n, u = s;
  return (A !== 0 || l !== 0) && (h = jr(((i - n) * A + (e - s) * l) / (A * A + l * l), 0, 1), c += A * h, u += l * h), c_.along = h, c_.squaredDistance = cg(ko(i, e, c, u), 10), c_;
}
function Vc(i, e) {
  const t = i.length;
  let r = Math.floor(e);
  const n = e - r;
  r >= t ? r -= t : r < 0 && (r += t);
  let s = r + 1;
  s >= t && (s -= t);
  const a = i[r], o = a[0], A = a[1], l = i[s], h = l[0] - o, c = l[1] - A;
  return [o + h * n, A + c * n];
}
class HW extends eo {
  /**
   * @param {Options} options Options.
   */
  constructor(e) {
    const t = (
      /** @type {import("./Pointer.js").Options} */
      e
    );
    t.stopDown || (t.stopDown = Eh), super(t), this.on, this.once, this.un, this.shouldHandle_ = !1, this.downPx_ = null, this.downTimeout_, this.lastDragTime_, this.pointerType_, this.freehand_ = !1, this.source_ = e.source ? e.source : null, this.features_ = e.features ? e.features : null, this.snapTolerance_ = e.snapTolerance ? e.snapTolerance : 12, this.type_ = /** @type {import("../geom/Geometry.js").Type} */
    e.type, this.mode_ = $W(this.type_), this.stopClick_ = !!e.stopClick, this.minPoints_ = e.minPoints ? e.minPoints : this.mode_ === "Polygon" ? 3 : 2, this.maxPoints_ = this.mode_ === "Circle" ? 2 : e.maxPoints ? e.maxPoints : 1 / 0, this.finishCondition_ = e.finishCondition ? e.finishCondition : Xo, this.geometryLayout_ = e.geometryLayout ? e.geometryLayout : "XY";
    let r = e.geometryFunction;
    if (!r) {
      const n = this.mode_;
      if (n === "Circle")
        r = function(s, a, o) {
          const A = a || new gB([NaN, NaN]), l = ai(s[0]), h = Ho(
            l,
            ai(s[s.length - 1])
          );
          return A.setCenterAndRadius(
            l,
            Math.sqrt(h),
            this.geometryLayout_
          ), A;
        };
      else {
        let s;
        n === "Point" ? s = gr : n === "LineString" ? s = Gr : n === "Polygon" && (s = Li), r = function(a, o, A) {
          return o ? n === "Polygon" ? a[0].length ? o.setCoordinates(
            [a[0].concat([a[0][0]])],
            this.geometryLayout_
          ) : o.setCoordinates([], this.geometryLayout_) : o.setCoordinates(a, this.geometryLayout_) : o = new s(a, this.geometryLayout_), o;
        };
      }
    }
    this.geometryFunction_ = r, this.dragVertexDelay_ = e.dragVertexDelay !== void 0 ? e.dragVertexDelay : 500, this.finishCoordinate_ = null, this.sketchFeature_ = null, this.sketchPoint_ = null, this.sketchCoords_ = null, this.sketchLine_ = null, this.sketchLineCoords_ = null, this.squaredClickTolerance_ = e.clickTolerance ? e.clickTolerance * e.clickTolerance : 36, this.overlay_ = new nA({
      source: new sA({
        useSpatialIndex: !1,
        wrapX: e.wrapX ? e.wrapX : !1
      }),
      style: e.style ? e.style : GW(),
      updateWhileInteracting: !0
    }), this.geometryName_ = e.geometryName, this.condition_ = e.condition ? e.condition : kv, this.freehandCondition_, e.freehand ? this.freehandCondition_ = Ud : this.freehandCondition_ = e.freehandCondition ? e.freehandCondition : mg, this.traceCondition_, this.setTrace(e.trace || !1), this.traceState_ = { active: !1 }, this.traceSource_ = e.traceSource || e.source || null, this.addChangeListener($w.ACTIVE, this.updateState_);
  }
  /**
   * Toggle tracing mode or set a tracing condition.
   *
   * @param {boolean|import("../events/condition.js").Condition} trace A boolean to toggle tracing mode or an event
   *     condition that will be checked when a feature is clicked to determine if tracing should be active.
   */
  setTrace(e) {
    let t;
    e ? e === !0 ? t = Ud : t = e : t = Sm, this.traceCondition_ = t;
  }
  /**
   * Remove the interaction from its current map and attach it to the new map.
   * Subclasses may set up event handlers to get notified about changes to
   * the map here.
   * @param {import("../Map.js").default} map Map.
   */
  setMap(e) {
    super.setMap(e), this.updateState_();
  }
  /**
   * Get the overlay layer that this interaction renders sketch features to.
   * @return {VectorLayer} Overlay layer.
   * @api
   */
  getOverlay() {
    return this.overlay_;
  }
  /**
   * Handles the {@link module:ol/MapBrowserEvent~MapBrowserEvent map browser event} and may actually draw or finish the drawing.
   * @param {import("../MapBrowserEvent.js").default} event Map browser event.
   * @return {boolean} `false` to stop event propagation.
   * @api
   */
  handleEvent(e) {
    e.originalEvent.type === ut.CONTEXTMENU && e.originalEvent.preventDefault(), this.freehand_ = this.mode_ !== "Point" && this.freehandCondition_(e);
    let t = e.type === or.POINTERMOVE, r = !0;
    return !this.freehand_ && this.lastDragTime_ && e.type === or.POINTERDRAG && (Date.now() - this.lastDragTime_ >= this.dragVertexDelay_ ? (this.downPx_ = e.pixel, this.shouldHandle_ = !this.freehand_, t = !0) : this.lastDragTime_ = void 0, this.shouldHandle_ && this.downTimeout_ !== void 0 && (clearTimeout(this.downTimeout_), this.downTimeout_ = void 0)), this.freehand_ && e.type === or.POINTERDRAG && this.sketchFeature_ !== null ? (this.addToDrawing_(e.coordinate), r = !1) : this.freehand_ && e.type === or.POINTERDOWN ? r = !1 : t && this.getPointerCount() < 2 ? (r = e.type === or.POINTERMOVE, r && this.freehand_ ? (this.handlePointerMove_(e), this.shouldHandle_ && e.originalEvent.preventDefault()) : (e.originalEvent.pointerType === "mouse" || e.type === or.POINTERDRAG && this.downTimeout_ === void 0) && this.handlePointerMove_(e)) : e.type === or.DBLCLICK && (r = !1), super.handleEvent(e) && r;
  }
  /**
   * Handle pointer down events.
   * @param {import("../MapBrowserEvent.js").default} event Event.
   * @return {boolean} If the event was consumed.
   */
  handleDownEvent(e) {
    return this.shouldHandle_ = !this.freehand_, this.freehand_ ? (this.downPx_ = e.pixel, this.finishCoordinate_ || this.startDrawing_(e.coordinate), !0) : this.condition_(e) ? (this.lastDragTime_ = Date.now(), this.downTimeout_ = setTimeout(() => {
      this.handlePointerMove_(
        new No(
          or.POINTERMOVE,
          e.map,
          e.originalEvent,
          !1,
          e.frameState
        )
      );
    }, this.dragVertexDelay_), this.downPx_ = e.pixel, !0) : (this.lastDragTime_ = void 0, !1);
  }
  /**
   * @private
   */
  deactivateTrace_() {
    this.traceState_ = { active: !1 };
  }
  /**
   * Activate or deactivate trace state based on a browser event.
   * @param {import("../MapBrowserEvent.js").default} event Event.
   * @private
   */
  toggleTraceState_(e) {
    if (!this.traceSource_ || !this.traceCondition_(e))
      return;
    if (this.traceState_.active) {
      this.deactivateTrace_();
      return;
    }
    const t = this.getMap(), r = t.getCoordinateFromPixel([
      e.pixel[0] - this.snapTolerance_,
      e.pixel[1] + this.snapTolerance_
    ]), n = t.getCoordinateFromPixel([
      e.pixel[0] + this.snapTolerance_,
      e.pixel[1] - this.snapTolerance_
    ]), s = Xi([r, n]), a = this.traceSource_.getFeaturesInExtent(s);
    if (a.length === 0)
      return;
    const o = DW(e.coordinate, a);
    o.length && (this.traceState_ = {
      active: !0,
      startPx: e.pixel.slice(),
      targets: o,
      targetIndex: -1
    });
  }
  /**
   * @param {TraceTarget} target The trace target.
   * @param {number} endIndex The new end index of the trace.
   * @private
   */
  addOrRemoveTracedCoordinates_(e, t) {
    const r = e.startIndex <= e.endIndex, n = e.startIndex <= t;
    r === n ? r && t > e.endIndex || !r && t < e.endIndex ? this.addTracedCoordinates_(e, e.endIndex, t) : (r && t < e.endIndex || !r && t > e.endIndex) && this.removeTracedCoordinates_(t, e.endIndex) : (this.removeTracedCoordinates_(e.startIndex, e.endIndex), this.addTracedCoordinates_(e, e.startIndex, t));
  }
  /**
   * @param {number} fromIndex The start index.
   * @param {number} toIndex The end index.
   * @private
   */
  removeTracedCoordinates_(e, t) {
    if (e === t)
      return;
    let r = 0;
    if (e < t) {
      const n = Math.ceil(e);
      let s = Math.floor(t);
      s === t && (s -= 1), r = s - n + 1;
    } else {
      const n = Math.floor(e);
      let s = Math.ceil(t);
      s === t && (s += 1), r = n - s + 1;
    }
    r > 0 && this.removeLastPoints_(r);
  }
  /**
   * @param {TraceTarget} target The trace target.
   * @param {number} fromIndex The start index.
   * @param {number} toIndex The end index.
   * @private
   */
  addTracedCoordinates_(e, t, r) {
    if (t === r)
      return;
    const n = [];
    if (t < r) {
      const s = Math.ceil(t);
      let a = Math.floor(r);
      a === r && (a -= 1);
      for (let o = s; o <= a; ++o)
        n.push($c(e.coordinates, o));
    } else {
      const s = Math.floor(t);
      let a = Math.ceil(r);
      a === r && (a += 1);
      for (let o = s; o >= a; --o)
        n.push($c(e.coordinates, o));
    }
    n.length && this.appendCoordinates(n);
  }
  /**
   * Update the trace.
   * @param {import("../MapBrowserEvent.js").default} event Event.
   * @private
   */
  updateTrace_(e) {
    const t = this.traceState_;
    if (!t.active || t.targetIndex === -1 && dm(t.startPx, e.pixel) < this.snapTolerance_)
      return;
    const r = kW(
      e.coordinate,
      t,
      this.getMap(),
      this.snapTolerance_
    );
    if (t.targetIndex !== r.index) {
      if (t.targetIndex !== -1) {
        const A = t.targets[t.targetIndex];
        this.removeTracedCoordinates_(A.startIndex, A.endIndex);
      }
      const o = t.targets[r.index];
      this.addTracedCoordinates_(
        o,
        o.startIndex,
        r.endIndex
      );
    } else {
      const o = t.targets[t.targetIndex];
      this.addOrRemoveTracedCoordinates_(o, r.endIndex);
    }
    t.targetIndex = r.index;
    const n = t.targets[t.targetIndex];
    n.endIndex = r.endIndex;
    const s = Vc(
      n.coordinates,
      n.endIndex
    ), a = this.getMap().getPixelFromCoordinate(s);
    e.coordinate = s, e.pixel = [Math.round(a[0]), Math.round(a[1])];
  }
  /**
   * Handle pointer up events.
   * @param {import("../MapBrowserEvent.js").default} event Event.
   * @return {boolean} If the event was consumed.
   */
  handleUpEvent(e) {
    let t = !0;
    if (this.getPointerCount() === 0) {
      this.downTimeout_ && (clearTimeout(this.downTimeout_), this.downTimeout_ = void 0), this.handlePointerMove_(e);
      const r = this.traceState_.active;
      if (this.toggleTraceState_(e), this.shouldHandle_) {
        const n = !this.finishCoordinate_;
        n && this.startDrawing_(e.coordinate), !n && this.freehand_ ? this.finishDrawing() : !this.freehand_ && (!n || this.mode_ === "Point") && (this.atFinish_(e.pixel, r) ? this.finishCondition_(e) && this.finishDrawing() : this.addToDrawing_(e.coordinate)), t = !1;
      } else
        this.freehand_ && this.abortDrawing();
    }
    return !t && this.stopClick_ && e.preventDefault(), t;
  }
  /**
   * Handle move events.
   * @param {import("../MapBrowserEvent.js").default} event A move event.
   * @private
   */
  handlePointerMove_(e) {
    if (this.pointerType_ = e.originalEvent.pointerType, this.downPx_ && (!this.freehand_ && this.shouldHandle_ || this.freehand_ && !this.shouldHandle_)) {
      const t = this.downPx_, r = e.pixel, n = t[0] - r[0], s = t[1] - r[1], a = n * n + s * s;
      if (this.shouldHandle_ = this.freehand_ ? a > this.squaredClickTolerance_ : a <= this.squaredClickTolerance_, !this.shouldHandle_)
        return;
    }
    if (!this.finishCoordinate_) {
      this.createOrUpdateSketchPoint_(e.coordinate.slice());
      return;
    }
    this.updateTrace_(e), this.modifyDrawing_(e.coordinate);
  }
  /**
   * Determine if an event is within the snapping tolerance of the start coord.
   * @param {import("../pixel.js").Pixel} pixel Pixel.
   * @param {boolean} [tracing] Drawing in trace mode (only stop if at the starting point).
   * @return {boolean} The event is within the snapping tolerance of the start.
   * @private
   */
  atFinish_(e, t) {
    let r = !1;
    if (this.sketchFeature_) {
      let n = !1, s = [this.finishCoordinate_];
      const a = this.mode_;
      if (a === "Point")
        r = !0;
      else if (a === "Circle")
        r = this.sketchCoords_.length === 2;
      else if (a === "LineString")
        n = !t && this.sketchCoords_.length > this.minPoints_;
      else if (a === "Polygon") {
        const o = (
          /** @type {PolyCoordType} */
          this.sketchCoords_
        );
        n = o[0].length > this.minPoints_, s = [
          o[0][0],
          o[0][o[0].length - 2]
        ], t ? s = [o[0][0]] : s = [
          o[0][0],
          o[0][o[0].length - 2]
        ];
      }
      if (n) {
        const o = this.getMap();
        for (let A = 0, l = s.length; A < l; A++) {
          const h = s[A], c = o.getPixelFromCoordinate(h), u = e[0] - c[0], f = e[1] - c[1], g = this.freehand_ ? 1 : this.snapTolerance_;
          if (r = Math.sqrt(u * u + f * f) <= g, r) {
            this.finishCoordinate_ = h;
            break;
          }
        }
      }
    }
    return r;
  }
  /**
   * @param {import("../coordinate").Coordinate} coordinates Coordinate.
   * @private
   */
  createOrUpdateSketchPoint_(e) {
    this.sketchPoint_ ? this.sketchPoint_.getGeometry().setCoordinates(e) : (this.sketchPoint_ = new qt(new gr(e)), this.updateSketchFeatures_());
  }
  /**
   * @param {import("../geom/Polygon.js").default} geometry Polygon geometry.
   * @private
   */
  createOrUpdateCustomSketchLine_(e) {
    this.sketchLine_ || (this.sketchLine_ = new qt());
    const t = e.getLinearRing(0);
    let r = this.sketchLine_.getGeometry();
    r ? (r.setFlatCoordinates(
      t.getLayout(),
      t.getFlatCoordinates()
    ), r.changed()) : (r = new Gr(
      t.getFlatCoordinates(),
      t.getLayout()
    ), this.sketchLine_.setGeometry(r));
  }
  /**
   * Start the drawing.
   * @param {import("../coordinate.js").Coordinate} start Start coordinate.
   * @private
   */
  startDrawing_(e) {
    const t = this.getMap().getView().getProjection(), r = Fd(this.geometryLayout_);
    for (; e.length < r; )
      e.push(0);
    this.finishCoordinate_ = e, this.mode_ === "Point" ? this.sketchCoords_ = e.slice() : this.mode_ === "Polygon" ? (this.sketchCoords_ = [[e.slice(), e.slice()]], this.sketchLineCoords_ = this.sketchCoords_[0]) : this.sketchCoords_ = [e.slice(), e.slice()], this.sketchLineCoords_ && (this.sketchLine_ = new qt(new Gr(this.sketchLineCoords_)));
    const n = this.geometryFunction_(
      this.sketchCoords_,
      void 0,
      t
    );
    this.sketchFeature_ = new qt(), this.geometryName_ && this.sketchFeature_.setGeometryName(this.geometryName_), this.sketchFeature_.setGeometry(n), this.updateSketchFeatures_(), this.dispatchEvent(
      new Vp($p.DRAWSTART, this.sketchFeature_)
    );
  }
  /**
   * Modify the drawing.
   * @param {import("../coordinate.js").Coordinate} coordinate Coordinate.
   * @private
   */
  modifyDrawing_(e) {
    const t = this.getMap(), r = this.sketchFeature_.getGeometry(), n = t.getView().getProjection(), s = Fd(this.geometryLayout_);
    let a, o;
    for (; e.length < s; )
      e.push(0);
    this.mode_ === "Point" ? o = this.sketchCoords_ : this.mode_ === "Polygon" ? (a = /** @type {PolyCoordType} */
    this.sketchCoords_[0], o = a[a.length - 1], this.atFinish_(t.getPixelFromCoordinate(e)) && (e = this.finishCoordinate_.slice())) : (a = this.sketchCoords_, o = a[a.length - 1]), o[0] = e[0], o[1] = e[1], this.geometryFunction_(
      /** @type {!LineCoordType} */
      this.sketchCoords_,
      r,
      n
    ), this.sketchPoint_ && this.sketchPoint_.getGeometry().setCoordinates(e), r.getType() === "Polygon" && this.mode_ !== "Polygon" ? this.createOrUpdateCustomSketchLine_(
      /** @type {Polygon} */
      r
    ) : this.sketchLineCoords_ && this.sketchLine_.getGeometry().setCoordinates(this.sketchLineCoords_), this.updateSketchFeatures_();
  }
  /**
   * Add a new coordinate to the drawing.
   * @param {!PointCoordType} coordinate Coordinate
   * @private
   */
  addToDrawing_(e) {
    const t = this.sketchFeature_.getGeometry(), r = this.getMap().getView().getProjection();
    let n, s;
    const a = this.mode_;
    a === "LineString" || a === "Circle" ? (this.finishCoordinate_ = e.slice(), s = /** @type {LineCoordType} */
    this.sketchCoords_, s.length >= this.maxPoints_ && (this.freehand_ ? s.pop() : n = !0), s.push(e.slice()), this.geometryFunction_(s, t, r)) : a === "Polygon" && (s = /** @type {PolyCoordType} */
    this.sketchCoords_[0], s.length >= this.maxPoints_ && (this.freehand_ ? s.pop() : n = !0), s.push(e.slice()), n && (this.finishCoordinate_ = s[0]), this.geometryFunction_(this.sketchCoords_, t, r)), this.createOrUpdateSketchPoint_(e.slice()), this.updateSketchFeatures_(), n && this.finishDrawing();
  }
  /**
   * @param {number} n The number of points to remove.
   */
  removeLastPoints_(e) {
    if (!this.sketchFeature_)
      return;
    const t = this.sketchFeature_.getGeometry(), r = this.getMap().getView().getProjection(), n = this.mode_;
    for (let s = 0; s < e; ++s) {
      let a;
      if (n === "LineString" || n === "Circle") {
        if (a = /** @type {LineCoordType} */
        this.sketchCoords_, a.splice(-2, 1), a.length >= 2) {
          this.finishCoordinate_ = a[a.length - 2].slice();
          const o = this.finishCoordinate_.slice();
          a[a.length - 1] = o, this.createOrUpdateSketchPoint_(o);
        }
        this.geometryFunction_(a, t, r), t.getType() === "Polygon" && this.sketchLine_ && this.createOrUpdateCustomSketchLine_(
          /** @type {Polygon} */
          t
        );
      } else if (n === "Polygon") {
        a = /** @type {PolyCoordType} */
        this.sketchCoords_[0], a.splice(-2, 1);
        const o = this.sketchLine_.getGeometry();
        if (a.length >= 2) {
          const A = a[a.length - 2].slice();
          a[a.length - 1] = A, this.createOrUpdateSketchPoint_(A);
        }
        o.setCoordinates(a), this.geometryFunction_(this.sketchCoords_, t, r);
      }
      if (a.length === 1) {
        this.abortDrawing();
        break;
      }
    }
    this.updateSketchFeatures_();
  }
  /**
   * Remove last point of the feature currently being drawn. Does not do anything when
   * drawing POINT or MULTI_POINT geometries.
   * @api
   */
  removeLastPoint() {
    this.removeLastPoints_(1);
  }
  /**
   * Stop drawing and add the sketch feature to the target layer.
   * The {@link module:ol/interaction/Draw~DrawEventType.DRAWEND} event is
   * dispatched before inserting the feature.
   * @api
   */
  finishDrawing() {
    const e = this.abortDrawing_();
    if (!e)
      return;
    let t = this.sketchCoords_;
    const r = e.getGeometry(), n = this.getMap().getView().getProjection();
    this.mode_ === "LineString" ? (t.pop(), this.geometryFunction_(t, r, n)) : this.mode_ === "Polygon" && (t[0].pop(), this.geometryFunction_(t, r, n), t = r.getCoordinates()), this.type_ === "MultiPoint" ? e.setGeometry(
      new ta([
        /** @type {PointCoordType} */
        t
      ])
    ) : this.type_ === "MultiLineString" ? e.setGeometry(
      new In([
        /** @type {LineCoordType} */
        t
      ])
    ) : this.type_ === "MultiPolygon" && e.setGeometry(
      new Rn([
        /** @type {PolyCoordType} */
        t
      ])
    ), this.dispatchEvent(new Vp($p.DRAWEND, e)), this.features_ && this.features_.push(e), this.source_ && this.source_.addFeature(e);
  }
  /**
   * Stop drawing without adding the sketch feature to the target layer.
   * @return {Feature<import("../geom/SimpleGeometry.js").default>|null} The sketch feature (or null if none).
   * @private
   */
  abortDrawing_() {
    this.finishCoordinate_ = null;
    const e = this.sketchFeature_;
    return this.sketchFeature_ = null, this.sketchPoint_ = null, this.sketchLine_ = null, this.overlay_.getSource().clear(!0), this.deactivateTrace_(), e;
  }
  /**
   * Stop drawing without adding the sketch feature to the target layer.
   * @api
   */
  abortDrawing() {
    const e = this.abortDrawing_();
    e && this.dispatchEvent(new Vp($p.DRAWABORT, e));
  }
  /**
   * Append coordinates to the end of the geometry that is currently being drawn.
   * This can be used when drawing LineStrings or Polygons. Coordinates will
   * either be appended to the current LineString or the outer ring of the current
   * Polygon. If no geometry is being drawn, a new one will be created.
   * @param {!LineCoordType} coordinates Linear coordinates to be appended to
   * the coordinate array.
   * @api
   */
  appendCoordinates(e) {
    const t = this.mode_, r = !this.sketchFeature_;
    r && this.startDrawing_(e[0]);
    let n;
    if (t === "LineString" || t === "Circle")
      n = /** @type {LineCoordType} */
      this.sketchCoords_;
    else if (t === "Polygon")
      n = this.sketchCoords_ && this.sketchCoords_.length ? (
        /** @type {PolyCoordType} */
        this.sketchCoords_[0]
      ) : [];
    else
      return;
    r && n.shift(), n.pop();
    for (let a = 0; a < e.length; a++)
      this.addToDrawing_(e[a]);
    const s = e[e.length - 1];
    this.addToDrawing_(s), this.modifyDrawing_(s);
  }
  /**
   * Initiate draw mode by starting from an existing geometry which will
   * receive new additional points. This only works on features with
   * `LineString` geometries, where the interaction will extend lines by adding
   * points to the end of the coordinates array.
   * This will change the original feature, instead of drawing a copy.
   *
   * The function will dispatch a `drawstart` event.
   *
   * @param {!Feature<LineString>} feature Feature to be extended.
   * @api
   */
  extend(e) {
    const r = e.getGeometry();
    this.sketchFeature_ = e, this.sketchCoords_ = r.getCoordinates();
    const n = this.sketchCoords_[this.sketchCoords_.length - 1];
    this.finishCoordinate_ = n.slice(), this.sketchCoords_.push(n.slice()), this.sketchPoint_ = new qt(new gr(n)), this.updateSketchFeatures_(), this.dispatchEvent(
      new Vp($p.DRAWSTART, this.sketchFeature_)
    );
  }
  /**
   * Redraw the sketch features.
   * @private
   */
  updateSketchFeatures_() {
    const e = [];
    this.sketchFeature_ && e.push(this.sketchFeature_), this.sketchLine_ && e.push(this.sketchLine_), this.sketchPoint_ && e.push(this.sketchPoint_);
    const t = this.overlay_.getSource();
    t.clear(!0), t.addFeatures(e);
  }
  /**
   * @private
   */
  updateState_() {
    const e = this.getMap(), t = this.getActive();
    (!e || !t) && this.abortDrawing(), this.overlay_.setMap(t ? e : null);
  }
}
function GW() {
  const i = nB();
  return function(e, t) {
    return i[e.getGeometry().getType()];
  };
}
function $W(i) {
  switch (i) {
    case "Point":
    case "MultiPoint":
      return "Point";
    case "LineString":
    case "MultiLineString":
      return "LineString";
    case "Polygon":
    case "MultiPolygon":
      return "Polygon";
    case "Circle":
      return "Circle";
    default:
      throw new Error("Invalid type: " + i);
  }
}
const pB = HW, hT = 0, gd = 1, cT = [0, 0, 0, 0], nu = [], u_ = {
  /**
   * Triggered upon feature modification start
   * @event ModifyEvent#modifystart
   * @api
   */
  MODIFYSTART: "modifystart",
  /**
   * Triggered upon feature modification end
   * @event ModifyEvent#modifyend
   * @api
   */
  MODIFYEND: "modifyend"
};
class f_ extends _s {
  /**
   * @param {ModifyEventType} type Type.
   * @param {Collection<Feature>} features
   * The features modified.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent
   * Associated {@link module:ol/MapBrowserEvent~MapBrowserEvent}.
   */
  constructor(e, t, r) {
    super(e), this.features = t, this.mapBrowserEvent = r;
  }
}
class VW extends eo {
  /**
   * @param {Options} options Options.
   */
  constructor(e) {
    super(
      /** @type {import("./Pointer.js").Options} */
      e
    ), this.on, this.once, this.un, this.boundHandleFeatureChange_ = this.handleFeatureChange_.bind(this), this.condition_ = e.condition ? e.condition : UE, this.defaultDeleteCondition_ = function(r) {
      return sM(r) && Dv(r);
    }, this.deleteCondition_ = e.deleteCondition ? e.deleteCondition : this.defaultDeleteCondition_, this.insertVertexCondition_ = e.insertVertexCondition ? e.insertVertexCondition : Ud, this.vertexFeature_ = null, this.vertexSegments_ = null, this.lastPixel_ = [0, 0], this.ignoreNextSingleClick_ = !1, this.featuresBeingModified_ = null, this.rBush_ = new Gm(), this.pixelTolerance_ = e.pixelTolerance !== void 0 ? e.pixelTolerance : 10, this.snappedToVertex_ = !1, this.changingFeature_ = !1, this.dragSegments_ = [], this.overlay_ = new nA({
      source: new sA({
        useSpatialIndex: !1,
        wrapX: !!e.wrapX
      }),
      style: e.style ? e.style : jW(),
      updateWhileAnimating: !0,
      updateWhileInteracting: !0
    }), this.SEGMENT_WRITERS_ = {
      Point: this.writePointGeometry_.bind(this),
      LineString: this.writeLineStringGeometry_.bind(this),
      LinearRing: this.writeLineStringGeometry_.bind(this),
      Polygon: this.writePolygonGeometry_.bind(this),
      MultiPoint: this.writeMultiPointGeometry_.bind(this),
      MultiLineString: this.writeMultiLineStringGeometry_.bind(this),
      MultiPolygon: this.writeMultiPolygonGeometry_.bind(this),
      Circle: this.writeCircleGeometry_.bind(this),
      GeometryCollection: this.writeGeometryCollectionGeometry_.bind(this)
    }, this.source_ = null, this.hitDetection_ = null;
    let t;
    if (e.features ? t = e.features : e.source && (this.source_ = e.source, t = new Yi(this.source_.getFeatures()), this.source_.addEventListener(
      an.ADDFEATURE,
      this.handleSourceAdd_.bind(this)
    ), this.source_.addEventListener(
      an.REMOVEFEATURE,
      this.handleSourceRemove_.bind(this)
    )), !t)
      throw new Error(
        "The modify interaction requires features, a source or a layer"
      );
    e.hitDetection && (this.hitDetection_ = e.hitDetection), this.features_ = t, this.features_.forEach(this.addFeature_.bind(this)), this.features_.addEventListener(
      Si.ADD,
      this.handleFeatureAdd_.bind(this)
    ), this.features_.addEventListener(
      Si.REMOVE,
      this.handleFeatureRemove_.bind(this)
    ), this.lastPointerEvent_ = null, this.delta_ = [0, 0], this.snapToPointer_ = e.snapToPointer === void 0 ? !this.hitDetection_ : e.snapToPointer;
  }
  /**
   * @param {Feature} feature Feature.
   * @private
   */
  addFeature_(e) {
    const t = e.getGeometry();
    if (t) {
      const n = this.SEGMENT_WRITERS_[t.getType()];
      n && n(e, t);
    }
    const r = this.getMap();
    r && r.isRendered() && this.getActive() && this.handlePointerAtPixel_(this.lastPixel_, r), e.addEventListener(ut.CHANGE, this.boundHandleFeatureChange_);
  }
  /**
   * @param {import("../MapBrowserEvent.js").default} evt Map browser event.
   * @param {Array<Array<SegmentData>>} segments The segments subject to modification.
   * @private
   */
  willModifyFeatures_(e, t) {
    if (!this.featuresBeingModified_) {
      this.featuresBeingModified_ = new Yi();
      const r = this.featuresBeingModified_.getArray();
      for (let n = 0, s = t.length; n < s; ++n) {
        const a = t[n];
        for (let o = 0, A = a.length; o < A; ++o) {
          const l = a[o].feature;
          l && !r.includes(l) && this.featuresBeingModified_.push(l);
        }
      }
      this.featuresBeingModified_.getLength() === 0 ? this.featuresBeingModified_ = null : this.dispatchEvent(
        new f_(
          u_.MODIFYSTART,
          this.featuresBeingModified_,
          e
        )
      );
    }
  }
  /**
   * @param {Feature} feature Feature.
   * @private
   */
  removeFeature_(e) {
    this.removeFeatureSegmentData_(e), this.vertexFeature_ && this.features_.getLength() === 0 && (this.overlay_.getSource().removeFeature(this.vertexFeature_), this.vertexFeature_ = null), e.removeEventListener(
      ut.CHANGE,
      this.boundHandleFeatureChange_
    );
  }
  /**
   * @param {Feature} feature Feature.
   * @private
   */
  removeFeatureSegmentData_(e) {
    const t = this.rBush_, r = [];
    t.forEach(
      /**
       * @param {SegmentData} node RTree node.
       */
      function(n) {
        e === n.feature && r.push(n);
      }
    );
    for (let n = r.length - 1; n >= 0; --n) {
      const s = r[n];
      for (let a = this.dragSegments_.length - 1; a >= 0; --a)
        this.dragSegments_[a][0] === s && this.dragSegments_.splice(a, 1);
      t.remove(s);
    }
  }
  /**
   * Activate or deactivate the interaction.
   * @param {boolean} active Active.
   * @observable
   * @api
   */
  setActive(e) {
    this.vertexFeature_ && !e && (this.overlay_.getSource().removeFeature(this.vertexFeature_), this.vertexFeature_ = null), super.setActive(e);
  }
  /**
   * Remove the interaction from its current map and attach it to the new map.
   * Subclasses may set up event handlers to get notified about changes to
   * the map here.
   * @param {import("../Map.js").default} map Map.
   */
  setMap(e) {
    this.overlay_.setMap(e), super.setMap(e);
  }
  /**
   * Get the overlay layer that this interaction renders the modification point or vertex to.
   * @return {VectorLayer} Overlay layer.
   * @api
   */
  getOverlay() {
    return this.overlay_;
  }
  /**
   * @param {import("../source/Vector.js").VectorSourceEvent} event Event.
   * @private
   */
  handleSourceAdd_(e) {
    e.feature && this.features_.push(e.feature);
  }
  /**
   * @param {import("../source/Vector.js").VectorSourceEvent} event Event.
   * @private
   */
  handleSourceRemove_(e) {
    e.feature && this.features_.remove(e.feature);
  }
  /**
   * @param {import("../Collection.js").CollectionEvent<Feature>} evt Event.
   * @private
   */
  handleFeatureAdd_(e) {
    this.addFeature_(e.element);
  }
  /**
   * @param {import("../events/Event.js").default} evt Event.
   * @private
   */
  handleFeatureChange_(e) {
    if (!this.changingFeature_) {
      const t = (
        /** @type {Feature} */
        e.target
      );
      this.removeFeature_(t), this.addFeature_(t);
    }
  }
  /**
   * @param {import("../Collection.js").CollectionEvent<Feature>} evt Event.
   * @private
   */
  handleFeatureRemove_(e) {
    this.removeFeature_(e.element);
  }
  /**
   * @param {Feature} feature Feature
   * @param {Point} geometry Geometry.
   * @private
   */
  writePointGeometry_(e, t) {
    const r = t.getCoordinates(), n = {
      feature: e,
      geometry: t,
      segment: [r, r]
    };
    this.rBush_.insert(t.getExtent(), n);
  }
  /**
   * @param {Feature} feature Feature
   * @param {import("../geom/MultiPoint.js").default} geometry Geometry.
   * @private
   */
  writeMultiPointGeometry_(e, t) {
    const r = t.getCoordinates();
    for (let n = 0, s = r.length; n < s; ++n) {
      const a = r[n], o = {
        feature: e,
        geometry: t,
        depth: [n],
        index: n,
        segment: [a, a]
      };
      this.rBush_.insert(t.getExtent(), o);
    }
  }
  /**
   * @param {Feature} feature Feature
   * @param {import("../geom/LineString.js").default} geometry Geometry.
   * @private
   */
  writeLineStringGeometry_(e, t) {
    const r = t.getCoordinates();
    for (let n = 0, s = r.length - 1; n < s; ++n) {
      const a = r.slice(n, n + 2), o = {
        feature: e,
        geometry: t,
        index: n,
        segment: a
      };
      this.rBush_.insert(Xi(a), o);
    }
  }
  /**
   * @param {Feature} feature Feature
   * @param {import("../geom/MultiLineString.js").default} geometry Geometry.
   * @private
   */
  writeMultiLineStringGeometry_(e, t) {
    const r = t.getCoordinates();
    for (let n = 0, s = r.length; n < s; ++n) {
      const a = r[n];
      for (let o = 0, A = a.length - 1; o < A; ++o) {
        const l = a.slice(o, o + 2), h = {
          feature: e,
          geometry: t,
          depth: [n],
          index: o,
          segment: l
        };
        this.rBush_.insert(Xi(l), h);
      }
    }
  }
  /**
   * @param {Feature} feature Feature
   * @param {import("../geom/Polygon.js").default} geometry Geometry.
   * @private
   */
  writePolygonGeometry_(e, t) {
    const r = t.getCoordinates();
    for (let n = 0, s = r.length; n < s; ++n) {
      const a = r[n];
      for (let o = 0, A = a.length - 1; o < A; ++o) {
        const l = a.slice(o, o + 2), h = {
          feature: e,
          geometry: t,
          depth: [n],
          index: o,
          segment: l
        };
        this.rBush_.insert(Xi(l), h);
      }
    }
  }
  /**
   * @param {Feature} feature Feature
   * @param {import("../geom/MultiPolygon.js").default} geometry Geometry.
   * @private
   */
  writeMultiPolygonGeometry_(e, t) {
    const r = t.getCoordinates();
    for (let n = 0, s = r.length; n < s; ++n) {
      const a = r[n];
      for (let o = 0, A = a.length; o < A; ++o) {
        const l = a[o];
        for (let h = 0, c = l.length - 1; h < c; ++h) {
          const u = l.slice(h, h + 2), f = {
            feature: e,
            geometry: t,
            depth: [o, n],
            index: h,
            segment: u
          };
          this.rBush_.insert(Xi(u), f);
        }
      }
    }
  }
  /**
   * We convert a circle into two segments.  The segment at index
   * {@link CIRCLE_CENTER_INDEX} is the
   * circle's center (a point).  The segment at index
   * {@link CIRCLE_CIRCUMFERENCE_INDEX} is
   * the circumference, and is not a line segment.
   *
   * @param {Feature} feature Feature.
   * @param {import("../geom/Circle.js").default} geometry Geometry.
   * @private
   */
  writeCircleGeometry_(e, t) {
    const r = t.getCenter(), n = {
      feature: e,
      geometry: t,
      index: hT,
      segment: [r, r]
    }, s = {
      feature: e,
      geometry: t,
      index: gd,
      segment: [r, r]
    }, a = [n, s];
    n.featureSegments = a, s.featureSegments = a, this.rBush_.insert(Zl(r), n);
    let o = (
      /** @type {import("../geom/Geometry.js").default} */
      t
    );
    this.rBush_.insert(o.getExtent(), s);
  }
  /**
   * @param {Feature} feature Feature
   * @param {import("../geom/GeometryCollection.js").default} geometry Geometry.
   * @private
   */
  writeGeometryCollectionGeometry_(e, t) {
    const r = t.getGeometriesArray();
    for (let n = 0; n < r.length; ++n) {
      const s = r[n], a = this.SEGMENT_WRITERS_[s.getType()];
      a(e, s);
    }
  }
  /**
   * @param {import("../coordinate.js").Coordinate} coordinates Coordinates.
   * @param {Array<Feature>} features The features being modified.
   * @param {Array<import("../geom/SimpleGeometry.js").default>} geometries The geometries being modified.
   * @return {Feature} Vertex feature.
   * @private
   */
  createOrUpdateVertexFeature_(e, t, r) {
    let n = this.vertexFeature_;
    return n ? n.getGeometry().setCoordinates(e) : (n = new qt(new gr(e)), this.vertexFeature_ = n, this.overlay_.getSource().addFeature(n)), n.set("features", t), n.set("geometries", r), n;
  }
  /**
   * Handles the {@link module:ol/MapBrowserEvent~MapBrowserEvent map browser event} and may modify the geometry.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Map browser event.
   * @return {boolean} `false` to stop event propagation.
   */
  handleEvent(e) {
    if (!e.originalEvent)
      return !0;
    this.lastPointerEvent_ = e;
    let t;
    return !e.map.getView().getInteracting() && e.type == or.POINTERMOVE && !this.handlingDownUpSequence && this.handlePointerMove_(e), this.vertexFeature_ && this.deleteCondition_(e) && (e.type != or.SINGLECLICK || !this.ignoreNextSingleClick_ ? t = this.removePoint() : t = !0), e.type == or.SINGLECLICK && (this.ignoreNextSingleClick_ = !1), super.handleEvent(e) && !t;
  }
  /**
   * Handle pointer drag events.
   * @param {import("../MapBrowserEvent.js").default} evt Event.
   */
  handleDragEvent(e) {
    this.ignoreNextSingleClick_ = !1, this.willModifyFeatures_(e, this.dragSegments_);
    const t = [
      e.coordinate[0] + this.delta_[0],
      e.coordinate[1] + this.delta_[1]
    ], r = [], n = [];
    for (let s = 0, a = this.dragSegments_.length; s < a; ++s) {
      const o = this.dragSegments_[s], A = o[0], l = A.feature;
      r.includes(l) || r.push(l);
      const h = A.geometry;
      n.includes(h) || n.push(h);
      const c = A.depth;
      let u;
      const f = A.segment, g = o[1];
      for (; t.length < h.getStride(); )
        t.push(f[g][t.length]);
      switch (h.getType()) {
        case "Point":
          u = t, f[0] = t, f[1] = t;
          break;
        case "MultiPoint":
          u = h.getCoordinates(), u[A.index] = t, f[0] = t, f[1] = t;
          break;
        case "LineString":
          u = h.getCoordinates(), u[A.index + g] = t, f[g] = t;
          break;
        case "MultiLineString":
          u = h.getCoordinates(), u[c[0]][A.index + g] = t, f[g] = t;
          break;
        case "Polygon":
          u = h.getCoordinates(), u[c[0]][A.index + g] = t, f[g] = t;
          break;
        case "MultiPolygon":
          u = h.getCoordinates(), u[c[1]][c[0]][A.index + g] = t, f[g] = t;
          break;
        case "Circle":
          if (f[0] = t, f[1] = t, A.index === hT)
            this.changingFeature_ = !0, h.setCenter(t), this.changingFeature_ = !1;
          else {
            this.changingFeature_ = !0, e.map.getView().getProjection();
            let p = dm(
              ai(h.getCenter()),
              ai(t)
            );
            h.setRadius(p), this.changingFeature_ = !1;
          }
          break;
      }
      u && this.setGeometryCoordinates_(h, u);
    }
    this.createOrUpdateVertexFeature_(t, r, n);
  }
  /**
   * Handle pointer down events.
   * @param {import("../MapBrowserEvent.js").default} evt Event.
   * @return {boolean} If the event was consumed.
   */
  handleDownEvent(e) {
    if (!this.condition_(e))
      return !1;
    const t = e.coordinate;
    this.handlePointerAtPixel_(e.pixel, e.map, t), this.dragSegments_.length = 0, this.featuresBeingModified_ = null;
    const r = this.vertexFeature_;
    if (r) {
      e.map.getView().getProjection();
      const n = [], s = r.getGeometry().getCoordinates(), a = Xi([s]), o = this.rBush_.getInExtent(a), A = {};
      o.sort(KW);
      for (let l = 0, h = o.length; l < h; ++l) {
        const c = o[l], u = c.segment;
        let f = st(c.geometry);
        const g = c.depth;
        if (g && (f += "-" + g.join("-")), A[f] || (A[f] = new Array(2)), c.geometry.getType() === "Circle" && c.index === gd) {
          const p = fT(
            t,
            c
          );
          ya(p, s) && !A[f][0] && (this.dragSegments_.push([c, 0]), A[f][0] = c);
          continue;
        }
        if (ya(u[0], s) && !A[f][0]) {
          this.dragSegments_.push([c, 0]), A[f][0] = c;
          continue;
        }
        if (ya(u[1], s) && !A[f][1]) {
          if (A[f][0] && A[f][0].index === 0) {
            let p = c.geometry.getCoordinates();
            switch (c.geometry.getType()) {
              case "LineString":
              case "MultiLineString":
                continue;
              case "MultiPolygon":
                p = p[g[1]];
              case "Polygon":
                if (c.index !== p[g[0]].length - 2)
                  continue;
                break;
            }
          }
          this.dragSegments_.push([c, 1]), A[f][1] = c;
          continue;
        }
        st(u) in this.vertexSegments_ && !A[f][0] && !A[f][1] && this.insertVertexCondition_(e) && n.push(c);
      }
      n.length && this.willModifyFeatures_(e, [n]);
      for (let l = n.length - 1; l >= 0; --l)
        this.insertVertex_(n[l], s);
    }
    return !!this.vertexFeature_;
  }
  /**
   * Handle pointer up events.
   * @param {import("../MapBrowserEvent.js").default} evt Event.
   * @return {boolean} If the event was consumed.
   */
  handleUpEvent(e) {
    for (let t = this.dragSegments_.length - 1; t >= 0; --t) {
      const r = this.dragSegments_[t][0], n = r.geometry;
      if (n.getType() === "Circle") {
        const s = n.getCenter(), a = r.featureSegments[0], o = r.featureSegments[1];
        a.segment[0] = s, a.segment[1] = s, o.segment[0] = s, o.segment[1] = s, this.rBush_.update(Zl(s), a);
        let A = n;
        this.rBush_.update(
          A.getExtent(),
          o
        );
      } else
        this.rBush_.update(Xi(r.segment), r);
    }
    return this.featuresBeingModified_ && (this.dispatchEvent(
      new f_(
        u_.MODIFYEND,
        this.featuresBeingModified_,
        e
      )
    ), this.featuresBeingModified_ = null), !1;
  }
  /**
   * @param {import("../MapBrowserEvent.js").default} evt Event.
   * @private
   */
  handlePointerMove_(e) {
    this.lastPixel_ = e.pixel, this.handlePointerAtPixel_(e.pixel, e.map, e.coordinate);
  }
  /**
   * @param {import("../pixel.js").Pixel} pixel Pixel
   * @param {import("../Map.js").default} map Map.
   * @param {import("../coordinate.js").Coordinate} [coordinate] The pixel Coordinate.
   * @private
   */
  handlePointerAtPixel_(e, t, r) {
    const n = r || t.getCoordinateFromPixel(e);
    t.getView().getProjection();
    const s = function(A, l) {
      return uT(n, A) - uT(n, l);
    };
    let a, o;
    if (this.hitDetection_) {
      const A = typeof this.hitDetection_ == "object" ? (l) => l === this.hitDetection_ : void 0;
      t.forEachFeatureAtPixel(
        e,
        (l, h, c) => {
          const u = c || l.getGeometry();
          if (u.getType() === "Point" && l instanceof qt && this.features_.getArray().includes(l)) {
            o = /** @type {Point} */
            u;
            const f = o.getFlatCoordinates().slice(0, 2);
            a = [
              {
                feature: l,
                geometry: o,
                segment: [f, f]
              }
            ];
          }
          return !0;
        },
        { layerFilter: A }
      );
    }
    if (!a) {
      const A = Os(
        Zl(n, cT)
      ), l = t.getView().getResolution() * this.pixelTolerance_, h = fg(
        zn(A, l, cT)
      );
      a = this.rBush_.getInExtent(h);
    }
    if (a && a.length > 0) {
      const A = a.sort(s)[0], l = A.segment;
      let h = fT(n, A);
      const c = t.getPixelFromCoordinate(h);
      let u = dm(e, c);
      if (o || u <= this.pixelTolerance_) {
        const f = {};
        if (f[st(l)] = !0, this.snapToPointer_ || (this.delta_[0] = h[0] - n[0], this.delta_[1] = h[1] - n[1]), A.geometry.getType() === "Circle" && A.index === gd)
          this.snappedToVertex_ = !0, this.createOrUpdateVertexFeature_(
            h,
            [A.feature],
            [A.geometry]
          );
        else {
          const g = t.getPixelFromCoordinate(l[0]), p = t.getPixelFromCoordinate(l[1]), y = Ho(c, g), v = Ho(c, p);
          u = Math.sqrt(Math.min(y, v)), this.snappedToVertex_ = u <= this.pixelTolerance_, this.snappedToVertex_ && (h = y > v ? l[1] : l[0]), this.createOrUpdateVertexFeature_(
            h,
            [A.feature],
            [A.geometry]
          );
          const w = {};
          w[st(A.geometry)] = !0;
          for (let C = 1, E = a.length; C < E; ++C) {
            const S = a[C].segment;
            if (ya(l[0], S[0]) && ya(l[1], S[1]) || ya(l[0], S[1]) && ya(l[1], S[0])) {
              const M = st(a[C].geometry);
              M in w || (w[M] = !0, f[st(S)] = !0);
            } else
              break;
          }
        }
        this.vertexSegments_ = f;
        return;
      }
    }
    this.vertexFeature_ && (this.overlay_.getSource().removeFeature(this.vertexFeature_), this.vertexFeature_ = null);
  }
  /**
   * @param {SegmentData} segmentData Segment data.
   * @param {import("../coordinate.js").Coordinate} vertex Vertex.
   * @private
   */
  insertVertex_(e, t) {
    const r = e.segment, n = e.feature, s = e.geometry, a = e.depth, o = e.index;
    let A;
    for (; t.length < s.getStride(); )
      t.push(0);
    switch (s.getType()) {
      case "MultiLineString":
        A = s.getCoordinates(), A[a[0]].splice(o + 1, 0, t);
        break;
      case "Polygon":
        A = s.getCoordinates(), A[a[0]].splice(o + 1, 0, t);
        break;
      case "MultiPolygon":
        A = s.getCoordinates(), A[a[1]][a[0]].splice(o + 1, 0, t);
        break;
      case "LineString":
        A = s.getCoordinates(), A.splice(o + 1, 0, t);
        break;
      default:
        return;
    }
    this.setGeometryCoordinates_(s, A);
    const l = this.rBush_;
    l.remove(e), this.updateSegmentIndices_(s, o, a, 1);
    const h = {
      segment: [r[0], t],
      feature: n,
      geometry: s,
      depth: a,
      index: o
    };
    l.insert(Xi(h.segment), h), this.dragSegments_.push([h, 1]);
    const c = {
      segment: [t, r[1]],
      feature: n,
      geometry: s,
      depth: a,
      index: o + 1
    };
    l.insert(Xi(c.segment), c), this.dragSegments_.push([c, 0]), this.ignoreNextSingleClick_ = !0;
  }
  /**
   * Removes the vertex currently being pointed.
   * @return {boolean} True when a vertex was removed.
   * @api
   */
  removePoint() {
    if (this.lastPointerEvent_ && this.lastPointerEvent_.type != or.POINTERDRAG) {
      const e = this.lastPointerEvent_;
      this.willModifyFeatures_(e, this.dragSegments_);
      const t = this.removeVertex_();
      return this.featuresBeingModified_ && this.dispatchEvent(
        new f_(
          u_.MODIFYEND,
          this.featuresBeingModified_,
          e
        )
      ), this.featuresBeingModified_ = null, t;
    }
    return !1;
  }
  /**
   * Removes a vertex from all matching features.
   * @return {boolean} True when a vertex was removed.
   * @private
   */
  removeVertex_() {
    const e = this.dragSegments_, t = {};
    let r = !1, n, s, a, o, A, l, h, c, u, f, g;
    for (A = e.length - 1; A >= 0; --A)
      a = e[A], f = a[0], g = st(f.feature), f.depth && (g += "-" + f.depth.join("-")), g in t || (t[g] = {}), a[1] === 0 ? (t[g].right = f, t[g].index = f.index) : a[1] == 1 && (t[g].left = f, t[g].index = f.index + 1);
    for (g in t) {
      switch (u = t[g].right, h = t[g].left, l = t[g].index, c = l - 1, h !== void 0 ? f = h : f = u, c < 0 && (c = 0), o = f.geometry, s = o.getCoordinates(), n = s, r = !1, o.getType()) {
        case "MultiLineString":
          s[f.depth[0]].length > 2 && (s[f.depth[0]].splice(l, 1), r = !0);
          break;
        case "LineString":
          s.length > 2 && (s.splice(l, 1), r = !0);
          break;
        case "MultiPolygon":
          n = n[f.depth[1]];
        case "Polygon":
          n = n[f.depth[0]], n.length > 4 && (l == n.length - 1 && (l = 0), n.splice(l, 1), r = !0, l === 0 && (n.pop(), n.push(n[0]), c = n.length - 1));
          break;
      }
      if (r) {
        this.setGeometryCoordinates_(o, s);
        const p = [];
        if (h !== void 0 && (this.rBush_.remove(h), p.push(h.segment[0])), u !== void 0 && (this.rBush_.remove(u), p.push(u.segment[1])), h !== void 0 && u !== void 0) {
          const y = {
            depth: f.depth,
            feature: f.feature,
            geometry: f.geometry,
            index: c,
            segment: p
          };
          this.rBush_.insert(
            Xi(y.segment),
            y
          );
        }
        this.updateSegmentIndices_(o, l, f.depth, -1), this.vertexFeature_ && (this.overlay_.getSource().removeFeature(this.vertexFeature_), this.vertexFeature_ = null), e.length = 0;
      }
    }
    return r;
  }
  /**
   * @param {import("../geom/SimpleGeometry.js").default} geometry Geometry.
   * @param {Array} coordinates Coordinates.
   * @private
   */
  setGeometryCoordinates_(e, t) {
    this.changingFeature_ = !0, e.setCoordinates(t), this.changingFeature_ = !1;
  }
  /**
   * @param {import("../geom/SimpleGeometry.js").default} geometry Geometry.
   * @param {number} index Index.
   * @param {Array<number>|undefined} depth Depth.
   * @param {number} delta Delta (1 or -1).
   * @private
   */
  updateSegmentIndices_(e, t, r, n) {
    this.rBush_.forEachInExtent(
      e.getExtent(),
      function(s) {
        s.geometry === e && (r === void 0 || s.depth === void 0 || Za(s.depth, r)) && s.index > t && (s.index += n);
      }
    );
  }
}
function KW(i, e) {
  return i.index - e.index;
}
function uT(i, e, t) {
  const r = e.geometry;
  if (r.getType() === "Circle") {
    let s = (
      /** @type {import("../geom/Circle.js").default} */
      r
    );
    if (e.index === gd) {
      const a = Ho(
        s.getCenter(),
        ai(i)
      ), o = Math.sqrt(a) - s.getRadius();
      return o * o;
    }
  }
  const n = ai(i);
  return nu[0] = ai(e.segment[0]), nu[1] = ai(e.segment[1]), fD(n, nu);
}
function fT(i, e, t) {
  const r = e.geometry;
  if (r.getType() === "Circle" && e.index === gd)
    return fu(
      /** @type {import("../geom/Circle.js").default} */
      r.getClosestPoint(
        ai(i)
      )
    );
  const n = ai(i);
  return nu[0] = ai(e.segment[0]), nu[1] = ai(e.segment[1]), fu(
    uE(n, nu)
  );
}
function jW() {
  const i = nB();
  return function(e, t) {
    return i.Point;
  };
}
const mB = VW, zW = {
  name: "ol-style",
  setup(i) {
    const e = _t("stylable", null), { properties: t } = sr(i), r = cr(() => new ln(t)), n = (a) => {
      if (e instanceof pB || e instanceof mB) {
        e.getOverlay().setStyle(a), e.value.dispatchEvent("styleChanged");
        return;
      }
      try {
        e.value.setStyle(a), e.value.changed(), e.value.dispatchEvent("styleChanged");
      } catch {
        e.value.style_ = a, e.value.values_.style = a, e.value.changed(), e.value.dispatchEvent("styleChanged");
      }
    }, s = cr(() => (a) => (t.overrideStyleFunction != null && t.overrideStyleFunction(a, r.value), r.value));
    return at(t, () => {
      t.overrideStyleFunction == null ? n(r.value) : n(s.value);
    }), tr(() => {
      t.overrideStyleFunction == null ? n(r.value) : n(s.value);
    }), nr(() => {
      n(null);
    }), Ur("style", r), Ur("styledObj", e), {
      style: r
    };
  },
  props: {
    zIndex: {
      type: Number
    },
    overrideStyleFunction: {
      type: Function
    }
  }
};
function XW(i, e, t, r, n, s) {
  return xn(), Cn("div", null, [
    mr(i.$slots, "default")
  ]);
}
const mx = /* @__PURE__ */ qe(zW, [["render", XW]]), WW = {
  name: "ol-style-circle",
  setup(i) {
    const e = _t("style", null), t = _t("styledObj", null), { properties: r } = sr(i), n = (o) => new Ru({
      ...o,
      fill: new Wn(),
      stroke: new Zi()
    }), s = cr(() => n(r)), a = () => {
      e.value.setImage(null), e.value.setImage(s.value), t.value.changed();
    };
    at(r, () => {
      a();
    }), at(e, () => {
      a();
    }), tr(() => {
      e.value.setImage(s.value);
    }), nr(() => {
      e.value.setImage(null);
    }), Ur("circle", s), Ur("styledObj", t);
  },
  props: {
    radius: {
      type: Number
    },
    scale: {
      type: Number
    }
  }
};
function YW(i, e, t, r, n, s) {
  return xn(), Cn("div", null, [
    mr(i.$slots, "default")
  ]);
}
const vx = /* @__PURE__ */ qe(WW, [["render", YW]]), qW = {
  name: "ol-style-stroke",
  setup(i) {
    const e = _t("style", null), t = _t("circle", null), r = _t("styledObj", null), { properties: n } = sr(i);
    if (e != null && t == null) {
      let s = new Zi(n);
      e.value.setStroke(s);
      const a = () => {
        e.value.setStroke(null), s = new Zi(n), e.value.setStroke(s);
      };
      at(n, () => {
        a();
      }), at(e, () => {
        a();
      }), tr(() => {
        e.value.setStroke(s);
      }), nr(() => {
        e.value.setStroke(null);
      });
    } else if (t != null) {
      const s = (a) => {
        t.value.getStroke().setColor(a.color), t.value.getStroke().setLineCap(a.lineCap), t.value.getStroke().setLineDash(a.lineDash), t.value.getStroke().setLineDashOffset(a.lineDashOffset), t.value.getStroke().setLineJoin(a.lineJoin), t.value.getStroke().setMiterLimit(a.miterLimit), t.value.getStroke().setWidth(a.width), t.value.setRadius(t.value.getRadius());
        try {
          r.value.changed();
        } catch {
          r.changed();
        }
      };
      s(n), at(n, (a) => {
        s(a);
      }), at(t, () => {
        s(n);
      });
    }
  },
  props: {
    color: {
      type: String
    },
    lineCap: {
      type: String,
      default: "round"
    },
    lineJoin: {
      type: String,
      default: "round"
    },
    lineDash: {
      type: Array
    },
    lineDashOffset: {
      type: Number,
      default: 0
    },
    miterLimit: {
      type: Number,
      default: 10
    },
    width: {
      type: Number,
      default: 1
    }
  }
};
function ZW(i, e, t, r, n, s) {
  return ur("", !0);
}
const yx = /* @__PURE__ */ qe(qW, [["render", ZW]]), JW = {
  name: "ol-style-fill",
  setup(i) {
    const e = _t("style", null), t = _t("circle", null), r = _t("styledObj", null), { properties: n } = sr(i);
    if (e != null && t == null) {
      let s = new Wn(n);
      e.value.setFill(s);
      const a = () => {
        e.value.setFill(null), s = new Wn(n), e.value.setFill(s);
      };
      at(n, () => {
        a();
      }), at(e, () => {
        a();
      }), tr(() => {
        e.value.setFill(s);
      }), nr(() => {
        e.value.setFill(null);
      });
    } else if (t != null) {
      const s = (a) => {
        t.value.getFill().setColor(a), t.value.setRadius(t.value.getRadius());
        try {
          r.value.changed();
        } catch {
          r.changed();
        }
      };
      s(n.color), at(n, () => {
        s(n.color);
      }), at(t, () => {
        s(n.color);
      });
    }
  },
  props: {
    color: {
      type: String
    }
  }
};
function eY(i, e, t, r, n, s) {
  return ur("", !0);
}
const _x = /* @__PURE__ */ qe(JW, [["render", eY]]), tY = {
  name: "ol-style-icon",
  setup(i) {
    const e = _t("style", null), t = _t("styledObj", null), { properties: r } = sr(i), n = cr(() => {
      const a = new Mu(r);
      return a.load(), a;
    }), s = () => {
      e.value.setImage(null), e.value.setImage(n.value), t.value.changed();
    };
    at(r, () => {
      s();
    }), at(e, () => {
      s();
    }), tr(() => {
      e.value.setImage(n.value);
    }), nr(() => {
      e.value.setImage(null);
    });
  },
  props: {
    anchor: {
      type: Array
    },
    anchorOrigin: {
      type: String,
      default: "top-left"
    },
    anchorXUnits: {
      type: String,
      default: "fraction"
    },
    anchorYUnits: {
      type: String,
      default: "fraction"
    },
    color: {
      type: String
    },
    crossOrigin: {
      type: String
    },
    img: {
      type: [HTMLImageElement, HTMLCanvasElement]
    },
    offset: {
      type: Array,
      default: () => [0, 0]
    },
    displacement: {
      type: Array,
      default: () => [0, 0]
    },
    offsetOrigin: {
      type: String,
      default: "top-left"
    },
    opacity: {
      type: Number,
      default: 1
    },
    scale: {
      type: Number,
      default: 1
    },
    rotateWithView: {
      type: Boolean,
      default: !1
    },
    rotation: {
      type: Number,
      default: 0
    },
    size: {
      type: Array
    },
    imgSize: {
      type: Array
    },
    src: {
      type: String
    }
  }
};
function rY(i, e, t, r, n, s) {
  return ur("", !0);
}
const wx = /* @__PURE__ */ qe(tY, [["render", rY]]), iY = {
  name: "ol-style-text",
  setup(i) {
    const e = _t("style", null), t = _t("styledObj", null), { properties: r } = sr(i), n = (o) => new ih({
      ...o,
      fill: new Wn(),
      stroke: new Zi()
    }), s = cr(() => n(r)), a = () => {
      e.value.setText(null), e.value.setText(s.value), t.value.changed();
    };
    at(r, () => {
      a();
    }), at(e, () => {
      a();
    }), tr(() => {
      e.value.setText(s.value);
    }), nr(() => {
      e.value.setText(null);
    }), Ur("style", s), Ur("styledObj", t);
  },
  props: {
    font: {
      type: String
    },
    maxAngle: {
      type: Number,
      default: Math.PI / 4
    },
    offsetX: {
      type: Number,
      default: 0
    },
    offsetY: {
      type: Number,
      default: 0
    },
    overflow: {
      type: Boolean,
      default: !1
    },
    placement: {
      type: String,
      default: "point"
    },
    scale: {
      type: Number
    },
    rotateWithView: {
      type: Boolean,
      default: !1
    },
    rotation: {
      type: Number,
      default: 0
    },
    text: {
      type: String
    },
    textAlign: {
      type: String
    },
    textBaseline: {
      type: String,
      default: "middle"
    },
    padding: {
      type: Array,
      default: () => [0, 0, 0, 0]
    }
  }
};
function nY(i, e, t, r, n, s) {
  return xn(), Cn("div", null, [
    mr(i.$slots, "default")
  ]);
}
const xx = /* @__PURE__ */ qe(iY, [["render", nY]]);
var Kc = function(i, e) {
  var t = i[0] - e[0], r = i[1] - e[1];
  return Math.sqrt(t * t + r * r);
}, Pf = function(i, e) {
  return i[0] == e[0] && i[1] == e[1];
}, pN;
(function() {
  function i(t, r) {
    var n;
    for (let s = t.length - 1; s > 0; s--)
      (t[s][0] > r && t[s - 1][0] < r || t[s][0] < r && t[s - 1][0] > r) && (n = [r, (r - t[s][0]) / (t[s - 1][0] - t[s][0]) * (t[s - 1][1] - t[s][1]) + t[s][1]], t.splice(s, 0, n));
  }
  function e(t, r) {
    var n;
    for (let s = t.length - 1; s > 0; s--)
      (t[s][1] > r && t[s - 1][1] < r || t[s][1] < r && t[s - 1][1] > r) && (n = [(r - t[s][1]) / (t[s - 1][1] - t[s][1]) * (t[s - 1][0] - t[s][0]) + t[s][0], r], t.splice(s, 0, n));
  }
  pN = function(t, r) {
    var n = r.getType() === "Polygon";
    if (!n && r.getType() !== "MultiPolygon")
      return null;
    var s = r.getCoordinates();
    return n && (s = [s]), s.forEach(function(a) {
      a.forEach(function(o) {
        i(o, t[0]), i(o, t[2]), e(o, t[1]), e(o, t[3]);
      });
    }), s.forEach(function(a) {
      a.forEach(function(o) {
        o.forEach(function(A) {
          A[0] < t[0] ? A[0] = t[0] : A[0] > t[2] && (A[0] = t[2]), A[1] < t[1] ? A[1] = t[1] : A[1] > t[3] && (A[1] = t[3]);
        });
      });
    }), n ? new Li(s[0]) : new Rn(s);
  };
})();
var ny = function(i, e, t, r) {
  var n = [];
  r !== !1 && n.push(i);
  var s = Kc(i, e);
  if (s) {
    var a = Math.round(s / t);
    if (a > 1)
      for (var o = (e[0] - i[0]) / a, A = (e[1] - i[1]) / a, l = 1; l < a; l++)
        n.push([i[0] + o * l, i[1] + A * l]);
  }
  return n.push(e), n;
};
Gr.prototype.sampleAt = function(i) {
  for (var e = this.getCoordinates(), t = [], r = 1; r < e.length; r++)
    t = t.concat(ny(e[r - 1], e[r], i, r === 1));
  return new Gr(t);
};
In.prototype.sampleAt = function(i) {
  var e = this.getCoordinates(), t = [];
  return e.forEach(function(r) {
    for (var n = [], s = 1; s < r.length; s++)
      n = n.concat(ny(r[s - 1], r[s], i, s === 1));
    t.push(n);
  }), new In(t);
};
Li.prototype.sampleAt = function(i) {
  var e = this.getCoordinates(), t = [];
  return e.forEach(function(r) {
    for (var n = [], s = 1; s < r.length; s++)
      n = n.concat(ny(r[s - 1], r[s], i, s === 1));
    t.push(n);
  }), new Li(t);
};
Rn.prototype.sampleAt = function(i) {
  var e = this.getCoordinates(), t = [];
  return e.forEach(function(r) {
    var n = [];
    t.push(n), r.forEach(function(s) {
      for (var a = [], o = 1; o < s.length; o++)
        a = a.concat(ny(s[o - 1], s[o], i, o === 1));
      n.push(a);
    });
  }), new Rn(t);
};
gB.prototype.intersection = function(i, e) {
  if (i.sampleAt) {
    var t = zn(this.getCenter().concat(this.getCenter()), this.getRadius());
    i = pN(t, i), i = i.simplify(e);
    var r = this.getCenter(), n = this.getRadius(), s = i.sampleAt(e).getCoordinates();
    switch (i.getType()) {
      case "Polygon":
        s = [s];
      case "MultiPolygon": {
        var a = !1, o = [];
        return s.forEach(function(A) {
          var l = [];
          o.push(l), A.forEach(function(h) {
            var c = [];
            l.push(c), h.forEach(function(u) {
              var f = Kc(r, u);
              f > n ? (a = !0, c.push([
                r[0] + n / f * (u[0] - r[0]),
                r[1] + n / f * (u[1] - r[1])
              ])) : c.push(u);
            });
          });
        }), a ? i.getType() === "Polygon" ? new Li(o[0]) : new Rn(o) : i;
      }
    }
  } else
    console.warn("[ol/geom/Circle~intersection] Unsupported geometry type: " + i.getType());
  return i;
};
Gr.prototype.splitAt = function(i, e) {
  var t;
  if (!i)
    return [this];
  if (e || (e = 1e-10), i.length && i[0].length) {
    var r = [this];
    for (t = 0; t < i.length; t++) {
      for (var n = [], s = 0; s < r.length; s++) {
        var a = r[s].splitAt(i[t], e);
        n = n.concat(a);
      }
      r = n;
    }
    return r;
  }
  if (Pf(i, this.getFirstCoordinate()) || Pf(i, this.getLastCoordinate()))
    return [this];
  var o = this.getCoordinates(), A = [o[0]], l = [];
  for (t = 0; t < o.length - 1; t++)
    if (!Pf(o[t], o[t + 1])) {
      if (Pf(i, o[t + 1]))
        A.push(o[t + 1]), l.push(new Gr(A)), A = [];
      else if (!Pf(i, o[t])) {
        var h, c, u = !1;
        o[t][0] == o[t + 1][0] ? (h = (o[t][1] - i[1]) / (o[t][1] - o[t + 1][1]), u = o[t][0] == i[0] && 0 < h && h <= 1) : o[t][1] == o[t + 1][1] ? (h = (o[t][0] - i[0]) / (o[t][0] - o[t + 1][0]), u = o[t][1] == i[1] && 0 < h && h <= 1) : (h = (o[t][0] - i[0]) / (o[t][0] - o[t + 1][0]), c = (o[t][1] - i[1]) / (o[t][1] - o[t + 1][1]), u = Math.abs(h - c) <= e && 0 < h && h <= 1), u && (A.push(i), l.push(new Gr(A)), A = [i]);
      }
      A.push(o[t + 1]);
    }
  return A.length > 1 && l.push(new Gr(A)), l.length ? l : [this];
};
var sY = class extends ln {
  constructor(e) {
    e = e || {}, super({
      stroke: e.stroke,
      text: e.text,
      zIndex: e.zIndex,
      geometry: e.geometry
    }), this.setRenderer(this._render.bind(this)), this._visible = e.visible !== !1, typeof e.width == "function" ? this._widthFn = e.width : this.setWidth(e.width), this.setWidth2(e.width2), typeof e.color == "function" ? this._colorFn = e.color : this.setColor(e.color), this.setColor2(e.color2), this.setLineCap(e.lineCap), this.setArrow(e.arrow), this.setArrowSize(e.arrowSize), this.setArrowColor(e.arrowColor), this._offset = [0, 0], this.setOffset(e.offset0, 0), this.setOffset(e.offset1, 1), this._noOverlap = e.noOverlap;
  }
  /** Set the initial width
   * @param {number} width width, default 0
   */
  setWidth(e) {
    this._width = e || 0;
  }
  /** Set the final width
   * @param {number} width width, default 0
   */
  setWidth2(e) {
    this._width2 = e;
  }
  /** Get offset at start or end
   * @param {number} where 0=start, 1=end
   * @return {number} width
   */
  getOffset(e) {
    return this._offset[e];
  }
  /** Add an offset at start or end
   * @param {number} width
   * @param {number} where 0=start, 1=end
   */
  setOffset(e, t) {
    switch (e = Math.max(0, parseFloat(e)), t) {
      case 0: {
        this._offset[0] = e;
        break;
      }
      case 1: {
        this._offset[1] = e;
        break;
      }
    }
  }
  /** Set the LineCap
   * @param {steing} cap LineCap (round or butt), default butt
   */
  setLineCap(e) {
    this._lineCap = e === "round" ? "round" : "butt";
  }
  /** Get the current width at step
   * @param {ol.feature} feature
   * @param {number} step current drawing step beetween [0,1]
   * @return {number}
   */
  getWidth(e, t) {
    if (this._widthFn)
      return this._widthFn(e, t);
    var r = typeof this._width2 == "number" ? this._width2 : this._width;
    return this._width + (r - this._width) * t;
  }
  /** Set the initial color
   * @param {ol.colorLike} color
   */
  setColor(e) {
    try {
      this._color = hl(e);
    } catch {
      this._color = [0, 0, 0, 1];
    }
  }
  /** Set the final color
   * @param {ol.colorLike} color
   */
  setColor2(e) {
    try {
      this._color2 = hl(e);
    } catch {
      this._color2 = null;
    }
  }
  /** Set the arrow color
   * @param {ol.colorLike} color
   */
  setArrowColor(e) {
    try {
      this._acolor = rl(e);
    } catch {
      this._acolor = null;
    }
  }
  /** Get the current color at step
   * @param {ol.feature} feature
   * @param {number} step current drawing step beetween [0,1]
   * @return {string}
   */
  getColor(e, t) {
    if (this._colorFn)
      return rl(this._colorFn(e, t));
    var r = this._color, n = this._color2 || this._color;
    return "rgba(" + +Math.round(r[0] + (n[0] - r[0]) * t) + "," + Math.round(r[1] + (n[1] - r[1]) * t) + "," + Math.round(r[2] + (n[2] - r[2]) * t) + "," + (r[3] + (n[3] - r[3]) * t) + ")";
  }
  /** Get arrow
   */
  getArrow() {
    return this._arrow;
  }
  /** Set arrow
   * @param {number} n -1 | 0 | 1 | 2, default: 0
   */
  setArrow(e) {
    this._arrow = parseInt(e), (this._arrow < -1 || this._arrow > 2) && (this._arrow = 0);
  }
  /** getArrowSize
   * @return {ol.size}
   */
  getArrowSize() {
    return this._arrowSize || [16, 16];
  }
  /** setArrowSize
   * @param {number|ol.size} size
   */
  setArrowSize(e) {
    Array.isArray(e) ? this._arrowSize = e : typeof e == "number" && (this._arrowSize = [e, e]);
  }
  /** drawArrow
   * @param {CanvasRenderingContext2D} ctx
   * @param {ol.coordinate} p0
   * @param ol.coordinate} p1
   * @param {number} width
   * @param {number} ratio pixelratio
   * @private
   */
  drawArrow(e, t, r, n, s) {
    var a = this.getArrowSize()[0] * s, o = Kc(t, r), A = (t[0] - r[0]) / o, l = (t[1] - r[1]) / o;
    n = Math.max(this.getArrowSize()[1] / 2, n / 2) * s, e.beginPath(), e.moveTo(t[0], t[1]), e.lineTo(t[0] - a * A + n * l, t[1] - a * l - n * A), e.lineTo(t[0] - a * A - n * l, t[1] - a * l + n * A), e.lineTo(t[0], t[1]), e.fill();
  }
  /** Renderer function
   * @param {Array<ol.coordinate>} geom The pixel coordinates of the geometry in GeoJSON notation
   * @param {ol.render.State} e The olx.render.State of the layer renderer
   */
  _render(e, t) {
    if (t.geometry.getType() === "LineString") {
      var r, n, s, a = t.context;
      if (!this._visible) {
        var o = t.pixelRatio / t.resolution, A = Math.cos(t.rotation), l = Math.sin(t.rotation);
        n = t.geometry.getCoordinates();
        var h = e[0][0] - n[0][0] * o * A - n[0][1] * o * l, c = e[0][1] - n[0][0] * o * l + n[0][1] * o * A;
        for (e = [], r = 0; s = n[r]; r++)
          e[r] = [
            h + s[0] * o * A + s[1] * o * l,
            c + s[0] * o * l - s[1] * o * A,
            s[2]
          ];
      }
      var u = this.getArrowSize()[0] * t.pixelRatio;
      a.save(), this.getOffset(0) && this._splitAsize(e, this.getOffset(0) * t.pixelRatio), this.getOffset(1) && this._splitAsize(e, this.getOffset(1) * t.pixelRatio, !0), e.length > 1 && (this.getArrow() === -1 || this.getArrow() === 2) && (s = this._splitAsize(e, u), this._acolor ? a.fillStyle = this._acolor : a.fillStyle = this.getColor(t.feature, 0), this.drawArrow(a, s[0], s[1], this.getWidth(t.feature, 0), t.pixelRatio)), e.length > 1 && this.getArrow() > 0 && (s = this._splitAsize(e, u, !0), this._acolor ? a.fillStyle = this._acolor : a.fillStyle = this.getColor(t.feature, 1), this.drawArrow(a, s[0], s[1], this.getWidth(t.feature, 1), t.pixelRatio));
      var f = this._splitInto(e, 255, 2), g = 0, p = f.length;
      if (a.lineJoin = "round", a.lineCap = this._lineCap || "butt", f.length > 1)
        for (g = 0; g < f.length; g++) {
          var y = g / p;
          for (n = f[g], a.lineWidth = this.getWidth(t.feature, y) * t.pixelRatio, a.strokeStyle = this.getColor(t.feature, y), a.beginPath(), a.moveTo(n[0][0], n[0][1]), r = 1; s = n[r]; r++)
            a.lineTo(s[0], s[1]);
          a.stroke();
        }
      a.restore();
    }
  }
  /** Split extremity at
   * @param {ol.geom.LineString} geom
   * @param {number} asize
   * @param {boolean} end start=false or end=true, default false (start)
   */
  _splitAsize(e, t, r) {
    var n, s, a, o, A = 0;
    for (r ? a = e.pop() : a = e.shift(), n = a; e.length; ) {
      if (r ? s = e.pop() : s = e.shift(), o = Kc(n, s), A + o > t) {
        n = [n[0] + (s[0] - n[0]) * (t - A) / o, n[1] + (s[1] - n[1]) * (t - A) / o], o = Kc(n, a), r ? (e.push(s), e.push(n), e.push([n[0] + (a[0] - n[0]) / o, n[1] + (a[1] - n[1]) / o])) : (e.unshift(s), e.unshift(n), e.unshift([n[0] + (a[0] - n[0]) / o, n[1] + (a[1] - n[1]) / o]));
        break;
      }
      A += o, n = s;
    }
    return [a, n];
  }
  /** Split line geometry into equal length geometries
   * @param {Array<ol.coordinate>} geom
   * @param {number} nb number of resulting geometries, default 255
   * @param {number} nim minimum length of the resulting geometries, default 1
   */
  _splitInto(e, t, r) {
    var n, s, a = this._noOverlap ? 1 : 0.9, o = [], A, l = 0;
    for (n = 1; s = e[n]; n++)
      l += Kc(e[n - 1], s);
    var h = Math.max(r || 2, l / (t || 255)), c = e[0];
    l = 0;
    var u = [c];
    for (n = 1, s = e[1]; n < e.length; ) {
      var f = s[0] - c[0], g = s[1] - c[1];
      if (A = Math.sqrt(f * f + g * g), l + A > h) {
        var p = (h - l) / A;
        u.push([
          c[0] + f * p,
          c[1] + g * p
        ]), o.push(u), c = [
          c[0] + f * p * a,
          c[1] + g * p * a
        ], u = [c], l = 0;
      } else
        l += A, c = s, u.push(c), n++, s = e[n];
    }
    return o.push(u), o;
  }
};
const aY = {
  name: "ol-style-flowline",
  setup(i) {
    const e = _t("stylable", null), { properties: t } = sr(i), r = cr(() => new sY(t)), n = (a) => {
      if (e instanceof pB || e instanceof mB) {
        e.getOverlay().setStyle(a), e.value.dispatchEvent("styleChanged");
        return;
      }
      try {
        e.value.setStyle(a), e.value.changed(), e.value.dispatchEvent("styleChanged");
      } catch {
        e.value.style_ = a, e.value.values_.style = a, e.value.changed(), e.value.dispatchEvent("styleChanged");
      }
    }, s = cr(() => (a) => (t.overrideStyleFunction != null && t.overrideStyleFunction(a, r.value), r.value));
    return at(t, () => {
      t.overrideStyleFunction == null ? n(r.value) : n(s.value);
    }), tr(() => {
      t.overrideStyleFunction == null ? n(r.value) : n(s.value);
    }), nr(() => {
      n(null);
    }), {
      style: r
    };
  },
  props: {
    color: {
      type: [String, Function]
    },
    color2: {
      type: String
    },
    width: {
      type: [Number, Function]
    },
    width2: {
      type: Number
    },
    arrow: {
      type: Number
    },
    arrowColor: {
      type: String
    }
  }
};
function oY(i, e, t, r, n, s) {
  return xn(), Cn("div", null, [
    mr(i.$slots, "default")
  ]);
}
const Cx = /* @__PURE__ */ qe(aY, [["render", oY]]);
function tv(i) {
  tv.installed || (tv.installed = !0, i.component(mx.name, mx), i.component(vx.name, vx), i.component(yx.name, yx), i.component(_x.name, _x), i.component(wx.name, wx), i.component(xx.name, xx), i.component(Cx.name, Cx));
}
const AY = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  Circle: vx,
  Fill: _x,
  FlowLine: Cx,
  Icon: wx,
  Stroke: yx,
  Style: mx,
  Text: xx,
  default: tv,
  install: tv
}, Symbol.toStringTag, { value: "Module" })), lY = {
  /**
   * Triggered when feature(s) has been (de)selected.
   * @event SelectEvent#select
   * @api
   */
  SELECT: "select"
};
class hY extends _s {
  /**
   * @param {SelectEventType} type The event type.
   * @param {Array<import("../Feature.js").default>} selected Selected features.
   * @param {Array<import("../Feature.js").default>} deselected Deselected features.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Associated
   *     {@link module:ol/MapBrowserEvent~MapBrowserEvent}.
   */
  constructor(e, t, r, n) {
    super(e), this.selected = t, this.deselected = r, this.mapBrowserEvent = n;
  }
}
const Xp = {};
class vB extends Lu {
  /**
   * @param {Options} [options] Options.
   */
  constructor(e) {
    super(), this.on, this.once, this.un, e = e || {}, this.boundAddFeature_ = this.addFeature_.bind(this), this.boundRemoveFeature_ = this.removeFeature_.bind(this), this.condition_ = e.condition ? e.condition : Dv, this.addCondition_ = e.addCondition ? e.addCondition : Sm, this.removeCondition_ = e.removeCondition ? e.removeCondition : Sm, this.toggleCondition_ = e.toggleCondition ? e.toggleCondition : mg, this.multi_ = e.multi ? e.multi : !1, this.filter_ = e.filter ? e.filter : Xo, this.hitTolerance_ = e.hitTolerance ? e.hitTolerance : 0, this.style_ = e.style !== void 0 ? e.style : cY(), this.features_ = e.features || new Yi();
    let t;
    if (e.layers)
      if (typeof e.layers == "function")
        t = e.layers;
      else {
        const r = e.layers;
        t = function(n) {
          return r.includes(n);
        };
      }
    else
      t = Xo;
    this.layerFilter_ = t, this.featureLayerAssociation_ = {};
  }
  /**
   * @param {import("../Feature.js").default} feature Feature.
   * @param {import("../layer/Layer.js").default} layer Layer.
   * @private
   */
  addFeatureLayerAssociation_(e, t) {
    this.featureLayerAssociation_[st(e)] = t;
  }
  /**
   * Get the selected features.
   * @return {Collection<Feature>} Features collection.
   * @api
   */
  getFeatures() {
    return this.features_;
  }
  /**
   * Returns the Hit-detection tolerance.
   * @return {number} Hit tolerance in pixels.
   * @api
   */
  getHitTolerance() {
    return this.hitTolerance_;
  }
  /**
   * Returns the associated {@link module:ol/layer/Vector~VectorLayer vector layer} of
   * a selected feature.
   * @param {import("../Feature.js").default} feature Feature
   * @return {import('../layer/Vector.js').default} Layer.
   * @api
   */
  getLayer(e) {
    return (
      /** @type {import('../layer/Vector.js').default} */
      this.featureLayerAssociation_[st(e)]
    );
  }
  /**
   * Hit-detection tolerance. Pixels inside the radius around the given position
   * will be checked for features.
   * @param {number} hitTolerance Hit tolerance in pixels.
   * @api
   */
  setHitTolerance(e) {
    this.hitTolerance_ = e;
  }
  /**
   * Remove the interaction from its current map, if any,  and attach it to a new
   * map, if any. Pass `null` to just remove the interaction from the current map.
   * @param {import("../Map.js").default|null} map Map.
   * @api
   */
  setMap(e) {
    this.getMap() && this.style_ && this.features_.forEach(this.restorePreviousStyle_.bind(this)), super.setMap(e), e ? (this.features_.addEventListener(
      Si.ADD,
      this.boundAddFeature_
    ), this.features_.addEventListener(
      Si.REMOVE,
      this.boundRemoveFeature_
    ), this.style_ && this.features_.forEach(this.applySelectedStyle_.bind(this))) : (this.features_.removeEventListener(
      Si.ADD,
      this.boundAddFeature_
    ), this.features_.removeEventListener(
      Si.REMOVE,
      this.boundRemoveFeature_
    ));
  }
  /**
   * @param {import("../Collection.js").CollectionEvent<Feature>} evt Event.
   * @private
   */
  addFeature_(e) {
    const t = e.element;
    if (this.style_ && this.applySelectedStyle_(t), !this.getLayer(t)) {
      const r = (
        /** @type {VectorLayer} */
        this.getMap().getAllLayers().find(function(n) {
          if (n instanceof nA && n.getSource() && n.getSource().hasFeature(t))
            return n;
        })
      );
      r && this.addFeatureLayerAssociation_(t, r);
    }
  }
  /**
   * @param {import("../Collection.js").CollectionEvent<Feature>} evt Event.
   * @private
   */
  removeFeature_(e) {
    this.style_ && this.restorePreviousStyle_(e.element);
  }
  /**
   * @return {import("../style/Style.js").StyleLike|null} Select style.
   */
  getStyle() {
    return this.style_;
  }
  /**
   * @param {Feature} feature Feature
   * @private
   */
  applySelectedStyle_(e) {
    const t = st(e);
    t in Xp || (Xp[t] = e.getStyle()), e.setStyle(this.style_);
  }
  /**
   * @param {Feature} feature Feature
   * @private
   */
  restorePreviousStyle_(e) {
    const t = this.getMap().getInteractions().getArray();
    for (let n = t.length - 1; n >= 0; --n) {
      const s = t[n];
      if (s !== this && s instanceof vB && s.getStyle() && s.getFeatures().getArray().lastIndexOf(e) !== -1) {
        e.setStyle(s.getStyle());
        return;
      }
    }
    const r = st(e);
    e.setStyle(Xp[r]), delete Xp[r];
  }
  /**
   * @param {Feature} feature Feature.
   * @private
   */
  removeFeatureLayerAssociation_(e) {
    delete this.featureLayerAssociation_[st(e)];
  }
  /**
   * Handles the {@link module:ol/MapBrowserEvent~MapBrowserEvent map browser event} and may change the
   * selected state of features.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Map browser event.
   * @return {boolean} `false` to stop event propagation.
   */
  handleEvent(e) {
    if (!this.condition_(e))
      return !0;
    const t = this.addCondition_(e), r = this.removeCondition_(e), n = this.toggleCondition_(e), s = !t && !r && !n, a = e.map, o = this.getFeatures(), A = [], l = [];
    if (s) {
      Bh(this.featureLayerAssociation_), a.forEachFeatureAtPixel(
        e.pixel,
        /**
         * @param {import("../Feature.js").FeatureLike} feature Feature.
         * @param {import("../layer/Layer.js").default} layer Layer.
         * @return {boolean|undefined} Continue to iterate over the features.
         */
        (h, c) => {
          if (!(!(h instanceof qt) || !this.filter_(h, c)))
            return this.addFeatureLayerAssociation_(h, c), l.push(h), !this.multi_;
        },
        {
          layerFilter: this.layerFilter_,
          hitTolerance: this.hitTolerance_
        }
      );
      for (let h = o.getLength() - 1; h >= 0; --h) {
        const c = o.item(h), u = l.indexOf(c);
        u > -1 ? l.splice(u, 1) : (o.remove(c), A.push(c));
      }
      l.length !== 0 && o.extend(l);
    } else {
      a.forEachFeatureAtPixel(
        e.pixel,
        /**
         * @param {import("../Feature.js").FeatureLike} feature Feature.
         * @param {import("../layer/Layer.js").default} layer Layer.
         * @return {boolean|undefined} Continue to iterate over the features.
         */
        (h, c) => {
          if (!(!(h instanceof qt) || !this.filter_(h, c)))
            return (t || n) && !o.getArray().includes(h) ? (this.addFeatureLayerAssociation_(h, c), l.push(h)) : (r || n) && o.getArray().includes(h) && (A.push(h), this.removeFeatureLayerAssociation_(h)), !this.multi_;
        },
        {
          layerFilter: this.layerFilter_,
          hitTolerance: this.hitTolerance_
        }
      );
      for (let h = A.length - 1; h >= 0; --h)
        o.remove(A[h]);
      o.extend(l);
    }
    return (l.length > 0 || A.length > 0) && this.dispatchEvent(
      new hY(
        lY.SELECT,
        l,
        A,
        e
      )
    ), !0;
  }
}
function cY() {
  const i = nB();
  return Er(i.Polygon, i.LineString), Er(i.GeometryCollection, i.LineString), function(e) {
    return e.getGeometry() ? i[e.getGeometry().getType()] : null;
  };
}
const mN = vB, uY = {
  name: "ol-interaction-select",
  emits: ["select"],
  setup(i, { emit: e }) {
    const t = _t("map"), { properties: r } = sr(i), n = cr(() => {
      const s = new mN({
        ...r,
        style: new ln()
      });
      return s.on("select", (a) => {
        e("select", a);
      }), s;
    });
    return at(n, (s, a) => {
      t.removeInteraction(a), t.addInteraction(s), t.changed();
    }), tr(() => {
      t.addInteraction(n.value);
    }), nr(() => {
      t.removeInteraction(n.value);
    }), Ur("stylable", n), {
      select: n
    };
  },
  props: {
    multi: {
      type: Boolean,
      default: !1
    },
    condition: {
      type: Function
    },
    filter: {
      type: Function
    },
    features: {
      type: [Yi, Object]
    },
    hitTolerance: {
      type: Number,
      default: 0,
      validator: (i) => i >= 0
    },
    removeCondition: {
      type: Function
    }
  }
};
function fY(i, e, t, r, n, s) {
  return mr(i.$slots, "default");
}
const Ex = /* @__PURE__ */ qe(uY, [["render", fY]]);
var dY = class extends mN {
  constructor(e) {
    e = e || {};
    var t = new nA({
      source: new sA({
        features: new Yi(),
        wrapX: e.wrapX,
        useSpatialIndex: !0
      }),
      name: "Cluster overlay",
      updateWhileAnimating: !0,
      updateWhileInteracting: !0,
      displayInLayerSwitcher: !1,
      style: e.featureStyle
    });
    if (e.layers)
      if (typeof e.layers == "function") {
        var r = e.layers;
        e.layers = function(s) {
          return s === t || r(s);
        };
      } else
        e.layers.push && e.layers.push(t);
    if (e.filter) {
      var n = e.filter;
      e.filter = function(s, a) {
        return !a && s.get("selectclusterlink") ? !1 : n(s, a);
      };
    } else
      e.filter = function(s, a) {
        return !(!a && s.get("selectclusterlink"));
      };
    e.autoClose === !1 && !e.toggleCondition && (e.toggleCondition = Dv), super(e), this.overlayLayer_ = t, this.filter_ = e.filter, this.pointRadius = e.pointRadius || 12, this.circleMaxObjects = e.circleMaxObjects || 10, this.maxObjects = e.maxObjects || 60, this.spiral = e.spiral !== !1, this.animate = e.animate, this.animationDuration = e.animationDuration || 500, this.selectCluster_ = e.selectCluster !== !1, this._autoClose = e.autoClose !== !1, this.on("select", this.selectCluster.bind(this));
  }
  /**
   * Remove the interaction from its current map, if any,  and attach it to a new
   * map, if any. Pass `null` to just remove the interaction from the current map.
   * @param {ol.Map} map Map.
   * @api stable
   */
  setMap(e) {
    this.getMap() && this.getMap().removeLayer(this.overlayLayer_), this._listener && Js(this._listener), this._listener = null, super.setMap(e), this.overlayLayer_.setMap(e), e && e.getView() && (this._listener = e.getView().on("change:resolution", this.clear.bind(this)));
  }
  /**
   * Clear the selection, close the cluster and remove revealed features
   * @api stable
   */
  clear() {
    this.getFeatures().clear(), this.overlayLayer_.getSource().clear();
  }
  /**
   * Get the layer for the revealed features
   * @api stable
   */
  getLayer() {
    return this.overlayLayer_;
  }
  /**
   * Select a cluster
   * @param {ol.SelectEvent | ol.Feature} a cluster feature ie. a feature with a 'features' attribute.
   * @api stable
   */
  selectCluster(e) {
    if (e instanceof qt && (e = { selected: [e] }), !e.selected.length) {
      if (this._autoClose)
        this.clear();
      else {
        var t = e.deselected;
        t.forEach((C) => {
          var E = C.get("selectcluserfeatures");
          E && E.forEach((S) => {
            this.overlayLayer_.getSource().removeFeature(S);
          });
        });
      }
      return;
    }
    var r = e.selected[0];
    if (!r.get("selectclusterfeature")) {
      var n = this.overlayLayer_.getSource();
      this._autoClose && n.clear();
      var s = r.get("features");
      if (!(!s || s.length == 1)) {
        this.selectCluster_ || this.getFeatures().clear();
        var a = r.getGeometry().getCoordinates(), o = this.getMap().getView().getResolution(), A, l, h, c, u, f, g, p = [];
        if (!this.spiral || s.length <= this.circleMaxObjects)
          for (c = Math.min(s.length, this.circleMaxObjects), A = o * this.pointRadius * (0.5 + c / 4), h = 0; h < c; h++)
            l = 2 * Math.PI * h / c, (c == 2 || c == 4) && (l += Math.PI / 4), u = [a[0] + A * Math.sin(l), a[1] + A * Math.cos(l)], f = new qt({ selectclusterfeature: !0, features: [s[h]], geometry: new gr(u) }), f.setStyle(s[h].getStyle()), p.push(f), g = new qt({ selectclusterlink: !0, geometry: new Gr([a, u]) }), p.push(g);
        else {
          l = 0;
          var y = 2 * this.pointRadius;
          for (c = Math.min(this.maxObjects, s.length), h = 0; h < c; h++) {
            A = y / 2 + y * l / (2 * Math.PI), l = l + (y + 0.1) / A;
            var v = o * A * Math.sin(l), w = o * A * Math.cos(l);
            u = [a[0] + v, a[1] + w], f = new qt({ selectclusterfeature: !0, features: [s[h]], geometry: new gr(u) }), f.setStyle(s[h].getStyle()), p.push(f), g = new qt({ selectclusterlink: !0, geometry: new Gr([a, u]) }), p.push(g);
          }
        }
        r.set("selectcluserfeatures", p), this.animate ? this.animateCluster_(a, p) : n.addFeatures(p);
      }
    }
  }
  /**
   * Animate the cluster and spread out the features
   * @param {ol.Coordinates} the center of the cluster
   */
  animateCluster_(e, t) {
    if (this.listenerKey_ && Js(this.listenerKey_), !t.length)
      return;
    var r = this.overlayLayer_.getStyle(), n = typeof r == "function" ? r : r.length ? function() {
      return r;
    } : function() {
      return [r];
    }, s = this.animationDuration || 500, a = (/* @__PURE__ */ new Date()).getTime();
    function o(l) {
      for (var h = l.vectorContext || Zv(l), c = l.frameState.pixelRatio, u = this.getMap().getView().getResolution(), f = ea((l.frameState.time - a) / s), g = 0, p; p = t[g]; g++)
        if (p.get("features")) {
          var y = p.getGeometry().getCoordinates();
          y[0] = e[0] + f * (y[0] - e[0]), y[1] = e[1] + f * (y[1] - e[1]);
          for (var v = new gr(y), w = n(p, u), C = 0; C < w.length; C++) {
            var E, S = vg.prototype.getFeaturesAtPixel ? !1 : w[C].getImage();
            S && (E = S.getScale(), S.setScale(c)), h.setStyle ? (h.setStyle(w[C]), h.drawGeometry(v)) : (h.setImageStyle(S), h.drawPointGeometry(v)), S && S.setScale(E);
          }
        }
      if (f > 1) {
        Js(this.listenerKey_), this.overlayLayer_.getSource().addFeatures(t), this.overlayLayer_.changed();
        return;
      }
      l.frameState.animate = !0;
    }
    this.listenerKey_ = this.overlayLayer_.on(["postcompose", "postrender"], o.bind(this));
    var A = new qt(new gr(this.getMap().getView().getCenter()));
    A.setStyle(new ln({ image: new Ru({}) })), this.overlayLayer_.getSource().addFeature(A);
  }
  /** Helper function to get the extent of a cluster
   * @param {ol.feature} feature
   * @return {ol.extent|null} the extent or null if extent is empty (no cluster or superimposed points)
   */
  getClusterExtent(e) {
    if (!e.get("features"))
      return null;
    var t = Ji();
    return e.get("features").forEach(function(r) {
      t = Jl(t, r.getGeometry().getExtent());
    }), t[0] === t[2] && t[1] === t[3] ? null : t;
  }
};
const gY = {
  name: "ol-interaction-clusterselect",
  emits: ["select"],
  setup(i, { emit: e }) {
    const t = _t("map"), { properties: r } = sr(i), n = cr(() => {
      const s = new dY({
        ...r,
        style: new ln()
      });
      return s.on("select", (a) => {
        e("select", a);
      }), s;
    });
    at(n, (s, a) => {
      t.removeInteraction(a), t.addInteraction(s), t.changed();
    }), tr(() => {
      t.addInteraction(n.value);
    }), nr(() => {
      t.removeInteraction(n.value);
    }), Ur("stylable", n);
  },
  props: {
    multi: {
      type: Boolean,
      default: !1
    },
    condition: {
      type: Function
    },
    filter: {
      type: Function
    },
    pointRadius: {
      type: Number,
      default: 7
    },
    animate: {
      type: Boolean,
      default: !0
    },
    featureStyle: {
      type: Function
    },
    style: {
      type: Function
    }
  }
};
function pY(i, e, t, r, n, s) {
  return mr(i.$slots, "default");
}
const Bx = /* @__PURE__ */ qe(gY, [["render", pY]]), mY = {
  name: "ol-interaction-draw",
  emits: ["drawstart", "drawend"],
  setup(i, { emit: e }) {
    const t = _t("map"), r = _t("vectorSource"), {
      type: n,
      clickTolerance: s,
      dragVertexDelay: a,
      snapTolerance: o,
      stopClick: A,
      maxPoints: l,
      minPoints: h,
      finishCondition: c,
      geometryFunction: u,
      geometryName: f,
      condition: g,
      freehand: p,
      freehandCondition: y,
      wrapX: v
    } = uh(i), w = () => {
      const E = new pB({
        source: r.value,
        type: n.value,
        clickTolerance: s.value,
        dragVertexDelay: a.value,
        snapTolerance: o.value,
        stopClick: A.value,
        maxPoints: l.value,
        minPoints: h.value,
        finishCondition: c.value,
        geometryFunction: u.value,
        geometryName: f.value,
        condition: g.value,
        freehand: p.value,
        freehandCondition: y.value,
        wrapX: v.value
      });
      return E.on("drawstart", (S) => {
        e("drawstart", S);
      }), E.on("drawend", (S) => {
        e("drawend", S);
      }), E;
    };
    let C = w();
    at(
      [
        n,
        s,
        a,
        o,
        A,
        l,
        h,
        c,
        u,
        f,
        g,
        p,
        y,
        v
      ],
      () => {
        t.removeInteraction(C), C = w(), t.addInteraction(C), C.changed(), t.changed();
      }
    ), tr(() => {
      t.addInteraction(C);
    }), nr(() => {
      t.removeInteraction(C);
    }), Ur("stylable", C);
  },
  props: {
    type: {
      type: String,
      required: !0
    },
    clickTolerance: {
      type: Number,
      default: 6
    },
    dragVertexDelay: {
      type: Number,
      default: 500
    },
    snapTolerance: {
      type: Number,
      default: 12
    },
    stopClick: {
      type: Boolean,
      default: !1
    },
    maxPoints: {
      type: Number
    },
    minPoints: {
      type: Number
    },
    finishCondition: {
      type: Function
    },
    geometryFunction: {
      type: Function
    },
    geometryName: {
      type: String
    },
    condition: {
      type: Function
    },
    freehand: {
      type: Boolean,
      default: !1
    },
    freehandCondition: {
      type: Function
    },
    wrapX: {
      type: Boolean,
      default: !1
    }
  }
};
function vY(i, e, t, r, n, s) {
  return mr(i.$slots, "default");
}
const bx = /* @__PURE__ */ qe(mY, [["render", vY]]);
function dT(i) {
  if (
    /** @type {import("../source/Vector.js").VectorSourceEvent} */
    i.feature
  )
    return (
      /** @type {import("../source/Vector.js").VectorSourceEvent} */
      i.feature
    );
  if (
    /** @type {import("../Collection.js").CollectionEvent<import("../Feature.js").default>} */
    i.element
  )
    return (
      /** @type {import("../Collection.js").CollectionEvent<import("../Feature.js").default>} */
      i.element
    );
}
const d_ = [];
class yY extends eo {
  /**
   * @param {Options} [options] Options.
   */
  constructor(e) {
    e = e || {};
    const t = (
      /** @type {import("./Pointer.js").Options} */
      e
    );
    t.handleDownEvent || (t.handleDownEvent = Xo), t.stopDown || (t.stopDown = Eh), super(t), this.source_ = e.source ? e.source : null, this.vertex_ = e.vertex !== void 0 ? e.vertex : !0, this.edge_ = e.edge !== void 0 ? e.edge : !0, this.features_ = e.features ? e.features : null, this.featuresListenerKeys_ = [], this.featureChangeListenerKeys_ = {}, this.indexedFeaturesExtents_ = {}, this.pendingFeatures_ = {}, this.pixelTolerance_ = e.pixelTolerance !== void 0 ? e.pixelTolerance : 10, this.rBush_ = new Gm(), this.GEOMETRY_SEGMENTERS_ = {
      Point: this.segmentPointGeometry_.bind(this),
      LineString: this.segmentLineStringGeometry_.bind(this),
      LinearRing: this.segmentLineStringGeometry_.bind(this),
      Polygon: this.segmentPolygonGeometry_.bind(this),
      MultiPoint: this.segmentMultiPointGeometry_.bind(this),
      MultiLineString: this.segmentMultiLineStringGeometry_.bind(this),
      MultiPolygon: this.segmentMultiPolygonGeometry_.bind(this),
      GeometryCollection: this.segmentGeometryCollectionGeometry_.bind(this),
      Circle: this.segmentCircleGeometry_.bind(this)
    };
  }
  /**
   * Add a feature to the collection of features that we may snap to.
   * @param {import("../Feature.js").default} feature Feature.
   * @param {boolean} [register] Whether to listen to the feature change or not
   *     Defaults to `true`.
   * @api
   */
  addFeature(e, t) {
    t = t !== void 0 ? t : !0;
    const r = st(e), n = e.getGeometry();
    if (n) {
      const s = this.GEOMETRY_SEGMENTERS_[n.getType()];
      if (s) {
        this.indexedFeaturesExtents_[r] = n.getExtent(
          Ji()
        );
        const a = (
          /** @type {Array<Array<import('../coordinate.js').Coordinate>>} */
          []
        );
        if (s(a, n), a.length === 1)
          this.rBush_.insert(Xi(a[0]), {
            feature: e,
            segment: a[0]
          });
        else if (a.length > 1) {
          const o = a.map((l) => Xi(l)), A = a.map((l) => ({
            feature: e,
            segment: l
          }));
          this.rBush_.load(o, A);
        }
      }
    }
    t && (this.featureChangeListenerKeys_[r] = St(
      e,
      ut.CHANGE,
      this.handleFeatureChange_,
      this
    ));
  }
  /**
   * @return {import("../Collection.js").default<import("../Feature.js").default>|Array<import("../Feature.js").default>} Features.
   * @private
   */
  getFeatures_() {
    let e;
    return this.features_ ? e = this.features_ : this.source_ && (e = this.source_.getFeatures()), e;
  }
  /**
   * @param {import("../MapBrowserEvent.js").default} evt Map browser event.
   * @return {boolean} `false` to stop event propagation.
   */
  handleEvent(e) {
    const t = this.snapTo(e.pixel, e.coordinate, e.map);
    return t && (e.coordinate = t.vertex.slice(0, 2), e.pixel = t.vertexPixel), super.handleEvent(e);
  }
  /**
   * @param {import("../source/Vector.js").VectorSourceEvent|import("../Collection.js").CollectionEvent<import("../Feature.js").default>} evt Event.
   * @private
   */
  handleFeatureAdd_(e) {
    const t = dT(e);
    this.addFeature(t);
  }
  /**
   * @param {import("../source/Vector.js").VectorSourceEvent|import("../Collection.js").CollectionEvent<import("../Feature.js").default>} evt Event.
   * @private
   */
  handleFeatureRemove_(e) {
    const t = dT(e);
    this.removeFeature(t);
  }
  /**
   * @param {import("../events/Event.js").default} evt Event.
   * @private
   */
  handleFeatureChange_(e) {
    const t = (
      /** @type {import("../Feature.js").default} */
      e.target
    );
    if (this.handlingDownUpSequence) {
      const r = st(t);
      r in this.pendingFeatures_ || (this.pendingFeatures_[r] = t);
    } else
      this.updateFeature_(t);
  }
  /**
   * Handle pointer up events.
   * @param {import("../MapBrowserEvent.js").default} evt Event.
   * @return {boolean} If the event was consumed.
   */
  handleUpEvent(e) {
    const t = Object.values(this.pendingFeatures_);
    return t.length && (t.forEach(this.updateFeature_.bind(this)), this.pendingFeatures_ = {}), !1;
  }
  /**
   * Remove a feature from the collection of features that we may snap to.
   * @param {import("../Feature.js").default} feature Feature
   * @param {boolean} [unlisten] Whether to unlisten to the feature change
   *     or not. Defaults to `true`.
   * @api
   */
  removeFeature(e, t) {
    const r = t !== void 0 ? t : !0, n = st(e), s = this.indexedFeaturesExtents_[n];
    if (s) {
      const a = this.rBush_, o = [];
      a.forEachInExtent(s, function(A) {
        e === A.feature && o.push(A);
      });
      for (let A = o.length - 1; A >= 0; --A)
        a.remove(o[A]);
    }
    r && (pr(this.featureChangeListenerKeys_[n]), delete this.featureChangeListenerKeys_[n]);
  }
  /**
   * Remove the interaction from its current map and attach it to the new map.
   * Subclasses may set up event handlers to get notified about changes to
   * the map here.
   * @param {import("../Map.js").default} map Map.
   */
  setMap(e) {
    const t = this.getMap(), r = this.featuresListenerKeys_, n = (
      /** @type {Array<import("../Feature.js").default>} */
      this.getFeatures_()
    );
    t && (r.forEach(pr), r.length = 0, this.rBush_.clear(), Object.values(this.featureChangeListenerKeys_).forEach(pr), this.featureChangeListenerKeys_ = {}), super.setMap(e), e && (this.features_ ? r.push(
      St(
        this.features_,
        Si.ADD,
        this.handleFeatureAdd_,
        this
      ),
      St(
        this.features_,
        Si.REMOVE,
        this.handleFeatureRemove_,
        this
      )
    ) : this.source_ && r.push(
      St(
        this.source_,
        an.ADDFEATURE,
        this.handleFeatureAdd_,
        this
      ),
      St(
        this.source_,
        an.REMOVEFEATURE,
        this.handleFeatureRemove_,
        this
      )
    ), n.forEach((s) => this.addFeature(s)));
  }
  /**
   * @param {import("../pixel.js").Pixel} pixel Pixel
   * @param {import("../coordinate.js").Coordinate} pixelCoordinate Coordinate
   * @param {import("../Map.js").default} map Map.
   * @return {Result|null} Snap result
   */
  snapTo(e, t, r) {
    r.getView().getProjection();
    const n = ai(t), s = fg(
      zn(
        Xi([n]),
        r.getView().getResolution() * this.pixelTolerance_
      )
    ), a = this.rBush_.getInExtent(s), o = a.length;
    if (o === 0)
      return null;
    let A, l = 1 / 0;
    const h = this.pixelTolerance_ * this.pixelTolerance_, c = () => {
      if (A) {
        const u = r.getPixelFromCoordinate(A);
        if (Ho(e, u) <= h)
          return {
            vertex: A,
            vertexPixel: [
              Math.round(u[0]),
              Math.round(u[1])
            ]
          };
      }
      return null;
    };
    if (this.vertex_) {
      for (let f = 0; f < o; ++f) {
        const g = a[f];
        g.feature.getGeometry().getType() !== "Circle" && g.segment.forEach((p) => {
          const y = ai(p), v = Ho(n, y);
          v < l && (A = p, l = v);
        });
      }
      const u = c();
      if (u)
        return u;
    }
    if (this.edge_) {
      for (let f = 0; f < o; ++f) {
        let g = null;
        const p = a[f];
        if (p.feature.getGeometry().getType() === "Circle") {
          let y = p.feature.getGeometry();
          g = uD(
            n,
            /** @type {import("../geom/Circle.js").default} */
            y
          );
        } else {
          const [y, v] = p.segment;
          v && (d_[0] = ai(y), d_[1] = ai(v), g = uE(n, d_));
        }
        if (g) {
          const y = Ho(n, g);
          y < l && (A = fu(g), l = y);
        }
      }
      const u = c();
      if (u)
        return u;
    }
    return null;
  }
  /**
   * @param {import("../Feature.js").default} feature Feature
   * @private
   */
  updateFeature_(e) {
    this.removeFeature(e, !1), this.addFeature(e, !1);
  }
  /**
   * @param {Array<Array<import('../coordinate.js').Coordinate>>} segments Segments
   * @param {import("../geom/Circle.js").default} geometry Geometry.
   * @private
   */
  segmentCircleGeometry_(e, t) {
    this.getMap().getView().getProjection();
    const s = YD(t).getCoordinates()[0];
    for (let a = 0, o = s.length - 1; a < o; ++a)
      e.push(s.slice(a, a + 2));
  }
  /**
   * @param {Array<Array<import('../coordinate.js').Coordinate>>} segments Segments
   * @param {import("../geom/GeometryCollection.js").default} geometry Geometry.
   * @private
   */
  segmentGeometryCollectionGeometry_(e, t) {
    const r = t.getGeometriesArray();
    for (let n = 0; n < r.length; ++n) {
      const s = this.GEOMETRY_SEGMENTERS_[r[n].getType()];
      s && s(e, r[n]);
    }
  }
  /**
   * @param {Array<Array<import('../coordinate.js').Coordinate>>} segments Segments
   * @param {import("../geom/LineString.js").default} geometry Geometry.
   * @private
   */
  segmentLineStringGeometry_(e, t) {
    const r = t.getCoordinates();
    for (let n = 0, s = r.length - 1; n < s; ++n)
      e.push(r.slice(n, n + 2));
  }
  /**
   * @param {Array<Array<import('../coordinate.js').Coordinate>>} segments Segments
   * @param {import("../geom/MultiLineString.js").default} geometry Geometry.
   * @private
   */
  segmentMultiLineStringGeometry_(e, t) {
    const r = t.getCoordinates();
    for (let n = 0, s = r.length; n < s; ++n) {
      const a = r[n];
      for (let o = 0, A = a.length - 1; o < A; ++o)
        e.push(a.slice(o, o + 2));
    }
  }
  /**
   * @param {Array<Array<import('../coordinate.js').Coordinate>>} segments Segments
   * @param {import("../geom/MultiPoint.js").default} geometry Geometry.
   * @private
   */
  segmentMultiPointGeometry_(e, t) {
    t.getCoordinates().forEach((r) => {
      e.push([r]);
    });
  }
  /**
   * @param {Array<Array<import('../coordinate.js').Coordinate>>} segments Segments
   * @param {import("../geom/MultiPolygon.js").default} geometry Geometry.
   * @private
   */
  segmentMultiPolygonGeometry_(e, t) {
    const r = t.getCoordinates();
    for (let n = 0, s = r.length; n < s; ++n) {
      const a = r[n];
      for (let o = 0, A = a.length; o < A; ++o) {
        const l = a[o];
        for (let h = 0, c = l.length - 1; h < c; ++h)
          e.push(l.slice(h, h + 2));
      }
    }
  }
  /**
   * @param {Array<Array<import('../coordinate.js').Coordinate>>} segments Segments
   * @param {import("../geom/Point.js").default} geometry Geometry.
   * @private
   */
  segmentPointGeometry_(e, t) {
    e.push([t.getCoordinates()]);
  }
  /**
   * @param {Array<Array<import('../coordinate.js').Coordinate>>} segments Segments
   * @param {import("../geom/Polygon.js").default} geometry Geometry.
   * @private
   */
  segmentPolygonGeometry_(e, t) {
    const r = t.getCoordinates();
    for (let n = 0, s = r.length; n < s; ++n) {
      const a = r[n];
      for (let o = 0, A = a.length - 1; o < A; ++o)
        e.push(a.slice(o, o + 2));
    }
  }
}
const _Y = yY, wY = {
  name: "ol-interaction-snap",
  setup(i) {
    const e = _t("map"), t = _t("vectorSource"), { properties: r } = sr(i), n = () => new _Y({
      ...r,
      source: t.value
    });
    let s = n();
    at(r, () => {
      e.removeInteraction(s), s = n(), e.addInteraction(s), e.changed();
    }), tr(() => {
      e.addInteraction(s);
    }), nr(() => {
      e.removeInteraction(s);
    });
  },
  props: {
    vertex: {
      type: Boolean,
      default: !0
    },
    edge: {
      type: Boolean,
      default: !0
    },
    pixelTolerance: {
      type: Number,
      default: 10
    }
  }
};
function xY(i, e, t, r, n, s) {
  return mr(i.$slots, "default");
}
const Sx = /* @__PURE__ */ qe(wY, [["render", xY]]), CY = {
  name: "ol-interaction-modify",
  emits: ["modifystart", "modifyend"],
  setup(i, { emit: e }) {
    const t = _t("map"), r = _t("vectorSource"), {
      features: n,
      condition: s,
      deleteCondition: a,
      insertVertexCondition: o,
      pixelTolerance: A,
      wrapX: l,
      hitDetection: h
    } = uh(i), c = () => {
      const f = new mB({
        source: r.value,
        features: n.value,
        condition: s.value,
        deleteCondition: a.value,
        insertVertexCondition: o.value,
        pixelTolerance: A.value,
        wrapX: l.value,
        hitDetection: h.value
      });
      return f.on("modifystart", (g) => {
        e("modifystart", g);
      }), f.on("modifyend", (g) => {
        e("modifyend", g);
      }), f;
    };
    let u = c();
    at(
      [
        s,
        a,
        o,
        A,
        l,
        h
      ],
      () => {
        t.removeInteraction(u), u = c(), t.addInteraction(u), u.changed(), t.changed();
      }
    ), tr(() => {
      t.addInteraction(u);
    }), nr(() => {
      t.removeInteraction(u);
    }), Ur("stylable", u);
  },
  props: {
    condition: {
      type: Function
    },
    deleteCondition: {
      type: Function
    },
    insertVertexCondition: {
      type: Function
    },
    pixelTolerance: {
      type: Number,
      default: 10
    },
    wrapX: {
      type: Boolean,
      default: !1
    },
    hitDetection: {
      type: Boolean
    },
    features: {
      type: [Yi, Object]
    }
  }
};
function EY(i, e, t, r, n, s) {
  return mr(i.$slots, "default");
}
const Tx = /* @__PURE__ */ qe(CY, [["render", EY]]);
var vN = class extends eo {
  constructor(e) {
    e = e || {}, super({
      handleDownEvent: function(r) {
        return t.handleDownEvent_(r);
      },
      handleDragEvent: function(r) {
        return this.handleDragEvent_(r);
      },
      handleMoveEvent: function(r) {
        return this.handleMoveEvent_(r);
      },
      handleUpEvent: function(r) {
        return this.handleUpEvent_(r);
      }
    });
    var t = this;
    this.selection_ = new Yi(), this.handles_ = new Yi(), this.overlayLayer_ = new nA({
      source: new sA({
        features: this.handles_,
        useSpatialIndex: !1,
        wrapX: !1
        // For vector editing across the -180 and 180 meridians to work properly, this should be set to false
      }),
      name: "Transform overlay",
      displayInLayerSwitcher: !1,
      // Return the style according to the handle type
      style: function(r) {
        return t.style[(r.get("handle") || "default") + (r.get("constraint") || "") + (r.get("option") || "")];
      }
    }), this.features_ = e.features, typeof e.filter == "function" && (this._filter = e.filter), this.layers_ = e.layers ? e.layers instanceof Array ? e.layers : [e.layers] : null, this._handleEvent = e.condition || function() {
      return !0;
    }, this.addFn_ = e.addCondition || function() {
      return !1;
    }, this.setPointRadius(e.pointRadius), this.set("translateFeature", e.translateFeature !== !1), this.set("translate", e.translate !== !1), this.set("translateBBox", e.translateBBox === !0), this.set("stretch", e.stretch !== !1), this.set("scale", e.scale !== !1), this.set("rotate", e.rotate !== !1), this.set("keepAspectRatio", e.keepAspectRatio || function(r) {
      return r.originalEvent.shiftKey;
    }), this.set("modifyCenter", e.modifyCenter || function(r) {
      return r.originalEvent.metaKey || r.originalEvent.ctrlKey;
    }), this.set("noFlip", e.noFlip || !1), this.set("selection", e.selection !== !1), this.set("hitTolerance", e.hitTolerance || 0), this.set("enableRotatedTransform", e.enableRotatedTransform || !1), this.set("keepRectangle", e.keepRectangle || !1), this.on("propertychange", function() {
      this.drawSketch_();
    }), this.setDefaultStyle();
  }
  /**
   * Remove the interaction from its current map, if any,  and attach it to a new
   * map, if any. Pass `null` to just remove the interaction from the current map.
   * @param {ol.Map} map Map.
   * @api stable
   */
  setMap(e) {
    var t = this.getMap();
    if (t) {
      var r = t.getTargetElement();
      t.removeLayer(this.overlayLayer_), this.previousCursor_ && r && (r.style.cursor = this.previousCursor_), this.previousCursor_ = void 0;
    }
    super.setMap(e), this.overlayLayer_.setMap(e), e === null && this.select(null), e !== null && (this.isTouch = /touch/.test(e.getViewport().className), this.setDefaultStyle());
  }
  /**
   * Activate/deactivate interaction
   * @param {bool}
   * @api stable
   */
  setActive(e) {
    this.select(null), this.overlayLayer_ && this.overlayLayer_.setVisible(e), super.setActive(e);
  }
  /** Set default sketch style
   * @param {Object|undefined} options
   *  @param {ol_style_Stroke} stroke stroke style for selection rectangle
   *  @param {ol_style_Fill} fill fill style for selection rectangle
   *  @param {ol_style_Stroke} pointStroke stroke style for handles
   *  @param {ol_style_Fill} pointFill fill style for handles
   */
  setDefaultStyle(e) {
    e = e || {};
    var t = e.pointStroke || new Zi({ color: [255, 0, 0, 1], width: 1 }), r = e.stroke || new Zi({ color: [255, 0, 0, 1], width: 1, lineDash: [4, 4] }), n = e.fill || new Wn({ color: [255, 0, 0, 0.01] }), s = e.pointFill || new Wn({ color: [255, 255, 255, 0.8] }), a = new ud({
      fill: s,
      stroke: t,
      radius: this.isTouch ? 12 : 6,
      displacement: this.isTouch ? [24, -24] : [12, -12],
      points: 15
    });
    a.setDisplacement || (a.getAnchor()[0] = this.isTouch ? -10 : -5);
    var o = new ud({
      fill: s,
      stroke: t,
      radius: this.isTouch ? 16 : 8,
      points: 4,
      angle: Math.PI / 4
    }), A = new ud({
      fill: s,
      stroke: t,
      radius: this.isTouch ? 12 : 6,
      points: 4,
      angle: Math.PI / 4
    });
    function l(h, c, u) {
      return [new ln({ image: h, stroke: c, fill: u })];
    }
    this.style = {
      default: l(o, r, n),
      translate: l(o, t, s),
      rotate: l(a, t, s),
      rotate0: l(o, t, s),
      scale: l(o, t, s),
      scale1: l(o, t, s),
      scale2: l(o, t, s),
      scale3: l(o, t, s),
      scalev: l(A, t, s),
      scaleh1: l(A, t, s),
      scalev2: l(A, t, s),
      scaleh3: l(A, t, s)
    }, this.drawSketch_();
  }
  /**
   * Set sketch style.
   * @param {style} style Style name: 'default','translate','rotate','rotate0','scale','scale1','scale2','scale3','scalev','scaleh1','scalev2','scaleh3'
   * @param {ol.style.Style|Array<ol.style.Style>} olstyle
   * @api stable
   */
  setStyle(e, t) {
    if (t) {
      t instanceof Array ? this.style[e] = t : this.style[e] = [t];
      for (var r = 0; r < this.style[e].length; r++) {
        var n = this.style[e][r].getImage();
        n && (e == "rotate" && (n.getAnchor()[0] = -5), this.isTouch && n.setScale(1.8));
        var s = this.style[e][r].getText();
        s && (e == "rotate" && s.setOffsetX(this.isTouch ? 14 : 7), this.isTouch && s.setScale(1.8));
      }
      this.drawSketch_();
    }
  }
  /** Get Feature at pixel
   * @param {ol.Pixel}
   * @return {ol.feature}
   * @private
   */
  getFeatureAtPixel_(e) {
    var t = this;
    return this.getMap().forEachFeatureAtPixel(
      e,
      function(r, n) {
        var s = !1;
        if (!n) {
          if (r === t.bbox_)
            return t.get("translateBBox") ? { feature: r, handle: "translate", constraint: "", option: "" } : !1;
          if (t.handles_.forEach(function(o) {
            o === r && (s = !0);
          }), s)
            return { feature: r, handle: r.get("handle"), constraint: r.get("constraint"), option: r.get("option") };
        }
        if (!t.get("selection"))
          return t.selection_.getArray().some(function(o) {
            return r === o;
          }) ? { feature: r } : null;
        if (t._filter)
          return t._filter(r, n) ? { feature: r } : null;
        if (t.layers_) {
          for (var a = 0; a < t.layers_.length; a++)
            if (t.layers_[a] === n)
              return { feature: r };
          return null;
        } else
          return t.features_ ? (t.features_.forEach(function(o) {
            o === r && (s = !0);
          }), s ? { feature: r } : null) : { feature: r };
      },
      { hitTolerance: this.get("hitTolerance") }
    ) || {};
  }
  /** Rotate feature from map view rotation
   * @param {ol.Feature} f the feature
   * @param {boolean} clone clone resulting geom
   * @param {ol.geom.Geometry} rotated geometry
   */
  getGeometryRotateToZero_(e, t) {
    var r = e.getGeometry(), n = this.getMap().getView().getRotation();
    if (n === 0 || !this.get("enableRotatedTransform"))
      return t ? r.clone() : r;
    var s = r.clone();
    return s.rotate(n * -1, this.getMap().getView().getCenter()), s;
  }
  /** Test if rectangle
   * @param {ol.Geometry} geom
   * @returns {boolean}
   * @private
   */
  _isRectangle(e) {
    if (this.get("keepRectangle") && e.getType() === "Polygon") {
      var t = e.getCoordinates()[0];
      return t.length === 5;
    }
    return !1;
  }
  /** Draw transform sketch
  * @param {boolean} draw only the center
  */
  drawSketch_(e) {
    var t, r, n, s = this.selection_.item(0) && this._isRectangle(this.selection_.item(0).getGeometry());
    if (this.overlayLayer_.getSource().clear(), !!this.selection_.getLength()) {
      var a = this.getMap().getView().getRotation(), o = this.getGeometryRotateToZero_(this.selection_.item(0)).getExtent(), A;
      s && (A = this.getGeometryRotateToZero_(this.selection_.item(0)).getCoordinates()[0].slice(0, 4), A.unshift(A[3])), o = zn(o, 0), this.selection_.forEach(function(p) {
        var y = this.getGeometryRotateToZero_(p).getExtent();
        Jl(o, y);
      }.bind(this));
      var l = this.selection_.getLength() === 1 ? this._pointRadius(this.selection_.item(0)) : 0;
      if (l && !(l instanceof Array) && (l = [l, l]), e === !0)
        this.ispt_ || (this.overlayLayer_.getSource().addFeature(new qt({ geometry: new gr(this.center_), handle: "rotate0" })), n = jA(o), this.get("enableRotatedTransform") && a !== 0 && n.rotate(a, this.getMap().getView().getCenter()), r = this.bbox_ = new qt(n), this.overlayLayer_.getSource().addFeature(r));
      else {
        if (this.ispt_) {
          var h = this.getMap().getPixelFromCoordinate([o[0], o[1]]);
          if (h) {
            var c = l && l[0] || 10, u = l && l[1] || 10;
            o = Xi([
              this.getMap().getCoordinateFromPixel([h[0] - c, h[1] - u]),
              this.getMap().getCoordinateFromPixel([h[0] + c, h[1] + u])
            ]);
          }
        }
        n = s ? new Li([A]) : jA(o), this.get("enableRotatedTransform") && a !== 0 && n.rotate(a, this.getMap().getView().getCenter()), r = this.bbox_ = new qt(n);
        var f = [], g = n.getCoordinates()[0];
        if (!this.ispt_ || l) {
          if (f.push(r), !this.iscircle_ && !this.ispt_ && this.get("stretch") && this.get("scale"))
            for (t = 0; t < g.length - 1; t++)
              r = new qt({ geometry: new gr([(g[t][0] + g[t + 1][0]) / 2, (g[t][1] + g[t + 1][1]) / 2]), handle: "scale", constraint: t % 2 ? "h" : "v", option: t }), f.push(r);
          if (this.get("scale"))
            for (t = 0; t < g.length - 1; t++)
              r = new qt({ geometry: new gr(g[t]), handle: "scale", option: t }), f.push(r);
          this.get("translate") && !this.get("translateFeature") && (r = new qt({ geometry: new gr([(g[0][0] + g[2][0]) / 2, (g[0][1] + g[2][1]) / 2]), handle: "translate" }), f.push(r));
        }
        !this.iscircle_ && this.get("rotate") && (r = new qt({ geometry: new gr(g[3]), handle: "rotate" }), f.push(r)), this.overlayLayer_.getSource().addFeatures(f);
      }
    }
  }
  /** Select a feature to transform
  * @param {ol.Feature} feature the feature to transform
  * @param {boolean} add true to add the feature to the selection, default false
  */
  select(e, t) {
    if (!e) {
      this.selection_ && (this.selection_.clear(), this.drawSketch_());
      return;
    }
    if (!(!e.getGeometry || !e.getGeometry())) {
      if (t)
        this.selection_.push(e);
      else {
        var r = this.selection_.getArray().indexOf(e);
        this.selection_.removeAt(r);
      }
      this.ispt_ = this.selection_.getLength() === 1 ? this.selection_.item(0).getGeometry().getType() == "Point" : !1, this.iscircle_ = this.selection_.getLength() === 1 ? this.selection_.item(0).getGeometry().getType() == "Circle" : !1, this.drawSketch_(), this.watchFeatures_(), this.dispatchEvent({ type: "select", feature: e, features: this.selection_ });
    }
  }
  /** Update the selection collection.
  * @param {ol.Collection<ol.Feature>} features the features to transform
  */
  setSelection(e) {
    this.selection_.clear(), e.forEach(function(t) {
      this.selection_.push(t);
    }.bind(this)), this.ispt_ = this.selection_.getLength() === 1 ? this.selection_.item(0).getGeometry().getType() == "Point" : !1, this.iscircle_ = this.selection_.getLength() === 1 ? this.selection_.item(0).getGeometry().getType() == "Circle" : !1, this.drawSketch_(), this.watchFeatures_(), this.dispatchEvent({ type: "select", features: this.selection_ });
  }
  /** Watch selected features
   * @private
   */
  watchFeatures_() {
    this._featureListeners && this._featureListeners.forEach(function(e) {
      Js(e);
    }), this._featureListeners = [], this.selection_.forEach(function(e) {
      this._featureListeners.push(
        e.on("change", function() {
          this.isUpdating_ || this.drawSketch_();
        }.bind(this))
      );
    }.bind(this));
  }
  /**
   * @param {ol.MapBrowserEvent} evt Map browser event.
   * @return {boolean} `true` to start the drag sequence.
   * @private
   */
  handleDownEvent_(e) {
    if (this._handleEvent(e, this.selection_)) {
      var t = this.getFeatureAtPixel_(e.pixel), r = t.feature;
      if (this.selection_.getLength() && this.selection_.getArray().indexOf(r) >= 0 && (this.ispt_ && this.get("translate") || this.get("translateFeature")) && (t.handle = "translate"), t.handle) {
        this.mode_ = t.handle, this.opt_ = t.option, this.constraint_ = t.constraint;
        var n = this.getMap().getView().getRotation();
        this.coordinate_ = e.coordinate, this.pixel_ = e.pixel, this.geoms_ = [], this.rotatedGeoms_ = [];
        for (var s = Ji(), a = Ji(), o = 0, A; A = this.selection_.item(o); o++)
          if (this.geoms_.push(A.getGeometry().clone()), s = Jl(s, A.getGeometry().getExtent()), this.get("enableRotatedTransform") && n !== 0) {
            var l = this.getGeometryRotateToZero_(A, !0);
            this.rotatedGeoms_.push(l), a = Jl(a, l.getExtent());
          }
        if (this.extent_ = jA(s).getCoordinates()[0], this.get("enableRotatedTransform") && n !== 0 && (this.rotatedExtent_ = jA(a).getCoordinates()[0]), this.mode_ === "rotate") {
          this.center_ = this.getCenter() || Xn(s);
          var h = e.map.getTargetElement();
          h.style.cursor = this.Cursors.rotate0, this.previousCursor_ = h.style.cursor;
        } else
          this.center_ = Xn(s);
        return this.angle_ = Math.atan2(this.center_[1] - e.coordinate[1], this.center_[0] - e.coordinate[0]), this.dispatchEvent({
          type: this.mode_ + "start",
          feature: this.selection_.item(0),
          features: this.selection_,
          pixel: e.pixel,
          coordinate: e.coordinate
        }), !0;
      } else if (this.get("selection")) {
        if (r) {
          this.addFn_(e) || this.selection_.clear();
          var c = this.selection_.getArray().indexOf(r);
          c < 0 ? this.selection_.push(r) : this.selection_.removeAt(c);
        } else
          this.selection_.clear();
        return this.ispt_ = this.selection_.getLength() === 1 ? this.selection_.item(0).getGeometry().getType() == "Point" : !1, this.iscircle_ = this.selection_.getLength() === 1 ? this.selection_.item(0).getGeometry().getType() == "Circle" : !1, this.drawSketch_(), this.watchFeatures_(), this.dispatchEvent({ type: "select", feature: r, features: this.selection_, pixel: e.pixel, coordinate: e.coordinate }), !1;
      }
    }
  }
  /**
   * Get the rotation center
   * @return {ol.coordinate|undefined}
   */
  getCenter() {
    return this.get("center");
  }
  /**
   * Set the rotation center
   * @param {ol.coordinate|undefined} c the center point, default center on the objet
   */
  setCenter(e) {
    return this.set("center", e);
  }
  /**
   * @param {ol.MapBrowserEvent} evt Map browser event.
   * @private
   */
  handleDragEvent_(e) {
    if (this._handleEvent(e, this.features_)) {
      var t = this.getMap().getView().getRotation(), r, n, s, a, o = [this.coordinate_[0], this.coordinate_[1]], A = [e.coordinate[0], e.coordinate[1]];
      switch (this.isUpdating_ = !0, this.mode_) {
        case "rotate": {
          var l = Math.atan2(this.center_[1] - A[1], this.center_[0] - A[0]);
          if (!this.ispt)
            for (r = 0, s; s = this.selection_.item(r); r++)
              a = this.geoms_[r].clone(), a.rotate(l - this.angle_, this.center_), a.getType() == "Circle" && a.setCenterAndRadius(a.getCenter(), a.getRadius()), s.setGeometry(a);
          this.drawSketch_(!0), this.dispatchEvent({
            type: "rotating",
            feature: this.selection_.item(0),
            features: this.selection_,
            angle: l - this.angle_,
            pixel: e.pixel,
            coordinate: e.coordinate
          });
          break;
        }
        case "translate": {
          var h = A[0] - o[0], c = A[1] - o[1];
          for (r = 0, s; s = this.selection_.item(r); r++)
            s.getGeometry().translate(h, c);
          this.handles_.forEach(function(k) {
            k.getGeometry().translate(h, c);
          }), this.coordinate_ = e.coordinate, this.dispatchEvent({
            type: "translating",
            feature: this.selection_.item(0),
            features: this.selection_,
            delta: [h, c],
            pixel: e.pixel,
            coordinate: e.coordinate
          });
          break;
        }
        case "scale": {
          var u = this.center_;
          if (this.get("modifyCenter")(e)) {
            var f = this.extent_;
            this.get("enableRotatedTransform") && t !== 0 && (f = this.rotatedExtent_), u = f[(Number(this.opt_) + 2) % 4];
          }
          var g = this.geoms_.length == 1 && this._isRectangle(this.geoms_[0]), p = this.constraint_, y = this.opt_, v = this.coordinate_, w = e.coordinate;
          if (this.get("enableRotatedTransform") && t !== 0) {
            var C = new gr(this.coordinate_);
            C.rotate(t * -1, u), v = C.getCoordinates();
            var E = new gr(e.coordinate);
            E.rotate(t * -1, u), w = E.getCoordinates();
          }
          var S = (w[0] - u[0]) / (v[0] - u[0]), M = (w[1] - u[1]) / (v[1] - u[1]), T = [w[0] - v[0], w[1] - v[1]];
          if (this.get("enableRotatedTransform") && t !== 0) {
            var F = new gr(u);
            F.rotate(t * -1, this.getMap().getView().getCenter()), u = F.getCoordinates();
          }
          for (this.get("noFlip") && (S < 0 && (S = -S), M < 0 && (M = -M)), this.constraint_ ? this.constraint_ == "h" ? S = 1 : M = 1 : this.get("keepAspectRatio")(e) && (S = M = Math.min(S, M)), r = 0, s; s = this.selection_.item(r); r++)
            a = t === 0 || !this.get("enableRotatedTransform") ? this.geoms_[r].clone() : this.rotatedGeoms_[r].clone(), a.applyTransform(function(k, $, I) {
              if (I < 2)
                return $;
              if (g) {
                var L = [[6], [0, 8], [2], [4]], P = [k[0], k[1]], Q = [k[2], k[3]], X = [k[4], k[5]], W = [k[6], k[7]], q = [k[8], k[9]];
                if (p) {
                  var Z = y % 2 === 0 ? this._countVector(P, Q) : this._countVector(W, P), oe = this._projectVectorOnVector(T, Z), ne = y + 1 < L.length ? y + 1 : 0, me = [...L[y], ...L[ne]];
                  for (n = 0; n < k.length; n += I)
                    $[n] = me.includes(n) ? k[n] + oe[0] : k[n], $[n + 1] = me.includes(n) ? k[n + 1] + oe[1] : k[n + 1];
                } else {
                  var b, H;
                  switch (y) {
                    case 0:
                      T = this._countVector(W, w), b = this._projectVectorOnVector(T, this._countVector(X, W)), H = this._projectVectorOnVector(T, this._countVector(P, W)), [$[0], $[1]] = this._movePoint(P, b), [$[4], $[5]] = this._movePoint(X, H), [$[6], $[7]] = this._movePoint(W, T), [$[8], $[9]] = this._movePoint(q, b);
                      break;
                    case 1:
                      T = this._countVector(P, w), b = this._projectVectorOnVector(T, this._countVector(W, P)), H = this._projectVectorOnVector(T, this._countVector(Q, P)), [$[0], $[1]] = this._movePoint(P, T), [$[2], $[3]] = this._movePoint(Q, b), [$[6], $[7]] = this._movePoint(W, H), [$[8], $[9]] = this._movePoint(q, T);
                      break;
                    case 2:
                      T = this._countVector(Q, w), b = this._projectVectorOnVector(T, this._countVector(P, Q)), H = this._projectVectorOnVector(T, this._countVector(X, Q)), [$[0], $[1]] = this._movePoint(P, H), [$[2], $[3]] = this._movePoint(Q, T), [$[4], $[5]] = this._movePoint(X, b), [$[8], $[9]] = this._movePoint(q, H);
                      break;
                    case 3:
                      T = this._countVector(X, w), b = this._projectVectorOnVector(T, this._countVector(Q, X)), H = this._projectVectorOnVector(T, this._countVector(W, X)), [$[2], $[3]] = this._movePoint(Q, H), [$[4], $[5]] = this._movePoint(X, T), [$[6], $[7]] = this._movePoint(W, b);
                      break;
                  }
                }
              } else
                for (n = 0; n < k.length; n += I)
                  S != 1 && ($[n] = u[0] + (k[n] - u[0]) * S), M != 1 && ($[n + 1] = u[1] + (k[n + 1] - u[1]) * M);
              return a.getType() == "Circle" && a.setCenterAndRadius(a.getCenter(), a.getRadius()), $;
            }.bind(this)), this.get("enableRotatedTransform") && t !== 0 && a.rotate(t, this.getMap().getView().getCenter()), s.setGeometry(a);
          this.drawSketch_(), this.dispatchEvent({
            type: "scaling",
            feature: this.selection_.item(0),
            features: this.selection_,
            scale: [S, M],
            pixel: e.pixel,
            coordinate: e.coordinate
          });
          break;
        }
      }
      this.isUpdating_ = !1;
    }
  }
  /**
   * @param {ol.MapBrowserEvent} evt Event.
   * @private
   */
  handleMoveEvent_(e) {
    if (this._handleEvent(e, this.features_) && !this.mode_) {
      var t = this.getFeatureAtPixel_(e.pixel), r = e.map.getTargetElement();
      if (t.feature) {
        var n = t.handle ? this.Cursors[(t.handle || "default") + (t.constraint || "") + (t.option || "")] : this.Cursors.select;
        this.previousCursor_ === void 0 && (this.previousCursor_ = r.style.cursor), r.style.cursor = n;
      } else
        this.previousCursor_ !== void 0 && (r.style.cursor = this.previousCursor_), this.previousCursor_ = void 0;
    }
  }
  /**
   * @param {ol.MapBrowserEvent} evt Map browser event.
   * @return {boolean} `false` to stop the drag sequence.
   */
  handleUpEvent_(e) {
    if (this.mode_ === "rotate") {
      var t = e.map.getTargetElement();
      t.style.cursor = this.Cursors.default, this.previousCursor_ = void 0;
    }
    return this.dispatchEvent({
      type: this.mode_ + "end",
      feature: this.selection_.item(0),
      features: this.selection_,
      oldgeom: this.geoms_[0],
      oldgeoms: this.geoms_
    }), this.drawSketch_(), this.mode_ = null, !1;
  }
  /** Set the point radius to calculate handles on points
   *  @param {number|Array<number>|function} [pointRadius=0] radius for points or a function that takes a feature and returns the radius (or [radiusX, radiusY]). If not null show handles to transform the points
   */
  setPointRadius(e) {
    typeof e == "function" ? this._pointRadius = e : this._pointRadius = function() {
      return e;
    };
  }
  /** Get the features that are selected for transform
   * @return ol.Collection
   */
  getFeatures() {
    return this.selection_;
  }
  /**
   * @private
   */
  _projectVectorOnVector(e, t) {
    var r = (e[0] * t[0] + e[1] * t[1]) / (t[0] * t[0] + t[1] * t[1]);
    return [t[0] * r, t[1] * r];
  }
  /**
   * @private
   */
  _countVector(e, t) {
    return [t[0] - e[0], t[1] - e[1]];
  }
  /**
   * @private
   */
  _movePoint(e, t) {
    return [e[0] + t[0], e[1] + t[1]];
  }
};
vN.prototype.Cursors = {
  default: "auto",
  select: "pointer",
  translate: "move",
  rotate: "move",
  rotate0: "move",
  scale: "nesw-resize",
  scale1: "nwse-resize",
  scale2: "nesw-resize",
  scale3: "nwse-resize",
  scalev: "ew-resize",
  scaleh1: "ns-resize",
  scalev2: "ew-resize",
  scaleh3: "ns-resize"
};
const BY = {
  name: "ol-interaction-transform",
  setup(i) {
    const e = _t("map"), { properties: t } = sr(i), r = cr(() => new vN({
      ...t
    }));
    at(r, (n, s) => {
      e.removeInteraction(s), e.addInteraction(n), e.changed();
    }), tr(() => {
      e.addInteraction(r.value);
    }), nr(() => {
      e.removeInteraction(r.value);
    }), Ur("stylable", r);
  },
  props: {
    enableRotatedTransform: {
      type: Boolean,
      default: !1
    },
    condition: {
      type: Function
    },
    addCondition: {
      type: Function
    },
    filter: {
      type: Function
    },
    layers: {
      type: Array
    },
    hitTolerance: {
      type: Number,
      default: 2
    },
    translateFeature: {
      type: Boolean,
      default: !0
    },
    scale: {
      type: Boolean,
      default: !0
    },
    rotate: {
      type: Boolean,
      default: !0
    },
    keepAspectRatio: {
      type: Boolean,
      default: !1
    },
    translate: {
      type: Boolean,
      default: !0
    },
    stretch: {
      type: Boolean,
      default: !0
    }
  }
};
function bY(i, e, t, r, n, s) {
  return mr(i.$slots, "default");
}
const Fx = /* @__PURE__ */ qe(BY, [["render", bY]]);
class SY extends eo {
  /**
   * @param {Options} [options] Options.
   */
  constructor(e) {
    e = e || {}, super(
      /** @type {import("./Pointer.js").Options} */
      e
    ), this.condition_ = e.condition ? e.condition : mg, this.lastAngle_ = void 0, this.lastMagnitude_ = void 0, this.lastScaleDelta_ = 0, this.duration_ = e.duration !== void 0 ? e.duration : 400;
  }
  /**
   * Handle pointer drag events.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
   */
  handleDragEvent(e) {
    if (!rh(e))
      return;
    const t = e.map, r = t.getSize(), n = e.pixel, s = n[0] - r[0] / 2, a = r[1] / 2 - n[1], o = Math.atan2(a, s), A = Math.sqrt(s * s + a * a), l = t.getView();
    if (this.lastAngle_ !== void 0) {
      const h = this.lastAngle_ - o;
      l.adjustRotationInternal(h);
    }
    this.lastAngle_ = o, this.lastMagnitude_ !== void 0 && l.adjustResolutionInternal(this.lastMagnitude_ / A), this.lastMagnitude_ !== void 0 && (this.lastScaleDelta_ = this.lastMagnitude_ / A), this.lastMagnitude_ = A;
  }
  /**
   * Handle pointer up events.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
   * @return {boolean} If the event was consumed.
   */
  handleUpEvent(e) {
    if (!rh(e))
      return !0;
    const r = e.map.getView(), n = this.lastScaleDelta_ > 1 ? 1 : -1;
    return r.endInteraction(this.duration_, n), this.lastScaleDelta_ = 0, !1;
  }
  /**
   * Handle pointer down events.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
   * @return {boolean} If the event was consumed.
   */
  handleDownEvent(e) {
    return rh(e) && this.condition_(e) ? (e.map.getView().beginInteraction(), this.lastAngle_ = void 0, this.lastMagnitude_ = void 0, !0) : !1;
  }
}
const TY = SY, FY = {
  name: "ol-interaction-dragrotatezoom",
  setup(i) {
    const e = _t("map"), { properties: t } = sr(i), r = cr(() => new TY({
      ...t
    }));
    at(r, (n, s) => {
      e.removeInteraction(s), e.addInteraction(n), e.changed();
    }), tr(() => {
      e.addInteraction(r.value);
    }), nr(() => {
      e.removeInteraction(r.value);
    });
  },
  props: {
    condition: {
      type: Function
    },
    duration: {
      type: Number,
      default: 400
    }
  }
};
function LY(i, e, t, r, n, s) {
  return mr(i.$slots, "default");
}
const Lx = /* @__PURE__ */ qe(FY, [["render", LY]]);
function rv(i) {
  rv.installed || (rv.installed = !0, i.component(Ex.name, Ex), i.component(Bx.name, Bx), i.component(bx.name, bx), i.component(Sx.name, Sx), i.component(Tx.name, Tx), i.component(Fx.name, Fx), i.component(
    Lx.name,
    Lx
  ));
}
const IY = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  ClusterSelectInteraction: Bx,
  DragRotateAndZoomInteraction: Lx,
  DrawInteraction: bx,
  ModifyInteraction: Tx,
  SelectInteraction: Ex,
  SnapInteraction: Sx,
  TransformInteraction: Fx,
  default: rv,
  install: rv
}, Symbol.toStringTag, { value: "Module" })), RY = {
  setup() {
    const i = _t("map"), e = _t("vectorLayer");
    return {
      map: i,
      vectorLayer: e
    };
  },
  props: {
    duration: {
      type: Number,
      default: 1e3
    },
    revers: {
      type: Boolean,
      default: !1
    },
    repeat: {
      type: Number,
      default: 0
    },
    fade: {
      type: Function
    },
    easing: {
      type: Function,
      default: ea
    }
  }
};
function MY(i, e, t, r, n, s) {
  return mr(i.$slots, "default");
}
const Ba = /* @__PURE__ */ qe(RY, [["render", MY]]);
var aA = class extends ws {
  constructor(e) {
    e = e || {}, super(), this.duration_ = typeof e.duration == "number" ? e.duration >= 0 ? e.duration : 0 : 1e3, this.fade_ = typeof e.fade == "function" ? e.fade : null, this.repeat_ = Number(e.repeat);
    var t = typeof e.easing == "function" ? e.easing : _E;
    e.revers ? this.easing_ = function(r) {
      return 1 - t(r);
    } : this.easing_ = t, this.hiddenStyle = e.hiddenStyle;
  }
  /** Draw a geometry
  * @param {olx.animateFeatureEvent} e
  * @param {ol.geom} geom geometry for shadow
  * @param {ol.geom} shadow geometry for shadow (ie. style with zIndex = -1)
  * @private
  */
  drawGeom_(e, t, r) {
    this.fade_ && (e.context.globalAlpha = this.fade_(1 - e.elapsed));
    for (var n = e.style, s = 0; s < n.length; s++)
      try {
        var a = e.vectorContext || Zv(e), o = l2(e, n[s]);
        a.setStyle(o), o.getZIndex() < 0 ? a.drawGeometry(r || t) : a.drawGeometry(t);
      } catch {
      }
  }
  /** Function to perform manipulations onpostcompose.
   * This function is called with an ol_featureAnimationEvent argument.
   * The function will be overridden by the child implementation.
   * Return true to keep this function for the next frame, false to remove it.
   * @param {ol_featureAnimationEvent} e
   * @return {bool} true to continue animation.
   * @api
   */
  animate() {
    return !1;
  }
};
aA.hiddenStyle = new ln({
  image: new Ru({}),
  stroke: new Zi({
    color: "transparent"
  })
});
vg.prototype.animateFeature = function(i, e) {
  var t = this._featureAnimationLayer;
  t || (t = this._featureAnimationLayer = new nA({ source: new sA() }), t.setMap(this)), t.getSource().addFeature(i);
  var r = e.on("animationend", function(n) {
    n.feature === i && (t.getSource().removeFeature(i), Js(r));
  });
  t.animateFeature(i, e);
};
hE.prototype.animateFeature = function(i, e, t) {
  var r = this, n, s = i.getStyle(), a = s || (this.getStyleFunction ? this.getStyleFunction()(i) : null);
  a || (a = []), a instanceof Array || (a = [a]);
  var o = {
    // Frame context
    vectorContext: null,
    frameState: null,
    start: 0,
    time: 0,
    elapsed: 0,
    extent: !1,
    // Feature information
    feature: i,
    geom: i.getGeometry(),
    typeGeom: i.getGeometry().getType(),
    bbox: i.getGeometry().getExtent(),
    coord: Xn(i.getGeometry().getExtent()),
    style: a
  };
  e instanceof Array || (e = [e]);
  for (var A = e.length - 1; A >= 0; A--)
    e[A].duration_ === 0 && e.splice(A, 1);
  var l = 0, h = 0, c = t && this.getFilters ? this.getFilters() : [];
  function u(p) {
    o.type = p.type;
    try {
      o.vectorContext = p.vectorContext || Zv(p);
    } catch {
    }
    if (o.frameState = p.frameState, o.inversePixelTransform = p.inversePixelTransform, o.extent || (o.extent = p.frameState.extent, o.start = p.frameState.time, o.context = p.context), o.time = p.frameState.time - o.start, o.elapsed = o.time / e[h].duration_, o.elapsed > 1 && (o.elapsed = 1), p.context.save(), c.forEach(function(v) {
      v.get("active") && v.precompose(p);
    }), this.getOpacity && (p.context.globalAlpha = this.getOpacity()), !e[h].animate(o))
      l++, l < e[h].repeat_ ? o.extent = !1 : h < e.length - 1 ? (e[h].dispatchEvent({ type: "animationend", feature: i }), h++, l = 0, o.extent = !1) : f();
    else {
      var y = {
        type: "animating",
        step: h,
        start: o.start,
        time: o.time,
        elapsed: o.elapsed,
        rotation: o.rotation || 0,
        geom: o.geom,
        coordinate: o.coord,
        feature: i,
        extra: o.extra || {}
      };
      e[h].dispatchEvent(y), r.dispatchEvent(y);
    }
    c.forEach(function(v) {
      v.get("active") && v.postcompose(p);
    }), p.context.restore(), p.frameState.animate = !0;
  }
  function f(p) {
    Js(n), n = null, i.setStyle(s), o.stop = (/* @__PURE__ */ new Date()).getTime();
    var y = { type: "animationend", feature: i };
    if (p)
      for (var v in p)
        p.hasOwnProperty(v) && (y[v] = p[v]);
    e[h].dispatchEvent(y), r.dispatchEvent(y);
  }
  function g(p) {
    if (e.length && !n) {
      if (o.stop && (o.start = (/* @__PURE__ */ new Date()).getTime() - o.stop + o.start, o.stop = 0), n = r.on(["postcompose", "postrender"], u.bind(r)), r.renderSync)
        try {
          r.renderSync();
        } catch {
        }
      else
        r.changed();
      i.setStyle(e[h].hiddenStyle || aA.hiddenStyle);
      var y = { type: "animationstart", feature: i };
      if (p)
        for (var v in p)
          p.hasOwnProperty(v) && (y[v] = p[v]);
      e[h].dispatchEvent(y), r.dispatchEvent(y);
    }
  }
  return g(), {
    start: g,
    stop: f,
    isPlaying: function() {
      return !!n;
    }
  };
};
var NY = class extends aA {
  constructor(e) {
    e = e || {}, super(e), this.speed_ = e.speed || 0, this.side_ = e.side || "top";
  }
  /** Animate
  * @param {ol_featureAnimationEvent} e
  */
  animate(e) {
    if (!e.time) {
      var t = e.frameState.viewState.rotation, r = e.frameState.size[1] * e.frameState.viewState.resolution;
      this.side_ != "top" && (r *= -1), this.dx = -Math.sin(t) * r, this.dy = Math.cos(t) * r, this.speed_ && (this.duration_ = r / this.speed_ / e.frameState.viewState.resolution);
    }
    var n = e.geom.clone();
    return n.translate(
      this.dx * (1 - this.easing_(e.elapsed)),
      this.dy * (1 - this.easing_(e.elapsed))
    ), this.drawGeom_(e, n, e.geom), e.time <= this.duration_;
  }
};
function Ih(i, e) {
  const { map: t, vectorLayer: r } = Ba.setup(), { properties: n } = sr(e), s = cr(() => new i({
    ...n
  }));
  return Ur("animation", s), {
    map: t,
    vectorLayer: r,
    animation: s,
    properties: n
  };
}
const PY = {
  name: "ol-animation-drop",
  extends: Ba,
  setup(i) {
    const { map: e, vectorLayer: t, properties: r } = Ih(NY, i);
    return {
      map: e,
      vectorLayer: t,
      properties: r
    };
  },
  props: {
    side: {
      type: Number,
      default: 0
    },
    speed: {
      type: Number,
      default: 0
    }
  }
};
function OY(i, e, t, r, n, s) {
  return mr(i.$slots, "default");
}
const Ix = /* @__PURE__ */ qe(PY, [["render", OY]]);
var UY = class extends aA {
  constructor(e) {
    e = e || {}, super(e), this.amplitude_ = e.amplitude || 40, this.bounce_ = -Math.PI * (e.bounce || 6), this.horizontal_ = e.horizontal;
  }
  /** Animate
  * @param {ol_featureAnimationEvent} e
  */
  animate(e) {
    var t = e.geom.clone(), r = e.geom.clone(), n = this.easing_(e.elapsed);
    return n = Math.sin(this.bounce_ * n) * this.amplitude_ * (1 - n) * e.frameState.viewState.resolution, this.horizontal_ ? (t.translate(n, 0), r.translate(n, 0)) : t.translate(0, n), this.drawGeom_(e, t, r), e.time <= this.duration_;
  }
};
const QY = {
  name: "ol-animation-shake",
  extends: Ba,
  setup(i) {
    const { map: e, vectorLayer: t, properties: r, animation: n } = Ih(
      UY,
      i
    );
    return {
      map: e,
      vectorLayer: t,
      properties: r,
      animation: n
    };
  },
  props: {
    bounce: {
      type: Number,
      default: 6
    },
    amplitude: {
      type: Number,
      default: 40
    },
    horizontal: {
      type: Boolean,
      default: !1
    }
  }
};
function DY(i, e, t, r, n, s) {
  return mr(i.$slots, "default");
}
const Rx = /* @__PURE__ */ qe(QY, [["render", DY]]);
var kY = class extends aA {
  constructor(e) {
    e = e || {}, super(e), this.set("zoomout", e.zoomOut);
  }
  /** Animate
  * @param {ol_featureAnimationEvent} e
  */
  animate(e) {
    var t = this.easing_(e.elapsed);
    if (t) {
      this.get("zoomout") && (t = 1 / t);
      var r = e.style, n, s, a = [];
      for (n = 0; n < r.length; n++)
        s = r[n].getImage(), s && (a[n] = s.getScale(), e.type === "postrender" ? s.setScale(a[n] * t / e.frameState.pixelRatio) : s.setScale(a[n] * t));
      for (this.drawGeom_(e, e.geom), n = 0; n < r.length; n++)
        s = r[n].getImage(), s && s.setScale(a[n]);
    }
    return e.time <= this.duration_;
  }
};
const HY = {
  name: "ol-animation-zoom",
  extends: Ba,
  setup(i) {
    const { map: e, vectorLayer: t, properties: r } = Ih(kY, i);
    return {
      map: e,
      vectorLayer: t,
      properties: r
    };
  },
  props: {
    zoomOut: {
      type: Boolean,
      default: !1
    }
  }
};
function GY(i, e, t, r, n, s) {
  return mr(i.$slots, "default");
}
const Mx = /* @__PURE__ */ qe(HY, [["render", GY]]);
var $Y = class extends aA {
  constructor(e) {
    super(e);
  }
  /** Animate
  * @param {ol_featureAnimationEvent} e
  */
  animate(e) {
    var t = this.easing_(e.elapsed);
    if (t) {
      e.context.save();
      var r = e.frameState.pixelRatio;
      e.context.globalAlpha = t, e.context.scale(t, 1 / t);
      var n = e.frameState.coordinateToPixelTransform, s = (1 / t - 1) * r * (n[0] * e.coord[0] + n[1] * e.coord[1] + n[4]), a = (t - 1) * r * (n[2] * e.coord[0] + n[3] * e.coord[1] + n[5]);
      e.context.translate(s, a), this.drawGeom_(e, e.geom), e.context.restore();
    }
    return e.time <= this.duration_;
  }
};
const VY = {
  name: "ol-animation-teleport",
  extends: Ba,
  setup(i) {
    const { map: e, vectorLayer: t, properties: r } = Ih($Y, i);
    return {
      map: e,
      vectorLayer: t,
      properties: r
    };
  },
  props: {}
};
function KY(i, e, t, r, n, s) {
  return mr(i.$slots, "default");
}
const Nx = /* @__PURE__ */ qe(VY, [["render", KY]]);
var jY = class extends aA {
  constructor(e) {
    e = e || {}, super(e), this.speed_ = e.speed || 0;
  }
  /** Animate
  * @param {ol_featureAnimationEvent} e
  */
  animate(e) {
    return e.context.globalAlpha = this.easing_(e.elapsed), this.drawGeom_(e, e.geom), e.time <= this.duration_;
  }
};
const zY = {
  name: "ol-animation-fade",
  extends: Ba,
  setup(i) {
    const { map: e, vectorLayer: t, properties: r } = Ih(jY, i);
    return {
      map: e,
      vectorLayer: t,
      properties: r
    };
  }
};
function XY(i, e, t, r, n, s) {
  return mr(i.$slots, "default");
}
const Px = /* @__PURE__ */ qe(zY, [["render", XY]]);
var WY = class extends aA {
  constructor(e) {
    e = e || {}, super(e), this.speed_ = e.speed || 0, this.side_ = e.side || "left";
  }
  /** Animate
  * @param {ol_featureAnimationEvent} e
  */
  animate(e) {
    e.time || (this.side_ == "left" ? this.dx = e.extent[0] - e.bbox[2] : this.dx = e.extent[2] - e.bbox[0], this.speed_ && (this.duration_ = Math.abs(this.dx) / this.speed_ / e.frameState.viewState.resolution));
    var t = e.geom.clone();
    return t.translate(this.dx * (1 - this.easing_(e.elapsed)), 0), this.drawGeom_(e, t), e.time <= this.duration_;
  }
};
const YY = {
  name: "ol-animation-slide",
  extends: Ba,
  setup(i) {
    const { map: e, vectorLayer: t, properties: r } = Ih(WY, i);
    return {
      map: e,
      vectorLayer: t,
      properties: r
    };
  },
  props: {
    speed: {
      type: Number,
      default: 0
    }
  }
};
function qY(i, e, t, r, n, s) {
  return mr(i.$slots, "default");
}
const Ox = /* @__PURE__ */ qe(YY, [["render", qY]]);
var ZY = class extends aA {
  constructor(e) {
    switch (e = e || {}, super(e), this.speed_ = e.speed || 0, this.path_ = e.path, e.rotate) {
      case !0:
      case 0:
        this.rotate_ = 0;
        break;
      default:
        this.rotate_ = e.rotate || !1;
        break;
    }
    this.path_ && this.path_.getGeometry && (this.path_ = this.path_.getGeometry()), this.path_ && this.path_.getLineString && (this.path_ = this.path_.getLineString()), this.path_.getLength ? (this.dist_ = this.path_.getLength(), this.path_ && this.path_.getCoordinates && (this.path_ = this.path_.getCoordinates())) : this.dist_ = 0, this.speed_ > 0 && (this.duration_ = this.dist_ / this.speed_);
  }
  /** Animate
  * @param {ol_featureAnimationEvent} e
  */
  animate(e) {
    if (!e.time && !this.dist_)
      return !1;
    var t = this.dist_ * this.easing_(e.elapsed), r, n, s, a, o, A, l = 0;
    n = this.path_[0];
    for (var h = 1; h < this.path_.length; h++) {
      if (r = n, n = this.path_[h], a = n[0] - r[0], o = n[1] - r[1], A = Math.sqrt(a * a + o * o), A && l + A >= t) {
        e.extra = { index: h, coordinates: n }, s = (t - l) / A, n = [r[0] + (n[0] - r[0]) * s, r[1] + (n[1] - r[1]) * s];
        break;
      }
      l += A;
    }
    var c = e.style;
    if (e.rotation = Math.PI / 2 + Math.atan2(r[1] - n[1], r[0] - n[0]), this.rotate_ !== !1) {
      var u = [], f = this.rotate_ - e.rotation + e.frameState.viewState.rotation;
      e.rotation = Math.PI / 2 + Math.atan2(r[1] - n[1], r[0] - n[0]);
      for (var g = 0; s = e.style[g]; g++)
        s.getImage() && s.getImage().setRotation(f), u.push(s);
      e.style = u;
    }
    return e.geom.setCoordinates(n), this.drawGeom_(e, e.geom), e.style = c, e.time <= this.duration_;
  }
};
const JY = {
  name: "ol-animation-path",
  extends: Ba,
  setup(i) {
    const { map: e, vectorLayer: t, properties: r } = Ih(ZY, i);
    return {
      map: e,
      vectorLayer: t,
      properties: r
    };
  },
  props: {
    rotate: {
      type: Boolean,
      default: !1
    },
    speed: {
      type: Number,
      default: 0
    },
    path: {
      type: Object
    }
  }
};
function eq(i, e, t, r, n, s) {
  return mr(i.$slots, "default");
}
const Ux = /* @__PURE__ */ qe(JY, [["render", eq]]);
function iv(i) {
  iv.installed || (iv.installed = !0, i.component(Ba.name, Ba), i.component(Ix.name, Ix), i.component(Rx.name, Rx), i.component(Mx.name, Mx), i.component(Nx.name, Nx), i.component(Px.name, Px), i.component(Ox.name, Ox), i.component(Ux.name, Ux));
}
const tq = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  DropAnimation: Ix,
  FadeAnimation: Px,
  FeatureAnimation: Ba,
  PathAnimation: Ux,
  ShakeAnimation: Rx,
  SlideAnimation: Ox,
  TeleportAnimation: Nx,
  ZoomAnimation: Mx,
  default: iv,
  install: iv
}, Symbol.toStringTag, { value: "Module" }));
const rq = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  Circle: gB,
  Geometry: dg,
  GeometryCollection: _n,
  LineString: Gr,
  LinearRing: du,
  MultiLineString: In,
  MultiPoint: ta,
  MultiPolygon: Rn,
  Point: gr,
  Polygon: Li,
  SimpleGeometry: Ea
}, Symbol.toStringTag, { value: "Module" }));
class iq {
  constructor() {
    this.dataProjection = void 0, this.defaultFeatureProjection = void 0, this.supportedMediaTypes = null;
  }
  /**
   * Adds the data projection to the read options.
   * @param {Document|Element|Object|string} source Source.
   * @param {ReadOptions} [options] Options.
   * @return {ReadOptions|undefined} Options.
   * @protected
   */
  getReadOptions(e, t) {
    if (t) {
      let r = t.dataProjection ? Ct(t.dataProjection) : this.readProjection(e);
      t.extent && r && r.getUnits() === "tile-pixels" && (r = Ct(r), r.setWorldExtent(t.extent)), t = {
        dataProjection: r,
        featureProjection: t.featureProjection
      };
    }
    return this.adaptOptions(t);
  }
  /**
   * Sets the `dataProjection` on the options, if no `dataProjection`
   * is set.
   * @param {WriteOptions|ReadOptions|undefined} options
   *     Options.
   * @protected
   * @return {WriteOptions|ReadOptions|undefined}
   *     Updated options.
   */
  adaptOptions(e) {
    return Object.assign(
      {
        dataProjection: this.dataProjection,
        featureProjection: this.defaultFeatureProjection
      },
      e
    );
  }
  /**
   * @abstract
   * @return {Type} The format type.
   */
  getType() {
    return pt();
  }
  /**
   * Read a single feature from a source.
   *
   * @abstract
   * @param {Document|Element|Object|string} source Source.
   * @param {ReadOptions} [options] Read options.
   * @return {import("../Feature.js").FeatureLike} Feature.
   */
  readFeature(e, t) {
    return pt();
  }
  /**
   * Read all features from a source.
   *
   * @abstract
   * @param {Document|Element|ArrayBuffer|Object|string} source Source.
   * @param {ReadOptions} [options] Read options.
   * @return {Array<import("../Feature.js").FeatureLike>} Features.
   */
  readFeatures(e, t) {
    return pt();
  }
  /**
   * Read a single geometry from a source.
   *
   * @abstract
   * @param {Document|Element|Object|string} source Source.
   * @param {ReadOptions} [options] Read options.
   * @return {import("../geom/Geometry.js").default} Geometry.
   */
  readGeometry(e, t) {
    return pt();
  }
  /**
   * Read the projection from a source.
   *
   * @abstract
   * @param {Document|Element|Object|string} source Source.
   * @return {import("../proj/Projection.js").default|undefined} Projection.
   */
  readProjection(e) {
    return pt();
  }
  /**
   * Encode a feature in this format.
   *
   * @abstract
   * @param {import("../Feature.js").default} feature Feature.
   * @param {WriteOptions} [options] Write options.
   * @return {string|ArrayBuffer} Result.
   */
  writeFeature(e, t) {
    return pt();
  }
  /**
   * Encode an array of features in this format.
   *
   * @abstract
   * @param {Array<import("../Feature.js").default>} features Features.
   * @param {WriteOptions} [options] Write options.
   * @return {string|ArrayBuffer} Result.
   */
  writeFeatures(e, t) {
    return pt();
  }
  /**
   * Write a single geometry in this format.
   *
   * @abstract
   * @param {import("../geom/Geometry.js").default} geometry Geometry.
   * @param {WriteOptions} [options] Write options.
   * @return {string|ArrayBuffer} Result.
   */
  writeGeometry(e, t) {
    return pt();
  }
}
const bg = iq;
function ui(i, e, t) {
  const r = t ? Ct(t.featureProjection) : null, n = t ? Ct(t.dataProjection) : null;
  let s;
  if (r && n && !Da(r, n) ? s = (e ? i.clone() : i).transform(
    e ? r : n,
    e ? n : r
  ) : s = i, e && t && /** @type {WriteOptions} */
  t.decimals !== void 0) {
    const a = Math.pow(
      10,
      /** @type {WriteOptions} */
      t.decimals
    ), o = function(A) {
      for (let l = 0, h = A.length; l < h; ++l)
        A[l] = Math.round(A[l] * a) / a;
      return A;
    };
    s === i && (s = i.clone()), s.applyTransform(o);
  }
  return s;
}
function yB(i, e) {
  const t = e ? Ct(e.featureProjection) : null, r = e ? Ct(e.dataProjection) : null;
  return t && r && !Da(t, r) ? mm(i, r, t) : i;
}
class nq extends bg {
  constructor() {
    super();
  }
  /**
   * @return {import("./Feature.js").Type} Format.
   */
  getType() {
    return "json";
  }
  /**
   * Read a feature.  Only works for a single feature. Use `readFeatures` to
   * read a feature collection.
   *
   * @param {ArrayBuffer|Document|Element|Object|string} source Source.
   * @param {import("./Feature.js").ReadOptions} [options] Read options.
   * @return {import("../Feature.js").default} Feature.
   * @api
   */
  readFeature(e, t) {
    return this.readFeatureFromObject(
      Wp(e),
      this.getReadOptions(e, t)
    );
  }
  /**
   * Read all features.  Works with both a single feature and a feature
   * collection.
   *
   * @param {ArrayBuffer|Document|Element|Object|string} source Source.
   * @param {import("./Feature.js").ReadOptions} [options] Read options.
   * @return {Array<import("../Feature.js").default>} Features.
   * @api
   */
  readFeatures(e, t) {
    return this.readFeaturesFromObject(
      Wp(e),
      this.getReadOptions(e, t)
    );
  }
  /**
   * @abstract
   * @param {Object} object Object.
   * @param {import("./Feature.js").ReadOptions} [options] Read options.
   * @protected
   * @return {import("../Feature.js").default} Feature.
   */
  readFeatureFromObject(e, t) {
    return pt();
  }
  /**
   * @abstract
   * @param {Object} object Object.
   * @param {import("./Feature.js").ReadOptions} [options] Read options.
   * @protected
   * @return {Array<import("../Feature.js").default>} Features.
   */
  readFeaturesFromObject(e, t) {
    return pt();
  }
  /**
   * Read a geometry.
   *
   * @param {ArrayBuffer|Document|Element|Object|string} source Source.
   * @param {import("./Feature.js").ReadOptions} [options] Read options.
   * @return {import("../geom/Geometry.js").default} Geometry.
   * @api
   */
  readGeometry(e, t) {
    return this.readGeometryFromObject(
      Wp(e),
      this.getReadOptions(e, t)
    );
  }
  /**
   * @abstract
   * @param {Object} object Object.
   * @param {import("./Feature.js").ReadOptions} [options] Read options.
   * @protected
   * @return {import("../geom/Geometry.js").default} Geometry.
   */
  readGeometryFromObject(e, t) {
    return pt();
  }
  /**
   * Read the projection.
   *
   * @param {ArrayBuffer|Document|Element|Object|string} source Source.
   * @return {import("../proj/Projection.js").default} Projection.
   * @api
   */
  readProjection(e) {
    return this.readProjectionFromObject(Wp(e));
  }
  /**
   * @abstract
   * @param {Object} object Object.
   * @protected
   * @return {import("../proj/Projection.js").default} Projection.
   */
  readProjectionFromObject(e) {
    return pt();
  }
  /**
   * Encode a feature as string.
   *
   * @param {import("../Feature.js").default} feature Feature.
   * @param {import("./Feature.js").WriteOptions} [options] Write options.
   * @return {string} Encoded feature.
   * @api
   */
  writeFeature(e, t) {
    return JSON.stringify(this.writeFeatureObject(e, t));
  }
  /**
   * @abstract
   * @param {import("../Feature.js").default} feature Feature.
   * @param {import("./Feature.js").WriteOptions} [options] Write options.
   * @return {Object} Object.
   */
  writeFeatureObject(e, t) {
    return pt();
  }
  /**
   * Encode an array of features as string.
   *
   * @param {Array<import("../Feature.js").default>} features Features.
   * @param {import("./Feature.js").WriteOptions} [options] Write options.
   * @return {string} Encoded features.
   * @api
   */
  writeFeatures(e, t) {
    return JSON.stringify(this.writeFeaturesObject(e, t));
  }
  /**
   * @abstract
   * @param {Array<import("../Feature.js").default>} features Features.
   * @param {import("./Feature.js").WriteOptions} [options] Write options.
   * @return {Object} Object.
   */
  writeFeaturesObject(e, t) {
    return pt();
  }
  /**
   * Encode a geometry as string.
   *
   * @param {import("../geom/Geometry.js").default} geometry Geometry.
   * @param {import("./Feature.js").WriteOptions} [options] Write options.
   * @return {string} Encoded geometry.
   * @api
   */
  writeGeometry(e, t) {
    return JSON.stringify(this.writeGeometryObject(e, t));
  }
  /**
   * @abstract
   * @param {import("../geom/Geometry.js").default} geometry Geometry.
   * @param {import("./Feature.js").WriteOptions} [options] Write options.
   * @return {Object} Object.
   */
  writeGeometryObject(e, t) {
    return pt();
  }
}
function Wp(i) {
  if (typeof i == "string") {
    const e = JSON.parse(i);
    return e || null;
  } else if (i !== null)
    return i;
  return null;
}
const _B = nq, sq = {
  Point: lq,
  LineString: hq,
  Polygon: dq,
  MultiPoint: uq,
  MultiLineString: cq,
  MultiPolygon: fq
}, aq = {
  Point: gq,
  LineString: pq,
  Polygon: mq,
  MultiPoint: yq,
  MultiLineString: vq,
  MultiPolygon: _q
};
class oq extends _B {
  /**
   * @param {Options} [options] Options.
   */
  constructor(e) {
    e = e || {}, super(), this.geometryName_ = e.geometryName;
  }
  /**
   * @param {Object} object Object.
   * @param {import("./Feature.js").ReadOptions} [options] Read options.
   * @param {string} [idField] Name of the field where to get the id from.
   * @protected
   * @return {import("../Feature.js").default} Feature.
   */
  readFeatureFromObject(e, t, r) {
    const n = (
      /** @type {EsriJSONFeature} */
      e
    ), s = gT(n.geometry, t), a = new qt();
    if (this.geometryName_ && a.setGeometryName(this.geometryName_), a.setGeometry(s), n.attributes) {
      a.setProperties(n.attributes, !0);
      const o = n.attributes[r];
      o !== void 0 && a.setId(
        /** @type {number} */
        o
      );
    }
    return a;
  }
  /**
   * @param {Object} object Object.
   * @param {import("./Feature.js").ReadOptions} [options] Read options.
   * @protected
   * @return {Array<Feature>} Features.
   */
  readFeaturesFromObject(e, t) {
    if (t = t || {}, e.features) {
      const r = (
        /** @type {EsriJSONFeatureSet} */
        e
      ), n = [], s = r.features;
      for (let a = 0, o = s.length; a < o; ++a)
        n.push(
          this.readFeatureFromObject(
            s[a],
            t,
            e.objectIdFieldName
          )
        );
      return n;
    }
    return [this.readFeatureFromObject(e, t)];
  }
  /**
   * @param {EsriJSONGeometry} object Object.
   * @param {import("./Feature.js").ReadOptions} [options] Read options.
   * @protected
   * @return {import("../geom/Geometry.js").default} Geometry.
   */
  readGeometryFromObject(e, t) {
    return gT(e, t);
  }
  /**
   * @param {Object} object Object.
   * @protected
   * @return {import("../proj/Projection.js").default} Projection.
   */
  readProjectionFromObject(e) {
    if (e.spatialReference && e.spatialReference.wkid !== void 0) {
      const r = /** @type {EsriJSONSpatialReferenceWkid} */ e.spatialReference.wkid;
      return Ct("EPSG:" + r);
    }
    return null;
  }
  /**
   * Encode a geometry as a EsriJSON object.
   *
   * @param {import("../geom/Geometry.js").default} geometry Geometry.
   * @param {import("./Feature.js").WriteOptions} [options] Write options.
   * @return {EsriJSONGeometry} Object.
   * @api
   */
  writeGeometryObject(e, t) {
    return pT(e, this.adaptOptions(t));
  }
  /**
   * Encode a feature as a esriJSON Feature object.
   *
   * @param {import("../Feature.js").default} feature Feature.
   * @param {import("./Feature.js").WriteOptions} [options] Write options.
   * @return {Object} Object.
   * @api
   */
  writeFeatureObject(e, t) {
    t = this.adaptOptions(t);
    const r = {};
    if (!e.hasProperties())
      return r.attributes = {}, r;
    const n = e.getProperties(), s = e.getGeometry();
    if (s) {
      r.geometry = pT(s, t);
      const a = t && (t.dataProjection || t.featureProjection);
      a && (r.geometry.spatialReference = /** @type {EsriJSONSpatialReferenceWkid} */
      {
        wkid: Number(Ct(a).getCode().split(":").pop())
      }), delete n[e.getGeometryName()];
    }
    return dh(n) ? r.attributes = {} : r.attributes = n, r;
  }
  /**
   * Encode an array of features as a EsriJSON object.
   *
   * @param {Array<import("../Feature.js").default>} features Features.
   * @param {import("./Feature.js").WriteOptions} [options] Write options.
   * @return {EsriJSONFeatureSet} EsriJSON Object.
   * @api
   */
  writeFeaturesObject(e, t) {
    t = this.adaptOptions(t);
    const r = [];
    for (let n = 0, s = e.length; n < s; ++n)
      r.push(this.writeFeatureObject(e[n], t));
    return {
      features: r
    };
  }
}
function gT(i, e) {
  if (!i)
    return null;
  let t;
  if (typeof i.x == "number" && typeof i.y == "number")
    t = "Point";
  else if (i.points)
    t = "MultiPoint";
  else if (i.paths)
    /** @type {EsriJSONPolyline} */
    i.paths.length === 1 ? t = "LineString" : t = "MultiLineString";
  else if (i.rings) {
    const n = (
      /** @type {EsriJSONPolygon} */
      i
    ), s = Pu(n), a = Aq(n.rings, s);
    a.length === 1 ? (t = "Polygon", i = Object.assign({}, i, { rings: a[0] })) : (t = "MultiPolygon", i = Object.assign({}, i, { rings: a }));
  }
  const r = sq[t];
  return ui(r(i), !1, e);
}
function Aq(i, e) {
  const t = [], r = [], n = [];
  let s, a;
  for (s = 0, a = i.length; s < a; ++s)
    t.length = 0, gg(t, 0, i[s], e.length), Uv(
      t,
      0,
      t.length,
      e.length
    ) ? r.push([i[s]]) : n.push(i[s]);
  for (; n.length; ) {
    const o = n.shift();
    let A = !1;
    for (s = r.length - 1; s >= 0; s--) {
      const l = r[s][0];
      if (Ps(
        new du(l).getExtent(),
        new du(o).getExtent()
      )) {
        r[s].push(o), A = !0;
        break;
      }
    }
    A || r.push([o.reverse()]);
  }
  return r;
}
function lq(i) {
  let e;
  return i.m !== void 0 && i.z !== void 0 ? e = new gr([i.x, i.y, i.z, i.m], "XYZM") : i.z !== void 0 ? e = new gr([i.x, i.y, i.z], "XYZ") : i.m !== void 0 ? e = new gr([i.x, i.y, i.m], "XYM") : e = new gr([i.x, i.y]), e;
}
function hq(i) {
  const e = Pu(i);
  return new Gr(i.paths[0], e);
}
function cq(i) {
  const e = Pu(i);
  return new In(i.paths, e);
}
function Pu(i) {
  let e = "XY";
  return i.hasZ === !0 && i.hasM === !0 ? e = "XYZM" : i.hasZ === !0 ? e = "XYZ" : i.hasM === !0 && (e = "XYM"), e;
}
function uq(i) {
  const e = Pu(i);
  return new ta(i.points, e);
}
function fq(i) {
  const e = Pu(i);
  return new Rn(i.rings, e);
}
function dq(i) {
  const e = Pu(i);
  return new Li(i.rings, e);
}
function gq(i, e) {
  const t = i.getCoordinates();
  let r;
  const n = i.getLayout();
  return n === "XYZ" ? r = {
    x: t[0],
    y: t[1],
    z: t[2]
  } : n === "XYM" ? r = {
    x: t[0],
    y: t[1],
    m: t[2]
  } : n === "XYZM" ? r = {
    x: t[0],
    y: t[1],
    z: t[2],
    m: t[3]
  } : n === "XY" ? r = {
    x: t[0],
    y: t[1]
  } : lt(!1, 34), r;
}
function Sg(i) {
  const e = i.getLayout();
  return {
    hasZ: e === "XYZ" || e === "XYZM",
    hasM: e === "XYM" || e === "XYZM"
  };
}
function pq(i, e) {
  const t = Sg(i);
  return {
    hasZ: t.hasZ,
    hasM: t.hasM,
    paths: [
      /** @type {Array<EsriJSONPosition>} */
      i.getCoordinates()
    ]
  };
}
function mq(i, e) {
  const t = Sg(i);
  return {
    hasZ: t.hasZ,
    hasM: t.hasM,
    rings: (
      /** @type {Array<Array<EsriJSONPosition>>} */
      i.getCoordinates(!1)
    )
  };
}
function vq(i, e) {
  const t = Sg(i);
  return {
    hasZ: t.hasZ,
    hasM: t.hasM,
    paths: (
      /** @type {Array<Array<EsriJSONPosition>>} */
      i.getCoordinates()
    )
  };
}
function yq(i, e) {
  const t = Sg(i);
  return {
    hasZ: t.hasZ,
    hasM: t.hasM,
    points: (
      /** @type {Array<EsriJSONPosition>} */
      i.getCoordinates()
    )
  };
}
function _q(i, e) {
  const t = Sg(i), r = i.getCoordinates(!1), n = [];
  for (let s = 0; s < r.length; s++)
    for (let a = r[s].length - 1; a >= 0; a--)
      n.push(r[s][a]);
  return {
    hasZ: t.hasZ,
    hasM: t.hasM,
    rings: (
      /** @type {Array<Array<EsriJSONPosition>>} */
      n
    )
  };
}
function pT(i, e) {
  const t = aq[i.getType()];
  return t(
    ui(i, !0, e),
    e
  );
}
const wq = oq;
class xq extends _B {
  /**
   * @param {Options} [options] Options.
   */
  constructor(e) {
    e = e || {}, super(), this.dataProjection = Ct(
      e.dataProjection ? e.dataProjection : "EPSG:4326"
    ), e.featureProjection && (this.defaultFeatureProjection = Ct(e.featureProjection)), this.geometryName_ = e.geometryName, this.extractGeometryName_ = e.extractGeometryName, this.supportedMediaTypes = [
      "application/geo+json",
      "application/vnd.geo+json"
    ];
  }
  /**
   * @param {Object} object Object.
   * @param {import("./Feature.js").ReadOptions} [options] Read options.
   * @protected
   * @return {import("../Feature.js").default} Feature.
   */
  readFeatureFromObject(e, t) {
    let r = null;
    e.type === "Feature" ? r = /** @type {GeoJSONFeature} */
    e : r = {
      type: "Feature",
      geometry: (
        /** @type {GeoJSONGeometry} */
        e
      ),
      properties: null
    };
    const n = Qx(r.geometry, t), s = new qt();
    return this.geometryName_ ? s.setGeometryName(this.geometryName_) : this.extractGeometryName_ && "geometry_name" in r !== void 0 && s.setGeometryName(r.geometry_name), s.setGeometry(n), "id" in r && s.setId(r.id), r.properties && s.setProperties(r.properties, !0), s;
  }
  /**
   * @param {Object} object Object.
   * @param {import("./Feature.js").ReadOptions} [options] Read options.
   * @protected
   * @return {Array<Feature>} Features.
   */
  readFeaturesFromObject(e, t) {
    const r = (
      /** @type {GeoJSONObject} */
      e
    );
    let n = null;
    if (r.type === "FeatureCollection") {
      const s = (
        /** @type {GeoJSONFeatureCollection} */
        e
      );
      n = [];
      const a = s.features;
      for (let o = 0, A = a.length; o < A; ++o)
        n.push(this.readFeatureFromObject(a[o], t));
    } else
      n = [this.readFeatureFromObject(e, t)];
    return n;
  }
  /**
   * @param {GeoJSONGeometry} object Object.
   * @param {import("./Feature.js").ReadOptions} [options] Read options.
   * @protected
   * @return {import("../geom/Geometry.js").default} Geometry.
   */
  readGeometryFromObject(e, t) {
    return Qx(e, t);
  }
  /**
   * @param {Object} object Object.
   * @protected
   * @return {import("../proj/Projection.js").default} Projection.
   */
  readProjectionFromObject(e) {
    const t = e.crs;
    let r;
    return t ? t.type == "name" ? r = Ct(t.properties.name) : t.type === "EPSG" ? r = Ct("EPSG:" + t.properties.code) : lt(!1, 36) : r = this.dataProjection, /** @type {import("../proj/Projection.js").default} */
    r;
  }
  /**
   * Encode a feature as a GeoJSON Feature object.
   *
   * @param {import("../Feature.js").default} feature Feature.
   * @param {import("./Feature.js").WriteOptions} [options] Write options.
   * @return {GeoJSONFeature} Object.
   * @api
   */
  writeFeatureObject(e, t) {
    t = this.adaptOptions(t);
    const r = {
      type: "Feature",
      geometry: null,
      properties: null
    }, n = e.getId();
    if (n !== void 0 && (r.id = n), !e.hasProperties())
      return r;
    const s = e.getProperties(), a = e.getGeometry();
    return a && (r.geometry = Dx(a, t), delete s[e.getGeometryName()]), dh(s) || (r.properties = s), r;
  }
  /**
   * Encode an array of features as a GeoJSON object.
   *
   * @param {Array<import("../Feature.js").default>} features Features.
   * @param {import("./Feature.js").WriteOptions} [options] Write options.
   * @return {GeoJSONFeatureCollection} GeoJSON Object.
   * @api
   */
  writeFeaturesObject(e, t) {
    t = this.adaptOptions(t);
    const r = [];
    for (let n = 0, s = e.length; n < s; ++n)
      r.push(this.writeFeatureObject(e[n], t));
    return {
      type: "FeatureCollection",
      features: r
    };
  }
  /**
   * Encode a geometry as a GeoJSON object.
   *
   * @param {import("../geom/Geometry.js").default} geometry Geometry.
   * @param {import("./Feature.js").WriteOptions} [options] Write options.
   * @return {GeoJSONGeometry|GeoJSONGeometryCollection} Object.
   * @api
   */
  writeGeometryObject(e, t) {
    return Dx(e, this.adaptOptions(t));
  }
}
function Qx(i, e) {
  if (!i)
    return null;
  let t;
  switch (i.type) {
    case "Point": {
      t = Eq(
        /** @type {GeoJSONPoint} */
        i
      );
      break;
    }
    case "LineString": {
      t = Bq(
        /** @type {GeoJSONLineString} */
        i
      );
      break;
    }
    case "Polygon": {
      t = Fq(
        /** @type {GeoJSONPolygon} */
        i
      );
      break;
    }
    case "MultiPoint": {
      t = Sq(
        /** @type {GeoJSONMultiPoint} */
        i
      );
      break;
    }
    case "MultiLineString": {
      t = bq(
        /** @type {GeoJSONMultiLineString} */
        i
      );
      break;
    }
    case "MultiPolygon": {
      t = Tq(
        /** @type {GeoJSONMultiPolygon} */
        i
      );
      break;
    }
    case "GeometryCollection": {
      t = Cq(
        /** @type {GeoJSONGeometryCollection} */
        i
      );
      break;
    }
    default:
      throw new Error("Unsupported GeoJSON type: " + i.type);
  }
  return ui(t, !1, e);
}
function Cq(i, e) {
  const t = i.geometries.map(
    /**
     * @param {GeoJSONGeometry} geometry Geometry.
     * @return {import("../geom/Geometry.js").default} geometry Geometry.
     */
    function(r) {
      return Qx(r, e);
    }
  );
  return new _n(t);
}
function Eq(i) {
  return new gr(i.coordinates);
}
function Bq(i) {
  return new Gr(i.coordinates);
}
function bq(i) {
  return new In(i.coordinates);
}
function Sq(i) {
  return new ta(i.coordinates);
}
function Tq(i) {
  return new Rn(i.coordinates);
}
function Fq(i) {
  return new Li(i.coordinates);
}
function Dx(i, e) {
  i = ui(i, !0, e);
  const t = i.getType();
  let r;
  switch (t) {
    case "Point": {
      r = Pq(
        /** @type {Point} */
        i
      );
      break;
    }
    case "LineString": {
      r = Iq(
        /** @type {LineString} */
        i
      );
      break;
    }
    case "Polygon": {
      r = Oq(
        /** @type {Polygon} */
        i,
        e
      );
      break;
    }
    case "MultiPoint": {
      r = Mq(
        /** @type {MultiPoint} */
        i
      );
      break;
    }
    case "MultiLineString": {
      r = Rq(
        /** @type {MultiLineString} */
        i
      );
      break;
    }
    case "MultiPolygon": {
      r = Nq(
        /** @type {MultiPolygon} */
        i,
        e
      );
      break;
    }
    case "GeometryCollection": {
      r = Lq(
        /** @type {GeometryCollection} */
        i,
        e
      );
      break;
    }
    case "Circle": {
      r = {
        type: "GeometryCollection",
        geometries: []
      };
      break;
    }
    default:
      throw new Error("Unsupported geometry type: " + t);
  }
  return r;
}
function Lq(i, e) {
  return e = Object.assign({}, e), delete e.featureProjection, {
    type: "GeometryCollection",
    geometries: i.getGeometriesArray().map(function(r) {
      return Dx(r, e);
    })
  };
}
function Iq(i, e) {
  return {
    type: "LineString",
    coordinates: i.getCoordinates()
  };
}
function Rq(i, e) {
  return {
    type: "MultiLineString",
    coordinates: i.getCoordinates()
  };
}
function Mq(i, e) {
  return {
    type: "MultiPoint",
    coordinates: i.getCoordinates()
  };
}
function Nq(i, e) {
  let t;
  return e && (t = e.rightHanded), {
    type: "MultiPolygon",
    coordinates: i.getCoordinates(t)
  };
}
function Pq(i, e) {
  return {
    type: "Point",
    coordinates: i.getCoordinates()
  };
}
function Oq(i, e) {
  let t;
  return e && (t = e.rightHanded), {
    type: "Polygon",
    coordinates: i.getCoordinates(t)
  };
}
const Uq = xq, wh = "http://www.w3.org/2001/XMLSchema-instance";
function Nt(i, e) {
  return Ou().createElementNS(i, e);
}
function ns(i, e) {
  return yN(i, e, []).join("");
}
function yN(i, e, t) {
  if (i.nodeType == Node.CDATA_SECTION_NODE || i.nodeType == Node.TEXT_NODE)
    e ? t.push(String(i.nodeValue).replace(/(\r\n|\r|\n)/g, "")) : t.push(i.nodeValue);
  else {
    let r;
    for (r = i.firstChild; r; r = r.nextSibling)
      yN(r, e, t);
  }
  return t;
}
function Va(i) {
  return "documentElement" in i;
}
function Qq(i, e, t) {
  return i.getAttributeNS(e, t) || "";
}
function Ka(i) {
  return new DOMParser().parseFromString(i, "application/xml");
}
function nv(i, e) {
  return (
    /**
     * @param {Node} node Node.
     * @param {Array<*>} objectStack Object stack.
     */
    function(t, r) {
      const n = i.call(
        e !== void 0 ? e : this,
        t,
        r
      );
      if (n !== void 0) {
        const s = (
          /** @type {Array<*>} */
          r[r.length - 1]
        );
        Er(s, n);
      }
    }
  );
}
function ht(i, e) {
  return (
    /**
     * @param {Element} node Node.
     * @param {Array<*>} objectStack Object stack.
     */
    function(t, r) {
      const n = i.call(
        e !== void 0 ? e : this,
        t,
        r
      );
      n !== void 0 && /** @type {Array<*>} */
      r[r.length - 1].push(n);
    }
  );
}
function wt(i, e) {
  return (
    /**
     * @param {Node} node Node.
     * @param {Array<*>} objectStack Object stack.
     */
    function(t, r) {
      const n = i.call(
        e !== void 0 ? e : this,
        t,
        r
      );
      n !== void 0 && (r[r.length - 1] = n);
    }
  );
}
function Jr(i, e, t) {
  return (
    /**
     * @param {Element} node Node.
     * @param {Array<*>} objectStack Object stack.
     */
    function(r, n) {
      const s = i.call(
        t !== void 0 ? t : this,
        r,
        n
      );
      if (s !== void 0) {
        const a = (
          /** @type {!Object} */
          n[n.length - 1]
        ), o = e !== void 0 ? e : r.localName;
        let A;
        o in a ? A = a[o] : (A = [], a[o] = A), A.push(s);
      }
    }
  );
}
function J(i, e, t) {
  return (
    /**
     * @param {Element} node Node.
     * @param {Array<*>} objectStack Object stack.
     */
    function(r, n) {
      const s = i.call(
        t !== void 0 ? t : this,
        r,
        n
      );
      if (s !== void 0) {
        const a = (
          /** @type {!Object} */
          n[n.length - 1]
        ), o = e !== void 0 ? e : r.localName;
        a[o] = s;
      }
    }
  );
}
function te(i, e) {
  return function(t, r, n) {
    i.call(
      e !== void 0 ? e : this,
      t,
      r,
      n
    ), /** @type {NodeStackItem} */
    n[n.length - 1].node.appendChild(t);
  };
}
function _N(i, e) {
  let t, r;
  return function(n, s, a) {
    if (t === void 0) {
      t = {};
      const o = {};
      o[n.localName] = i, t[n.namespaceURI] = o, r = wi(n.localName);
    }
    wN(t, r, s, a);
  };
}
function wi(i, e) {
  return (
    /**
     * @param {*} value Value.
     * @param {Array<*>} objectStack Object stack.
     * @param {string} [newNodeName] Node name.
     * @return {Node} Node.
     */
    function(t, r, n) {
      const a = /** @type {NodeStackItem} */ r[r.length - 1].node;
      let o = i;
      o === void 0 && (o = n);
      const A = e !== void 0 ? e : a.namespaceURI;
      return Nt(
        A,
        /** @type {string} */
        o
      );
    }
  );
}
const wn = wi();
function ys(i, e) {
  const t = e.length, r = new Array(t);
  for (let n = 0; n < t; ++n)
    r[n] = i[e[n]];
  return r;
}
function we(i, e, t) {
  t = t !== void 0 ? t : {};
  let r, n;
  for (r = 0, n = i.length; r < n; ++r)
    t[i[r]] = e;
  return t;
}
function gs(i, e, t, r) {
  let n;
  for (n = e.firstElementChild; n; n = n.nextElementSibling) {
    const s = i[n.namespaceURI];
    if (s !== void 0) {
      const a = s[n.localName];
      a !== void 0 && a.call(r, n, t);
    }
  }
}
function Se(i, e, t, r, n) {
  return r.push(i), gs(e, t, r, n), /** @type {T} */
  r.pop();
}
function wN(i, e, t, r, n, s) {
  const a = (n !== void 0 ? n : t).length;
  let o, A;
  for (let l = 0; l < a; ++l)
    o = t[l], o !== void 0 && (A = e.call(
      s !== void 0 ? s : this,
      o,
      r,
      n !== void 0 ? n[l] : void 0
    ), A !== void 0 && i[A.namespaceURI][A.localName].call(
      s,
      A,
      o,
      r
    ));
}
function Rt(i, e, t, r, n, s, a) {
  return n.push(i), wN(e, t, r, n, s, a), /** @type {O|undefined} */
  n.pop();
}
let g_;
function Dq() {
  return g_ === void 0 && typeof XMLSerializer < "u" && (g_ = new XMLSerializer()), g_;
}
let p_;
function Ou() {
  return p_ === void 0 && typeof document < "u" && (p_ = document.implementation.createDocument("", "", null)), p_;
}
class kq extends bg {
  constructor() {
    super(), this.xmlSerializer_ = Dq();
  }
  /**
   * @return {import("./Feature.js").Type} Format.
   */
  getType() {
    return "xml";
  }
  /**
   * Read a single feature.
   *
   * @param {Document|Element|Object|string} source Source.
   * @param {import("./Feature.js").ReadOptions} [options] Read options.
   * @return {import("../Feature.js").default} Feature.
   * @api
   */
  readFeature(e, t) {
    if (e) {
      if (typeof e == "string") {
        const r = Ka(e);
        return this.readFeatureFromDocument(r, t);
      } else if (Va(e))
        return this.readFeatureFromDocument(
          /** @type {Document} */
          e,
          t
        );
    } else
      return null;
    return this.readFeatureFromNode(
      /** @type {Element} */
      e,
      t
    );
  }
  /**
   * @param {Document} doc Document.
   * @param {import("./Feature.js").ReadOptions} [options] Options.
   * @return {import("../Feature.js").default} Feature.
   */
  readFeatureFromDocument(e, t) {
    const r = this.readFeaturesFromDocument(e, t);
    return r.length > 0 ? r[0] : null;
  }
  /**
   * @param {Element} node Node.
   * @param {import("./Feature.js").ReadOptions} [options] Options.
   * @return {import("../Feature.js").default} Feature.
   */
  readFeatureFromNode(e, t) {
    return null;
  }
  /**
   * Read all features from a feature collection.
   *
   * @param {Document|Element|Object|string} source Source.
   * @param {import("./Feature.js").ReadOptions} [options] Options.
   * @return {Array<import("../Feature.js").default>} Features.
   * @api
   */
  readFeatures(e, t) {
    if (e) {
      if (typeof e == "string") {
        const r = Ka(e);
        return this.readFeaturesFromDocument(r, t);
      } else if (Va(e))
        return this.readFeaturesFromDocument(
          /** @type {Document} */
          e,
          t
        );
    } else
      return [];
    return this.readFeaturesFromNode(
      /** @type {Element} */
      e,
      t
    );
  }
  /**
   * @param {Document} doc Document.
   * @param {import("./Feature.js").ReadOptions} [options] Options.
   * @protected
   * @return {Array<import("../Feature.js").default>} Features.
   */
  readFeaturesFromDocument(e, t) {
    const r = [];
    for (let n = e.firstChild; n; n = n.nextSibling)
      n.nodeType == Node.ELEMENT_NODE && Er(
        r,
        this.readFeaturesFromNode(
          /** @type {Element} */
          n,
          t
        )
      );
    return r;
  }
  /**
   * @abstract
   * @param {Element} node Node.
   * @param {import("./Feature.js").ReadOptions} [options] Options.
   * @protected
   * @return {Array<import("../Feature.js").default>} Features.
   */
  readFeaturesFromNode(e, t) {
    return pt();
  }
  /**
   * Read a single geometry from a source.
   *
   * @param {Document|Element|Object|string} source Source.
   * @param {import("./Feature.js").ReadOptions} [options] Read options.
   * @return {import("../geom/Geometry.js").default} Geometry.
   */
  readGeometry(e, t) {
    if (e) {
      if (typeof e == "string") {
        const r = Ka(e);
        return this.readGeometryFromDocument(r, t);
      } else if (Va(e))
        return this.readGeometryFromDocument(
          /** @type {Document} */
          e,
          t
        );
    } else
      return null;
    return this.readGeometryFromNode(
      /** @type {Element} */
      e,
      t
    );
  }
  /**
   * @param {Document} doc Document.
   * @param {import("./Feature.js").ReadOptions} [options] Options.
   * @protected
   * @return {import("../geom/Geometry.js").default} Geometry.
   */
  readGeometryFromDocument(e, t) {
    return null;
  }
  /**
   * @param {Element} node Node.
   * @param {import("./Feature.js").ReadOptions} [options] Options.
   * @protected
   * @return {import("../geom/Geometry.js").default} Geometry.
   */
  readGeometryFromNode(e, t) {
    return null;
  }
  /**
   * Read the projection from the source.
   *
   * @param {Document|Element|Object|string} source Source.
   * @return {import("../proj/Projection.js").default} Projection.
   * @api
   */
  readProjection(e) {
    if (e) {
      if (typeof e == "string") {
        const t = Ka(e);
        return this.readProjectionFromDocument(t);
      } else if (Va(e))
        return this.readProjectionFromDocument(
          /** @type {Document} */
          e
        );
    } else
      return null;
    return this.readProjectionFromNode(
      /** @type {Element} */
      e
    );
  }
  /**
   * @param {Document} doc Document.
   * @protected
   * @return {import("../proj/Projection.js").default} Projection.
   */
  readProjectionFromDocument(e) {
    return this.dataProjection;
  }
  /**
   * @param {Element} node Node.
   * @protected
   * @return {import("../proj/Projection.js").default} Projection.
   */
  readProjectionFromNode(e) {
    return this.dataProjection;
  }
  /**
   * Encode a feature as string.
   *
   * @param {import("../Feature.js").default} feature Feature.
   * @param {import("./Feature.js").WriteOptions} [options] Write options.
   * @return {string} Encoded feature.
   */
  writeFeature(e, t) {
    const r = this.writeFeatureNode(e, t);
    return this.xmlSerializer_.serializeToString(r);
  }
  /**
   * @param {import("../Feature.js").default} feature Feature.
   * @param {import("./Feature.js").WriteOptions} [options] Options.
   * @protected
   * @return {Node} Node.
   */
  writeFeatureNode(e, t) {
    return null;
  }
  /**
   * Encode an array of features as string.
   *
   * @param {Array<import("../Feature.js").default>} features Features.
   * @param {import("./Feature.js").WriteOptions} [options] Write options.
   * @return {string} Result.
   * @api
   */
  writeFeatures(e, t) {
    const r = this.writeFeaturesNode(e, t);
    return this.xmlSerializer_.serializeToString(r);
  }
  /**
   * @param {Array<import("../Feature.js").default>} features Features.
   * @param {import("./Feature.js").WriteOptions} [options] Options.
   * @return {Node} Node.
   */
  writeFeaturesNode(e, t) {
    return null;
  }
  /**
   * Encode a geometry as string.
   *
   * @param {import("../geom/Geometry.js").default} geometry Geometry.
   * @param {import("./Feature.js").WriteOptions} [options] Write options.
   * @return {string} Encoded geometry.
   */
  writeGeometry(e, t) {
    const r = this.writeGeometryNode(e, t);
    return this.xmlSerializer_.serializeToString(r);
  }
  /**
   * @param {import("../geom/Geometry.js").default} geometry Geometry.
   * @param {import("./Feature.js").WriteOptions} [options] Options.
   * @return {Node} Node.
   */
  writeGeometryNode(e, t) {
    return null;
  }
}
const Tg = kq, Vo = "http://www.opengis.net/gml", Hq = /^\s*$/;
class Fi extends Tg {
  /**
   * @param {Options} [options] Optional configuration object.
   */
  constructor(e) {
    super(), e = e || {}, this.featureType = e.featureType, this.featureNS = e.featureNS, this.srsName = e.srsName, this.schemaLocation = "", this.FEATURE_COLLECTION_PARSERS = {}, this.FEATURE_COLLECTION_PARSERS[this.namespace] = {
      featureMember: ht(this.readFeaturesInternal),
      featureMembers: wt(this.readFeaturesInternal)
    }, this.supportedMediaTypes = ["application/gml+xml"];
  }
  /**
   * @param {Element} node Node.
   * @param {Array<*>} objectStack Object stack.
   * @return {Array<Feature> | undefined} Features.
   */
  readFeaturesInternal(e, t) {
    const r = e.localName;
    let n = null;
    if (r == "FeatureCollection")
      n = Se(
        [],
        this.FEATURE_COLLECTION_PARSERS,
        e,
        t,
        this
      );
    else if (r == "featureMembers" || r == "featureMember" || r == "member") {
      const s = t[0];
      let a = s.featureType, o = s.featureNS;
      const A = "p", l = "p0";
      if (!a && e.childNodes) {
        a = [], o = {};
        for (let u = 0, f = e.childNodes.length; u < f; ++u) {
          const g = (
            /** @type {Element} */
            e.childNodes[u]
          );
          if (g.nodeType === 1) {
            const p = g.nodeName.split(":").pop();
            if (!a.includes(p)) {
              let y = "", v = 0;
              const w = g.namespaceURI;
              for (const C in o) {
                if (o[C] === w) {
                  y = C;
                  break;
                }
                ++v;
              }
              y || (y = A + v, o[y] = w), a.push(y + ":" + p);
            }
          }
        }
        r != "featureMember" && (s.featureType = a, s.featureNS = o);
      }
      if (typeof o == "string") {
        const u = o;
        o = {}, o[l] = u;
      }
      const h = {}, c = Array.isArray(a) ? a : [a];
      for (const u in o) {
        const f = {};
        for (let g = 0, p = c.length; g < p; ++g)
          (c[g].includes(":") ? c[g].split(":")[0] : l) === u && (f[c[g].split(":").pop()] = r == "featureMembers" ? ht(this.readFeatureElement, this) : wt(this.readFeatureElement, this));
        h[o[u]] = f;
      }
      r == "featureMember" || r == "member" ? n = Se(void 0, h, e, t) : n = Se([], h, e, t);
    }
    return n === null && (n = []), n;
  }
  /**
   * @param {Element} node Node.
   * @param {Array<*>} objectStack Object stack.
   * @return {import("../geom/Geometry.js").default|import("../extent.js").Extent|undefined} Geometry.
   */
  readGeometryOrExtent(e, t) {
    const r = (
      /** @type {Object} */
      t[0]
    );
    return r.srsName = e.firstElementChild.getAttribute("srsName"), r.srsDimension = e.firstElementChild.getAttribute("srsDimension"), Se(
      null,
      this.GEOMETRY_PARSERS,
      e,
      t,
      this
    );
  }
  /**
   * @param {Element} node Node.
   * @param {Array<*>} objectStack Object stack.
   * @return {import("../extent.js").Extent|undefined} Geometry.
   */
  readExtentElement(e, t) {
    const r = (
      /** @type {Object} */
      t[0]
    ), n = (
      /** @type {import("../extent.js").Extent} */
      this.readGeometryOrExtent(e, t)
    );
    return n ? yB(n, r) : void 0;
  }
  /**
   * @param {Element} node Node.
   * @param {Array<*>} objectStack Object stack.
   * @return {import("../geom/Geometry.js").default|undefined} Geometry.
   */
  readGeometryElement(e, t) {
    const r = (
      /** @type {Object} */
      t[0]
    ), n = (
      /** @type {import("../geom/Geometry.js").default} */
      this.readGeometryOrExtent(e, t)
    );
    return n ? ui(n, !1, r) : void 0;
  }
  /**
   * @param {Element} node Node.
   * @param {Array<*>} objectStack Object stack.
   * @param {boolean} asFeature whether result should be wrapped as a feature.
   * @return {Feature|Object} Feature
   */
  readFeatureElementInternal(e, t, r) {
    let n;
    const s = {};
    for (let A = e.firstElementChild; A; A = A.nextElementSibling) {
      let l;
      const h = A.localName;
      A.childNodes.length === 0 || A.childNodes.length === 1 && (A.firstChild.nodeType === 3 || A.firstChild.nodeType === 4) ? (l = ns(A, !1), Hq.test(l) && (l = void 0)) : (r && (l = h === "boundedBy" ? this.readExtentElement(A, t) : this.readGeometryElement(A, t)), l ? h !== "boundedBy" && (n = h) : l = this.readFeatureElementInternal(A, t, !1));
      const c = A.attributes.length;
      if (c > 0 && !(l instanceof dg)) {
        l = { _content_: l };
        for (let u = 0; u < c; u++) {
          const f = A.attributes[u].name;
          l[f] = A.attributes[u].value;
        }
      }
      s[h] ? (s[h] instanceof Array || (s[h] = [s[h]]), s[h].push(l)) : s[h] = l;
    }
    if (!r)
      return s;
    const a = new qt(s);
    n && a.setGeometryName(n);
    const o = e.getAttribute("fid") || Qq(e, this.namespace, "id");
    return o && a.setId(o), a;
  }
  /**
   * @param {Element} node Node.
   * @param {Array<*>} objectStack Object stack.
   * @return {Feature} Feature.
   */
  readFeatureElement(e, t) {
    return this.readFeatureElementInternal(e, t, !0);
  }
  /**
   * @param {Element} node Node.
   * @param {Array<*>} objectStack Object stack.
   * @return {Point|undefined} Point.
   */
  readPoint(e, t) {
    const r = this.readFlatCoordinatesFromNode(e, t);
    if (r)
      return new gr(r, "XYZ");
  }
  /**
   * @param {Element} node Node.
   * @param {Array<*>} objectStack Object stack.
   * @return {MultiPoint|undefined} MultiPoint.
   */
  readMultiPoint(e, t) {
    const r = Se(
      [],
      this.MULTIPOINT_PARSERS,
      e,
      t,
      this
    );
    if (r)
      return new ta(r);
  }
  /**
   * @param {Element} node Node.
   * @param {Array<*>} objectStack Object stack.
   * @return {MultiLineString|undefined} MultiLineString.
   */
  readMultiLineString(e, t) {
    const r = Se(
      [],
      this.MULTILINESTRING_PARSERS,
      e,
      t,
      this
    );
    if (r)
      return new In(r);
  }
  /**
   * @param {Element} node Node.
   * @param {Array<*>} objectStack Object stack.
   * @return {MultiPolygon|undefined} MultiPolygon.
   */
  readMultiPolygon(e, t) {
    const r = Se(
      [],
      this.MULTIPOLYGON_PARSERS,
      e,
      t,
      this
    );
    if (r)
      return new Rn(r);
  }
  /**
   * @param {Element} node Node.
   * @param {Array<*>} objectStack Object stack.
   */
  pointMemberParser(e, t) {
    gs(this.POINTMEMBER_PARSERS, e, t, this);
  }
  /**
   * @param {Element} node Node.
   * @param {Array<*>} objectStack Object stack.
   */
  lineStringMemberParser(e, t) {
    gs(this.LINESTRINGMEMBER_PARSERS, e, t, this);
  }
  /**
   * @param {Element} node Node.
   * @param {Array<*>} objectStack Object stack.
   */
  polygonMemberParser(e, t) {
    gs(this.POLYGONMEMBER_PARSERS, e, t, this);
  }
  /**
   * @param {Element} node Node.
   * @param {Array<*>} objectStack Object stack.
   * @return {LineString|undefined} LineString.
   */
  readLineString(e, t) {
    const r = this.readFlatCoordinatesFromNode(e, t);
    if (r)
      return new Gr(r, "XYZ");
  }
  /**
   * @param {Element} node Node.
   * @param {Array<*>} objectStack Object stack.
   * @return {Array<number>|undefined} LinearRing flat coordinates.
   */
  readFlatLinearRing(e, t) {
    const r = Se(
      null,
      this.GEOMETRY_FLAT_COORDINATES_PARSERS,
      e,
      t,
      this
    );
    if (r)
      return r;
  }
  /**
   * @param {Element} node Node.
   * @param {Array<*>} objectStack Object stack.
   * @return {LinearRing|undefined} LinearRing.
   */
  readLinearRing(e, t) {
    const r = this.readFlatCoordinatesFromNode(e, t);
    if (r)
      return new du(r, "XYZ");
  }
  /**
   * @param {Element} node Node.
   * @param {Array<*>} objectStack Object stack.
   * @return {Polygon|undefined} Polygon.
   */
  readPolygon(e, t) {
    const r = Se(
      [null],
      this.FLAT_LINEAR_RINGS_PARSERS,
      e,
      t,
      this
    );
    if (r && r[0]) {
      const n = r[0], s = [n.length];
      let a, o;
      for (a = 1, o = r.length; a < o; ++a)
        Er(n, r[a]), s.push(n.length);
      return new Li(n, "XYZ", s);
    }
  }
  /**
   * @param {Element} node Node.
   * @param {Array<*>} objectStack Object stack.
   * @return {Array<number>} Flat coordinates.
   */
  readFlatCoordinatesFromNode(e, t) {
    return Se(
      null,
      this.GEOMETRY_FLAT_COORDINATES_PARSERS,
      e,
      t,
      this
    );
  }
  /**
   * @param {Element} node Node.
   * @param {import("./Feature.js").ReadOptions} [options] Options.
   * @protected
   * @return {import("../geom/Geometry.js").default} Geometry.
   */
  readGeometryFromNode(e, t) {
    const r = this.readGeometryElement(e, [
      this.getReadOptions(e, t || {})
    ]);
    return r || null;
  }
  /**
   * @param {Element} node Node.
   * @param {import("./Feature.js").ReadOptions} [options] Options.
   * @return {Array<import("../Feature.js").default>} Features.
   */
  readFeaturesFromNode(e, t) {
    const r = {
      featureType: this.featureType,
      featureNS: this.featureNS
    };
    return r && Object.assign(r, this.getReadOptions(e, t)), this.readFeaturesInternal(e, [r]) || [];
  }
  /**
   * @param {Element} node Node.
   * @return {import("../proj/Projection.js").default} Projection.
   */
  readProjectionFromNode(e) {
    return Ct(
      this.srsName ? this.srsName : e.firstElementChild.getAttribute("srsName")
    );
  }
}
Fi.prototype.namespace = Vo;
Fi.prototype.FLAT_LINEAR_RINGS_PARSERS = {
  "http://www.opengis.net/gml": {}
};
Fi.prototype.GEOMETRY_FLAT_COORDINATES_PARSERS = {
  "http://www.opengis.net/gml": {}
};
Fi.prototype.GEOMETRY_PARSERS = {
  "http://www.opengis.net/gml": {}
};
Fi.prototype.MULTIPOINT_PARSERS = {
  "http://www.opengis.net/gml": {
    pointMember: ht(Fi.prototype.pointMemberParser),
    pointMembers: ht(Fi.prototype.pointMemberParser)
  }
};
Fi.prototype.MULTILINESTRING_PARSERS = {
  "http://www.opengis.net/gml": {
    lineStringMember: ht(
      Fi.prototype.lineStringMemberParser
    ),
    lineStringMembers: ht(
      Fi.prototype.lineStringMemberParser
    )
  }
};
Fi.prototype.MULTIPOLYGON_PARSERS = {
  "http://www.opengis.net/gml": {
    polygonMember: ht(Fi.prototype.polygonMemberParser),
    polygonMembers: ht(Fi.prototype.polygonMemberParser)
  }
};
Fi.prototype.POINTMEMBER_PARSERS = {
  "http://www.opengis.net/gml": {
    Point: ht(Fi.prototype.readFlatCoordinatesFromNode)
  }
};
Fi.prototype.LINESTRINGMEMBER_PARSERS = {
  "http://www.opengis.net/gml": {
    LineString: ht(Fi.prototype.readLineString)
  }
};
Fi.prototype.POLYGONMEMBER_PARSERS = {
  "http://www.opengis.net/gml": {
    Polygon: ht(Fi.prototype.readPolygon)
  }
};
Fi.prototype.RING_PARSERS = {
  "http://www.opengis.net/gml": {
    LinearRing: wt(Fi.prototype.readFlatLinearRing)
  }
};
const Xt = Fi;
function pl(i) {
  const e = ns(i, !1);
  return ah(e);
}
function ah(i) {
  const e = /^\s*(true|1)|(false|0)\s*$/.exec(i);
  if (e)
    return e[1] !== void 0 || !1;
}
function wB(i) {
  const e = ns(i, !1), t = Date.parse(e);
  return isNaN(t) ? void 0 : t / 1e3;
}
function xr(i) {
  const e = ns(i, !1);
  return Oo(e);
}
function Oo(i) {
  const e = /^\s*([+\-]?\d*\.?\d+(?:e[+\-]?\d+)?)\s*$/i.exec(i);
  if (e)
    return parseFloat(e[1]);
}
function Hi(i) {
  const e = ns(i, !1);
  return Do(e);
}
function Do(i) {
  const e = /^\s*(\d+)\s*$/.exec(i);
  if (e)
    return parseInt(e[1], 10);
}
function Me(i) {
  return ns(i, !1).trim();
}
function xu(i, e) {
  Tt(i, e ? "1" : "0");
}
function Gq(i, e) {
  i.appendChild(Ou().createCDATASection(e));
}
function $q(i, e) {
  const t = new Date(e * 1e3), r = t.getUTCFullYear() + "-" + bf(t.getUTCMonth() + 1, 2) + "-" + bf(t.getUTCDate(), 2) + "T" + bf(t.getUTCHours(), 2) + ":" + bf(t.getUTCMinutes(), 2) + ":" + bf(t.getUTCSeconds(), 2) + "Z";
  i.appendChild(Ou().createTextNode(r));
}
function us(i, e) {
  const t = e.toPrecision();
  i.appendChild(Ou().createTextNode(t));
}
function sv(i, e) {
  const t = e.toString();
  i.appendChild(Ou().createTextNode(t));
}
function Tt(i, e) {
  i.appendChild(Ou().createTextNode(e));
}
const Vq = Vo + " http://schemas.opengis.net/gml/2.1.2/feature.xsd", Kq = {
  MultiLineString: "lineStringMember",
  MultiCurve: "curveMember",
  MultiPolygon: "polygonMember",
  MultiSurface: "surfaceMember"
};
class dr extends Xt {
  /**
   * @param {import("./GMLBase.js").Options} [options] Optional configuration object.
   */
  constructor(e) {
    e = e || {}, super(e), this.FEATURE_COLLECTION_PARSERS[Vo].featureMember = ht(
      this.readFeaturesInternal
    ), this.schemaLocation = e.schemaLocation ? e.schemaLocation : Vq;
  }
  /**
   * @param {Node} node Node.
   * @param {Array<*>} objectStack Object stack.
   * @return {Array<number>|undefined} Flat coordinates.
   */
  readFlatCoordinates(e, t) {
    const r = ns(e, !1).replace(/^\s*|\s*$/g, ""), s = /** @type {import("../xml.js").NodeStackItem} */ t[0].srsName;
    let a = "enu";
    if (s) {
      const l = Ct(s);
      l && (a = l.getAxisOrientation());
    }
    const o = r.trim().split(/\s+/), A = [];
    for (let l = 0, h = o.length; l < h; l++) {
      const c = o[l].split(/,+/), u = parseFloat(c[0]), f = parseFloat(c[1]), g = c.length === 3 ? parseFloat(c[2]) : 0;
      a.substr(0, 2) === "en" ? A.push(u, f, g) : A.push(f, u, g);
    }
    return A;
  }
  /**
   * @param {Element} node Node.
   * @param {Array<*>} objectStack Object stack.
   * @return {import("../extent.js").Extent|undefined} Envelope.
   */
  readBox(e, t) {
    const r = Se(
      [null],
      this.BOX_PARSERS_,
      e,
      t,
      this
    );
    return ms(
      r[1][0],
      r[1][1],
      r[1][3],
      r[1][4]
    );
  }
  /**
   * @param {Element} node Node.
   * @param {Array<*>} objectStack Object stack.
   */
  innerBoundaryIsParser(e, t) {
    const r = Se(
      void 0,
      this.RING_PARSERS,
      e,
      t,
      this
    );
    r && /** @type {Array<Array<number>>} */
    t[t.length - 1].push(r);
  }
  /**
   * @param {Element} node Node.
   * @param {Array<*>} objectStack Object stack.
   */
  outerBoundaryIsParser(e, t) {
    const r = Se(
      void 0,
      this.RING_PARSERS,
      e,
      t,
      this
    );
    if (r) {
      const n = (
        /** @type {Array<Array<number>>} */
        t[t.length - 1]
      );
      n[0] = r;
    }
  }
  /**
   * @const
   * @param {*} value Value.
   * @param {Array<*>} objectStack Object stack.
   * @param {string} [nodeName] Node name.
   * @return {Element|undefined} Node.
   * @private
   */
  GEOMETRY_NODE_FACTORY_(e, t, r) {
    const n = t[t.length - 1], s = n.multiSurface, a = n.surface, o = n.multiCurve;
    return Array.isArray(e) ? r = "Envelope" : (r = /** @type {import("../geom/Geometry.js").default} */
    e.getType(), r === "MultiPolygon" && s === !0 ? r = "MultiSurface" : r === "Polygon" && a === !0 ? r = "Surface" : r === "MultiLineString" && o === !0 && (r = "MultiCurve")), Nt("http://www.opengis.net/gml", r);
  }
  /**
   * @param {Element} node Node.
   * @param {import("../Feature.js").default} feature Feature.
   * @param {Array<*>} objectStack Node stack.
   */
  writeFeatureElement(e, t, r) {
    const n = t.getId();
    n && e.setAttribute(
      "fid",
      /** @type {string} */
      n
    );
    const s = (
      /** @type {Object} */
      r[r.length - 1]
    ), a = s.featureNS, o = t.getGeometryName();
    s.serializers || (s.serializers = {}, s.serializers[a] = {});
    const A = [], l = [];
    if (t.hasProperties()) {
      const c = t.getProperties();
      for (const u in c) {
        const f = c[u];
        f !== null && (A.push(u), l.push(f), u == o || typeof /** @type {?} */
        f.getSimplifiedGeometry == "function" ? u in s.serializers[a] || (s.serializers[a][u] = te(
          this.writeGeometryElement,
          this
        )) : u in s.serializers[a] || (s.serializers[a][u] = te(Tt)));
      }
    }
    const h = Object.assign({}, s);
    h.node = e, Rt(
      /** @type {import("../xml.js").NodeStackItem} */
      h,
      s.serializers,
      wi(void 0, a),
      l,
      r,
      A
    );
  }
  /**
   * @param {Element} node Node.
   * @param {import("../geom/LineString.js").default} geometry LineString geometry.
   * @param {Array<*>} objectStack Node stack.
   */
  writeCurveOrLineString(e, t, r) {
    const s = r[r.length - 1].srsName;
    if (e.nodeName !== "LineStringSegment" && s && e.setAttribute("srsName", s), e.nodeName === "LineString" || e.nodeName === "LineStringSegment") {
      const a = this.createCoordinatesNode_(e.namespaceURI);
      e.appendChild(a), this.writeCoordinates_(a, t, r);
    } else if (e.nodeName === "Curve") {
      const a = Nt(e.namespaceURI, "segments");
      e.appendChild(a), this.writeCurveSegments_(a, t, r);
    }
  }
  /**
   * @param {Element} node Node.
   * @param {import("../geom/LineString.js").default} line LineString geometry.
   * @param {Array<*>} objectStack Node stack.
   */
  writeLineStringOrCurveMember(e, t, r) {
    const n = this.GEOMETRY_NODE_FACTORY_(t, r);
    n && (e.appendChild(n), this.writeCurveOrLineString(n, t, r));
  }
  /**
   * @param {Element} node Node.
   * @param {import("../geom/MultiLineString.js").default} geometry MultiLineString geometry.
   * @param {Array<*>} objectStack Node stack.
   */
  writeMultiCurveOrLineString(e, t, r) {
    const n = r[r.length - 1], s = n.hasZ, a = n.srsName, o = n.curve;
    a && e.setAttribute("srsName", a);
    const A = t.getLineStrings();
    Rt(
      { node: e, hasZ: s, srsName: a, curve: o },
      this.LINESTRINGORCURVEMEMBER_SERIALIZERS,
      this.MULTIGEOMETRY_MEMBER_NODE_FACTORY_,
      A,
      r,
      void 0,
      this
    );
  }
  /**
   * @param {Node} node Node.
   * @param {import("../geom/Geometry.js").default|import("../extent.js").Extent} geometry Geometry.
   * @param {Array<*>} objectStack Node stack.
   */
  writeGeometryElement(e, t, r) {
    const n = (
      /** @type {import("./Feature.js").WriteOptions} */
      r[r.length - 1]
    ), s = Object.assign({}, n);
    s.node = e;
    let a;
    Array.isArray(t) ? a = yB(
      /** @type {import("../extent.js").Extent} */
      t,
      n
    ) : a = ui(
      /** @type {import("../geom/Geometry.js").default} */
      t,
      !0,
      n
    ), Rt(
      /** @type {import("../xml.js").NodeStackItem} */
      s,
      this.GEOMETRY_SERIALIZERS,
      this.GEOMETRY_NODE_FACTORY_,
      [a],
      r,
      void 0,
      this
    );
  }
  /**
   * @param {string} namespaceURI XML namespace.
   * @return {Element} coordinates node.
   * @private
   */
  createCoordinatesNode_(e) {
    const t = Nt(e, "coordinates");
    return t.setAttribute("decimal", "."), t.setAttribute("cs", ","), t.setAttribute("ts", " "), t;
  }
  /**
   * @param {Node} node Node.
   * @param {import("../geom/LineString.js").default|import("../geom/LinearRing.js").default} value Geometry.
   * @param {Array<*>} objectStack Node stack.
   * @private
   */
  writeCoordinates_(e, t, r) {
    const n = r[r.length - 1], s = n.hasZ, a = n.srsName, o = t.getCoordinates(), A = o.length, l = new Array(A);
    for (let h = 0; h < A; ++h) {
      const c = o[h];
      l[h] = this.getCoords_(c, a, s);
    }
    Tt(e, l.join(" "));
  }
  /**
   * @param {Element} node Node.
   * @param {import("../geom/LineString.js").default} line LineString geometry.
   * @param {Array<*>} objectStack Node stack.
   * @private
   */
  writeCurveSegments_(e, t, r) {
    const n = Nt(e.namespaceURI, "LineStringSegment");
    e.appendChild(n), this.writeCurveOrLineString(n, t, r);
  }
  /**
   * @param {Element} node Node.
   * @param {import("../geom/Polygon.js").default} geometry Polygon geometry.
   * @param {Array<*>} objectStack Node stack.
   */
  writeSurfaceOrPolygon(e, t, r) {
    const n = r[r.length - 1], s = n.hasZ, a = n.srsName;
    if (e.nodeName !== "PolygonPatch" && a && e.setAttribute("srsName", a), e.nodeName === "Polygon" || e.nodeName === "PolygonPatch") {
      const o = t.getLinearRings();
      Rt(
        { node: e, hasZ: s, srsName: a },
        this.RING_SERIALIZERS,
        this.RING_NODE_FACTORY_,
        o,
        r,
        void 0,
        this
      );
    } else if (e.nodeName === "Surface") {
      const o = Nt(e.namespaceURI, "patches");
      e.appendChild(o), this.writeSurfacePatches_(o, t, r);
    }
  }
  /**
   * @param {*} value Value.
   * @param {Array<*>} objectStack Object stack.
   * @param {string} [nodeName] Node name.
   * @return {Node} Node.
   * @private
   */
  RING_NODE_FACTORY_(e, t, r) {
    const n = t[t.length - 1], s = n.node, a = n.exteriorWritten;
    return a === void 0 && (n.exteriorWritten = !0), Nt(
      s.namespaceURI,
      a !== void 0 ? "innerBoundaryIs" : "outerBoundaryIs"
    );
  }
  /**
   * @param {Element} node Node.
   * @param {import("../geom/Polygon.js").default} polygon Polygon geometry.
   * @param {Array<*>} objectStack Node stack.
   * @private
   */
  writeSurfacePatches_(e, t, r) {
    const n = Nt(e.namespaceURI, "PolygonPatch");
    e.appendChild(n), this.writeSurfaceOrPolygon(n, t, r);
  }
  /**
   * @param {Element} node Node.
   * @param {import("../geom/LinearRing.js").default} ring LinearRing geometry.
   * @param {Array<*>} objectStack Node stack.
   */
  writeRing(e, t, r) {
    const n = Nt(e.namespaceURI, "LinearRing");
    e.appendChild(n), this.writeLinearRing(n, t, r);
  }
  /**
   * @param {Array<number>} point Point geometry.
   * @param {string} [srsName] Optional srsName
   * @param {boolean} [hasZ] whether the geometry has a Z coordinate (is 3D) or not.
   * @return {string} The coords string.
   * @private
   */
  getCoords_(e, t, r) {
    let n = "enu";
    t && (n = Ct(t).getAxisOrientation());
    let s = n.substr(0, 2) === "en" ? e[0] + "," + e[1] : e[1] + "," + e[0];
    if (r) {
      const a = e[2] || 0;
      s += "," + a;
    }
    return s;
  }
  /**
   * @param {Element} node Node.
   * @param {import("../geom/Point.js").default} geometry Point geometry.
   * @param {Array<*>} objectStack Node stack.
   */
  writePoint(e, t, r) {
    const n = r[r.length - 1], s = n.hasZ, a = n.srsName;
    a && e.setAttribute("srsName", a);
    const o = this.createCoordinatesNode_(e.namespaceURI);
    e.appendChild(o);
    const A = t.getCoordinates(), l = this.getCoords_(A, a, s);
    Tt(o, l);
  }
  /**
   * @param {Element} node Node.
   * @param {import("../geom/MultiPoint.js").default} geometry MultiPoint geometry.
   * @param {Array<*>} objectStack Node stack.
   */
  writeMultiPoint(e, t, r) {
    const n = r[r.length - 1], s = n.hasZ, a = n.srsName;
    a && e.setAttribute("srsName", a);
    const o = t.getPoints();
    Rt(
      { node: e, hasZ: s, srsName: a },
      this.POINTMEMBER_SERIALIZERS,
      wi("pointMember"),
      o,
      r,
      void 0,
      this
    );
  }
  /**
   * @param {Element} node Node.
   * @param {import("../geom/Point.js").default} point Point geometry.
   * @param {Array<*>} objectStack Node stack.
   */
  writePointMember(e, t, r) {
    const n = Nt(e.namespaceURI, "Point");
    e.appendChild(n), this.writePoint(n, t, r);
  }
  /**
   * @param {Element} node Node.
   * @param {import("../geom/LinearRing.js").default} geometry LinearRing geometry.
   * @param {Array<*>} objectStack Node stack.
   */
  writeLinearRing(e, t, r) {
    const s = r[r.length - 1].srsName;
    s && e.setAttribute("srsName", s);
    const a = this.createCoordinatesNode_(e.namespaceURI);
    e.appendChild(a), this.writeCoordinates_(a, t, r);
  }
  /**
   * @param {Element} node Node.
   * @param {import("../geom/MultiPolygon.js").default} geometry MultiPolygon geometry.
   * @param {Array<*>} objectStack Node stack.
   */
  writeMultiSurfaceOrPolygon(e, t, r) {
    const n = r[r.length - 1], s = n.hasZ, a = n.srsName, o = n.surface;
    a && e.setAttribute("srsName", a);
    const A = t.getPolygons();
    Rt(
      { node: e, hasZ: s, srsName: a, surface: o },
      this.SURFACEORPOLYGONMEMBER_SERIALIZERS,
      this.MULTIGEOMETRY_MEMBER_NODE_FACTORY_,
      A,
      r,
      void 0,
      this
    );
  }
  /**
   * @param {Node} node Node.
   * @param {import("../geom/Polygon.js").default} polygon Polygon geometry.
   * @param {Array<*>} objectStack Node stack.
   */
  writeSurfaceOrPolygonMember(e, t, r) {
    const n = this.GEOMETRY_NODE_FACTORY_(t, r);
    n && (e.appendChild(n), this.writeSurfaceOrPolygon(n, t, r));
  }
  /**
   * @param {Element} node Node.
   * @param {import("../extent.js").Extent} extent Extent.
   * @param {Array<*>} objectStack Node stack.
   */
  writeEnvelope(e, t, r) {
    const s = r[r.length - 1].srsName;
    s && e.setAttribute("srsName", s);
    const a = ["lowerCorner", "upperCorner"], o = [t[0] + " " + t[1], t[2] + " " + t[3]];
    Rt(
      /** @type {import("../xml.js").NodeStackItem} */
      { node: e },
      this.ENVELOPE_SERIALIZERS,
      wn,
      o,
      r,
      a,
      this
    );
  }
  /**
   * @const
   * @param {*} value Value.
   * @param {Array<*>} objectStack Object stack.
   * @param {string} [nodeName] Node name.
   * @return {Node|undefined} Node.
   * @private
   */
  MULTIGEOMETRY_MEMBER_NODE_FACTORY_(e, t, r) {
    const n = t[t.length - 1].node;
    return Nt(
      "http://www.opengis.net/gml",
      Kq[n.nodeName]
    );
  }
}
dr.prototype.GEOMETRY_FLAT_COORDINATES_PARSERS = {
  "http://www.opengis.net/gml": {
    coordinates: wt(dr.prototype.readFlatCoordinates)
  }
};
dr.prototype.FLAT_LINEAR_RINGS_PARSERS = {
  "http://www.opengis.net/gml": {
    innerBoundaryIs: dr.prototype.innerBoundaryIsParser,
    outerBoundaryIs: dr.prototype.outerBoundaryIsParser
  }
};
dr.prototype.BOX_PARSERS_ = {
  "http://www.opengis.net/gml": {
    coordinates: ht(dr.prototype.readFlatCoordinates)
  }
};
dr.prototype.GEOMETRY_PARSERS = {
  "http://www.opengis.net/gml": {
    Point: wt(Xt.prototype.readPoint),
    MultiPoint: wt(Xt.prototype.readMultiPoint),
    LineString: wt(Xt.prototype.readLineString),
    MultiLineString: wt(Xt.prototype.readMultiLineString),
    LinearRing: wt(Xt.prototype.readLinearRing),
    Polygon: wt(Xt.prototype.readPolygon),
    MultiPolygon: wt(Xt.prototype.readMultiPolygon),
    Box: wt(dr.prototype.readBox)
  }
};
dr.prototype.GEOMETRY_SERIALIZERS = {
  "http://www.opengis.net/gml": {
    Curve: te(dr.prototype.writeCurveOrLineString),
    MultiCurve: te(dr.prototype.writeMultiCurveOrLineString),
    Point: te(dr.prototype.writePoint),
    MultiPoint: te(dr.prototype.writeMultiPoint),
    LineString: te(dr.prototype.writeCurveOrLineString),
    MultiLineString: te(
      dr.prototype.writeMultiCurveOrLineString
    ),
    LinearRing: te(dr.prototype.writeLinearRing),
    Polygon: te(dr.prototype.writeSurfaceOrPolygon),
    MultiPolygon: te(
      dr.prototype.writeMultiSurfaceOrPolygon
    ),
    Surface: te(dr.prototype.writeSurfaceOrPolygon),
    MultiSurface: te(
      dr.prototype.writeMultiSurfaceOrPolygon
    ),
    Envelope: te(dr.prototype.writeEnvelope)
  }
};
dr.prototype.LINESTRINGORCURVEMEMBER_SERIALIZERS = {
  "http://www.opengis.net/gml": {
    lineStringMember: te(
      dr.prototype.writeLineStringOrCurveMember
    ),
    curveMember: te(
      dr.prototype.writeLineStringOrCurveMember
    )
  }
};
dr.prototype.RING_SERIALIZERS = {
  "http://www.opengis.net/gml": {
    outerBoundaryIs: te(dr.prototype.writeRing),
    innerBoundaryIs: te(dr.prototype.writeRing)
  }
};
dr.prototype.POINTMEMBER_SERIALIZERS = {
  "http://www.opengis.net/gml": {
    pointMember: te(dr.prototype.writePointMember)
  }
};
dr.prototype.SURFACEORPOLYGONMEMBER_SERIALIZERS = {
  "http://www.opengis.net/gml": {
    surfaceMember: te(
      dr.prototype.writeSurfaceOrPolygonMember
    ),
    polygonMember: te(
      dr.prototype.writeSurfaceOrPolygonMember
    )
  }
};
dr.prototype.ENVELOPE_SERIALIZERS = {
  "http://www.opengis.net/gml": {
    lowerCorner: te(Tt),
    upperCorner: te(Tt)
  }
};
const Uu = dr, jq = Vo + " http://schemas.opengis.net/gml/3.1.1/profiles/gmlsfProfile/1.0.0/gmlsf.xsd", zq = {
  MultiLineString: "lineStringMember",
  MultiCurve: "curveMember",
  MultiPolygon: "polygonMember",
  MultiSurface: "surfaceMember"
};
class ct extends Xt {
  /**
   * @param {import("./GMLBase.js").Options} [options] Optional configuration object.
   */
  constructor(e) {
    e = e || {}, super(e), this.surface_ = e.surface !== void 0 ? e.surface : !1, this.curve_ = e.curve !== void 0 ? e.curve : !1, this.multiCurve_ = e.multiCurve !== void 0 ? e.multiCurve : !0, this.multiSurface_ = e.multiSurface !== void 0 ? e.multiSurface : !0, this.schemaLocation = e.schemaLocation ? e.schemaLocation : jq, this.hasZ = e.hasZ !== void 0 ? e.hasZ : !1;
  }
  /**
   * @param {Element} node Node.
   * @param {Array<*>} objectStack Object stack.
   * @return {MultiLineString|undefined} MultiLineString.
   */
  readMultiCurve(e, t) {
    const r = Se(
      [],
      this.MULTICURVE_PARSERS,
      e,
      t,
      this
    );
    if (r)
      return new In(r);
  }
  /**
   * @param {Element} node Node.
   * @param {Array<*>} objectStack Object stack.
   * @return {Array<number>|undefined} Polygon.
   */
  readFlatCurveRing(e, t) {
    const r = Se(
      [],
      this.MULTICURVE_PARSERS,
      e,
      t,
      this
    ), n = [];
    for (let s = 0, a = r.length; s < a; ++s)
      Er(n, r[s].getFlatCoordinates());
    return n;
  }
  /**
   * @param {Element} node Node.
   * @param {Array<*>} objectStack Object stack.
   * @return {MultiPolygon|undefined} MultiPolygon.
   */
  readMultiSurface(e, t) {
    const r = Se(
      [],
      this.MULTISURFACE_PARSERS,
      e,
      t,
      this
    );
    if (r)
      return new Rn(r);
  }
  /**
   * @param {Element} node Node.
   * @param {Array<*>} objectStack Object stack.
   */
  curveMemberParser(e, t) {
    gs(this.CURVEMEMBER_PARSERS, e, t, this);
  }
  /**
   * @param {Element} node Node.
   * @param {Array<*>} objectStack Object stack.
   */
  surfaceMemberParser(e, t) {
    gs(this.SURFACEMEMBER_PARSERS, e, t, this);
  }
  /**
   * @param {Element} node Node.
   * @param {Array<*>} objectStack Object stack.
   * @return {Array<(Array<number>)>|undefined} flat coordinates.
   */
  readPatch(e, t) {
    return Se(
      [null],
      this.PATCHES_PARSERS,
      e,
      t,
      this
    );
  }
  /**
   * @param {Element} node Node.
   * @param {Array<*>} objectStack Object stack.
   * @return {Array<number>|undefined} flat coordinates.
   */
  readSegment(e, t) {
    return Se([], this.SEGMENTS_PARSERS, e, t, this);
  }
  /**
   * @param {Element} node Node.
   * @param {Array<*>} objectStack Object stack.
   * @return {Array<(Array<number>)>|undefined} flat coordinates.
   */
  readPolygonPatch(e, t) {
    return Se(
      [null],
      this.FLAT_LINEAR_RINGS_PARSERS,
      e,
      t,
      this
    );
  }
  /**
   * @param {Element} node Node.
   * @param {Array<*>} objectStack Object stack.
   * @return {Array<number>|undefined} flat coordinates.
   */
  readLineStringSegment(e, t) {
    return Se(
      [null],
      this.GEOMETRY_FLAT_COORDINATES_PARSERS,
      e,
      t,
      this
    );
  }
  /**
   * @param {Element} node Node.
   * @param {Array<*>} objectStack Object stack.
   */
  interiorParser(e, t) {
    const r = Se(
      void 0,
      this.RING_PARSERS,
      e,
      t,
      this
    );
    r && /** @type {Array<Array<number>>} */
    t[t.length - 1].push(r);
  }
  /**
   * @param {Element} node Node.
   * @param {Array<*>} objectStack Object stack.
   */
  exteriorParser(e, t) {
    const r = Se(
      void 0,
      this.RING_PARSERS,
      e,
      t,
      this
    );
    if (r) {
      const n = (
        /** @type {Array<Array<number>>} */
        t[t.length - 1]
      );
      n[0] = r;
    }
  }
  /**
   * @param {Element} node Node.
   * @param {Array<*>} objectStack Object stack.
   * @return {Polygon|undefined} Polygon.
   */
  readSurface(e, t) {
    const r = Se(
      [null],
      this.SURFACE_PARSERS,
      e,
      t,
      this
    );
    if (r && r[0]) {
      const n = r[0], s = [n.length];
      let a, o;
      for (a = 1, o = r.length; a < o; ++a)
        Er(n, r[a]), s.push(n.length);
      return new Li(n, "XYZ", s);
    }
  }
  /**
   * @param {Element} node Node.
   * @param {Array<*>} objectStack Object stack.
   * @return {LineString|undefined} LineString.
   */
  readCurve(e, t) {
    const r = Se(
      [null],
      this.CURVE_PARSERS,
      e,
      t,
      this
    );
    if (r)
      return new Gr(r, "XYZ");
  }
  /**
   * @param {Element} node Node.
   * @param {Array<*>} objectStack Object stack.
   * @return {import("../extent.js").Extent|undefined} Envelope.
   */
  readEnvelope(e, t) {
    const r = Se(
      [null],
      this.ENVELOPE_PARSERS,
      e,
      t,
      this
    );
    return ms(
      r[1][0],
      r[1][1],
      r[2][0],
      r[2][1]
    );
  }
  /**
   * @param {Node} node Node.
   * @param {Array<*>} objectStack Object stack.
   * @return {Array<number>|undefined} Flat coordinates.
   */
  readFlatPos(e, t) {
    let r = ns(e, !1);
    const n = /^\s*([+\-]?\d*\.?\d+(?:[eE][+\-]?\d+)?)\s*/, s = [];
    let a;
    for (; a = n.exec(r); )
      s.push(parseFloat(a[1])), r = r.substr(a[0].length);
    if (r !== "")
      return;
    const A = t[0].srsName;
    let l = "enu";
    if (A && (l = Ct(A).getAxisOrientation()), l === "neu") {
      let c, u;
      for (c = 0, u = s.length; c < u; c += 3) {
        const f = s[c], g = s[c + 1];
        s[c] = g, s[c + 1] = f;
      }
    }
    const h = s.length;
    if (h == 2 && s.push(0), h !== 0)
      return s;
  }
  /**
   * @param {Element} node Node.
   * @param {Array<*>} objectStack Object stack.
   * @return {Array<number>|undefined} Flat coordinates.
   */
  readFlatPosList(e, t) {
    const r = ns(e, !1).replace(/^\s*|\s*$/g, ""), n = t[0], s = n.srsName, a = n.srsDimension;
    let o = "enu";
    s && (o = Ct(s).getAxisOrientation());
    const A = r.split(/\s+/);
    let l = 2;
    e.getAttribute("srsDimension") ? l = Do(e.getAttribute("srsDimension")) : e.getAttribute("dimension") ? l = Do(e.getAttribute("dimension")) : /** @type {Element} */ e.parentNode.getAttribute("srsDimension") ? l = Do(
      /** @type {Element} */
      e.parentNode.getAttribute("srsDimension")
    ) : a && (l = Do(a));
    let h, c, u;
    const f = [];
    for (let g = 0, p = A.length; g < p; g += l)
      h = parseFloat(A[g]), c = parseFloat(A[g + 1]), u = l === 3 ? parseFloat(A[g + 2]) : 0, o.substr(0, 2) === "en" ? f.push(h, c, u) : f.push(c, h, u);
    return f;
  }
  /**
   * @param {Element} node Node.
   * @param {import("../geom/Point.js").default} value Point geometry.
   * @param {Array<*>} objectStack Node stack.
   * @private
   */
  writePos_(e, t, r) {
    const n = r[r.length - 1], s = n.hasZ, a = s ? "3" : "2";
    e.setAttribute("srsDimension", a);
    const o = n.srsName;
    let A = "enu";
    o && (A = Ct(o).getAxisOrientation());
    const l = t.getCoordinates();
    let h;
    if (A.substr(0, 2) === "en" ? h = l[0] + " " + l[1] : h = l[1] + " " + l[0], s) {
      const c = l[2] || 0;
      h += " " + c;
    }
    Tt(e, h);
  }
  /**
   * @param {Array<number>} point Point geometry.
   * @param {string} [srsName] Optional srsName
   * @param {boolean} [hasZ] whether the geometry has a Z coordinate (is 3D) or not.
   * @return {string} The coords string.
   * @private
   */
  getCoords_(e, t, r) {
    let n = "enu";
    t && (n = Ct(t).getAxisOrientation());
    let s = n.substr(0, 2) === "en" ? e[0] + " " + e[1] : e[1] + " " + e[0];
    if (r) {
      const a = e[2] || 0;
      s += " " + a;
    }
    return s;
  }
  /**
   * @param {Element} node Node.
   * @param {LineString|import("../geom/LinearRing.js").default} value Geometry.
   * @param {Array<*>} objectStack Node stack.
   * @private
   */
  writePosList_(e, t, r) {
    const n = r[r.length - 1], s = n.hasZ, a = s ? "3" : "2";
    e.setAttribute("srsDimension", a);
    const o = n.srsName, A = t.getCoordinates(), l = A.length, h = new Array(l);
    let c;
    for (let u = 0; u < l; ++u)
      c = A[u], h[u] = this.getCoords_(c, o, s);
    Tt(e, h.join(" "));
  }
  /**
   * @param {Element} node Node.
   * @param {import("../geom/Point.js").default} geometry Point geometry.
   * @param {Array<*>} objectStack Node stack.
   */
  writePoint(e, t, r) {
    const s = r[r.length - 1].srsName;
    s && e.setAttribute("srsName", s);
    const a = Nt(e.namespaceURI, "pos");
    e.appendChild(a), this.writePos_(a, t, r);
  }
  /**
   * @param {Element} node Node.
   * @param {import("../extent.js").Extent} extent Extent.
   * @param {Array<*>} objectStack Node stack.
   */
  writeEnvelope(e, t, r) {
    const s = r[r.length - 1].srsName;
    s && e.setAttribute("srsName", s);
    const a = ["lowerCorner", "upperCorner"], o = [t[0] + " " + t[1], t[2] + " " + t[3]];
    Rt(
      /** @type {import("../xml.js").NodeStackItem} */
      { node: e },
      this.ENVELOPE_SERIALIZERS,
      wn,
      o,
      r,
      a,
      this
    );
  }
  /**
   * @param {Element} node Node.
   * @param {import("../geom/LinearRing.js").default} geometry LinearRing geometry.
   * @param {Array<*>} objectStack Node stack.
   */
  writeLinearRing(e, t, r) {
    const s = r[r.length - 1].srsName;
    s && e.setAttribute("srsName", s);
    const a = Nt(e.namespaceURI, "posList");
    e.appendChild(a), this.writePosList_(a, t, r);
  }
  /**
   * @param {*} value Value.
   * @param {Array<*>} objectStack Object stack.
   * @param {string} [nodeName] Node name.
   * @return {Node} Node.
   * @private
   */
  RING_NODE_FACTORY_(e, t, r) {
    const n = t[t.length - 1], s = n.node, a = n.exteriorWritten;
    return a === void 0 && (n.exteriorWritten = !0), Nt(
      s.namespaceURI,
      a !== void 0 ? "interior" : "exterior"
    );
  }
  /**
   * @param {Element} node Node.
   * @param {Polygon} geometry Polygon geometry.
   * @param {Array<*>} objectStack Node stack.
   */
  writeSurfaceOrPolygon(e, t, r) {
    const n = r[r.length - 1], s = n.hasZ, a = n.srsName;
    if (e.nodeName !== "PolygonPatch" && a && e.setAttribute("srsName", a), e.nodeName === "Polygon" || e.nodeName === "PolygonPatch") {
      const o = t.getLinearRings();
      Rt(
        { node: e, hasZ: s, srsName: a },
        this.RING_SERIALIZERS,
        this.RING_NODE_FACTORY_,
        o,
        r,
        void 0,
        this
      );
    } else if (e.nodeName === "Surface") {
      const o = Nt(e.namespaceURI, "patches");
      e.appendChild(o), this.writeSurfacePatches_(o, t, r);
    }
  }
  /**
   * @param {Element} node Node.
   * @param {LineString} geometry LineString geometry.
   * @param {Array<*>} objectStack Node stack.
   */
  writeCurveOrLineString(e, t, r) {
    const s = r[r.length - 1].srsName;
    if (e.nodeName !== "LineStringSegment" && s && e.setAttribute("srsName", s), e.nodeName === "LineString" || e.nodeName === "LineStringSegment") {
      const a = Nt(e.namespaceURI, "posList");
      e.appendChild(a), this.writePosList_(a, t, r);
    } else if (e.nodeName === "Curve") {
      const a = Nt(e.namespaceURI, "segments");
      e.appendChild(a), this.writeCurveSegments_(a, t, r);
    }
  }
  /**
   * @param {Element} node Node.
   * @param {MultiPolygon} geometry MultiPolygon geometry.
   * @param {Array<*>} objectStack Node stack.
   */
  writeMultiSurfaceOrPolygon(e, t, r) {
    const n = r[r.length - 1], s = n.hasZ, a = n.srsName, o = n.surface;
    a && e.setAttribute("srsName", a);
    const A = t.getPolygons();
    Rt(
      { node: e, hasZ: s, srsName: a, surface: o },
      this.SURFACEORPOLYGONMEMBER_SERIALIZERS,
      this.MULTIGEOMETRY_MEMBER_NODE_FACTORY_,
      A,
      r,
      void 0,
      this
    );
  }
  /**
   * @param {Element} node Node.
   * @param {import("../geom/MultiPoint.js").default} geometry MultiPoint geometry.
   * @param {Array<*>} objectStack Node stack.
   */
  writeMultiPoint(e, t, r) {
    const n = r[r.length - 1], s = n.srsName, a = n.hasZ;
    s && e.setAttribute("srsName", s);
    const o = t.getPoints();
    Rt(
      { node: e, hasZ: a, srsName: s },
      this.POINTMEMBER_SERIALIZERS,
      wi("pointMember"),
      o,
      r,
      void 0,
      this
    );
  }
  /**
   * @param {Element} node Node.
   * @param {MultiLineString} geometry MultiLineString geometry.
   * @param {Array<*>} objectStack Node stack.
   */
  writeMultiCurveOrLineString(e, t, r) {
    const n = r[r.length - 1], s = n.hasZ, a = n.srsName, o = n.curve;
    a && e.setAttribute("srsName", a);
    const A = t.getLineStrings();
    Rt(
      { node: e, hasZ: s, srsName: a, curve: o },
      this.LINESTRINGORCURVEMEMBER_SERIALIZERS,
      this.MULTIGEOMETRY_MEMBER_NODE_FACTORY_,
      A,
      r,
      void 0,
      this
    );
  }
  /**
   * @param {Element} node Node.
   * @param {import("../geom/LinearRing.js").default} ring LinearRing geometry.
   * @param {Array<*>} objectStack Node stack.
   */
  writeRing(e, t, r) {
    const n = Nt(e.namespaceURI, "LinearRing");
    e.appendChild(n), this.writeLinearRing(n, t, r);
  }
  /**
   * @param {Node} node Node.
   * @param {Polygon} polygon Polygon geometry.
   * @param {Array<*>} objectStack Node stack.
   */
  writeSurfaceOrPolygonMember(e, t, r) {
    const n = this.GEOMETRY_NODE_FACTORY_(t, r);
    n && (e.appendChild(n), this.writeSurfaceOrPolygon(n, t, r));
  }
  /**
   * @param {Element} node Node.
   * @param {import("../geom/Point.js").default} point Point geometry.
   * @param {Array<*>} objectStack Node stack.
   */
  writePointMember(e, t, r) {
    const n = Nt(e.namespaceURI, "Point");
    e.appendChild(n), this.writePoint(n, t, r);
  }
  /**
   * @param {Node} node Node.
   * @param {LineString} line LineString geometry.
   * @param {Array<*>} objectStack Node stack.
   */
  writeLineStringOrCurveMember(e, t, r) {
    const n = this.GEOMETRY_NODE_FACTORY_(t, r);
    n && (e.appendChild(n), this.writeCurveOrLineString(n, t, r));
  }
  /**
   * @param {Element} node Node.
   * @param {Polygon} polygon Polygon geometry.
   * @param {Array<*>} objectStack Node stack.
   * @private
   */
  writeSurfacePatches_(e, t, r) {
    const n = Nt(e.namespaceURI, "PolygonPatch");
    e.appendChild(n), this.writeSurfaceOrPolygon(n, t, r);
  }
  /**
   * @param {Element} node Node.
   * @param {LineString} line LineString geometry.
   * @param {Array<*>} objectStack Node stack.
   * @private
   */
  writeCurveSegments_(e, t, r) {
    const n = Nt(e.namespaceURI, "LineStringSegment");
    e.appendChild(n), this.writeCurveOrLineString(n, t, r);
  }
  /**
   * @param {Node} node Node.
   * @param {import("../geom/Geometry.js").default|import("../extent.js").Extent} geometry Geometry.
   * @param {Array<*>} objectStack Node stack.
   */
  writeGeometryElement(e, t, r) {
    const n = (
      /** @type {import("./Feature.js").WriteOptions} */
      r[r.length - 1]
    ), s = Object.assign({}, n);
    s.node = e;
    let a;
    Array.isArray(t) ? a = yB(
      /** @type {import("../extent.js").Extent} */
      t,
      n
    ) : a = ui(
      /** @type {import("../geom/Geometry.js").default} */
      t,
      !0,
      n
    ), Rt(
      /** @type {import("../xml.js").NodeStackItem} */
      s,
      this.GEOMETRY_SERIALIZERS,
      this.GEOMETRY_NODE_FACTORY_,
      [a],
      r,
      void 0,
      this
    );
  }
  /**
   * @param {Element} node Node.
   * @param {import("../Feature.js").default} feature Feature.
   * @param {Array<*>} objectStack Node stack.
   */
  writeFeatureElement(e, t, r) {
    const n = t.getId();
    n && e.setAttribute(
      "fid",
      /** @type {string} */
      n
    );
    const s = (
      /** @type {Object} */
      r[r.length - 1]
    ), a = s.featureNS, o = t.getGeometryName();
    s.serializers || (s.serializers = {}, s.serializers[a] = {});
    const A = [], l = [];
    if (t.hasProperties()) {
      const c = t.getProperties();
      for (const u in c) {
        const f = c[u];
        f !== null && (A.push(u), l.push(f), u == o || typeof /** @type {?} */
        f.getSimplifiedGeometry == "function" ? u in s.serializers[a] || (s.serializers[a][u] = te(
          this.writeGeometryElement,
          this
        )) : u in s.serializers[a] || (s.serializers[a][u] = te(Tt)));
      }
    }
    const h = Object.assign({}, s);
    h.node = e, Rt(
      /** @type {import("../xml.js").NodeStackItem} */
      h,
      s.serializers,
      wi(void 0, a),
      l,
      r,
      A
    );
  }
  /**
   * @param {Node} node Node.
   * @param {Array<import("../Feature.js").default>} features Features.
   * @param {Array<*>} objectStack Node stack.
   * @private
   */
  writeFeatureMembers_(e, t, r) {
    const n = (
      /** @type {Object} */
      r[r.length - 1]
    ), s = n.featureType, a = n.featureNS, o = {};
    o[a] = {}, o[a][s] = te(
      this.writeFeatureElement,
      this
    );
    const A = Object.assign({}, n);
    A.node = e, Rt(
      /** @type {import("../xml.js").NodeStackItem} */
      A,
      o,
      wi(s, a),
      t,
      r
    );
  }
  /**
   * @const
   * @param {*} value Value.
   * @param {Array<*>} objectStack Object stack.
   * @param {string} [nodeName] Node name.
   * @return {Node|undefined} Node.
   * @private
   */
  MULTIGEOMETRY_MEMBER_NODE_FACTORY_(e, t, r) {
    const n = t[t.length - 1].node;
    return Nt(
      this.namespace,
      zq[n.nodeName]
    );
  }
  /**
   * @const
   * @param {*} value Value.
   * @param {Array<*>} objectStack Object stack.
   * @param {string} [nodeName] Node name.
   * @return {Element|undefined} Node.
   * @private
   */
  GEOMETRY_NODE_FACTORY_(e, t, r) {
    const n = t[t.length - 1], s = n.multiSurface, a = n.surface, o = n.curve, A = n.multiCurve;
    return Array.isArray(e) ? r = "Envelope" : (r = /** @type {import("../geom/Geometry.js").default} */
    e.getType(), r === "MultiPolygon" && s === !0 ? r = "MultiSurface" : r === "Polygon" && a === !0 ? r = "Surface" : r === "LineString" && o === !0 ? r = "Curve" : r === "MultiLineString" && A === !0 && (r = "MultiCurve")), Nt(this.namespace, r);
  }
  /**
   * Encode a geometry in GML 3.1.1 Simple Features.
   *
   * @param {import("../geom/Geometry.js").default} geometry Geometry.
   * @param {import("./Feature.js").WriteOptions} [options] Options.
   * @return {Node} Node.
   * @api
   */
  writeGeometryNode(e, t) {
    t = this.adaptOptions(t);
    const r = Nt(this.namespace, "geom"), n = {
      node: r,
      hasZ: this.hasZ,
      srsName: this.srsName,
      curve: this.curve_,
      surface: this.surface_,
      multiSurface: this.multiSurface_,
      multiCurve: this.multiCurve_
    };
    return t && Object.assign(n, t), this.writeGeometryElement(r, e, [n]), r;
  }
  /**
   * Encode an array of features in the GML 3.1.1 format as an XML node.
   *
   * @param {Array<import("../Feature.js").default>} features Features.
   * @param {import("./Feature.js").WriteOptions} [options] Options.
   * @return {Element} Node.
   * @api
   */
  writeFeaturesNode(e, t) {
    t = this.adaptOptions(t);
    const r = Nt(this.namespace, "featureMembers");
    r.setAttributeNS(
      wh,
      "xsi:schemaLocation",
      this.schemaLocation
    );
    const n = {
      srsName: this.srsName,
      hasZ: this.hasZ,
      curve: this.curve_,
      surface: this.surface_,
      multiSurface: this.multiSurface_,
      multiCurve: this.multiCurve_,
      featureNS: this.featureNS,
      featureType: this.featureType
    };
    return t && Object.assign(n, t), this.writeFeatureMembers_(r, e, [n]), r;
  }
}
ct.prototype.GEOMETRY_FLAT_COORDINATES_PARSERS = {
  "http://www.opengis.net/gml": {
    pos: wt(ct.prototype.readFlatPos),
    posList: wt(ct.prototype.readFlatPosList),
    coordinates: wt(Uu.prototype.readFlatCoordinates)
  }
};
ct.prototype.FLAT_LINEAR_RINGS_PARSERS = {
  "http://www.opengis.net/gml": {
    interior: ct.prototype.interiorParser,
    exterior: ct.prototype.exteriorParser
  }
};
ct.prototype.GEOMETRY_PARSERS = {
  "http://www.opengis.net/gml": {
    Point: wt(Xt.prototype.readPoint),
    MultiPoint: wt(Xt.prototype.readMultiPoint),
    LineString: wt(Xt.prototype.readLineString),
    MultiLineString: wt(Xt.prototype.readMultiLineString),
    LinearRing: wt(Xt.prototype.readLinearRing),
    Polygon: wt(Xt.prototype.readPolygon),
    MultiPolygon: wt(Xt.prototype.readMultiPolygon),
    Surface: wt(ct.prototype.readSurface),
    MultiSurface: wt(ct.prototype.readMultiSurface),
    Curve: wt(ct.prototype.readCurve),
    MultiCurve: wt(ct.prototype.readMultiCurve),
    Envelope: wt(ct.prototype.readEnvelope)
  }
};
ct.prototype.MULTICURVE_PARSERS = {
  "http://www.opengis.net/gml": {
    curveMember: ht(ct.prototype.curveMemberParser),
    curveMembers: ht(ct.prototype.curveMemberParser)
  }
};
ct.prototype.MULTISURFACE_PARSERS = {
  "http://www.opengis.net/gml": {
    surfaceMember: ht(ct.prototype.surfaceMemberParser),
    surfaceMembers: ht(ct.prototype.surfaceMemberParser)
  }
};
ct.prototype.CURVEMEMBER_PARSERS = {
  "http://www.opengis.net/gml": {
    LineString: ht(Xt.prototype.readLineString),
    Curve: ht(ct.prototype.readCurve)
  }
};
ct.prototype.SURFACEMEMBER_PARSERS = {
  "http://www.opengis.net/gml": {
    Polygon: ht(Xt.prototype.readPolygon),
    Surface: ht(ct.prototype.readSurface)
  }
};
ct.prototype.SURFACE_PARSERS = {
  "http://www.opengis.net/gml": {
    patches: wt(ct.prototype.readPatch)
  }
};
ct.prototype.CURVE_PARSERS = {
  "http://www.opengis.net/gml": {
    segments: wt(ct.prototype.readSegment)
  }
};
ct.prototype.ENVELOPE_PARSERS = {
  "http://www.opengis.net/gml": {
    lowerCorner: ht(ct.prototype.readFlatPosList),
    upperCorner: ht(ct.prototype.readFlatPosList)
  }
};
ct.prototype.PATCHES_PARSERS = {
  "http://www.opengis.net/gml": {
    PolygonPatch: wt(ct.prototype.readPolygonPatch)
  }
};
ct.prototype.SEGMENTS_PARSERS = {
  "http://www.opengis.net/gml": {
    LineStringSegment: nv(
      ct.prototype.readLineStringSegment
    )
  }
};
Xt.prototype.RING_PARSERS = {
  "http://www.opengis.net/gml": {
    LinearRing: wt(Xt.prototype.readFlatLinearRing),
    Ring: wt(ct.prototype.readFlatCurveRing)
  }
};
ct.prototype.writeFeatures;
ct.prototype.RING_SERIALIZERS = {
  "http://www.opengis.net/gml": {
    exterior: te(ct.prototype.writeRing),
    interior: te(ct.prototype.writeRing)
  }
};
ct.prototype.ENVELOPE_SERIALIZERS = {
  "http://www.opengis.net/gml": {
    lowerCorner: te(Tt),
    upperCorner: te(Tt)
  }
};
ct.prototype.SURFACEORPOLYGONMEMBER_SERIALIZERS = {
  "http://www.opengis.net/gml": {
    surfaceMember: te(
      ct.prototype.writeSurfaceOrPolygonMember
    ),
    polygonMember: te(
      ct.prototype.writeSurfaceOrPolygonMember
    )
  }
};
ct.prototype.POINTMEMBER_SERIALIZERS = {
  "http://www.opengis.net/gml": {
    pointMember: te(ct.prototype.writePointMember)
  }
};
ct.prototype.LINESTRINGORCURVEMEMBER_SERIALIZERS = {
  "http://www.opengis.net/gml": {
    lineStringMember: te(
      ct.prototype.writeLineStringOrCurveMember
    ),
    curveMember: te(
      ct.prototype.writeLineStringOrCurveMember
    )
  }
};
ct.prototype.GEOMETRY_SERIALIZERS = {
  "http://www.opengis.net/gml": {
    Curve: te(ct.prototype.writeCurveOrLineString),
    MultiCurve: te(ct.prototype.writeMultiCurveOrLineString),
    Point: te(ct.prototype.writePoint),
    MultiPoint: te(ct.prototype.writeMultiPoint),
    LineString: te(ct.prototype.writeCurveOrLineString),
    MultiLineString: te(
      ct.prototype.writeMultiCurveOrLineString
    ),
    LinearRing: te(ct.prototype.writeLinearRing),
    Polygon: te(ct.prototype.writeSurfaceOrPolygon),
    MultiPolygon: te(
      ct.prototype.writeMultiSurfaceOrPolygon
    ),
    Surface: te(ct.prototype.writeSurfaceOrPolygon),
    MultiSurface: te(
      ct.prototype.writeMultiSurfaceOrPolygon
    ),
    Envelope: te(ct.prototype.writeEnvelope)
  }
};
const zt = ct, xB = zt;
xB.prototype.writeFeatures;
xB.prototype.writeFeaturesNode;
const Xq = xB, en = [
  null,
  "http://www.topografix.com/GPX/1/0",
  "http://www.topografix.com/GPX/1/1"
], Wq = "http://www.topografix.com/GPX/1/1 http://www.topografix.com/GPX/1/1/gpx.xsd", Yq = {
  rte: xN,
  trk: CN,
  wpt: EN
}, qq = we(en, {
  rte: ht(xN),
  trk: ht(CN),
  wpt: ht(EN)
}), Zq = we(en, {
  text: J(Me, "linkText"),
  type: J(Me, "linkType")
}), Jq = we(en, {
  rte: te(CZ),
  trk: te(EZ),
  wpt: te(bZ)
});
class eZ extends Tg {
  /**
   * @param {Options} [options] Options.
   */
  constructor(e) {
    super(), e = e || {}, this.dataProjection = Ct("EPSG:4326"), this.readExtensions_ = e.readExtensions;
  }
  /**
   * @param {Array<Feature>} features List of features.
   * @private
   */
  handleReadExtensions_(e) {
    e || (e = []);
    for (let t = 0, r = e.length; t < r; ++t) {
      const n = e[t];
      if (this.readExtensions_) {
        const s = n.get("extensionsNode_") || null;
        this.readExtensions_(n, s);
      }
      n.set("extensionsNode_", void 0);
    }
  }
  /**
   * @param {Element} node Node.
   * @param {import("./Feature.js").ReadOptions} [options] Options.
   * @return {import("../Feature.js").default} Feature.
   */
  readFeatureFromNode(e, t) {
    if (!en.includes(e.namespaceURI))
      return null;
    const r = Yq[e.localName];
    if (!r)
      return null;
    const n = r(e, [this.getReadOptions(e, t)]);
    return n ? (this.handleReadExtensions_([n]), n) : null;
  }
  /**
   * @param {Element} node Node.
   * @param {import("./Feature.js").ReadOptions} [options] Options.
   * @return {Array<import("../Feature.js").default>} Features.
   */
  readFeaturesFromNode(e, t) {
    if (!en.includes(e.namespaceURI))
      return [];
    if (e.localName == "gpx") {
      const r = Se([], qq, e, [
        this.getReadOptions(e, t)
      ]);
      return r ? (this.handleReadExtensions_(r), r) : [];
    }
    return [];
  }
  /**
   * Encode an array of features in the GPX format as an XML node.
   * LineString geometries are output as routes (`<rte>`), and MultiLineString
   * as tracks (`<trk>`).
   *
   * @param {Array<Feature>} features Features.
   * @param {import("./Feature.js").WriteOptions} [options] Options.
   * @return {Node} Node.
   * @api
   */
  writeFeaturesNode(e, t) {
    t = this.adaptOptions(t);
    const r = Nt("http://www.topografix.com/GPX/1/1", "gpx"), n = "http://www.w3.org/2000/xmlns/";
    return r.setAttributeNS(n, "xmlns:xsi", wh), r.setAttributeNS(
      wh,
      "xsi:schemaLocation",
      Wq
    ), r.setAttribute("version", "1.1"), r.setAttribute("creator", "OpenLayers"), Rt(
      /** @type {import("../xml.js").NodeStackItem} */
      { node: r },
      Jq,
      yZ,
      e,
      [t]
    ), r;
  }
}
const tZ = we(en, {
  name: J(Me),
  cmt: J(Me),
  desc: J(Me),
  src: J(Me),
  link: BB,
  number: J(Hi),
  extensions: bB,
  type: J(Me),
  rtept: _Z
}), rZ = we(en, {
  ele: J(xr),
  time: J(wB)
}), iZ = we(en, {
  name: J(Me),
  cmt: J(Me),
  desc: J(Me),
  src: J(Me),
  link: BB,
  number: J(Hi),
  type: J(Me),
  extensions: bB,
  trkseg: xZ
}), nZ = we(en, {
  trkpt: wZ
}), sZ = we(en, {
  ele: J(xr),
  time: J(wB)
}), aZ = we(en, {
  ele: J(xr),
  time: J(wB),
  magvar: J(xr),
  geoidheight: J(xr),
  name: J(Me),
  cmt: J(Me),
  desc: J(Me),
  src: J(Me),
  link: BB,
  sym: J(Me),
  type: J(Me),
  fix: J(Me),
  sat: J(Hi),
  hdop: J(xr),
  vdop: J(xr),
  pdop: J(xr),
  ageofdgpsdata: J(xr),
  dgpsid: J(Hi),
  extensions: bB
}), oZ = ["text", "type"], AZ = we(en, {
  text: te(Tt),
  type: te(Tt)
}), lZ = we(en, [
  "name",
  "cmt",
  "desc",
  "src",
  "link",
  "number",
  "type",
  "rtept"
]), hZ = we(en, {
  name: te(Tt),
  cmt: te(Tt),
  desc: te(Tt),
  src: te(Tt),
  link: te(SB),
  number: te(sv),
  type: te(Tt),
  rtept: _N(te(TB))
}), cZ = we(en, ["ele", "time"]), uZ = we(en, [
  "name",
  "cmt",
  "desc",
  "src",
  "link",
  "number",
  "type",
  "trkseg"
]), fZ = we(en, {
  name: te(Tt),
  cmt: te(Tt),
  desc: te(Tt),
  src: te(Tt),
  link: te(SB),
  number: te(sv),
  type: te(Tt),
  trkseg: _N(te(BZ))
}), dZ = wi("trkpt"), gZ = we(en, {
  trkpt: te(TB)
}), pZ = we(en, [
  "ele",
  "time",
  "magvar",
  "geoidheight",
  "name",
  "cmt",
  "desc",
  "src",
  "link",
  "sym",
  "type",
  "fix",
  "sat",
  "hdop",
  "vdop",
  "pdop",
  "ageofdgpsdata",
  "dgpsid"
]), mZ = we(en, {
  ele: te(us),
  time: te($q),
  magvar: te(us),
  geoidheight: te(us),
  name: te(Tt),
  cmt: te(Tt),
  desc: te(Tt),
  src: te(Tt),
  link: te(SB),
  sym: te(Tt),
  type: te(Tt),
  fix: te(Tt),
  sat: te(sv),
  hdop: te(us),
  vdop: te(us),
  pdop: te(us),
  ageofdgpsdata: te(us),
  dgpsid: te(sv)
}), vZ = {
  Point: "wpt",
  LineString: "rte",
  MultiLineString: "trk"
};
function yZ(i, e, t) {
  const r = (
    /** @type {Feature} */
    i.getGeometry()
  );
  if (r) {
    const n = vZ[r.getType()];
    if (n) {
      const s = e[e.length - 1].node;
      return Nt(s.namespaceURI, n);
    }
  }
}
function CB(i, e, t, r) {
  return i.push(
    parseFloat(t.getAttribute("lon")),
    parseFloat(t.getAttribute("lat"))
  ), "ele" in r ? (i.push(
    /** @type {number} */
    r.ele
  ), delete r.ele, e.hasZ = !0) : i.push(0), "time" in r ? (i.push(
    /** @type {number} */
    r.time
  ), delete r.time, e.hasM = !0) : i.push(0), i;
}
function EB(i, e, t) {
  let r = "XY", n = 2;
  if (i.hasZ && i.hasM ? (r = "XYZM", n = 4) : i.hasZ ? (r = "XYZ", n = 3) : i.hasM && (r = "XYM", n = 3), n !== 4) {
    for (let s = 0, a = e.length / 4; s < a; s++)
      e[s * n] = e[s * 4], e[s * n + 1] = e[s * 4 + 1], i.hasZ && (e[s * n + 2] = e[s * 4 + 2]), i.hasM && (e[s * n + 2] = e[s * 4 + 3]);
    if (e.length = e.length / 4 * n, t)
      for (let s = 0, a = t.length; s < a; s++)
        t[s] = t[s] / 4 * n;
  }
  return r;
}
function BB(i, e) {
  const t = (
    /** @type {Object} */
    e[e.length - 1]
  ), r = i.getAttribute("href");
  r !== null && (t.link = r), gs(Zq, i, e);
}
function bB(i, e) {
  const t = (
    /** @type {Object} */
    e[e.length - 1]
  );
  t.extensionsNode_ = i;
}
function _Z(i, e) {
  const t = Se({}, rZ, i, e);
  if (t) {
    const r = (
      /** @type {!Object} */
      e[e.length - 1]
    ), n = (
      /** @type {Array<number>} */
      r.flatCoordinates
    ), s = (
      /** @type {LayoutOptions} */
      r.layoutOptions
    );
    CB(n, s, i, t);
  }
}
function wZ(i, e) {
  const t = Se({}, sZ, i, e);
  if (t) {
    const r = (
      /** @type {!Object} */
      e[e.length - 1]
    ), n = (
      /** @type {Array<number>} */
      r.flatCoordinates
    ), s = (
      /** @type {LayoutOptions} */
      r.layoutOptions
    );
    CB(n, s, i, t);
  }
}
function xZ(i, e) {
  const t = (
    /** @type {Object} */
    e[e.length - 1]
  );
  gs(nZ, i, e);
  const r = (
    /** @type {Array<number>} */
    t.flatCoordinates
  );
  /** @type {Array<number>} */
  t.ends.push(r.length);
}
function xN(i, e) {
  const t = (
    /** @type {import("./Feature.js").ReadOptions} */
    e[0]
  ), r = Se(
    {
      flatCoordinates: [],
      layoutOptions: {}
    },
    tZ,
    i,
    e
  );
  if (!r)
    return;
  const n = (
    /** @type {Array<number>} */
    r.flatCoordinates
  );
  delete r.flatCoordinates;
  const s = (
    /** @type {LayoutOptions} */
    r.layoutOptions
  );
  delete r.layoutOptions;
  const a = EB(s, n), o = new Gr(n, a);
  ui(o, !1, t);
  const A = new qt(o);
  return A.setProperties(r, !0), A;
}
function CN(i, e) {
  const t = (
    /** @type {import("./Feature.js").ReadOptions} */
    e[0]
  ), r = Se(
    {
      flatCoordinates: [],
      ends: [],
      layoutOptions: {}
    },
    iZ,
    i,
    e
  );
  if (!r)
    return;
  const n = (
    /** @type {Array<number>} */
    r.flatCoordinates
  );
  delete r.flatCoordinates;
  const s = (
    /** @type {Array<number>} */
    r.ends
  );
  delete r.ends;
  const a = (
    /** @type {LayoutOptions} */
    r.layoutOptions
  );
  delete r.layoutOptions;
  const o = EB(a, n, s), A = new In(n, o, s);
  ui(A, !1, t);
  const l = new qt(A);
  return l.setProperties(r, !0), l;
}
function EN(i, e) {
  const t = (
    /** @type {import("./Feature.js").ReadOptions} */
    e[0]
  ), r = Se({}, aZ, i, e);
  if (!r)
    return;
  const n = (
    /** @type {LayoutOptions} */
    {}
  ), s = CB([], n, i, r), a = EB(n, s), o = new gr(s, a);
  ui(o, !1, t);
  const A = new qt(o);
  return A.setProperties(r, !0), A;
}
function SB(i, e, t) {
  i.setAttribute("href", e);
  const n = t[t.length - 1].properties, s = [n.linkText, n.linkType];
  Rt(
    /** @type {import("../xml.js").NodeStackItem} */
    { node: i },
    AZ,
    wn,
    s,
    t,
    oZ
  );
}
function TB(i, e, t) {
  const r = t[t.length - 1], s = r.node.namespaceURI, a = r.properties;
  switch (i.setAttributeNS(null, "lat", String(e[1])), i.setAttributeNS(null, "lon", String(e[0])), r.geometryLayout) {
    case "XYZM":
      e[3] !== 0 && (a.time = e[3]);
    case "XYZ":
      e[2] !== 0 && (a.ele = e[2]);
      break;
    case "XYM":
      e[2] !== 0 && (a.time = e[2]);
      break;
  }
  const A = i.nodeName == "rtept" ? cZ[s] : pZ[s], l = ys(a, A);
  Rt(
    /** @type {import("../xml.js").NodeStackItem} */
    { node: i, properties: a },
    mZ,
    wn,
    l,
    t,
    A
  );
}
function CZ(i, e, t) {
  const r = (
    /** @type {import("./Feature.js").WriteOptions} */
    t[0]
  ), n = e.getProperties(), s = { node: i };
  s.properties = n;
  const a = e.getGeometry();
  if (a.getType() == "LineString") {
    const h = (
      /** @type {LineString} */
      ui(a, !0, r)
    );
    s.geometryLayout = h.getLayout(), n.rtept = h.getCoordinates();
  }
  const o = t[t.length - 1].node, A = lZ[o.namespaceURI], l = ys(n, A);
  Rt(
    s,
    hZ,
    wn,
    l,
    t,
    A
  );
}
function EZ(i, e, t) {
  const r = (
    /** @type {import("./Feature.js").WriteOptions} */
    t[0]
  ), n = e.getProperties(), s = { node: i };
  s.properties = n;
  const a = e.getGeometry();
  if (a.getType() == "MultiLineString") {
    const h = (
      /** @type {MultiLineString} */
      ui(a, !0, r)
    );
    n.trkseg = h.getLineStrings();
  }
  const o = t[t.length - 1].node, A = uZ[o.namespaceURI], l = ys(n, A);
  Rt(
    s,
    fZ,
    wn,
    l,
    t,
    A
  );
}
function BZ(i, e, t) {
  const r = { node: i };
  r.geometryLayout = e.getLayout(), r.properties = {}, Rt(
    r,
    gZ,
    dZ,
    e.getCoordinates(),
    t
  );
}
function bZ(i, e, t) {
  const r = (
    /** @type {import("./Feature.js").WriteOptions} */
    t[0]
  ), n = t[t.length - 1];
  n.properties = e.getProperties();
  const s = e.getGeometry();
  if (s.getType() == "Point") {
    const a = (
      /** @type {Point} */
      ui(s, !0, r)
    );
    n.geometryLayout = a.getLayout(), TB(i, a.getCoordinates(), t);
  }
}
const SZ = eZ;
class TZ extends bg {
  constructor() {
    super();
  }
  /**
   * @return {import("./Feature.js").Type} Format.
   */
  getType() {
    return "text";
  }
  /**
   * Read the feature from the source.
   *
   * @param {Document|Element|Object|string} source Source.
   * @param {import("./Feature.js").ReadOptions} [options] Read options.
   * @return {import("../Feature.js").default} Feature.
   * @api
   */
  readFeature(e, t) {
    return this.readFeatureFromText(
      Yp(e),
      this.adaptOptions(t)
    );
  }
  /**
   * @abstract
   * @param {string} text Text.
   * @param {import("./Feature.js").ReadOptions} [options] Read options.
   * @protected
   * @return {import("../Feature.js").default} Feature.
   */
  readFeatureFromText(e, t) {
    return pt();
  }
  /**
   * Read the features from the source.
   *
   * @param {Document|Element|Object|string} source Source.
   * @param {import("./Feature.js").ReadOptions} [options] Read options.
   * @return {Array<import("../Feature.js").default>} Features.
   * @api
   */
  readFeatures(e, t) {
    return this.readFeaturesFromText(
      Yp(e),
      this.adaptOptions(t)
    );
  }
  /**
   * @abstract
   * @param {string} text Text.
   * @param {import("./Feature.js").ReadOptions} [options] Read options.
   * @protected
   * @return {Array<import("../Feature.js").default>} Features.
   */
  readFeaturesFromText(e, t) {
    return pt();
  }
  /**
   * Read the geometry from the source.
   *
   * @param {Document|Element|Object|string} source Source.
   * @param {import("./Feature.js").ReadOptions} [options] Read options.
   * @return {import("../geom/Geometry.js").default} Geometry.
   * @api
   */
  readGeometry(e, t) {
    return this.readGeometryFromText(
      Yp(e),
      this.adaptOptions(t)
    );
  }
  /**
   * @abstract
   * @param {string} text Text.
   * @param {import("./Feature.js").ReadOptions} [options] Read options.
   * @protected
   * @return {import("../geom/Geometry.js").default} Geometry.
   */
  readGeometryFromText(e, t) {
    return pt();
  }
  /**
   * Read the projection from the source.
   *
   * @param {Document|Element|Object|string} source Source.
   * @return {import("../proj/Projection.js").default|undefined} Projection.
   * @api
   */
  readProjection(e) {
    return this.readProjectionFromText(Yp(e));
  }
  /**
   * @param {string} text Text.
   * @protected
   * @return {import("../proj/Projection.js").default|undefined} Projection.
   */
  readProjectionFromText(e) {
    return this.dataProjection;
  }
  /**
   * Encode a feature as a string.
   *
   * @param {import("../Feature.js").default} feature Feature.
   * @param {import("./Feature.js").WriteOptions} [options] Write options.
   * @return {string} Encoded feature.
   * @api
   */
  writeFeature(e, t) {
    return this.writeFeatureText(e, this.adaptOptions(t));
  }
  /**
   * @abstract
   * @param {import("../Feature.js").default} feature Features.
   * @param {import("./Feature.js").WriteOptions} [options] Write options.
   * @protected
   * @return {string} Text.
   */
  writeFeatureText(e, t) {
    return pt();
  }
  /**
   * Encode an array of features as string.
   *
   * @param {Array<import("../Feature.js").default>} features Features.
   * @param {import("./Feature.js").WriteOptions} [options] Write options.
   * @return {string} Encoded features.
   * @api
   */
  writeFeatures(e, t) {
    return this.writeFeaturesText(e, this.adaptOptions(t));
  }
  /**
   * @abstract
   * @param {Array<import("../Feature.js").default>} features Features.
   * @param {import("./Feature.js").WriteOptions} [options] Write options.
   * @protected
   * @return {string} Text.
   */
  writeFeaturesText(e, t) {
    return pt();
  }
  /**
   * Write a single geometry.
   *
   * @param {import("../geom/Geometry.js").default} geometry Geometry.
   * @param {import("./Feature.js").WriteOptions} [options] Write options.
   * @return {string} Geometry.
   * @api
   */
  writeGeometry(e, t) {
    return this.writeGeometryText(e, this.adaptOptions(t));
  }
  /**
   * @abstract
   * @param {import("../geom/Geometry.js").default} geometry Geometry.
   * @param {import("./Feature.js").WriteOptions} [options] Write options.
   * @protected
   * @return {string} Text.
   */
  writeGeometryText(e, t) {
    return pt();
  }
}
function Yp(i) {
  return typeof i == "string" ? i : "";
}
const FB = TZ, FZ = /^B(\d{2})(\d{2})(\d{2})(\d{2})(\d{5})([NS])(\d{3})(\d{5})([EW])([AV])(\d{5})(\d{5})/, LZ = /^H.([A-Z]{3}).*?:(.*)/, IZ = /^HFDTE(\d{2})(\d{2})(\d{2})/, RZ = /\r\n|\r|\n/;
class MZ extends FB {
  /**
   * @param {Options} [options] Options.
   */
  constructor(e) {
    super(), e = e || {}, this.dataProjection = Ct("EPSG:4326"), this.altitudeMode_ = e.altitudeMode ? e.altitudeMode : "none";
  }
  /**
   * @protected
   * @param {string} text Text.
   * @param {import("./Feature.js").ReadOptions} [options] Read options.
   * @return {import("../Feature.js").default} Feature.
   */
  readFeatureFromText(e, t) {
    const r = this.altitudeMode_, n = e.split(RZ), s = {}, a = [];
    let o = 2e3, A = 0, l = 1, h = -1, c, u;
    for (c = 0, u = n.length; c < u; ++c) {
      const y = n[c];
      let v;
      if (y.charAt(0) == "B") {
        if (v = FZ.exec(y), v) {
          const w = parseInt(v[1], 10), C = parseInt(v[2], 10), E = parseInt(v[3], 10);
          let S = parseInt(v[4], 10) + parseInt(v[5], 10) / 6e4;
          v[6] == "S" && (S = -S);
          let M = parseInt(v[7], 10) + parseInt(v[8], 10) / 6e4;
          if (v[9] == "W" && (M = -M), a.push(M, S), r != "none") {
            let F;
            r == "gps" ? F = parseInt(v[11], 10) : r == "barometric" ? F = parseInt(v[12], 10) : F = 0, a.push(F);
          }
          let T = Date.UTC(o, A, l, w, C, E);
          T < h && (T = Date.UTC(o, A, l + 1, w, C, E)), a.push(T / 1e3), h = T;
        }
      } else
        y.charAt(0) == "H" && (v = IZ.exec(y), v ? (l = parseInt(v[1], 10), A = parseInt(v[2], 10) - 1, o = 2e3 + parseInt(v[3], 10)) : (v = LZ.exec(y), v && (s[v[1]] = v[2].trim())));
    }
    if (a.length === 0)
      return null;
    const f = r == "none" ? "XYM" : "XYZM", g = new Gr(a, f), p = new qt(
      ui(g, !1, t)
    );
    return p.setProperties(s, !0), p;
  }
  /**
   * @param {string} text Text.
   * @param {import("./Feature.js").ReadOptions} [options] Read options.
   * @protected
   * @return {Array<Feature>} Features.
   */
  readFeaturesFromText(e, t) {
    const r = this.readFeatureFromText(e, t);
    return r ? [r] : [];
  }
}
const NZ = MZ, oA = ["http://www.google.com/kml/ext/2.2"], dt = [
  null,
  "http://earth.google.com/kml/2.0",
  "http://earth.google.com/kml/2.1",
  "http://earth.google.com/kml/2.2",
  "http://www.opengis.net/kml/2.2"
], PZ = "http://www.opengis.net/kml/2.2 https://developers.google.com/kml/schema/kml22gx.xsd", mT = {
  fraction: "fraction",
  pixels: "pixels",
  insetPixels: "pixels"
}, OZ = we(
  dt,
  {
    ExtendedData: DN,
    Region: kN,
    MultiGeometry: J(ON, "geometry"),
    LineString: J(NN, "geometry"),
    LinearRing: J(PN, "geometry"),
    Point: J(UN, "geometry"),
    Polygon: J(QN, "geometry"),
    Style: J(RB),
    StyleMap: vJ,
    address: J(Me),
    description: J(Me),
    name: J(Me),
    open: J(pl),
    phoneNumber: J(Me),
    styleUrl: J(FN),
    visibility: J(pl)
  },
  we(oA, {
    MultiTrack: J(sJ, "geometry"),
    Track: J(MN, "geometry")
  })
), UZ = we(dt, {
  ExtendedData: DN,
  Region: kN,
  Link: LJ,
  address: J(Me),
  description: J(Me),
  name: J(Me),
  open: J(pl),
  phoneNumber: J(Me),
  visibility: J(pl)
}), QZ = we(dt, {
  href: J(TN)
}), BN = we(dt, {
  LatLonAltBox: CJ,
  Lod: BJ
}), DZ = we(dt, ["Document", "Placemark"]), kZ = we(dt, {
  Document: te(QJ),
  Placemark: te($N)
});
let su, Z0 = null, kx, pd, md, vd, av, Hx = null, LB, Gx = null, $x, Wl = null, vT = null, Vx = null;
function ov(i) {
  return 32 / Math.min(i[0], i[1]);
}
function HZ() {
  su = [255, 255, 255, 1], Z0 = new Wn({
    color: su
  }), kx = [20, 2], pd = "pixels", md = "pixels", vd = [64, 64], av = "https://maps.google.com/mapfiles/kml/pushpin/ylw-pushpin.png", Hx = new Mu({
    anchor: kx,
    anchorOrigin: "bottom-left",
    anchorXUnits: pd,
    anchorYUnits: md,
    crossOrigin: "anonymous",
    rotation: 0,
    scale: ov(vd),
    size: vd,
    src: av
  }), LB = "NO_IMAGE", Gx = new Zi({
    color: su,
    width: 1
  }), $x = new Zi({
    color: [51, 51, 51, 1],
    width: 2
  }), Wl = new ih({
    font: "bold 16px Helvetica",
    fill: Z0,
    stroke: $x,
    scale: 0.8
  }), vT = new ln({
    fill: Z0,
    image: Hx,
    text: Wl,
    stroke: Gx,
    zIndex: 0
  }), Vx = [vT];
}
let qp;
function GZ(i) {
  return i;
}
class $Z extends Tg {
  /**
   * @param {Options} [options] Options.
   */
  constructor(e) {
    super(), e = e || {}, Vx || HZ(), this.dataProjection = Ct("EPSG:4326"), this.defaultStyle_ = e.defaultStyle ? e.defaultStyle : Vx, this.extractStyles_ = e.extractStyles !== void 0 ? e.extractStyles : !0, this.writeStyles_ = e.writeStyles !== void 0 ? e.writeStyles : !0, this.sharedStyles_ = {}, this.showPointNames_ = e.showPointNames !== void 0 ? e.showPointNames : !0, this.crossOrigin_ = e.crossOrigin !== void 0 ? e.crossOrigin : "anonymous", this.iconUrlFunction_ = e.iconUrlFunction ? e.iconUrlFunction : GZ, this.supportedMediaTypes = ["application/vnd.google-earth.kml+xml"];
  }
  /**
   * @param {Node} node Node.
   * @param {Array<*>} objectStack Object stack.
   * @private
   * @return {Array<Feature>|undefined} Features.
   */
  readDocumentOrFolder_(e, t) {
    const r = we(dt, {
      Document: nv(this.readDocumentOrFolder_, this),
      Folder: nv(this.readDocumentOrFolder_, this),
      Placemark: ht(this.readPlacemark_, this),
      Style: this.readSharedStyle_.bind(this),
      StyleMap: this.readSharedStyleMap_.bind(this)
    }), n = Se([], r, e, t, this);
    if (n)
      return n;
  }
  /**
   * @param {Element} node Node.
   * @param {Array<*>} objectStack Object stack.
   * @private
   * @return {Feature|undefined} Feature.
   */
  readPlacemark_(e, t) {
    const r = Se(
      { geometry: null },
      OZ,
      e,
      t,
      this
    );
    if (!r)
      return;
    const n = new qt(), s = e.getAttribute("id");
    s !== null && n.setId(s);
    const a = (
      /** @type {import("./Feature.js").ReadOptions} */
      t[0]
    ), o = r.geometry;
    if (o && ui(o, !1, a), n.setGeometry(o), delete r.geometry, this.extractStyles_) {
      const A = r.Style, l = r.styleUrl, h = KZ(
        A,
        l,
        this.defaultStyle_,
        this.sharedStyles_,
        this.showPointNames_
      );
      n.setStyle(h);
    }
    return delete r.Style, n.setProperties(r, !0), n;
  }
  /**
   * @param {Element} node Node.
   * @param {Array<*>} objectStack Object stack.
   * @private
   */
  readSharedStyle_(e, t) {
    const r = e.getAttribute("id");
    if (r !== null) {
      const n = RB.call(this, e, t);
      if (n) {
        let s, a = e.baseURI;
        (!a || a == "about:blank") && (a = window.location.href), a ? s = new URL("#" + r, a).href : s = "#" + r, this.sharedStyles_[s] = n;
      }
    }
  }
  /**
   * @param {Element} node Node.
   * @param {Array<*>} objectStack Object stack.
   * @private
   */
  readSharedStyleMap_(e, t) {
    const r = e.getAttribute("id");
    if (r === null)
      return;
    const n = IN.call(this, e, t);
    if (!n)
      return;
    let s, a = e.baseURI;
    (!a || a == "about:blank") && (a = window.location.href), a ? s = new URL("#" + r, a).href : s = "#" + r, this.sharedStyles_[s] = n;
  }
  /**
   * @param {Element} node Node.
   * @param {import("./Feature.js").ReadOptions} [options] Options.
   * @return {import("../Feature.js").default} Feature.
   */
  readFeatureFromNode(e, t) {
    if (!dt.includes(e.namespaceURI))
      return null;
    const r = this.readPlacemark_(e, [
      this.getReadOptions(e, t)
    ]);
    return r || null;
  }
  /**
   * @protected
   * @param {Element} node Node.
   * @param {import("./Feature.js").ReadOptions} [options] Options.
   * @return {Array<import("../Feature.js").default>} Features.
   */
  readFeaturesFromNode(e, t) {
    if (!dt.includes(e.namespaceURI))
      return [];
    let r;
    const n = e.localName;
    if (n == "Document" || n == "Folder")
      return r = this.readDocumentOrFolder_(e, [
        this.getReadOptions(e, t)
      ]), r || [];
    if (n == "Placemark") {
      const s = this.readPlacemark_(e, [
        this.getReadOptions(e, t)
      ]);
      return s ? [s] : [];
    } else if (n == "kml") {
      r = [];
      for (let s = e.firstElementChild; s; s = s.nextElementSibling) {
        const a = this.readFeaturesFromNode(s, t);
        a && Er(r, a);
      }
      return r;
    }
    return [];
  }
  /**
   * Read the name of the KML.
   *
   * @param {Document|Element|string} source Source.
   * @return {string|undefined} Name.
   * @api
   */
  readName(e) {
    if (e) {
      if (typeof e == "string") {
        const t = Ka(e);
        return this.readNameFromDocument(t);
      } else if (Va(e))
        return this.readNameFromDocument(
          /** @type {Document} */
          e
        );
    } else
      return;
    return this.readNameFromNode(
      /** @type {Element} */
      e
    );
  }
  /**
   * @param {Document} doc Document.
   * @return {string|undefined} Name.
   */
  readNameFromDocument(e) {
    for (let t = (
      /** @type {Node} */
      e.firstChild
    ); t; t = t.nextSibling)
      if (t.nodeType == Node.ELEMENT_NODE) {
        const r = this.readNameFromNode(
          /** @type {Element} */
          t
        );
        if (r)
          return r;
      }
  }
  /**
   * @param {Element} node Node.
   * @return {string|undefined} Name.
   */
  readNameFromNode(e) {
    for (let t = e.firstElementChild; t; t = t.nextElementSibling)
      if (dt.includes(t.namespaceURI) && t.localName == "name")
        return Me(t);
    for (let t = e.firstElementChild; t; t = t.nextElementSibling) {
      const r = t.localName;
      if (dt.includes(t.namespaceURI) && (r == "Document" || r == "Folder" || r == "Placemark" || r == "kml")) {
        const n = this.readNameFromNode(t);
        if (n)
          return n;
      }
    }
  }
  /**
   * Read the network links of the KML.
   *
   * @param {Document|Element|string} source Source.
   * @return {Array<Object>} Network links.
   * @api
   */
  readNetworkLinks(e) {
    const t = [];
    if (typeof e == "string") {
      const r = Ka(e);
      Er(t, this.readNetworkLinksFromDocument(r));
    } else
      Va(e) ? Er(
        t,
        this.readNetworkLinksFromDocument(
          /** @type {Document} */
          e
        )
      ) : Er(
        t,
        this.readNetworkLinksFromNode(
          /** @type {Element} */
          e
        )
      );
    return t;
  }
  /**
   * @param {Document} doc Document.
   * @return {Array<Object>} Network links.
   */
  readNetworkLinksFromDocument(e) {
    const t = [];
    for (let r = (
      /** @type {Node} */
      e.firstChild
    ); r; r = r.nextSibling)
      r.nodeType == Node.ELEMENT_NODE && Er(
        t,
        this.readNetworkLinksFromNode(
          /** @type {Element} */
          r
        )
      );
    return t;
  }
  /**
   * @param {Element} node Node.
   * @return {Array<Object>} Network links.
   */
  readNetworkLinksFromNode(e) {
    const t = [];
    for (let r = e.firstElementChild; r; r = r.nextElementSibling)
      if (dt.includes(r.namespaceURI) && r.localName == "NetworkLink") {
        const n = Se({}, UZ, r, []);
        t.push(n);
      }
    for (let r = e.firstElementChild; r; r = r.nextElementSibling) {
      const n = r.localName;
      dt.includes(r.namespaceURI) && (n == "Document" || n == "Folder" || n == "kml") && Er(t, this.readNetworkLinksFromNode(r));
    }
    return t;
  }
  /**
   * Read the regions of the KML.
   *
   * @param {Document|Element|string} source Source.
   * @return {Array<Object>} Regions.
   * @api
   */
  readRegion(e) {
    const t = [];
    if (typeof e == "string") {
      const r = Ka(e);
      Er(t, this.readRegionFromDocument(r));
    } else
      Va(e) ? Er(
        t,
        this.readRegionFromDocument(
          /** @type {Document} */
          e
        )
      ) : Er(t, this.readRegionFromNode(
        /** @type {Element} */
        e
      ));
    return t;
  }
  /**
   * @param {Document} doc Document.
   * @return {Array<Object>} Region.
   */
  readRegionFromDocument(e) {
    const t = [];
    for (let r = (
      /** @type {Node} */
      e.firstChild
    ); r; r = r.nextSibling)
      r.nodeType == Node.ELEMENT_NODE && Er(t, this.readRegionFromNode(
        /** @type {Element} */
        r
      ));
    return t;
  }
  /**
   * @param {Element} node Node.
   * @return {Array<Object>} Region.
   * @api
   */
  readRegionFromNode(e) {
    const t = [];
    for (let r = e.firstElementChild; r; r = r.nextElementSibling)
      if (dt.includes(r.namespaceURI) && r.localName == "Region") {
        const n = Se({}, BN, r, []);
        t.push(n);
      }
    for (let r = e.firstElementChild; r; r = r.nextElementSibling) {
      const n = r.localName;
      dt.includes(r.namespaceURI) && (n == "Document" || n == "Folder" || n == "kml") && Er(t, this.readRegionFromNode(r));
    }
    return t;
  }
  /**
   * Encode an array of features in the KML format as an XML node. GeometryCollections,
   * MultiPoints, MultiLineStrings, and MultiPolygons are output as MultiGeometries.
   *
   * @param {Array<Feature>} features Features.
   * @param {import("./Feature.js").WriteOptions} [options] Options.
   * @return {Node} Node.
   * @api
   */
  writeFeaturesNode(e, t) {
    t = this.adaptOptions(t);
    const r = Nt(dt[4], "kml"), n = "http://www.w3.org/2000/xmlns/";
    r.setAttributeNS(n, "xmlns:gx", oA[0]), r.setAttributeNS(n, "xmlns:xsi", wh), r.setAttributeNS(
      wh,
      "xsi:schemaLocation",
      PZ
    );
    const s = {
      node: r
    }, a = {};
    e.length > 1 ? a.Document = e : e.length == 1 && (a.Placemark = e[0]);
    const o = DZ[r.namespaceURI], A = ys(a, o);
    return Rt(
      s,
      kZ,
      wn,
      A,
      [t],
      o,
      this
    ), r;
  }
}
function VZ(i, e) {
  const t = [0, 0];
  let r = "start";
  const n = i.getImage();
  if (n) {
    const o = n.getSize();
    if (o && o.length == 2) {
      const A = n.getScaleArray(), l = n.getAnchor();
      t[0] = A[0] * (o[0] - l[0]), t[1] = A[1] * (o[1] / 2 - l[1]), r = "left";
    }
  }
  let s = i.getText();
  return s ? (s = s.clone(), s.setFont(s.getFont() || Wl.getFont()), s.setScale(s.getScale() || Wl.getScale()), s.setFill(s.getFill() || Wl.getFill()), s.setStroke(s.getStroke() || $x)) : s = Wl.clone(), s.setText(e), s.setOffsetX(t[0]), s.setOffsetY(t[1]), s.setTextAlign(r), new ln({
    image: n,
    text: s
  });
}
function KZ(i, e, t, r, n) {
  return (
    /**
     * @param {Feature} feature feature.
     * @param {number} resolution Resolution.
     * @return {Array<Style>|Style} Style.
     */
    function(s, a) {
      let o = n, A = "", l = [];
      if (o) {
        const c = s.getGeometry();
        if (c)
          if (c instanceof _n)
            l = c.getGeometriesArrayRecursive().filter(function(u) {
              const f = u.getType();
              return f === "Point" || f === "MultiPoint";
            }), o = l.length > 0;
          else {
            const u = c.getType();
            o = u === "Point" || u === "MultiPoint";
          }
      }
      o && (A = /** @type {string} */
      s.get("name"), o = o && !!A, o && /&[^&]+;/.test(A) && (qp || (qp = document.createElement("textarea")), qp.innerHTML = A, A = qp.value));
      let h = t;
      if (i ? h = i : e && (h = bN(e, t, r)), o) {
        const c = VZ(h[0], A);
        if (l.length > 0) {
          c.setGeometry(new _n(l));
          const u = new ln({
            geometry: h[0].getGeometry(),
            image: null,
            fill: h[0].getFill(),
            stroke: h[0].getStroke(),
            text: null
          });
          return [c, u].concat(h.slice(1));
        }
        return c;
      }
      return h;
    }
  );
}
function bN(i, e, t) {
  return Array.isArray(i) ? i : typeof i == "string" ? bN(t[i], e, t) : e;
}
function sy(i) {
  const e = ns(i, !1), t = /^\s*#?\s*([0-9A-Fa-f]{8})\s*$/.exec(e);
  if (t) {
    const r = t[1];
    return [
      parseInt(r.substr(6, 2), 16),
      parseInt(r.substr(4, 2), 16),
      parseInt(r.substr(2, 2), 16),
      parseInt(r.substr(0, 2), 16) / 255
    ];
  }
}
function SN(i) {
  let e = ns(i, !1);
  const t = [];
  e = e.replace(/\s*,\s*/g, ",");
  const r = /^\s*([+\-]?\d*\.?\d+(?:e[+\-]?\d+)?),([+\-]?\d*\.?\d+(?:e[+\-]?\d+)?)(?:\s+|,|$)(?:([+\-]?\d*\.?\d+(?:e[+\-]?\d+)?)(?:\s+|$))?\s*/i;
  let n;
  for (; n = r.exec(e); ) {
    const s = parseFloat(n[1]), a = parseFloat(n[2]), o = n[3] ? parseFloat(n[3]) : 0;
    t.push(s, a, o), e = e.substr(n[0].length);
  }
  if (e === "")
    return t;
}
function TN(i) {
  const e = ns(i, !1).trim();
  let t = i.baseURI;
  return (!t || t == "about:blank") && (t = window.location.href), t ? new URL(e, t).href : e;
}
function FN(i) {
  const e = ns(i, !1).trim().replace(/^(?!.*#)/, "#");
  let t = i.baseURI;
  return (!t || t == "about:blank") && (t = window.location.href), t ? new URL(e, t).href : e;
}
function jZ(i) {
  const e = i.getAttribute("xunits"), t = i.getAttribute("yunits");
  let r;
  return e !== "insetPixels" ? t !== "insetPixels" ? r = "bottom-left" : r = "top-left" : t !== "insetPixels" ? r = "bottom-right" : r = "top-right", {
    x: parseFloat(i.getAttribute("x")),
    xunits: mT[e],
    y: parseFloat(i.getAttribute("y")),
    yunits: mT[t],
    origin: r
  };
}
function LN(i) {
  return xr(i);
}
const zZ = we(dt, {
  Pair: mJ
});
function IN(i, e) {
  return Se(void 0, zZ, i, e, this);
}
const XZ = we(dt, {
  Icon: J(AJ),
  color: J(sy),
  heading: J(xr),
  hotSpot: J(jZ),
  scale: J(LN)
});
function WZ(i, e) {
  const t = Se({}, XZ, i, e);
  if (!t)
    return;
  const r = (
    /** @type {Object} */
    e[e.length - 1]
  ), n = "Icon" in t ? t.Icon : {}, s = !("Icon" in t) || Object.keys(n).length > 0;
  let a;
  const o = (
    /** @type {string|undefined} */
    n.href
  );
  o ? a = o : s && (a = av);
  let A, l, h, c = "bottom-left";
  const u = (
    /** @type {Vec2|undefined} */
    t.hotSpot
  );
  u ? (A = [u.x, u.y], l = u.xunits, h = u.yunits, c = u.origin) : /^https?:\/\/maps\.(?:google|gstatic)\.com\//.test(a) && (a.includes("pushpin") ? (A = kx, l = pd, h = md) : a.includes("arrow-reverse") ? (A = [54, 42], l = pd, h = md) : a.includes("paddle") && (A = [32, 1], l = pd, h = md));
  let f;
  const g = (
    /** @type {number|undefined} */
    n.x
  ), p = (
    /** @type {number|undefined} */
    n.y
  );
  g !== void 0 && p !== void 0 && (f = [g, p]);
  let y;
  const v = (
    /** @type {number|undefined} */
    n.w
  ), w = (
    /** @type {number|undefined} */
    n.h
  );
  v !== void 0 && w !== void 0 && (y = [v, w]);
  let C;
  const E = (
    /** @type {number} */
    t.heading
  );
  E !== void 0 && (C = el(E));
  const S = (
    /** @type {number|undefined} */
    t.scale
  ), M = (
    /** @type {Array<number>|undefined} */
    t.color
  );
  if (s) {
    a == av && (y = vd);
    const T = new Mu({
      anchor: A,
      anchorOrigin: c,
      anchorXUnits: l,
      anchorYUnits: h,
      crossOrigin: this.crossOrigin_,
      offset: f,
      offsetOrigin: "bottom-left",
      rotation: C,
      scale: S,
      size: y,
      src: this.iconUrlFunction_(a),
      color: M
    }), F = T.getScaleArray()[0], k = T.getSize();
    if (k === null) {
      const $ = T.getImageState();
      if ($ === Pt.IDLE || $ === Pt.LOADING) {
        const I = function() {
          const L = T.getImageState();
          if (!(L === Pt.IDLE || L === Pt.LOADING)) {
            const P = T.getSize();
            if (P && P.length == 2) {
              const Q = ov(P);
              T.setScale(F * Q);
            }
            T.unlistenImageChange(I);
          }
        };
        T.listenImageChange(I), $ === Pt.IDLE && T.load();
      }
    } else if (k.length == 2) {
      const $ = ov(k);
      T.setScale(F * $);
    }
    r.imageStyle = T;
  } else
    r.imageStyle = LB;
}
const YZ = we(dt, {
  color: J(sy),
  scale: J(LN)
});
function qZ(i, e) {
  const t = Se({}, YZ, i, e);
  if (!t)
    return;
  const r = e[e.length - 1], n = new ih({
    fill: new Wn({
      color: (
        /** @type {import("../color.js").Color} */
        "color" in t ? t.color : su
      )
    }),
    scale: (
      /** @type {number|undefined} */
      t.scale
    )
  });
  r.textStyle = n;
}
const ZZ = we(dt, {
  color: J(sy),
  width: J(xr)
});
function JZ(i, e) {
  const t = Se({}, ZZ, i, e);
  if (!t)
    return;
  const r = e[e.length - 1], n = new Zi({
    color: (
      /** @type {import("../color.js").Color} */
      "color" in t ? t.color : su
    ),
    width: (
      /** @type {number} */
      "width" in t ? t.width : 1
    )
  });
  r.strokeStyle = n;
}
const eJ = we(dt, {
  color: J(sy),
  fill: J(pl),
  outline: J(pl)
});
function tJ(i, e) {
  const t = Se({}, eJ, i, e);
  if (!t)
    return;
  const r = e[e.length - 1], n = new Wn({
    color: (
      /** @type {import("../color.js").Color} */
      "color" in t ? t.color : su
    )
  });
  r.fillStyle = n;
  const s = (
    /** @type {boolean|undefined} */
    t.fill
  );
  s !== void 0 && (r.fill = s);
  const a = (
    /** @type {boolean|undefined} */
    t.outline
  );
  a !== void 0 && (r.outline = a);
}
const rJ = we(dt, {
  coordinates: wt(SN)
});
function RN(i, e) {
  return Se(null, rJ, i, e);
}
function iJ(i, e) {
  const r = /** @type {GxTrackObject} */ e[e.length - 1].coordinates, n = ns(i, !1), a = /^\s*([+\-]?\d+(?:\.\d*)?(?:e[+\-]?\d*)?)\s+([+\-]?\d+(?:\.\d*)?(?:e[+\-]?\d*)?)\s+([+\-]?\d+(?:\.\d*)?(?:e[+\-]?\d*)?)\s*$/i.exec(n);
  if (a) {
    const o = parseFloat(a[1]), A = parseFloat(a[2]), l = parseFloat(a[3]);
    r.push([o, A, l]);
  } else
    r.push([]);
}
const nJ = we(oA, {
  Track: ht(MN)
});
function sJ(i, e) {
  const t = Se(
    [],
    nJ,
    i,
    e
  );
  if (t)
    return new In(t);
}
const aJ = we(
  dt,
  {
    when: IJ
  },
  we(oA, {
    coord: iJ
  })
);
function MN(i, e) {
  const t = Se(
    /** @type {GxTrackObject} */
    {
      coordinates: [],
      whens: []
    },
    aJ,
    i,
    e
  );
  if (!t)
    return;
  const r = [], n = t.coordinates, s = t.whens;
  for (let a = 0, o = Math.min(n.length, s.length); a < o; ++a)
    n[a].length == 3 && r.push(
      n[a][0],
      n[a][1],
      n[a][2],
      s[a]
    );
  return new Gr(r, "XYZM");
}
const oJ = we(
  dt,
  {
    href: J(TN)
  },
  we(oA, {
    x: J(xr),
    y: J(xr),
    w: J(xr),
    h: J(xr)
  })
);
function AJ(i, e) {
  const t = Se({}, oJ, i, e);
  return t || null;
}
const lJ = we(dt, {
  coordinates: wt(SN)
});
function IB(i, e) {
  return Se(
    null,
    lJ,
    i,
    e
  );
}
const ay = we(dt, {
  extrude: J(pl),
  tessellate: J(pl),
  altitudeMode: J(Me)
});
function NN(i, e) {
  const t = Se(
    {},
    ay,
    i,
    e
  ), r = IB(i, e);
  if (r) {
    const n = new Gr(r, "XYZ");
    return n.setProperties(t, !0), n;
  }
}
function PN(i, e) {
  const t = Se(
    {},
    ay,
    i,
    e
  ), r = IB(i, e);
  if (r) {
    const n = new Li(r, "XYZ", [
      r.length
    ]);
    return n.setProperties(t, !0), n;
  }
}
const hJ = we(dt, {
  LineString: ht(NN),
  LinearRing: ht(PN),
  MultiGeometry: ht(ON),
  Point: ht(UN),
  Polygon: ht(QN)
});
function ON(i, e) {
  const t = Se(
    [],
    hJ,
    i,
    e
  );
  if (!t)
    return null;
  if (t.length === 0)
    return new _n(t);
  let r, n = !0;
  const s = t[0].getType();
  let a;
  for (let o = 1, A = t.length; o < A; ++o)
    if (a = t[o], a.getType() != s) {
      n = !1;
      break;
    }
  if (n) {
    let o, A;
    if (s == "Point") {
      const l = t[0];
      o = l.getLayout(), A = l.getFlatCoordinates();
      for (let h = 1, c = t.length; h < c; ++h)
        a = t[h], Er(A, a.getFlatCoordinates());
      r = new ta(A, o), m_(r, t);
    } else
      s == "LineString" ? (r = new In(t), m_(r, t)) : s == "Polygon" ? (r = new Rn(t), m_(r, t)) : s == "GeometryCollection" ? r = new _n(t) : lt(!1, 37);
  } else
    r = new _n(t);
  return (
    /** @type {import("../geom/Geometry.js").default} */
    r
  );
}
function UN(i, e) {
  const t = Se(
    {},
    ay,
    i,
    e
  ), r = IB(i, e);
  if (r) {
    const n = new gr(r, "XYZ");
    return n.setProperties(t, !0), n;
  }
}
const cJ = we(dt, {
  innerBoundaryIs: SJ,
  outerBoundaryIs: FJ
});
function QN(i, e) {
  const t = Se(
    /** @type {Object<string,*>} */
    {},
    ay,
    i,
    e
  ), r = Se(
    [null],
    cJ,
    i,
    e
  );
  if (r && r[0]) {
    const n = r[0], s = [n.length];
    for (let o = 1, A = r.length; o < A; ++o)
      Er(n, r[o]), s.push(n.length);
    const a = new Li(n, "XYZ", s);
    return a.setProperties(t, !0), a;
  }
}
const uJ = we(dt, {
  IconStyle: WZ,
  LabelStyle: qZ,
  LineStyle: JZ,
  PolyStyle: tJ
});
function RB(i, e) {
  const t = Se(
    {},
    uJ,
    i,
    e,
    this
  );
  if (!t)
    return null;
  let r = (
    /** @type {Fill} */
    "fillStyle" in t ? t.fillStyle : Z0
  );
  const n = (
    /** @type {boolean|undefined} */
    t.fill
  );
  n !== void 0 && !n && (r = null);
  let s;
  "imageStyle" in t ? t.imageStyle != LB && (s = /** @type {import("../style/Image.js").default} */
  t.imageStyle) : s = Hx;
  const a = (
    /** @type {Text} */
    "textStyle" in t ? t.textStyle : Wl
  ), o = (
    /** @type {Stroke} */
    "strokeStyle" in t ? t.strokeStyle : Gx
  ), A = (
    /** @type {boolean|undefined} */
    t.outline
  );
  return A !== void 0 && !A ? [
    new ln({
      geometry: function(l) {
        const h = l.getGeometry(), c = h.getType();
        if (c === "GeometryCollection") {
          const u = (
            /** @type {import("../geom/GeometryCollection").default} */
            h
          );
          return new _n(
            u.getGeometriesArrayRecursive().filter(function(f) {
              const g = f.getType();
              return g !== "Polygon" && g !== "MultiPolygon";
            })
          );
        } else if (c !== "Polygon" && c !== "MultiPolygon")
          return h;
      },
      fill: r,
      image: s,
      stroke: o,
      text: a,
      zIndex: void 0
      // FIXME
    }),
    new ln({
      geometry: function(l) {
        const h = l.getGeometry(), c = h.getType();
        if (c === "GeometryCollection") {
          const u = (
            /** @type {import("../geom/GeometryCollection").default} */
            h
          );
          return new _n(
            u.getGeometriesArrayRecursive().filter(function(f) {
              const g = f.getType();
              return g === "Polygon" || g === "MultiPolygon";
            })
          );
        } else if (c === "Polygon" || c === "MultiPolygon")
          return h;
      },
      fill: r,
      stroke: null,
      zIndex: void 0
      // FIXME
    })
  ] : [
    new ln({
      fill: r,
      image: s,
      stroke: o,
      text: a,
      zIndex: void 0
      // FIXME
    })
  ];
}
function m_(i, e) {
  const t = e.length, r = new Array(e.length), n = new Array(e.length), s = new Array(e.length);
  let a, o, A;
  a = !1, o = !1, A = !1;
  for (let l = 0; l < t; ++l) {
    const h = e[l];
    r[l] = h.get("extrude"), n[l] = h.get("tessellate"), s[l] = h.get("altitudeMode"), a = a || r[l] !== void 0, o = o || n[l] !== void 0, A = A || s[l];
  }
  a && i.set("extrude", r), o && i.set("tessellate", n), A && i.set("altitudeMode", s);
}
const fJ = we(dt, {
  displayName: J(Me),
  value: J(Me)
});
function dJ(i, e) {
  const t = i.getAttribute("name");
  gs(fJ, i, e);
  const r = (
    /** @type {Object} */
    e[e.length - 1]
  );
  t && r.displayName ? r[t] = {
    value: r.value,
    displayName: r.displayName,
    toString: function() {
      return r.value;
    }
  } : t !== null ? r[t] = r.value : r.displayName !== null && (r[r.displayName] = r.value), delete r.value;
}
const gJ = we(dt, {
  Data: dJ,
  SchemaData: _J
});
function DN(i, e) {
  gs(gJ, i, e);
}
function kN(i, e) {
  gs(BN, i, e);
}
const pJ = we(dt, {
  Style: J(RB),
  key: J(Me),
  styleUrl: J(FN)
});
function mJ(i, e) {
  const t = Se({}, pJ, i, e, this);
  if (!t)
    return;
  const r = (
    /** @type {string|undefined} */
    t.key
  );
  if (r && r == "normal") {
    const n = (
      /** @type {string|undefined} */
      t.styleUrl
    );
    n && (e[e.length - 1] = n);
    const s = (
      /** @type {Style} */
      t.Style
    );
    s && (e[e.length - 1] = s);
  }
}
function vJ(i, e) {
  const t = IN.call(this, i, e);
  if (!t)
    return;
  const r = e[e.length - 1];
  Array.isArray(t) ? r.Style = t : typeof t == "string" ? r.styleUrl = t : lt(!1, 38);
}
const yJ = we(dt, {
  SimpleData: wJ
});
function _J(i, e) {
  gs(yJ, i, e);
}
function wJ(i, e) {
  const t = i.getAttribute("name");
  if (t !== null) {
    const r = Me(i), n = (
      /** @type {Object} */
      e[e.length - 1]
    );
    n[t] = r;
  }
}
const xJ = we(dt, {
  altitudeMode: J(Me),
  minAltitude: J(xr),
  maxAltitude: J(xr),
  north: J(xr),
  south: J(xr),
  east: J(xr),
  west: J(xr)
});
function CJ(i, e) {
  const t = Se(
    {},
    xJ,
    i,
    e
  );
  if (!t)
    return;
  const r = (
    /** @type {Object} */
    e[e.length - 1]
  ), n = [
    parseFloat(t.west),
    parseFloat(t.south),
    parseFloat(t.east),
    parseFloat(t.north)
  ];
  r.extent = n, r.altitudeMode = t.altitudeMode, r.minAltitude = parseFloat(t.minAltitude), r.maxAltitude = parseFloat(t.maxAltitude);
}
const EJ = we(dt, {
  minLodPixels: J(xr),
  maxLodPixels: J(xr),
  minFadeExtent: J(xr),
  maxFadeExtent: J(xr)
});
function BJ(i, e) {
  const t = Se({}, EJ, i, e);
  if (!t)
    return;
  const r = (
    /** @type {Object} */
    e[e.length - 1]
  );
  r.minLodPixels = parseFloat(t.minLodPixels), r.maxLodPixels = parseFloat(t.maxLodPixels), r.minFadeExtent = parseFloat(t.minFadeExtent), r.maxFadeExtent = parseFloat(t.maxFadeExtent);
}
const bJ = we(dt, {
  // KML spec only allows one LinearRing  per innerBoundaryIs, but Google Earth
  // allows multiple, so we parse multiple here too.
  LinearRing: ht(RN)
});
function SJ(i, e) {
  const t = Se(
    /** @type {Array<Array<number>>} */
    [],
    bJ,
    i,
    e
  );
  t.length > 0 && /** @type {Array<Array<number>>} */
  e[e.length - 1].push(...t);
}
const TJ = we(dt, {
  LinearRing: wt(RN)
});
function FJ(i, e) {
  const t = Se(
    void 0,
    TJ,
    i,
    e
  );
  if (t) {
    const r = (
      /** @type {Array<Array<number>>} */
      e[e.length - 1]
    );
    r[0] = t;
  }
}
function LJ(i, e) {
  gs(QZ, i, e);
}
function IJ(i, e) {
  const r = /** @type {GxTrackObject} */ e[e.length - 1].whens, n = ns(i, !1), s = Date.parse(n);
  r.push(isNaN(s) ? 0 : s);
}
function oy(i, e) {
  const t = hl(e), n = [(t.length == 4 ? t[3] : 1) * 255, t[2], t[1], t[0]];
  for (let s = 0; s < 4; ++s) {
    const a = Math.floor(
      /** @type {number} */
      n[s]
    ).toString(16);
    n[s] = a.length == 1 ? "0" + a : a;
  }
  Tt(i, n.join(""));
}
function RJ(i, e, t) {
  const r = t[t.length - 1], n = r.layout, s = r.stride;
  let a;
  n == "XY" || n == "XYM" ? a = 2 : n == "XYZ" || n == "XYZM" ? a = 3 : lt(!1, 34);
  const o = e.length;
  let A = "";
  if (o > 0) {
    A += e[0];
    for (let l = 1; l < a; ++l)
      A += "," + e[l];
    for (let l = s; l < o; l += s) {
      A += " " + e[l];
      for (let h = 1; h < a; ++h)
        A += "," + e[l + h];
    }
  }
  Tt(i, A);
}
const J0 = we(dt, {
  Data: te(MJ),
  value: te(PJ),
  displayName: te(NJ)
});
function MJ(i, e, t) {
  i.setAttribute("name", e.name);
  const r = { node: i }, n = e.value;
  typeof n == "object" ? (n !== null && n.displayName && Rt(
    r,
    J0,
    wn,
    [n.displayName],
    t,
    ["displayName"]
  ), n !== null && n.value && Rt(
    r,
    J0,
    wn,
    [n.value],
    t,
    ["value"]
  )) : Rt(
    r,
    J0,
    wn,
    [n],
    t,
    ["value"]
  );
}
function NJ(i, e) {
  Gq(i, e);
}
function PJ(i, e) {
  Tt(i, e);
}
const OJ = we(dt, {
  Placemark: te($N)
}), UJ = function(i, e, t) {
  const r = e[e.length - 1].node;
  return Nt(r.namespaceURI, "Placemark");
};
function QJ(i, e, t) {
  Rt(
    { node: i },
    OJ,
    UJ,
    e,
    t,
    void 0,
    this
  );
}
const DJ = wi("Data");
function kJ(i, e, t) {
  const r = { node: i }, n = e.names, s = e.values, a = n.length;
  for (let o = 0; o < a; o++)
    Rt(
      r,
      J0,
      DJ,
      [{ name: n[o], value: s[o] }],
      t
    );
}
const yT = we(
  dt,
  ["href"],
  we(oA, ["x", "y", "w", "h"])
), _T = we(
  dt,
  {
    href: te(Tt)
  },
  we(oA, {
    x: te(us),
    y: te(us),
    w: te(us),
    h: te(us)
  })
), HJ = function(i, e, t) {
  return Nt(oA[0], "gx:" + t);
};
function GJ(i, e, t) {
  const r = { node: i }, n = t[t.length - 1].node;
  let s = yT[n.namespaceURI], a = ys(e, s);
  Rt(
    r,
    _T,
    wn,
    a,
    t,
    s
  ), s = yT[oA[0]], a = ys(e, s), Rt(
    r,
    _T,
    HJ,
    a,
    t,
    s
  );
}
const $J = we(dt, [
  "scale",
  "heading",
  "Icon",
  "color",
  "hotSpot"
]), VJ = we(dt, {
  Icon: te(GJ),
  color: te(oy),
  heading: te(us),
  hotSpot: te(mee),
  scale: te(KN)
});
function KJ(i, e, t) {
  const r = { node: i }, n = {}, s = e.getSrc(), a = e.getSize(), o = e.getImageSize(), A = {
    href: s
  };
  if (a) {
    A.w = a[0], A.h = a[1];
    const y = e.getAnchor(), v = e.getOrigin();
    if (v && o && v[0] !== 0 && v[1] !== a[1] && (A.x = v[0], A.y = o[1] - (v[1] + a[1])), y && (y[0] !== a[0] / 2 || y[1] !== a[1] / 2)) {
      const w = {
        x: y[0],
        xunits: "pixels",
        y: a[1] - y[1],
        yunits: "pixels"
      };
      n.hotSpot = w;
    }
  }
  n.Icon = A;
  let l = e.getScaleArray()[0], h = a;
  if (h === null && (h = vd), h.length == 2) {
    const y = ov(h);
    l = l / y;
  }
  l !== 1 && (n.scale = l);
  const c = e.getRotation();
  c !== 0 && (n.heading = c);
  const u = e.getColor();
  u && (n.color = u);
  const f = t[t.length - 1].node, g = $J[f.namespaceURI], p = ys(n, g);
  Rt(
    r,
    VJ,
    wn,
    p,
    t,
    g
  );
}
const jJ = we(dt, [
  "color",
  "scale"
]), zJ = we(dt, {
  color: te(oy),
  scale: te(KN)
});
function XJ(i, e, t) {
  const r = { node: i }, n = {}, s = e.getFill();
  s && (n.color = s.getColor());
  const a = e.getScale();
  a && a !== 1 && (n.scale = a);
  const o = t[t.length - 1].node, A = jJ[o.namespaceURI], l = ys(n, A);
  Rt(
    r,
    zJ,
    wn,
    l,
    t,
    A
  );
}
const WJ = we(dt, ["color", "width"]), YJ = we(dt, {
  color: te(oy),
  width: te(us)
});
function qJ(i, e, t) {
  const r = { node: i }, n = {
    color: e.getColor(),
    width: Number(e.getWidth()) || 1
  }, s = t[t.length - 1].node, a = WJ[s.namespaceURI], o = ys(n, a);
  Rt(
    r,
    YJ,
    wn,
    o,
    t,
    a
  );
}
const ZJ = {
  Point: "Point",
  LineString: "LineString",
  LinearRing: "LinearRing",
  Polygon: "Polygon",
  MultiPoint: "MultiGeometry",
  MultiLineString: "MultiGeometry",
  MultiPolygon: "MultiGeometry",
  GeometryCollection: "MultiGeometry"
}, HN = function(i, e, t) {
  if (i) {
    const r = e[e.length - 1].node;
    return Nt(
      r.namespaceURI,
      ZJ[
        /** @type {import("../geom/Geometry.js").default} */
        i.getType()
      ]
    );
  }
}, JJ = wi("Point"), eee = wi("LineString"), tee = wi("LinearRing"), ree = wi("Polygon"), iee = we(dt, {
  LineString: te(au),
  Point: te(au),
  Polygon: te(VN),
  GeometryCollection: te(GN)
});
function GN(i, e, t) {
  const r = { node: i }, n = e.getType();
  let s = [], a;
  n === "GeometryCollection" ? (e.getGeometriesArrayRecursive().forEach(function(o) {
    const A = o.getType();
    A === "MultiPoint" ? s = s.concat(
      /** @type {MultiPoint} */
      o.getPoints()
    ) : A === "MultiLineString" ? s = s.concat(
      /** @type {MultiLineString} */
      o.getLineStrings()
    ) : A === "MultiPolygon" ? s = s.concat(
      /** @type {MultiPolygon} */
      o.getPolygons()
    ) : A === "Point" || A === "LineString" || A === "Polygon" ? s.push(o) : lt(!1, 39);
  }), a = HN) : n === "MultiPoint" ? (s = /** @type {MultiPoint} */
  e.getPoints(), a = JJ) : n === "MultiLineString" ? (s = /** @type {MultiLineString} */
  e.getLineStrings(), a = eee) : n === "MultiPolygon" ? (s = /** @type {MultiPolygon} */
  e.getPolygons(), a = ree) : lt(!1, 39), Rt(
    r,
    iee,
    a,
    s,
    t
  );
}
const nee = we(dt, {
  LinearRing: te(au)
});
function wT(i, e, t) {
  Rt(
    { node: i },
    nee,
    tee,
    [e],
    t
  );
}
const v_ = we(dt, {
  ExtendedData: te(kJ),
  MultiGeometry: te(GN),
  LineString: te(au),
  LinearRing: te(au),
  Point: te(au),
  Polygon: te(VN),
  Style: te(pee),
  address: te(Tt),
  description: te(Tt),
  name: te(Tt),
  open: te(xu),
  phoneNumber: te(Tt),
  styleUrl: te(Tt),
  visibility: te(xu)
}), see = we(dt, [
  "name",
  "open",
  "visibility",
  "address",
  "phoneNumber",
  "description",
  "styleUrl",
  "Style"
]), aee = wi("ExtendedData");
function $N(i, e, t) {
  const r = { node: i };
  e.getId() && i.setAttribute(
    "id",
    /** @type {string} */
    e.getId()
  );
  const n = e.getProperties(), s = {
    address: 1,
    description: 1,
    name: 1,
    open: 1,
    phoneNumber: 1,
    styleUrl: 1,
    visibility: 1
  };
  s[e.getGeometryName()] = 1;
  const a = Object.keys(n || {}).sort().filter(function(f) {
    return !s[f];
  }), o = e.getStyleFunction();
  if (o) {
    const f = o(e, 0);
    if (f) {
      const g = Array.isArray(f) ? f : [f];
      let p = g;
      if (e.getGeometry() && (p = g.filter(function(y) {
        const v = y.getGeometryFunction()(e);
        if (v) {
          const w = v.getType();
          return w === "GeometryCollection" ? (
            /** @type {GeometryCollection} */
            v.getGeometriesArrayRecursive().filter(function(C) {
              const E = C.getType();
              return E === "Point" || E === "MultiPoint";
            }).length
          ) : w === "Point" || w === "MultiPoint";
        }
      })), this.writeStyles_) {
        let y = g, v = g;
        e.getGeometry() && (y = g.filter(function(w) {
          const C = w.getGeometryFunction()(e);
          if (C) {
            const E = C.getType();
            return E === "GeometryCollection" ? (
              /** @type {GeometryCollection} */
              C.getGeometriesArrayRecursive().filter(function(S) {
                const M = S.getType();
                return M === "LineString" || M === "MultiLineString";
              }).length
            ) : E === "LineString" || E === "MultiLineString";
          }
        }), v = g.filter(function(w) {
          const C = w.getGeometryFunction()(e);
          if (C) {
            const E = C.getType();
            return E === "GeometryCollection" ? (
              /** @type {GeometryCollection} */
              C.getGeometriesArrayRecursive().filter(function(S) {
                const M = S.getType();
                return M === "Polygon" || M === "MultiPolygon";
              }).length
            ) : E === "Polygon" || E === "MultiPolygon";
          }
        })), n.Style = {
          pointStyles: p,
          lineStyles: y,
          polyStyles: v
        };
      }
      if (p.length && n.name === void 0) {
        const y = p[0].getText();
        y && (n.name = y.getText());
      }
    }
  }
  const A = t[t.length - 1].node, l = see[A.namespaceURI], h = ys(n, l);
  if (Rt(
    r,
    v_,
    wn,
    h,
    t,
    l
  ), a.length > 0) {
    const f = ys(n, a);
    Rt(
      r,
      v_,
      aee,
      [{ names: a, values: f }],
      t
    );
  }
  const c = (
    /** @type {import("./Feature.js").WriteOptions} */
    t[0]
  );
  let u = e.getGeometry();
  u && (u = ui(u, !0, c)), Rt(
    r,
    v_,
    HN,
    [u],
    t
  );
}
const oee = we(dt, [
  "extrude",
  "tessellate",
  "altitudeMode",
  "coordinates"
]), Aee = we(dt, {
  extrude: te(xu),
  tessellate: te(xu),
  altitudeMode: te(Tt),
  coordinates: te(RJ)
});
function au(i, e, t) {
  const r = e.getFlatCoordinates(), n = { node: i };
  n.layout = e.getLayout(), n.stride = e.getStride();
  const s = e.getProperties();
  s.coordinates = r;
  const a = t[t.length - 1].node, o = oee[a.namespaceURI], A = ys(s, o);
  Rt(
    n,
    Aee,
    wn,
    A,
    t,
    o
  );
}
const lee = we(dt, [
  "color",
  "fill",
  "outline"
]), xT = we(dt, {
  outerBoundaryIs: te(wT),
  innerBoundaryIs: te(wT)
}), hee = wi("innerBoundaryIs"), cee = wi("outerBoundaryIs");
function VN(i, e, t) {
  const r = e.getLinearRings(), n = r.shift(), s = { node: i };
  Rt(
    s,
    xT,
    hee,
    r,
    t
  ), Rt(
    s,
    xT,
    cee,
    [n],
    t
  );
}
const uee = we(dt, {
  color: te(oy),
  fill: te(xu),
  outline: te(xu)
});
function fee(i, e, t) {
  const r = { node: i }, n = e.getFill(), s = e.getStroke(), a = {
    color: n ? n.getColor() : void 0,
    fill: n ? void 0 : !1,
    outline: s ? void 0 : !1
  }, o = t[t.length - 1].node, A = lee[o.namespaceURI], l = ys(a, A);
  Rt(
    r,
    uee,
    wn,
    l,
    t,
    A
  );
}
function KN(i, e) {
  us(i, Math.round(e * 1e6) / 1e6);
}
const dee = we(dt, [
  "IconStyle",
  "LabelStyle",
  "LineStyle",
  "PolyStyle"
]), gee = we(dt, {
  IconStyle: te(KJ),
  LabelStyle: te(XJ),
  LineStyle: te(qJ),
  PolyStyle: te(fee)
});
function pee(i, e, t) {
  const r = { node: i }, n = {};
  if (e.pointStyles.length) {
    const A = e.pointStyles[0].getText();
    A && (n.LabelStyle = A);
    const l = e.pointStyles[0].getImage();
    l && typeof /** @type {?} */
    l.getSrc == "function" && (n.IconStyle = l);
  }
  if (e.lineStyles.length) {
    const A = e.lineStyles[0].getStroke();
    A && (n.LineStyle = A);
  }
  if (e.polyStyles.length) {
    const A = e.polyStyles[0].getStroke();
    A && !n.LineStyle && (n.LineStyle = A), n.PolyStyle = e.polyStyles[0];
  }
  const s = t[t.length - 1].node, a = dee[s.namespaceURI], o = ys(n, a);
  Rt(
    r,
    gee,
    wn,
    o,
    t,
    a
  );
}
function mee(i, e) {
  i.setAttribute("x", String(e.x)), i.setAttribute("y", String(e.y)), i.setAttribute("xunits", e.xunits), i.setAttribute("yunits", e.yunits);
}
const vee = $Z;
var MB = {};
/*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */
MB.read = function(i, e, t, r, n) {
  var s, a, o = n * 8 - r - 1, A = (1 << o) - 1, l = A >> 1, h = -7, c = t ? n - 1 : 0, u = t ? -1 : 1, f = i[e + c];
  for (c += u, s = f & (1 << -h) - 1, f >>= -h, h += o; h > 0; s = s * 256 + i[e + c], c += u, h -= 8)
    ;
  for (a = s & (1 << -h) - 1, s >>= -h, h += r; h > 0; a = a * 256 + i[e + c], c += u, h -= 8)
    ;
  if (s === 0)
    s = 1 - l;
  else {
    if (s === A)
      return a ? NaN : (f ? -1 : 1) * (1 / 0);
    a = a + Math.pow(2, r), s = s - l;
  }
  return (f ? -1 : 1) * a * Math.pow(2, s - r);
};
MB.write = function(i, e, t, r, n, s) {
  var a, o, A, l = s * 8 - n - 1, h = (1 << l) - 1, c = h >> 1, u = n === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0, f = r ? 0 : s - 1, g = r ? 1 : -1, p = e < 0 || e === 0 && 1 / e < 0 ? 1 : 0;
  for (e = Math.abs(e), isNaN(e) || e === 1 / 0 ? (o = isNaN(e) ? 1 : 0, a = h) : (a = Math.floor(Math.log(e) / Math.LN2), e * (A = Math.pow(2, -a)) < 1 && (a--, A *= 2), a + c >= 1 ? e += u / A : e += u * Math.pow(2, 1 - c), e * A >= 2 && (a++, A /= 2), a + c >= h ? (o = 0, a = h) : a + c >= 1 ? (o = (e * A - 1) * Math.pow(2, n), a = a + c) : (o = e * Math.pow(2, c - 1) * Math.pow(2, n), a = 0)); n >= 8; i[t + f] = o & 255, f += g, o /= 256, n -= 8)
    ;
  for (a = a << n | o, l += n; l > 0; i[t + f] = a & 255, f += g, a /= 256, l -= 8)
    ;
  i[t + f - g] |= p * 128;
};
var yee = Sr, Zp = MB;
function Sr(i) {
  this.buf = ArrayBuffer.isView && ArrayBuffer.isView(i) ? i : new Uint8Array(i || 0), this.pos = 0, this.type = 0, this.length = this.buf.length;
}
Sr.Varint = 0;
Sr.Fixed64 = 1;
Sr.Bytes = 2;
Sr.Fixed32 = 5;
var Kx = (1 << 16) * (1 << 16), CT = 1 / Kx, _ee = 12, jN = typeof TextDecoder > "u" ? null : new TextDecoder("utf8");
Sr.prototype = {
  destroy: function() {
    this.buf = null;
  },
  // === READING =================================================================
  readFields: function(i, e, t) {
    for (t = t || this.length; this.pos < t; ) {
      var r = this.readVarint(), n = r >> 3, s = this.pos;
      this.type = r & 7, i(n, e, this), this.pos === s && this.skip(r);
    }
    return e;
  },
  readMessage: function(i, e) {
    return this.readFields(i, e, this.readVarint() + this.pos);
  },
  readFixed32: function() {
    var i = Jp(this.buf, this.pos);
    return this.pos += 4, i;
  },
  readSFixed32: function() {
    var i = BT(this.buf, this.pos);
    return this.pos += 4, i;
  },
  // 64-bit int handling is based on github.com/dpw/node-buffer-more-ints (MIT-licensed)
  readFixed64: function() {
    var i = Jp(this.buf, this.pos) + Jp(this.buf, this.pos + 4) * Kx;
    return this.pos += 8, i;
  },
  readSFixed64: function() {
    var i = Jp(this.buf, this.pos) + BT(this.buf, this.pos + 4) * Kx;
    return this.pos += 8, i;
  },
  readFloat: function() {
    var i = Zp.read(this.buf, this.pos, !0, 23, 4);
    return this.pos += 4, i;
  },
  readDouble: function() {
    var i = Zp.read(this.buf, this.pos, !0, 52, 8);
    return this.pos += 8, i;
  },
  readVarint: function(i) {
    var e = this.buf, t, r;
    return r = e[this.pos++], t = r & 127, r < 128 || (r = e[this.pos++], t |= (r & 127) << 7, r < 128) || (r = e[this.pos++], t |= (r & 127) << 14, r < 128) || (r = e[this.pos++], t |= (r & 127) << 21, r < 128) ? t : (r = e[this.pos], t |= (r & 15) << 28, wee(t, i, this));
  },
  readVarint64: function() {
    return this.readVarint(!0);
  },
  readSVarint: function() {
    var i = this.readVarint();
    return i % 2 === 1 ? (i + 1) / -2 : i / 2;
  },
  readBoolean: function() {
    return !!this.readVarint();
  },
  readString: function() {
    var i = this.readVarint() + this.pos, e = this.pos;
    return this.pos = i, i - e >= _ee && jN ? Pee(this.buf, e, i) : Nee(this.buf, e, i);
  },
  readBytes: function() {
    var i = this.readVarint() + this.pos, e = this.buf.subarray(this.pos, i);
    return this.pos = i, e;
  },
  // verbose for performance reasons; doesn't affect gzipped size
  readPackedVarint: function(i, e) {
    if (this.type !== Sr.Bytes)
      return i.push(this.readVarint(e));
    var t = So(this);
    for (i = i || []; this.pos < t; )
      i.push(this.readVarint(e));
    return i;
  },
  readPackedSVarint: function(i) {
    if (this.type !== Sr.Bytes)
      return i.push(this.readSVarint());
    var e = So(this);
    for (i = i || []; this.pos < e; )
      i.push(this.readSVarint());
    return i;
  },
  readPackedBoolean: function(i) {
    if (this.type !== Sr.Bytes)
      return i.push(this.readBoolean());
    var e = So(this);
    for (i = i || []; this.pos < e; )
      i.push(this.readBoolean());
    return i;
  },
  readPackedFloat: function(i) {
    if (this.type !== Sr.Bytes)
      return i.push(this.readFloat());
    var e = So(this);
    for (i = i || []; this.pos < e; )
      i.push(this.readFloat());
    return i;
  },
  readPackedDouble: function(i) {
    if (this.type !== Sr.Bytes)
      return i.push(this.readDouble());
    var e = So(this);
    for (i = i || []; this.pos < e; )
      i.push(this.readDouble());
    return i;
  },
  readPackedFixed32: function(i) {
    if (this.type !== Sr.Bytes)
      return i.push(this.readFixed32());
    var e = So(this);
    for (i = i || []; this.pos < e; )
      i.push(this.readFixed32());
    return i;
  },
  readPackedSFixed32: function(i) {
    if (this.type !== Sr.Bytes)
      return i.push(this.readSFixed32());
    var e = So(this);
    for (i = i || []; this.pos < e; )
      i.push(this.readSFixed32());
    return i;
  },
  readPackedFixed64: function(i) {
    if (this.type !== Sr.Bytes)
      return i.push(this.readFixed64());
    var e = So(this);
    for (i = i || []; this.pos < e; )
      i.push(this.readFixed64());
    return i;
  },
  readPackedSFixed64: function(i) {
    if (this.type !== Sr.Bytes)
      return i.push(this.readSFixed64());
    var e = So(this);
    for (i = i || []; this.pos < e; )
      i.push(this.readSFixed64());
    return i;
  },
  skip: function(i) {
    var e = i & 7;
    if (e === Sr.Varint)
      for (; this.buf[this.pos++] > 127; )
        ;
    else if (e === Sr.Bytes)
      this.pos = this.readVarint() + this.pos;
    else if (e === Sr.Fixed32)
      this.pos += 4;
    else if (e === Sr.Fixed64)
      this.pos += 8;
    else
      throw new Error("Unimplemented type: " + e);
  },
  // === WRITING =================================================================
  writeTag: function(i, e) {
    this.writeVarint(i << 3 | e);
  },
  realloc: function(i) {
    for (var e = this.length || 16; e < this.pos + i; )
      e *= 2;
    if (e !== this.length) {
      var t = new Uint8Array(e);
      t.set(this.buf), this.buf = t, this.length = e;
    }
  },
  finish: function() {
    return this.length = this.pos, this.pos = 0, this.buf.subarray(0, this.length);
  },
  writeFixed32: function(i) {
    this.realloc(4), cc(this.buf, i, this.pos), this.pos += 4;
  },
  writeSFixed32: function(i) {
    this.realloc(4), cc(this.buf, i, this.pos), this.pos += 4;
  },
  writeFixed64: function(i) {
    this.realloc(8), cc(this.buf, i & -1, this.pos), cc(this.buf, Math.floor(i * CT), this.pos + 4), this.pos += 8;
  },
  writeSFixed64: function(i) {
    this.realloc(8), cc(this.buf, i & -1, this.pos), cc(this.buf, Math.floor(i * CT), this.pos + 4), this.pos += 8;
  },
  writeVarint: function(i) {
    if (i = +i || 0, i > 268435455 || i < 0) {
      xee(i, this);
      return;
    }
    this.realloc(4), this.buf[this.pos++] = i & 127 | (i > 127 ? 128 : 0), !(i <= 127) && (this.buf[this.pos++] = (i >>>= 7) & 127 | (i > 127 ? 128 : 0), !(i <= 127) && (this.buf[this.pos++] = (i >>>= 7) & 127 | (i > 127 ? 128 : 0), !(i <= 127) && (this.buf[this.pos++] = i >>> 7 & 127)));
  },
  writeSVarint: function(i) {
    this.writeVarint(i < 0 ? -i * 2 - 1 : i * 2);
  },
  writeBoolean: function(i) {
    this.writeVarint(!!i);
  },
  writeString: function(i) {
    i = String(i), this.realloc(i.length * 4), this.pos++;
    var e = this.pos;
    this.pos = Oee(this.buf, i, this.pos);
    var t = this.pos - e;
    t >= 128 && ET(e, t, this), this.pos = e - 1, this.writeVarint(t), this.pos += t;
  },
  writeFloat: function(i) {
    this.realloc(4), Zp.write(this.buf, i, this.pos, !0, 23, 4), this.pos += 4;
  },
  writeDouble: function(i) {
    this.realloc(8), Zp.write(this.buf, i, this.pos, !0, 52, 8), this.pos += 8;
  },
  writeBytes: function(i) {
    var e = i.length;
    this.writeVarint(e), this.realloc(e);
    for (var t = 0; t < e; t++)
      this.buf[this.pos++] = i[t];
  },
  writeRawMessage: function(i, e) {
    this.pos++;
    var t = this.pos;
    i(e, this);
    var r = this.pos - t;
    r >= 128 && ET(t, r, this), this.pos = t - 1, this.writeVarint(r), this.pos += r;
  },
  writeMessage: function(i, e, t) {
    this.writeTag(i, Sr.Bytes), this.writeRawMessage(e, t);
  },
  writePackedVarint: function(i, e) {
    e.length && this.writeMessage(i, Bee, e);
  },
  writePackedSVarint: function(i, e) {
    e.length && this.writeMessage(i, bee, e);
  },
  writePackedBoolean: function(i, e) {
    e.length && this.writeMessage(i, Fee, e);
  },
  writePackedFloat: function(i, e) {
    e.length && this.writeMessage(i, See, e);
  },
  writePackedDouble: function(i, e) {
    e.length && this.writeMessage(i, Tee, e);
  },
  writePackedFixed32: function(i, e) {
    e.length && this.writeMessage(i, Lee, e);
  },
  writePackedSFixed32: function(i, e) {
    e.length && this.writeMessage(i, Iee, e);
  },
  writePackedFixed64: function(i, e) {
    e.length && this.writeMessage(i, Ree, e);
  },
  writePackedSFixed64: function(i, e) {
    e.length && this.writeMessage(i, Mee, e);
  },
  writeBytesField: function(i, e) {
    this.writeTag(i, Sr.Bytes), this.writeBytes(e);
  },
  writeFixed32Field: function(i, e) {
    this.writeTag(i, Sr.Fixed32), this.writeFixed32(e);
  },
  writeSFixed32Field: function(i, e) {
    this.writeTag(i, Sr.Fixed32), this.writeSFixed32(e);
  },
  writeFixed64Field: function(i, e) {
    this.writeTag(i, Sr.Fixed64), this.writeFixed64(e);
  },
  writeSFixed64Field: function(i, e) {
    this.writeTag(i, Sr.Fixed64), this.writeSFixed64(e);
  },
  writeVarintField: function(i, e) {
    this.writeTag(i, Sr.Varint), this.writeVarint(e);
  },
  writeSVarintField: function(i, e) {
    this.writeTag(i, Sr.Varint), this.writeSVarint(e);
  },
  writeStringField: function(i, e) {
    this.writeTag(i, Sr.Bytes), this.writeString(e);
  },
  writeFloatField: function(i, e) {
    this.writeTag(i, Sr.Fixed32), this.writeFloat(e);
  },
  writeDoubleField: function(i, e) {
    this.writeTag(i, Sr.Fixed64), this.writeDouble(e);
  },
  writeBooleanField: function(i, e) {
    this.writeVarintField(i, !!e);
  }
};
function wee(i, e, t) {
  var r = t.buf, n, s;
  if (s = r[t.pos++], n = (s & 112) >> 4, s < 128 || (s = r[t.pos++], n |= (s & 127) << 3, s < 128) || (s = r[t.pos++], n |= (s & 127) << 10, s < 128) || (s = r[t.pos++], n |= (s & 127) << 17, s < 128) || (s = r[t.pos++], n |= (s & 127) << 24, s < 128) || (s = r[t.pos++], n |= (s & 1) << 31, s < 128))
    return hc(i, n, e);
  throw new Error("Expected varint not more than 10 bytes");
}
function So(i) {
  return i.type === Sr.Bytes ? i.readVarint() + i.pos : i.pos + 1;
}
function hc(i, e, t) {
  return t ? e * 4294967296 + (i >>> 0) : (e >>> 0) * 4294967296 + (i >>> 0);
}
function xee(i, e) {
  var t, r;
  if (i >= 0 ? (t = i % 4294967296 | 0, r = i / 4294967296 | 0) : (t = ~(-i % 4294967296), r = ~(-i / 4294967296), t ^ 4294967295 ? t = t + 1 | 0 : (t = 0, r = r + 1 | 0)), i >= 18446744073709552e3 || i < -18446744073709552e3)
    throw new Error("Given varint doesn't fit into 10 bytes");
  e.realloc(10), Cee(t, r, e), Eee(r, e);
}
function Cee(i, e, t) {
  t.buf[t.pos++] = i & 127 | 128, i >>>= 7, t.buf[t.pos++] = i & 127 | 128, i >>>= 7, t.buf[t.pos++] = i & 127 | 128, i >>>= 7, t.buf[t.pos++] = i & 127 | 128, i >>>= 7, t.buf[t.pos] = i & 127;
}
function Eee(i, e) {
  var t = (i & 7) << 4;
  e.buf[e.pos++] |= t | ((i >>>= 3) ? 128 : 0), i && (e.buf[e.pos++] = i & 127 | ((i >>>= 7) ? 128 : 0), i && (e.buf[e.pos++] = i & 127 | ((i >>>= 7) ? 128 : 0), i && (e.buf[e.pos++] = i & 127 | ((i >>>= 7) ? 128 : 0), i && (e.buf[e.pos++] = i & 127 | ((i >>>= 7) ? 128 : 0), i && (e.buf[e.pos++] = i & 127)))));
}
function ET(i, e, t) {
  var r = e <= 16383 ? 1 : e <= 2097151 ? 2 : e <= 268435455 ? 3 : Math.floor(Math.log(e) / (Math.LN2 * 7));
  t.realloc(r);
  for (var n = t.pos - 1; n >= i; n--)
    t.buf[n + r] = t.buf[n];
}
function Bee(i, e) {
  for (var t = 0; t < i.length; t++)
    e.writeVarint(i[t]);
}
function bee(i, e) {
  for (var t = 0; t < i.length; t++)
    e.writeSVarint(i[t]);
}
function See(i, e) {
  for (var t = 0; t < i.length; t++)
    e.writeFloat(i[t]);
}
function Tee(i, e) {
  for (var t = 0; t < i.length; t++)
    e.writeDouble(i[t]);
}
function Fee(i, e) {
  for (var t = 0; t < i.length; t++)
    e.writeBoolean(i[t]);
}
function Lee(i, e) {
  for (var t = 0; t < i.length; t++)
    e.writeFixed32(i[t]);
}
function Iee(i, e) {
  for (var t = 0; t < i.length; t++)
    e.writeSFixed32(i[t]);
}
function Ree(i, e) {
  for (var t = 0; t < i.length; t++)
    e.writeFixed64(i[t]);
}
function Mee(i, e) {
  for (var t = 0; t < i.length; t++)
    e.writeSFixed64(i[t]);
}
function Jp(i, e) {
  return (i[e] | i[e + 1] << 8 | i[e + 2] << 16) + i[e + 3] * 16777216;
}
function cc(i, e, t) {
  i[t] = e, i[t + 1] = e >>> 8, i[t + 2] = e >>> 16, i[t + 3] = e >>> 24;
}
function BT(i, e) {
  return (i[e] | i[e + 1] << 8 | i[e + 2] << 16) + (i[e + 3] << 24);
}
function Nee(i, e, t) {
  for (var r = "", n = e; n < t; ) {
    var s = i[n], a = null, o = s > 239 ? 4 : s > 223 ? 3 : s > 191 ? 2 : 1;
    if (n + o > t)
      break;
    var A, l, h;
    o === 1 ? s < 128 && (a = s) : o === 2 ? (A = i[n + 1], (A & 192) === 128 && (a = (s & 31) << 6 | A & 63, a <= 127 && (a = null))) : o === 3 ? (A = i[n + 1], l = i[n + 2], (A & 192) === 128 && (l & 192) === 128 && (a = (s & 15) << 12 | (A & 63) << 6 | l & 63, (a <= 2047 || a >= 55296 && a <= 57343) && (a = null))) : o === 4 && (A = i[n + 1], l = i[n + 2], h = i[n + 3], (A & 192) === 128 && (l & 192) === 128 && (h & 192) === 128 && (a = (s & 15) << 18 | (A & 63) << 12 | (l & 63) << 6 | h & 63, (a <= 65535 || a >= 1114112) && (a = null))), a === null ? (a = 65533, o = 1) : a > 65535 && (a -= 65536, r += String.fromCharCode(a >>> 10 & 1023 | 55296), a = 56320 | a & 1023), r += String.fromCharCode(a), n += o;
  }
  return r;
}
function Pee(i, e, t) {
  return jN.decode(i.subarray(e, t));
}
function Oee(i, e, t) {
  for (var r = 0, n, s; r < e.length; r++) {
    if (n = e.charCodeAt(r), n > 55295 && n < 57344)
      if (s)
        if (n < 56320) {
          i[t++] = 239, i[t++] = 191, i[t++] = 189, s = n;
          continue;
        } else
          n = s - 55296 << 10 | n - 56320 | 65536, s = null;
      else {
        n > 56319 || r + 1 === e.length ? (i[t++] = 239, i[t++] = 191, i[t++] = 189) : s = n;
        continue;
      }
    else
      s && (i[t++] = 239, i[t++] = 191, i[t++] = 189, s = null);
    n < 128 ? i[t++] = n : (n < 2048 ? i[t++] = n >> 6 | 192 : (n < 65536 ? i[t++] = n >> 12 | 224 : (i[t++] = n >> 18 | 240, i[t++] = n >> 12 & 63 | 128), i[t++] = n >> 6 & 63 | 128), i[t++] = n & 63 | 128);
  }
  return t;
}
const bT = qi();
class Zd {
  /**
   * @param {import("../geom/Geometry.js").Type} type Geometry type.
   * @param {Array<number>} flatCoordinates Flat coordinates. These always need
   *     to be right-handed for polygons.
   * @param {Array<number>|Array<Array<number>>} ends Ends or Endss.
   * @param {Object<string, *>} properties Properties.
   * @param {number|string|undefined} id Feature id.
   */
  constructor(e, t, r, n, s) {
    this.styleFunction, this.extent_, this.id_ = s, this.type_ = e, this.flatCoordinates_ = t, this.flatInteriorPoints_ = null, this.flatMidpoints_ = null, this.ends_ = r, this.properties_ = n;
  }
  /**
   * Get a feature property by its key.
   * @param {string} key Key
   * @return {*} Value for the requested key.
   * @api
   */
  get(e) {
    return this.properties_[e];
  }
  /**
   * Get the extent of this feature's geometry.
   * @return {import("../extent.js").Extent} Extent.
   * @api
   */
  getExtent() {
    return this.extent_ || (this.extent_ = this.type_ === "Point" ? Zl(this.flatCoordinates_) : Rv(
      this.flatCoordinates_,
      0,
      this.flatCoordinates_.length,
      2
    )), this.extent_;
  }
  /**
   * @return {Array<number>} Flat interior points.
   */
  getFlatInteriorPoint() {
    if (!this.flatInteriorPoints_) {
      const e = Xn(this.getExtent());
      this.flatInteriorPoints_ = FE(
        this.flatCoordinates_,
        0,
        /** @type {Array<number>} */
        this.ends_,
        2,
        e,
        0
      );
    }
    return this.flatInteriorPoints_;
  }
  /**
   * @return {Array<number>} Flat interior points.
   */
  getFlatInteriorPoints() {
    if (!this.flatInteriorPoints_) {
      const e = cN(
        this.flatCoordinates_,
        0,
        /** @type {Array<Array<number>>} */
        this.ends_,
        2
      );
      this.flatInteriorPoints_ = zR(
        this.flatCoordinates_,
        0,
        /** @type {Array<Array<number>>} */
        this.ends_,
        2,
        e
      );
    }
    return this.flatInteriorPoints_;
  }
  /**
   * @return {Array<number>} Flat midpoint.
   */
  getFlatMidpoint() {
    return this.flatMidpoints_ || (this.flatMidpoints_ = Xm(
      this.flatCoordinates_,
      0,
      this.flatCoordinates_.length,
      2,
      0.5
    )), this.flatMidpoints_;
  }
  /**
   * @return {Array<number>} Flat midpoints.
   */
  getFlatMidpoints() {
    if (!this.flatMidpoints_) {
      this.flatMidpoints_ = [];
      const e = this.flatCoordinates_;
      let t = 0;
      const r = (
        /** @type {Array<number>} */
        this.ends_
      );
      for (let n = 0, s = r.length; n < s; ++n) {
        const a = r[n], o = Xm(e, t, a, 2, 0.5);
        Er(this.flatMidpoints_, o), t = a;
      }
    }
    return this.flatMidpoints_;
  }
  /**
   * Get the feature identifier.  This is a stable identifier for the feature and
   * is set when reading data from a remote source.
   * @return {number|string|undefined} Id.
   * @api
   */
  getId() {
    return this.id_;
  }
  /**
   * @return {Array<number>} Flat coordinates.
   */
  getOrientedFlatCoordinates() {
    return this.flatCoordinates_;
  }
  /**
   * For API compatibility with {@link module:ol/Feature~Feature}, this method is useful when
   * determining the geometry type in style function (see {@link #getType}).
   * @return {RenderFeature} Feature.
   * @api
   */
  getGeometry() {
    return this;
  }
  /**
   * @param {number} squaredTolerance Squared tolerance.
   * @return {RenderFeature} Simplified geometry.
   */
  getSimplifiedGeometry(e) {
    return this;
  }
  /**
   * Get a transformed and simplified version of the geometry.
   * @abstract
   * @param {number} squaredTolerance Squared tolerance.
   * @param {import("../proj.js").TransformFunction} [transform] Optional transform function.
   * @return {RenderFeature} Simplified geometry.
   */
  simplifyTransformed(e, t) {
    return this;
  }
  /**
   * Get the feature properties.
   * @return {Object<string, *>} Feature properties.
   * @api
   */
  getProperties() {
    return this.properties_;
  }
  /**
   * @return {number} Stride.
   */
  getStride() {
    return 2;
  }
  /**
   * @return {import('../style/Style.js').StyleFunction|undefined} Style
   */
  getStyleFunction() {
    return this.styleFunction;
  }
  /**
   * Get the type of this feature's geometry.
   * @return {import("../geom/Geometry.js").Type} Geometry type.
   * @api
   */
  getType() {
    return this.type_;
  }
  /**
   * Transform geometry coordinates from tile pixel space to projected.
   *
   * @param {import("../proj.js").ProjectionLike} projection The data projection
   */
  transform(e) {
    e = Ct(e);
    const t = e.getExtent(), r = e.getWorldExtent();
    if (t && r) {
      const n = _i(r) / _i(t);
      Qs(
        bT,
        r[0],
        r[3],
        n,
        -n,
        0,
        0,
        0
      ), il(
        this.flatCoordinates_,
        0,
        this.flatCoordinates_.length,
        2,
        bT,
        this.flatCoordinates_
      );
    }
  }
  /**
   * @return {Array<number>|Array<Array<number>>} Ends or endss.
   */
  getEnds() {
    return this.ends_;
  }
}
Zd.prototype.getEndss = Zd.prototype.getEnds;
Zd.prototype.getFlatCoordinates = Zd.prototype.getOrientedFlatCoordinates;
const ST = Zd;
class Uee extends bg {
  /**
   * @param {Options} [options] Options.
   */
  constructor(e) {
    super(), e = e || {}, this.dataProjection = new Ja({
      code: "",
      units: "tile-pixels"
    }), this.featureClass_ = e.featureClass ? e.featureClass : ST, this.geometryName_ = e.geometryName, this.layerName_ = e.layerName ? e.layerName : "layer", this.layers_ = e.layers ? e.layers : null, this.idProperty_ = e.idProperty, this.supportedMediaTypes = [
      "application/vnd.mapbox-vector-tile",
      "application/x-protobuf"
    ];
  }
  /**
   * Read the raw geometry from the pbf offset stored in a raw feature's geometry
   * property.
   * @param {PBF} pbf PBF.
   * @param {Object} feature Raw feature.
   * @param {Array<number>} flatCoordinates Array to store flat coordinates in.
   * @param {Array<number>} ends Array to store ends in.
   * @private
   */
  readRawGeometry_(e, t, r, n) {
    e.pos = t.geometry;
    const s = e.readVarint() + e.pos;
    let a = 1, o = 0, A = 0, l = 0, h = 0, c = 0;
    for (; e.pos < s; ) {
      if (!o) {
        const u = e.readVarint();
        a = u & 7, o = u >> 3;
      }
      o--, a === 1 || a === 2 ? (A += e.readSVarint(), l += e.readSVarint(), a === 1 && h > c && (n.push(h), c = h), r.push(A, l), h += 2) : a === 7 ? h > c && (r.push(
        r[c],
        r[c + 1]
      ), h += 2) : lt(!1, 59);
    }
    h > c && (n.push(h), c = h);
  }
  /**
   * @private
   * @param {PBF} pbf PBF
   * @param {Object} rawFeature Raw Mapbox feature.
   * @param {import("./Feature.js").ReadOptions} options Read options.
   * @return {import("../Feature.js").FeatureLike|null} Feature.
   */
  createFeature_(e, t, r) {
    const n = t.type;
    if (n === 0)
      return null;
    let s;
    const a = t.properties;
    let o;
    this.idProperty_ ? (o = a[this.idProperty_], delete a[this.idProperty_]) : o = t.id, a[this.layerName_] = t.layer.name;
    const A = (
      /** @type {Array<number>} */
      []
    ), l = (
      /** @type {Array<number>} */
      []
    );
    this.readRawGeometry_(e, t, A, l);
    const h = Gee(n, l.length);
    if (this.featureClass_ === ST)
      s = new this.featureClass_(
        h,
        A,
        l,
        a,
        o
      ), s.transform(r.dataProjection);
    else {
      let c;
      if (h == "Polygon") {
        const g = XD(A, l);
        c = g.length > 1 ? new Rn(A, "XY", g) : new Li(A, "XY", l);
      } else
        c = h === "Point" ? new gr(A, "XY") : h === "LineString" ? new Gr(A, "XY") : h === "MultiPoint" ? new ta(A, "XY") : h === "MultiLineString" ? new In(A, "XY", l) : null;
      const u = (
        /** @type {typeof import("../Feature.js").default} */
        this.featureClass_
      );
      s = new u(), this.geometryName_ && s.setGeometryName(this.geometryName_);
      const f = ui(c, !1, r);
      s.setGeometry(f), o !== void 0 && s.setId(o), s.setProperties(a, !0);
    }
    return s;
  }
  /**
   * @return {import("./Feature.js").Type} Format.
   */
  getType() {
    return "arraybuffer";
  }
  /**
   * Read all features.
   *
   * @param {ArrayBuffer} source Source.
   * @param {import("./Feature.js").ReadOptions} [options] Read options.
   * @return {Array<import("../Feature.js").FeatureLike>} Features.
   * @api
   */
  readFeatures(e, t) {
    const r = this.layers_;
    t = this.adaptOptions(t);
    const n = Ct(t.dataProjection);
    n.setWorldExtent(t.extent), t.dataProjection = n;
    const s = new yee(
      /** @type {ArrayBuffer} */
      e
    ), a = s.readFields(Qee, {}), o = [];
    for (const A in a) {
      if (r && !r.includes(A))
        continue;
      const l = a[A], h = l ? [0, 0, l.extent, l.extent] : null;
      n.setExtent(h);
      for (let c = 0, u = l.length; c < u; ++c) {
        const f = Hee(s, l, c), g = this.createFeature_(s, f, t);
        g !== null && o.push(g);
      }
    }
    return o;
  }
  /**
   * Read the projection from the source.
   *
   * @param {Document|Element|Object|string} source Source.
   * @return {import("../proj/Projection.js").default} Projection.
   * @api
   */
  readProjection(e) {
    return this.dataProjection;
  }
  /**
   * Sets the layers that features will be read from.
   * @param {Array<string>} layers Layers.
   * @api
   */
  setLayers(e) {
    this.layers_ = e;
  }
}
function Qee(i, e, t) {
  if (i === 3) {
    const r = {
      keys: [],
      values: [],
      features: []
    }, n = t.readVarint() + t.pos;
    t.readFields(Dee, r, n), r.length = r.features.length, r.length && (e[r.name] = r);
  }
}
function Dee(i, e, t) {
  if (i === 15)
    e.version = t.readVarint();
  else if (i === 1)
    e.name = t.readString();
  else if (i === 5)
    e.extent = t.readVarint();
  else if (i === 2)
    e.features.push(t.pos);
  else if (i === 3)
    e.keys.push(t.readString());
  else if (i === 4) {
    let r = null;
    const n = t.readVarint() + t.pos;
    for (; t.pos < n; )
      i = t.readVarint() >> 3, r = i === 1 ? t.readString() : i === 2 ? t.readFloat() : i === 3 ? t.readDouble() : i === 4 ? t.readVarint64() : i === 5 ? t.readVarint() : i === 6 ? t.readSVarint() : i === 7 ? t.readBoolean() : null;
    e.values.push(r);
  }
}
function kee(i, e, t) {
  if (i == 1)
    e.id = t.readVarint();
  else if (i == 2) {
    const r = t.readVarint() + t.pos;
    for (; t.pos < r; ) {
      const n = e.layer.keys[t.readVarint()], s = e.layer.values[t.readVarint()];
      e.properties[n] = s;
    }
  } else
    i == 3 ? e.type = t.readVarint() : i == 4 && (e.geometry = t.pos);
}
function Hee(i, e, t) {
  i.pos = e.features[t];
  const r = i.readVarint() + i.pos, n = {
    layer: e,
    type: 0,
    properties: {}
  };
  return i.readFields(kee, n, r), n;
}
function Gee(i, e) {
  let t;
  return i === 1 ? t = e === 1 ? "Point" : "MultiPoint" : i === 2 ? t = e === 1 ? "LineString" : "MultiLineString" : i === 3 && (t = "Polygon"), t;
}
const $ee = Uee;
class Vee {
  /**
   * Read the source document.
   *
   * @param {Document|Element|string} source The XML source.
   * @return {Object} An object representing the source.
   * @api
   */
  read(e) {
    if (e) {
      if (typeof e == "string") {
        const t = Ka(e);
        return this.readFromDocument(t);
      } else if (Va(e))
        return this.readFromDocument(
          /** @type {Document} */
          e
        );
    } else
      return null;
    return this.readFromNode(
      /** @type {Element} */
      e
    );
  }
  /**
   * @param {Document} doc Document.
   * @return {Object} Object
   */
  readFromDocument(e) {
    for (let t = e.firstChild; t; t = t.nextSibling)
      if (t.nodeType == Node.ELEMENT_NODE)
        return this.readFromNode(
          /** @type {Element} */
          t
        );
    return null;
  }
  /**
   * @abstract
   * @param {Element} node Node.
   * @return {Object} Object
   */
  readFromNode(e) {
  }
}
const NB = Vee, Kee = "http://www.w3.org/1999/xlink";
function Qu(i) {
  return i.getAttributeNS(Kee, "href");
}
const Es = [null, "http://www.opengis.net/ows/1.1"], jee = we(Es, {
  ServiceIdentification: J(mte),
  ServiceProvider: J(yte),
  OperationsMetadata: J(gte)
});
class zee extends NB {
  constructor() {
    super();
  }
  /**
   * @param {Element} node Node.
   * @return {Object} Object
   */
  readFromNode(e) {
    const t = Se({}, jee, e, []);
    return t || null;
  }
}
const Xee = we(Es, {
  DeliveryPoint: J(Me),
  City: J(Me),
  AdministrativeArea: J(Me),
  PostalCode: J(Me),
  Country: J(Me),
  ElectronicMailAddress: J(Me)
}), Wee = we(Es, {
  Value: Jr(_te)
}), Yee = we(Es, {
  AllowedValues: J(Ate)
}), qee = we(Es, {
  Phone: J(pte),
  Address: J(ote)
}), Zee = we(Es, {
  HTTP: J(fte)
}), Jee = we(Es, {
  Get: Jr(ute),
  Post: void 0
  // TODO
}), ete = we(Es, {
  DCP: J(cte)
}), tte = we(Es, {
  Operation: dte
}), rte = we(Es, {
  Voice: J(Me),
  Facsimile: J(Me)
}), ite = we(Es, {
  Constraint: Jr(lte)
}), nte = we(Es, {
  IndividualName: J(Me),
  PositionName: J(Me),
  ContactInfo: J(hte)
}), ste = we(Es, {
  Abstract: J(Me),
  AccessConstraints: J(Me),
  Fees: J(Me),
  Title: J(Me),
  ServiceTypeVersion: J(Me),
  ServiceType: J(Me)
}), ate = we(Es, {
  ProviderName: J(Me),
  ProviderSite: J(Qu),
  ServiceContact: J(vte)
});
function ote(i, e) {
  return Se({}, Xee, i, e);
}
function Ate(i, e) {
  return Se({}, Wee, i, e);
}
function lte(i, e) {
  const t = i.getAttribute("name");
  if (t)
    return Se({ name: t }, Yee, i, e);
}
function hte(i, e) {
  return Se({}, qee, i, e);
}
function cte(i, e) {
  return Se({}, Zee, i, e);
}
function ute(i, e) {
  const t = Qu(i);
  if (t)
    return Se(
      { href: t },
      ite,
      i,
      e
    );
}
function fte(i, e) {
  return Se({}, Jee, i, e);
}
function dte(i, e) {
  const t = i.getAttribute("name"), r = Se({}, ete, i, e);
  if (!r)
    return;
  const n = (
    /** @type {Object} */
    e[e.length - 1]
  );
  n[t] = r;
}
function gte(i, e) {
  return Se({}, tte, i, e);
}
function pte(i, e) {
  return Se({}, rte, i, e);
}
function mte(i, e) {
  return Se({}, ste, i, e);
}
function vte(i, e) {
  return Se({}, nte, i, e);
}
function yte(i, e) {
  return Se({}, ate, i, e);
}
function _te(i, e) {
  return Me(i);
}
const zN = zee;
function TT(i, e, t, r, n, s) {
  n !== void 0 ? (n = n, s = s !== void 0 ? s : 0) : (n = [], s = 0);
  let a = e;
  for (; a < t; ) {
    const o = i[a++];
    n[s++] = i[a++], n[s++] = o;
    for (let A = 2; A < r; ++A)
      n[s++] = i[a++];
  }
  return n.length = s, n;
}
class wte extends FB {
  /**
   * @param {Options} [options] Optional configuration object.
   */
  constructor(e) {
    super(), e = e || {}, this.dataProjection = Ct("EPSG:4326"), this.factor_ = e.factor ? e.factor : 1e5, this.geometryLayout_ = e.geometryLayout ? e.geometryLayout : "XY";
  }
  /**
   * @protected
   * @param {string} text Text.
   * @param {import("./Feature.js").ReadOptions} [options] Read options.
   * @return {import("../Feature.js").default} Feature.
   */
  readFeatureFromText(e, t) {
    const r = this.readGeometryFromText(e, t);
    return new qt(r);
  }
  /**
   * @param {string} text Text.
   * @param {import("./Feature.js").ReadOptions} [options] Read options.
   * @protected
   * @return {Array<Feature>} Features.
   */
  readFeaturesFromText(e, t) {
    return [this.readFeatureFromText(e, t)];
  }
  /**
   * @param {string} text Text.
   * @param {import("./Feature.js").ReadOptions} [options] Read options.
   * @protected
   * @return {import("../geom/Geometry.js").default} Geometry.
   */
  readGeometryFromText(e, t) {
    const r = Fd(this.geometryLayout_), n = Cte(e, r, this.factor_);
    TT(n, 0, n.length, r, n);
    const s = Qo(
      n,
      0,
      n.length,
      r
    ), a = new Gr(s, this.geometryLayout_);
    return ui(
      a,
      !1,
      this.adaptOptions(t)
    );
  }
  /**
   * @param {import("../Feature.js").default<LineString>} feature Features.
   * @param {import("./Feature.js").WriteOptions} [options] Write options.
   * @protected
   * @return {string} Text.
   */
  writeFeatureText(e, t) {
    const r = e.getGeometry();
    return r ? this.writeGeometryText(r, t) : (lt(!1, 40), "");
  }
  /**
   * @param {Array<import("../Feature.js").default<LineString>>} features Features.
   * @param {import("./Feature.js").WriteOptions} [options] Write options.
   * @protected
   * @return {string} Text.
   */
  writeFeaturesText(e, t) {
    return this.writeFeatureText(e[0], t);
  }
  /**
   * @param {LineString} geometry Geometry.
   * @param {import("./Feature.js").WriteOptions} [options] Write options.
   * @protected
   * @return {string} Text.
   */
  writeGeometryText(e, t) {
    e = /** @type {LineString} */
    ui(e, !0, this.adaptOptions(t));
    const r = e.getFlatCoordinates(), n = e.getStride();
    return TT(r, 0, r.length, n, r), xte(r, n, this.factor_);
  }
}
function xte(i, e, t) {
  t = t || 1e5;
  let r;
  const n = new Array(e);
  for (r = 0; r < e; ++r)
    n[r] = 0;
  for (let s = 0, a = i.length; s < a; )
    for (r = 0; r < e; ++r, ++s) {
      const o = i[s], A = o - n[r];
      n[r] = o, i[s] = A;
    }
  return Ete(i, t);
}
function Cte(i, e, t) {
  t = t || 1e5;
  let r;
  const n = new Array(e);
  for (r = 0; r < e; ++r)
    n[r] = 0;
  const s = Bte(i, t);
  for (let a = 0, o = s.length; a < o; )
    for (r = 0; r < e; ++r, ++a)
      n[r] += s[a], s[a] = n[r];
  return s;
}
function Ete(i, e) {
  e = e || 1e5;
  for (let t = 0, r = i.length; t < r; ++t)
    i[t] = Math.round(i[t] * e);
  return bte(i);
}
function Bte(i, e) {
  e = e || 1e5;
  const t = Ste(i);
  for (let r = 0, n = t.length; r < n; ++r)
    t[r] /= e;
  return t;
}
function bte(i) {
  for (let e = 0, t = i.length; e < t; ++e) {
    const r = i[e];
    i[e] = r < 0 ? ~(r << 1) : r << 1;
  }
  return Tte(i);
}
function Ste(i) {
  const e = Fte(i);
  for (let t = 0, r = e.length; t < r; ++t) {
    const n = e[t];
    e[t] = n & 1 ? ~(n >> 1) : n >> 1;
  }
  return e;
}
function Tte(i) {
  let e = "";
  for (let t = 0, r = i.length; t < r; ++t)
    e += Lte(i[t]);
  return e;
}
function Fte(i) {
  const e = [];
  let t = 0, r = 0;
  for (let n = 0, s = i.length; n < s; ++n) {
    const a = i.charCodeAt(n) - 63;
    t |= (a & 31) << r, a < 32 ? (e.push(t), t = 0, r = 0) : r += 5;
  }
  return e;
}
function Lte(i) {
  let e, t = "";
  for (; i >= 32; )
    e = (32 | i & 31) + 63, t += String.fromCharCode(e), i >>= 5;
  return e = i + 63, t += String.fromCharCode(e), t;
}
const Ite = wte;
class Rte extends _B {
  /**
   * @param {Options} [options] Options.
   */
  constructor(e) {
    super(), e = e || {}, this.layerName_ = e.layerName, this.layers_ = e.layers ? e.layers : null, this.dataProjection = Ct(
      e.dataProjection ? e.dataProjection : "EPSG:4326"
    );
  }
  /**
   * @param {Object} object Object.
   * @param {import("./Feature.js").ReadOptions} [options] Read options.
   * @protected
   * @return {Array<Feature>} Features.
   */
  readFeaturesFromObject(e, t) {
    if (e.type == "Topology") {
      const r = (
        /** @type {TopoJSONTopology} */
        e
      );
      let n, s = null, a = null;
      r.transform && (n = r.transform, s = n.scale, a = n.translate);
      const o = r.arcs;
      n && Hte(o, s, a);
      const A = [], l = r.objects, h = this.layerName_;
      let c;
      for (const u in l)
        this.layers_ && !this.layers_.includes(u) || (l[u].type === "GeometryCollection" ? (c = /** @type {TopoJSONGeometryCollection} */
        l[u], A.push.apply(
          A,
          kte(
            c,
            o,
            s,
            a,
            h,
            u,
            t
          )
        )) : (c = /** @type {TopoJSONGeometry} */
        l[u], A.push(
          XN(
            c,
            o,
            s,
            a,
            h,
            u,
            t
          )
        )));
      return A;
    }
    return [];
  }
  /**
   * @param {Object} object Object.
   * @protected
   * @return {import("../proj/Projection.js").default} Projection.
   */
  readProjectionFromObject(e) {
    return this.dataProjection;
  }
}
const Mte = {
  Point: Nte,
  LineString: Ote,
  Polygon: Qte,
  MultiPoint: Pte,
  MultiLineString: Ute,
  MultiPolygon: Dte
};
function Ay(i, e) {
  const t = [];
  let r;
  for (let n = 0, s = i.length; n < s; ++n)
    if (r = i[n], n > 0 && t.pop(), r >= 0) {
      const a = e[r];
      for (let o = 0, A = a.length; o < A; ++o)
        t.push(a[o].slice(0));
    } else {
      const a = e[~r];
      for (let o = a.length - 1; o >= 0; --o)
        t.push(a[o].slice(0));
    }
  return t;
}
function Nte(i, e, t) {
  const r = i.coordinates;
  return e && t && PB(r, e, t), new gr(r);
}
function Pte(i, e, t) {
  const r = i.coordinates;
  if (e && t)
    for (let n = 0, s = r.length; n < s; ++n)
      PB(r[n], e, t);
  return new ta(r);
}
function Ote(i, e) {
  const t = Ay(i.arcs, e);
  return new Gr(t);
}
function Ute(i, e) {
  const t = [];
  for (let r = 0, n = i.arcs.length; r < n; ++r)
    t[r] = Ay(i.arcs[r], e);
  return new In(t);
}
function Qte(i, e) {
  const t = [];
  for (let r = 0, n = i.arcs.length; r < n; ++r)
    t[r] = Ay(i.arcs[r], e);
  return new Li(t);
}
function Dte(i, e) {
  const t = [];
  for (let r = 0, n = i.arcs.length; r < n; ++r) {
    const s = i.arcs[r], a = [];
    for (let o = 0, A = s.length; o < A; ++o)
      a[o] = Ay(s[o], e);
    t[r] = a;
  }
  return new Rn(t);
}
function kte(i, e, t, r, n, s, a) {
  const o = i.geometries, A = [];
  for (let l = 0, h = o.length; l < h; ++l)
    A[l] = XN(
      o[l],
      e,
      t,
      r,
      n,
      s,
      a
    );
  return A;
}
function XN(i, e, t, r, n, s, a) {
  let o = null;
  const A = i.type;
  if (A) {
    const c = Mte[A];
    A === "Point" || A === "MultiPoint" ? o = c(i, t, r) : o = c(i, e), o = ui(o, !1, a);
  }
  const l = new qt({ geometry: o });
  i.id !== void 0 && l.setId(i.id);
  let h = i.properties;
  return n && (h || (h = {}), h[n] = s), h && l.setProperties(h, !0), l;
}
function Hte(i, e, t) {
  for (let r = 0, n = i.length; r < n; ++r)
    Gte(i[r], e, t);
}
function Gte(i, e, t) {
  let r = 0, n = 0;
  for (let s = 0, a = i.length; s < a; ++s) {
    const o = i[s];
    r += o[0], n += o[1], o[0] = r, o[1] = n, PB(o, e, t);
  }
}
function PB(i, e, t) {
  i[0] = i[0] * e[0] + t[0], i[1] = i[1] * e[1] + t[1];
}
const $te = Rte;
class Br extends zt {
  /**
   * @param {import("./GMLBase.js").Options} [options] Optional configuration object.
   */
  constructor(e) {
    e = e || {}, super(e), this.schemaLocation = e.schemaLocation ? e.schemaLocation : this.namespace + " http://schemas.opengis.net/gml/3.2.1/gml.xsd";
  }
  /**
   * @param {Node} node Node.
   * @param {import("../geom/Geometry.js").default|import("../extent.js").Extent} geometry Geometry.
   * @param {Array<*>} objectStack Node stack.
   */
  writeGeometryElement(e, t, r) {
    const n = r[r.length - 1];
    r[r.length - 1] = Object.assign(
      { multiCurve: !0, multiSurface: !0 },
      n
    ), super.writeGeometryElement(e, t, r);
  }
}
Br.prototype.namespace = "http://www.opengis.net/gml/3.2";
Br.prototype.GEOMETRY_FLAT_COORDINATES_PARSERS = {
  "http://www.opengis.net/gml/3.2": {
    pos: wt(zt.prototype.readFlatPos),
    posList: wt(zt.prototype.readFlatPosList),
    coordinates: wt(Uu.prototype.readFlatCoordinates)
  }
};
Br.prototype.FLAT_LINEAR_RINGS_PARSERS = {
  "http://www.opengis.net/gml/3.2": {
    interior: zt.prototype.interiorParser,
    exterior: zt.prototype.exteriorParser
  }
};
Br.prototype.GEOMETRY_PARSERS = {
  "http://www.opengis.net/gml/3.2": {
    Point: wt(Xt.prototype.readPoint),
    MultiPoint: wt(Xt.prototype.readMultiPoint),
    LineString: wt(Xt.prototype.readLineString),
    MultiLineString: wt(Xt.prototype.readMultiLineString),
    LinearRing: wt(Xt.prototype.readLinearRing),
    Polygon: wt(Xt.prototype.readPolygon),
    MultiPolygon: wt(Xt.prototype.readMultiPolygon),
    Surface: wt(Br.prototype.readSurface),
    MultiSurface: wt(zt.prototype.readMultiSurface),
    Curve: wt(Br.prototype.readCurve),
    MultiCurve: wt(zt.prototype.readMultiCurve),
    Envelope: wt(Br.prototype.readEnvelope)
  }
};
Br.prototype.MULTICURVE_PARSERS = {
  "http://www.opengis.net/gml/3.2": {
    curveMember: ht(zt.prototype.curveMemberParser),
    curveMembers: ht(zt.prototype.curveMemberParser)
  }
};
Br.prototype.MULTISURFACE_PARSERS = {
  "http://www.opengis.net/gml/3.2": {
    surfaceMember: ht(zt.prototype.surfaceMemberParser),
    surfaceMembers: ht(zt.prototype.surfaceMemberParser)
  }
};
Br.prototype.CURVEMEMBER_PARSERS = {
  "http://www.opengis.net/gml/3.2": {
    LineString: ht(Xt.prototype.readLineString),
    Curve: ht(zt.prototype.readCurve)
  }
};
Br.prototype.SURFACEMEMBER_PARSERS = {
  "http://www.opengis.net/gml/3.2": {
    Polygon: ht(Xt.prototype.readPolygon),
    Surface: ht(zt.prototype.readSurface)
  }
};
Br.prototype.SURFACE_PARSERS = {
  "http://www.opengis.net/gml/3.2": {
    patches: wt(zt.prototype.readPatch)
  }
};
Br.prototype.CURVE_PARSERS = {
  "http://www.opengis.net/gml/3.2": {
    segments: wt(zt.prototype.readSegment)
  }
};
Br.prototype.ENVELOPE_PARSERS = {
  "http://www.opengis.net/gml/3.2": {
    lowerCorner: ht(zt.prototype.readFlatPosList),
    upperCorner: ht(zt.prototype.readFlatPosList)
  }
};
Br.prototype.PATCHES_PARSERS = {
  "http://www.opengis.net/gml/3.2": {
    PolygonPatch: wt(zt.prototype.readPolygonPatch)
  }
};
Br.prototype.SEGMENTS_PARSERS = {
  "http://www.opengis.net/gml/3.2": {
    LineStringSegment: nv(
      zt.prototype.readLineStringSegment
    )
  }
};
Br.prototype.MULTIPOINT_PARSERS = {
  "http://www.opengis.net/gml/3.2": {
    pointMember: ht(Xt.prototype.pointMemberParser),
    pointMembers: ht(Xt.prototype.pointMemberParser)
  }
};
Br.prototype.MULTILINESTRING_PARSERS = {
  "http://www.opengis.net/gml/3.2": {
    lineStringMember: ht(
      Xt.prototype.lineStringMemberParser
    ),
    lineStringMembers: ht(
      Xt.prototype.lineStringMemberParser
    )
  }
};
Br.prototype.MULTIPOLYGON_PARSERS = {
  "http://www.opengis.net/gml/3.2": {
    polygonMember: ht(Xt.prototype.polygonMemberParser),
    polygonMembers: ht(Xt.prototype.polygonMemberParser)
  }
};
Br.prototype.POINTMEMBER_PARSERS = {
  "http://www.opengis.net/gml/3.2": {
    Point: ht(Xt.prototype.readFlatCoordinatesFromNode)
  }
};
Br.prototype.LINESTRINGMEMBER_PARSERS = {
  "http://www.opengis.net/gml/3.2": {
    LineString: ht(Xt.prototype.readLineString)
  }
};
Br.prototype.POLYGONMEMBER_PARSERS = {
  "http://www.opengis.net/gml/3.2": {
    Polygon: ht(Xt.prototype.readPolygon)
  }
};
Br.prototype.RING_PARSERS = {
  "http://www.opengis.net/gml/3.2": {
    LinearRing: wt(Xt.prototype.readFlatLinearRing),
    Ring: wt(Br.prototype.readFlatCurveRing)
  }
};
Br.prototype.RING_SERIALIZERS = {
  "http://www.opengis.net/gml/3.2": {
    exterior: te(zt.prototype.writeRing),
    interior: te(zt.prototype.writeRing)
  }
};
Br.prototype.ENVELOPE_SERIALIZERS = {
  "http://www.opengis.net/gml/3.2": {
    lowerCorner: te(Tt),
    upperCorner: te(Tt)
  }
};
Br.prototype.SURFACEORPOLYGONMEMBER_SERIALIZERS = {
  "http://www.opengis.net/gml/3.2": {
    surfaceMember: te(
      zt.prototype.writeSurfaceOrPolygonMember
    ),
    polygonMember: te(
      zt.prototype.writeSurfaceOrPolygonMember
    )
  }
};
Br.prototype.POINTMEMBER_SERIALIZERS = {
  "http://www.opengis.net/gml/3.2": {
    pointMember: te(zt.prototype.writePointMember)
  }
};
Br.prototype.LINESTRINGORCURVEMEMBER_SERIALIZERS = {
  "http://www.opengis.net/gml/3.2": {
    lineStringMember: te(
      zt.prototype.writeLineStringOrCurveMember
    ),
    curveMember: te(
      zt.prototype.writeLineStringOrCurveMember
    )
  }
};
Br.prototype.GEOMETRY_SERIALIZERS = {
  "http://www.opengis.net/gml/3.2": {
    Curve: te(zt.prototype.writeCurveOrLineString),
    MultiCurve: te(zt.prototype.writeMultiCurveOrLineString),
    Point: te(Br.prototype.writePoint),
    MultiPoint: te(zt.prototype.writeMultiPoint),
    LineString: te(zt.prototype.writeCurveOrLineString),
    MultiLineString: te(
      zt.prototype.writeMultiCurveOrLineString
    ),
    LinearRing: te(zt.prototype.writeLinearRing),
    Polygon: te(zt.prototype.writeSurfaceOrPolygon),
    MultiPolygon: te(
      zt.prototype.writeMultiSurfaceOrPolygon
    ),
    Surface: te(zt.prototype.writeSurfaceOrPolygon),
    MultiSurface: te(
      zt.prototype.writeMultiSurfaceOrPolygon
    ),
    Envelope: te(zt.prototype.writeEnvelope)
  }
};
const OB = Br;
class Vte {
  /**
   * @param {!string} tagName The XML tag name for this filter.
   */
  constructor(e) {
    this.tagName_ = e;
  }
  /**
   * The XML tag name for a filter.
   * @return {!string} Name.
   */
  getTagName() {
    return this.tagName_;
  }
}
const WN = Vte;
class Kte extends WN {
  /**
   * @param {!string} tagName The XML tag name for this filter.
   * @param {Array<import("./Filter.js").default>} conditions Conditions.
   */
  constructor(e, t) {
    super(e), this.conditions = t, lt(this.conditions.length >= 2, 57);
  }
}
const jte = Kte;
class zte extends jte {
  /**
   * @param {...import("./Filter.js").default} conditions Conditions.
   */
  constructor(e) {
    super("And", Array.prototype.slice.call(arguments));
  }
}
const Xte = zte;
class Wte extends WN {
  /**
   * @param {!string} geometryName Geometry name to use.
   * @param {!import("../../extent.js").Extent} extent Extent.
   * @param {string} [srsName] SRS name. No srsName attribute will be set
   * on geometries when this is not provided.
   */
  constructor(e, t, r) {
    if (super("BBOX"), this.geometryName = e, this.extent = t, t.length !== 4)
      throw new Error(
        "Expected an extent with four values ([minX, minY, maxX, maxY])"
      );
    this.srsName = r;
  }
}
const Yte = Wte;
function qte(i) {
  const e = [null].concat(Array.prototype.slice.call(arguments));
  return new (Function.prototype.bind.apply(Xte, e))();
}
function Zte(i, e, t) {
  return new Yte(i, e, t);
}
const FT = {
  "http://www.opengis.net/gml": {
    boundedBy: J(
      Xt.prototype.readExtentElement,
      "bounds"
    )
  },
  "http://www.opengis.net/wfs/2.0": {
    member: ht(Xt.prototype.readFeaturesInternal)
  }
}, Jte = {
  "http://www.opengis.net/wfs": {
    totalInserted: J(Hi),
    totalUpdated: J(Hi),
    totalDeleted: J(Hi)
  },
  "http://www.opengis.net/wfs/2.0": {
    totalInserted: J(Hi),
    totalUpdated: J(Hi),
    totalDeleted: J(Hi)
  }
}, ere = {
  "http://www.opengis.net/wfs": {
    TransactionSummary: J(
      IT,
      "transactionSummary"
    ),
    InsertResults: J(MT, "insertIds")
  },
  "http://www.opengis.net/wfs/2.0": {
    TransactionSummary: J(
      IT,
      "transactionSummary"
    ),
    InsertResults: J(MT, "insertIds")
  }
}, tre = {
  "http://www.opengis.net/wfs": {
    PropertyName: te(Tt)
  },
  "http://www.opengis.net/wfs/2.0": {
    PropertyName: te(Tt)
  }
}, YN = {
  "http://www.opengis.net/wfs": {
    Insert: te(NT),
    Update: te(OT),
    Delete: te(PT),
    Property: te(UT),
    Native: te(QT)
  },
  "http://www.opengis.net/wfs/2.0": {
    Insert: te(NT),
    Update: te(OT),
    Delete: te(PT),
    Property: te(UT),
    Native: te(QT)
  }
}, qN = "feature", UB = "http://www.w3.org/2000/xmlns/", QB = {
  "2.0.0": "http://www.opengis.net/ogc/1.1",
  "1.1.0": "http://www.opengis.net/ogc",
  "1.0.0": "http://www.opengis.net/ogc"
}, jx = {
  "2.0.0": "http://www.opengis.net/wfs/2.0",
  "1.1.0": "http://www.opengis.net/wfs",
  "1.0.0": "http://www.opengis.net/wfs"
}, DB = {
  "2.0.0": "http://www.opengis.net/fes/2.0",
  "1.1.0": "http://www.opengis.net/fes",
  "1.0.0": "http://www.opengis.net/fes"
}, LT = {
  "2.0.0": "http://www.opengis.net/wfs/2.0 http://schemas.opengis.net/wfs/2.0/wfs.xsd",
  "1.1.0": "http://www.opengis.net/wfs http://schemas.opengis.net/wfs/1.1.0/wfs.xsd",
  "1.0.0": "http://www.opengis.net/wfs http://schemas.opengis.net/wfs/1.0.0/wfs.xsd"
}, kB = {
  "2.0.0": OB,
  "1.1.0": zt,
  "1.0.0": Uu
}, rre = "1.1.0";
class ire extends Tg {
  /**
   * @param {Options} [options] Optional configuration object.
   */
  constructor(e) {
    super(), e = e || {}, this.version_ = e.version ? e.version : rre, this.featureType_ = e.featureType, this.featureNS_ = e.featureNS, this.gmlFormat_ = e.gmlFormat ? e.gmlFormat : new kB[this.version_](), this.schemaLocation_ = e.schemaLocation ? e.schemaLocation : LT[this.version_];
  }
  /**
   * @return {Array<string>|string|undefined} featureType
   */
  getFeatureType() {
    return this.featureType_;
  }
  /**
   * @param {Array<string>|string|undefined} featureType Feature type(s) to parse.
   */
  setFeatureType(e) {
    this.featureType_ = e;
  }
  /**
   * @protected
   * @param {Element} node Node.
   * @param {import("./Feature.js").ReadOptions} [options] Options.
   * @return {Array<import("../Feature.js").default>} Features.
   */
  readFeaturesFromNode(e, t) {
    const r = {
      node: e
    };
    Object.assign(r, {
      featureType: this.featureType_,
      featureNS: this.featureNS_
    }), Object.assign(r, this.getReadOptions(e, t || {}));
    const n = [r];
    let s;
    this.version_ === "2.0.0" ? s = FT : s = this.gmlFormat_.FEATURE_COLLECTION_PARSERS;
    let a = Se(
      [],
      s,
      e,
      n,
      this.gmlFormat_
    );
    return a || (a = []), a;
  }
  /**
   * Read transaction response of the source.
   *
   * @param {Document|Element|Object|string} source Source.
   * @return {TransactionResponse|undefined} Transaction response.
   * @api
   */
  readTransactionResponse(e) {
    if (e) {
      if (typeof e == "string") {
        const t = Ka(e);
        return this.readTransactionResponseFromDocument(t);
      } else if (Va(e))
        return this.readTransactionResponseFromDocument(
          /** @type {Document} */
          e
        );
    } else
      return;
    return this.readTransactionResponseFromNode(
      /** @type {Element} */
      e
    );
  }
  /**
   * Read feature collection metadata of the source.
   *
   * @param {Document|Element|Object|string} source Source.
   * @return {FeatureCollectionMetadata|undefined}
   *     FeatureCollection metadata.
   * @api
   */
  readFeatureCollectionMetadata(e) {
    if (e) {
      if (typeof e == "string") {
        const t = Ka(e);
        return this.readFeatureCollectionMetadataFromDocument(t);
      } else if (Va(e))
        return this.readFeatureCollectionMetadataFromDocument(
          /** @type {Document} */
          e
        );
    } else
      return;
    return this.readFeatureCollectionMetadataFromNode(
      /** @type {Element} */
      e
    );
  }
  /**
   * @param {Document} doc Document.
   * @return {FeatureCollectionMetadata|undefined}
   *     FeatureCollection metadata.
   */
  readFeatureCollectionMetadataFromDocument(e) {
    for (let t = (
      /** @type {Node} */
      e.firstChild
    ); t; t = t.nextSibling)
      if (t.nodeType == Node.ELEMENT_NODE)
        return this.readFeatureCollectionMetadataFromNode(
          /** @type {Element} */
          t
        );
  }
  /**
   * @param {Element} node Node.
   * @return {FeatureCollectionMetadata|undefined}
   *     FeatureCollection metadata.
   */
  readFeatureCollectionMetadataFromNode(e) {
    const t = {}, r = Do(
      e.getAttribute("numberOfFeatures")
    );
    return t.numberOfFeatures = r, Se(
      /** @type {FeatureCollectionMetadata} */
      t,
      FT,
      e,
      [],
      this.gmlFormat_
    );
  }
  /**
   * @param {Document} doc Document.
   * @return {TransactionResponse|undefined} Transaction response.
   */
  readTransactionResponseFromDocument(e) {
    for (let t = (
      /** @type {Node} */
      e.firstChild
    ); t; t = t.nextSibling)
      if (t.nodeType == Node.ELEMENT_NODE)
        return this.readTransactionResponseFromNode(
          /** @type {Element} */
          t
        );
  }
  /**
   * @param {Element} node Node.
   * @return {TransactionResponse|undefined} Transaction response.
   */
  readTransactionResponseFromNode(e) {
    return Se(
      /** @type {TransactionResponse} */
      {},
      ere,
      e,
      []
    );
  }
  /**
   * Encode format as WFS `GetFeature` and return the Node.
   *
   * @param {WriteGetFeatureOptions} options Options.
   * @return {Node} Result.
   * @api
   */
  writeGetFeature(e) {
    const t = Nt(jx[this.version_], "GetFeature");
    t.setAttribute("service", "WFS"), t.setAttribute("version", this.version_), e.handle && t.setAttribute("handle", e.handle), e.outputFormat && t.setAttribute("outputFormat", e.outputFormat), e.maxFeatures !== void 0 && t.setAttribute("maxFeatures", String(e.maxFeatures)), e.resultType && t.setAttribute("resultType", e.resultType), e.startIndex !== void 0 && t.setAttribute("startIndex", String(e.startIndex)), e.count !== void 0 && t.setAttribute("count", String(e.count)), e.viewParams !== void 0 && t.setAttribute("viewParams", e.viewParams), t.setAttributeNS(
      wh,
      "xsi:schemaLocation",
      this.schemaLocation_
    );
    const r = {
      node: t
    };
    if (Object.assign(r, {
      version: this.version_,
      srsName: e.srsName,
      featureNS: e.featureNS ? e.featureNS : this.featureNS_,
      featurePrefix: e.featurePrefix,
      propertyNames: e.propertyNames ? e.propertyNames : []
    }), lt(Array.isArray(e.featureTypes), 11), typeof e.featureTypes[0] == "string") {
      let n = e.filter;
      e.bbox && (lt(e.geometryName, 12), n = this.combineBboxAndFilter(
        e.geometryName,
        e.bbox,
        e.srsName,
        n
      )), Object.assign(r, {
        geometryName: e.geometryName,
        filter: n
      }), XT(
        t,
        /** @type {!Array<string>} */
        e.featureTypes,
        [r]
      );
    } else
      e.featureTypes.forEach((n) => {
        const s = this.combineBboxAndFilter(
          n.geometryName,
          n.bbox,
          e.srsName,
          e.filter
        );
        Object.assign(r, {
          geometryName: n.geometryName,
          filter: s
        }), XT(t, [n.name], [r]);
      });
    return t;
  }
  /**
   * Create a bbox filter and combine it with another optional filter.
   *
   * @param {!string} geometryName Geometry name to use.
   * @param {!import("../extent.js").Extent} extent Extent.
   * @param {string} [srsName] SRS name. No srsName attribute will be
   *    set on geometries when this is not provided.
   * @param {import("./filter/Filter.js").default} [filter] Filter condition.
   * @return {import("./filter/Filter.js").default} The filter.
   */
  combineBboxAndFilter(e, t, r, n) {
    const s = Zte(e, t, r);
    return n ? qte(n, s) : s;
  }
  /**
   * Encode format as WFS `Transaction` and return the Node.
   *
   * @param {Array<import("../Feature.js").default>} inserts The features to insert.
   * @param {Array<import("../Feature.js").default>} updates The features to update.
   * @param {Array<import("../Feature.js").default>} deletes The features to delete.
   * @param {WriteTransactionOptions} options Write options.
   * @return {Node} Result.
   * @api
   */
  writeTransaction(e, t, r, n) {
    const s = [], a = n.version ? n.version : this.version_, o = Nt(jx[a], "Transaction");
    o.setAttribute("service", "WFS"), o.setAttribute("version", a);
    let A;
    n && (A = n.gmlOptions ? n.gmlOptions : {}, n.handle && o.setAttribute("handle", n.handle)), o.setAttributeNS(
      wh,
      "xsi:schemaLocation",
      LT[a]
    );
    const l = nre(o, A, a, n);
    return e && e0("Insert", e, s, l), t && e0("Update", t, s, l), r && e0("Delete", r, s, l), n.nativeElements && e0(
      "Native",
      n.nativeElements,
      s,
      l
    ), o;
  }
  /**
   * @param {Document} doc Document.
   * @return {import("../proj/Projection.js").default} Projection.
   */
  readProjectionFromDocument(e) {
    for (let t = e.firstChild; t; t = t.nextSibling)
      if (t.nodeType == Node.ELEMENT_NODE)
        return this.readProjectionFromNode(
          /** @type {Element} */
          t
        );
    return null;
  }
  /**
   * @param {Element} node Node.
   * @return {import("../proj/Projection.js").default} Projection.
   */
  readProjectionFromNode(e) {
    if (e.firstElementChild && e.firstElementChild.firstElementChild) {
      e = e.firstElementChild.firstElementChild;
      for (let t = e.firstElementChild; t; t = t.nextElementSibling)
        if (!(t.childNodes.length === 0 || t.childNodes.length === 1 && t.firstChild.nodeType === 3)) {
          const r = [{}];
          return this.gmlFormat_.readGeometryElement(t, r), Ct(r.pop().srsName);
        }
    }
    return null;
  }
}
function nre(i, e, t, r) {
  const n = r.featurePrefix ? r.featurePrefix : qN;
  let s;
  return t === "1.0.0" ? s = 2 : t === "1.1.0" ? s = 3 : t === "2.0.0" && (s = 3.2), Object.assign(
    { node: i },
    {
      version: t,
      featureNS: r.featureNS,
      featureType: r.featureType,
      featurePrefix: n,
      gmlVersion: s,
      hasZ: r.hasZ,
      srsName: r.srsName
    },
    e
  );
}
function e0(i, e, t, r) {
  Rt(
    r,
    YN,
    wi(i),
    e,
    t
  );
}
function IT(i, e) {
  return Se({}, Jte, i, e);
}
const sre = {
  "http://www.opengis.net/ogc": {
    FeatureId: ht(function(i, e) {
      return i.getAttribute("fid");
    })
  },
  "http://www.opengis.net/ogc/1.1": {
    FeatureId: ht(function(i, e) {
      return i.getAttribute("fid");
    })
  }
};
function RT(i, e) {
  gs(sre, i, e);
}
const are = {
  "http://www.opengis.net/wfs": {
    Feature: RT
  },
  "http://www.opengis.net/wfs/2.0": {
    Feature: RT
  }
};
function MT(i, e) {
  return Se([], are, i, e);
}
function NT(i, e, t) {
  const r = t[t.length - 1], n = r.featureType, s = r.featureNS, a = r.gmlVersion, o = Nt(s, n);
  i.appendChild(o), a === 2 ? Uu.prototype.writeFeatureElement(o, e, t) : a === 3 ? zt.prototype.writeFeatureElement(o, e, t) : OB.prototype.writeFeatureElement(o, e, t);
}
function ZN(i, e, t) {
  const n = t[t.length - 1].version, s = QB[n], a = Nt(s, "Filter"), o = Nt(s, "FeatureId");
  a.appendChild(o), o.setAttribute(
    "fid",
    /** @type {string} */
    e
  ), i.appendChild(a);
}
function HB(i, e) {
  i = i || qN;
  const t = i + ":";
  return e.startsWith(t) ? e : t + e;
}
function PT(i, e, t) {
  const r = t[t.length - 1];
  lt(e.getId() !== void 0, 26);
  const n = r.featureType, s = r.featurePrefix, a = r.featureNS, o = HB(s, n);
  i.setAttribute("typeName", o), i.setAttributeNS(UB, "xmlns:" + s, a);
  const A = e.getId();
  A !== void 0 && ZN(i, A, t);
}
function OT(i, e, t) {
  const r = t[t.length - 1];
  lt(e.getId() !== void 0, 27);
  const n = r.version, s = r.featureType, a = r.featurePrefix, o = r.featureNS, A = HB(a, s), l = e.getGeometryName();
  i.setAttribute("typeName", A), i.setAttributeNS(UB, "xmlns:" + a, o);
  const h = e.getId();
  if (h !== void 0) {
    const c = e.getKeys(), u = [];
    for (let f = 0, g = c.length; f < g; f++) {
      const p = e.get(c[f]);
      if (p !== void 0) {
        let y = c[f];
        p && typeof /** @type {?} */
        p.getSimplifiedGeometry == "function" && (y = l), u.push({ name: y, value: p });
      }
    }
    Rt(
      /** @type {import("../xml.js").NodeStackItem} */
      {
        version: n,
        gmlVersion: r.gmlVersion,
        node: i,
        hasZ: r.hasZ,
        srsName: r.srsName
      },
      YN,
      wi("Property"),
      u,
      t
    ), ZN(i, h, t);
  }
}
function UT(i, e, t) {
  const r = t[t.length - 1], n = r.version, s = jx[n], a = Nt(s, "Name"), o = r.gmlVersion;
  if (i.appendChild(a), Tt(a, e.name), e.value !== void 0 && e.value !== null) {
    const A = Nt(s, "Value");
    i.appendChild(A), e.value && typeof /** @type {?} */
    e.value.getSimplifiedGeometry == "function" ? o === 2 ? Uu.prototype.writeGeometryElement(A, e.value, t) : o === 3 ? zt.prototype.writeGeometryElement(A, e.value, t) : OB.prototype.writeGeometryElement(A, e.value, t) : Tt(A, e.value);
  }
}
function QT(i, e, t) {
  e.vendorId && i.setAttribute("vendorId", e.vendorId), e.safeToIgnore !== void 0 && i.setAttribute("safeToIgnore", String(e.safeToIgnore)), e.value !== void 0 && Tt(i, e.value);
}
const ly = {
  "http://www.opengis.net/wfs": {
    Query: te(DT)
  },
  "http://www.opengis.net/wfs/2.0": {
    Query: te(DT)
  },
  "http://www.opengis.net/ogc": {
    During: te(GT),
    And: te(t0),
    Or: te(t0),
    Not: te($T),
    BBOX: te(kT),
    Contains: te(QA),
    Intersects: te(QA),
    Within: te(QA),
    DWithin: te(HT),
    PropertyIsEqualTo: te(Ks),
    PropertyIsNotEqualTo: te(Ks),
    PropertyIsLessThan: te(Ks),
    PropertyIsLessThanOrEqualTo: te(Ks),
    PropertyIsGreaterThan: te(Ks),
    PropertyIsGreaterThanOrEqualTo: te(Ks),
    PropertyIsNull: te(VT),
    PropertyIsBetween: te(KT),
    PropertyIsLike: te(jT)
  },
  "http://www.opengis.net/fes/2.0": {
    During: te(GT),
    And: te(t0),
    Or: te(t0),
    Not: te($T),
    BBOX: te(kT),
    Contains: te(QA),
    Disjoint: te(QA),
    Intersects: te(QA),
    ResourceId: te(Are),
    Within: te(QA),
    DWithin: te(HT),
    PropertyIsEqualTo: te(Ks),
    PropertyIsNotEqualTo: te(Ks),
    PropertyIsLessThan: te(Ks),
    PropertyIsLessThanOrEqualTo: te(Ks),
    PropertyIsGreaterThan: te(Ks),
    PropertyIsGreaterThanOrEqualTo: te(Ks),
    PropertyIsNull: te(VT),
    PropertyIsBetween: te(KT),
    PropertyIsLike: te(jT)
  }
};
function DT(i, e, t) {
  const r = (
    /** @type {Object} */
    t[t.length - 1]
  ), n = r.version, s = r.featurePrefix, a = r.featureNS, o = r.propertyNames, A = r.srsName;
  let l;
  s ? l = HB(s, e) : l = e;
  let h;
  n === "2.0.0" ? h = "typeNames" : h = "typeName", i.setAttribute(h, l), A && i.setAttribute("srsName", A), a && i.setAttributeNS(UB, "xmlns:" + s, a);
  const c = (
    /** @type {import("../xml.js").NodeStackItem} */
    Object.assign({}, r)
  );
  c.node = i, Rt(
    c,
    tre,
    wi("PropertyName"),
    o,
    t
  );
  const u = r.filter;
  if (u) {
    const f = Nt(hy(n), "Filter");
    i.appendChild(f), ore(f, u, t);
  }
}
function ore(i, e, t) {
  const r = (
    /** @type {Object} */
    t[t.length - 1]
  ), n = { node: i };
  Object.assign(n, { context: r }), Rt(
    n,
    ly,
    wi(e.getTagName()),
    [e],
    t
  );
}
function kT(i, e, t) {
  const r = (
    /** @type {Object} */
    t[t.length - 1]
  ), s = r.context.version;
  r.srsName = e.srsName;
  const a = kB[s];
  Du(s, i, e.geometryName), a.prototype.writeGeometryElement(i, e.extent, t);
}
function Are(i, e, t) {
  i.setAttribute(
    "rid",
    /** @type {string} */
    e.rid
  );
}
function QA(i, e, t) {
  const r = (
    /** @type {Object} */
    t[t.length - 1]
  ), s = r.context.version;
  r.srsName = e.srsName;
  const a = kB[s];
  Du(s, i, e.geometryName), a.prototype.writeGeometryElement(i, e.geometry, t);
}
function HT(i, e, t) {
  const s = /** @type {Object} */ t[t.length - 1].context.version;
  QA(i, e, t);
  const a = Nt(hy(s), "Distance");
  Tt(a, e.distance.toString()), s === "2.0.0" ? a.setAttribute("uom", e.unit) : a.setAttribute("units", e.unit), i.appendChild(a);
}
function GT(i, e, t) {
  const s = /** @type {Object} */ t[t.length - 1].context.version;
  Av(DB[s], "ValueReference", i, e.propertyName);
  const a = Nt(Vo, "TimePeriod");
  i.appendChild(a);
  const o = Nt(Vo, "begin");
  a.appendChild(o), zT(o, e.begin);
  const A = Nt(Vo, "end");
  a.appendChild(A), zT(A, e.end);
}
function t0(i, e, t) {
  const n = /** @type {Object} */ t[t.length - 1].context, s = { node: i };
  Object.assign(s, { context: n });
  const a = e.conditions;
  for (let o = 0, A = a.length; o < A; ++o) {
    const l = a[o];
    Rt(
      s,
      ly,
      wi(l.getTagName()),
      [l],
      t
    );
  }
}
function $T(i, e, t) {
  const n = /** @type {Object} */ t[t.length - 1].context, s = { node: i };
  Object.assign(s, { context: n });
  const a = e.condition;
  Rt(
    s,
    ly,
    wi(a.getTagName()),
    [a],
    t
  );
}
function Ks(i, e, t) {
  const s = /** @type {Object} */ t[t.length - 1].context.version;
  e.matchCase !== void 0 && i.setAttribute("matchCase", e.matchCase.toString()), Du(s, i, e.propertyName), lv(s, i, "" + e.expression);
}
function VT(i, e, t) {
  const s = /** @type {Object} */ t[t.length - 1].context.version;
  Du(s, i, e.propertyName);
}
function KT(i, e, t) {
  const s = /** @type {Object} */ t[t.length - 1].context.version, a = hy(s);
  Du(s, i, e.propertyName);
  const o = Nt(a, "LowerBoundary");
  i.appendChild(o), lv(s, o, "" + e.lowerBoundary);
  const A = Nt(a, "UpperBoundary");
  i.appendChild(A), lv(s, A, "" + e.upperBoundary);
}
function jT(i, e, t) {
  const s = /** @type {Object} */ t[t.length - 1].context.version;
  i.setAttribute("wildCard", e.wildCard), i.setAttribute("singleChar", e.singleChar), i.setAttribute("escapeChar", e.escapeChar), e.matchCase !== void 0 && i.setAttribute("matchCase", e.matchCase.toString()), Du(s, i, e.propertyName), lv(s, i, "" + e.pattern);
}
function Av(i, e, t, r) {
  const n = Nt(i, e);
  Tt(n, r), t.appendChild(n);
}
function lv(i, e, t) {
  Av(hy(i), "Literal", e, t);
}
function Du(i, e, t) {
  i === "2.0.0" ? Av(DB[i], "ValueReference", e, t) : Av(QB[i], "PropertyName", e, t);
}
function zT(i, e) {
  const t = Nt(Vo, "TimeInstant");
  i.appendChild(t);
  const r = Nt(Vo, "timePosition");
  t.appendChild(r), Tt(r, e);
}
function XT(i, e, t) {
  const r = (
    /** @type {Object} */
    t[t.length - 1]
  ), n = (
    /** @type {import("../xml.js").NodeStackItem} */
    Object.assign({}, r)
  );
  n.node = i, Rt(
    n,
    ly,
    wi("Query"),
    e,
    t
  );
}
function hy(i) {
  let e;
  return i === "2.0.0" ? e = DB[i] : e = QB[i], e;
}
const lre = ire, Mr = {
  POINT: 1,
  LINE_STRING: 2,
  POLYGON: 3,
  MULTI_POINT: 4,
  MULTI_LINE_STRING: 5,
  MULTI_POLYGON: 6,
  GEOMETRY_COLLECTION: 7,
  /*
    CIRCULAR_STRING: 8,
    COMPOUND_CURVE: 9,
    CURVE_POLYGON: 10,
  
    MULTI_CURVE: 11,
    MULTI_SURFACE: 12,
    CURVE: 13,
    SURFACE: 14,
    */
  POLYHEDRAL_SURFACE: 15,
  TIN: 16,
  TRIANGLE: 17
};
class WT {
  /**
   * @param {DataView} view source to read
   */
  constructor(e) {
    this.view_ = e, this.pos_ = 0, this.initialized_ = !1, this.isLittleEndian_ = !1, this.hasZ_ = !1, this.hasM_ = !1, this.srid_ = null, this.layout_ = "XY";
  }
  /**
   * @return {number} value
   */
  readUint8() {
    return this.view_.getUint8(this.pos_++);
  }
  /**
   * @param {boolean} [isLittleEndian] Whether read value as little endian
   * @return {number} value
   */
  readUint32(e) {
    return this.view_.getUint32(
      (this.pos_ += 4) - 4,
      e !== void 0 ? e : this.isLittleEndian_
    );
  }
  /**
   * @param {boolean} [isLittleEndian] Whether read value as little endian
   * @return {number} value
   */
  readDouble(e) {
    return this.view_.getFloat64(
      (this.pos_ += 8) - 8,
      e !== void 0 ? e : this.isLittleEndian_
    );
  }
  /**
   * @return {import('../coordinate.js').Coordinate} coords for Point
   */
  readPoint() {
    const e = [];
    return e.push(this.readDouble()), e.push(this.readDouble()), this.hasZ_ && e.push(this.readDouble()), this.hasM_ && e.push(this.readDouble()), e;
  }
  /**
   * @return {Array<import('../coordinate.js').Coordinate>} coords for LineString / LinearRing
   */
  readLineString() {
    const e = this.readUint32(), t = [];
    for (let r = 0; r < e; r++)
      t.push(this.readPoint());
    return t;
  }
  /**
   * @return {Array<Array<import('../coordinate.js').Coordinate>>} coords for Polygon like
   */
  readPolygon() {
    const e = this.readUint32(), t = [];
    for (let r = 0; r < e; r++)
      t.push(this.readLineString());
    return t;
  }
  /**
   * @param {number} [expectedTypeId] Expected WKB Type ID
   * @return {number} WKB Type ID
   */
  readWkbHeader(e) {
    const r = this.readUint8() > 0, n = this.readUint32(r), s = Math.floor((n & 268435455) / 1e3), a = !!(n & 2147483648) || s === 1 || s === 3, o = !!(n & 1073741824) || s === 2 || s === 3, A = !!(n & 536870912), l = (n & 268435455) % 1e3, h = (
      /** @type {import("../geom/Geometry.js").GeometryLayout} */
      ["XY", a ? "Z" : "", o ? "M" : ""].join("")
    ), c = A ? this.readUint32(r) : null;
    if (e !== void 0 && e !== l)
      throw new Error("Unexpected WKB geometry type " + l);
    if (this.initialized_) {
      if (this.isLittleEndian_ !== r)
        throw new Error("Inconsistent endian");
      if (this.layout_ !== h)
        throw new Error("Inconsistent geometry layout");
      if (c && this.srid_ !== c)
        throw new Error("Inconsistent coordinate system (SRID)");
    } else
      this.isLittleEndian_ = r, this.hasZ_ = a, this.hasM_ = o, this.layout_ = h, this.srid_ = c, this.initialized_ = !0;
    return l;
  }
  /**
   * @param {number} typeId WKB Type ID
   * @return {any} values read
   */
  readWkbPayload(e) {
    switch (e) {
      case Mr.POINT:
        return this.readPoint();
      case Mr.LINE_STRING:
        return this.readLineString();
      case Mr.POLYGON:
      case Mr.TRIANGLE:
        return this.readPolygon();
      case Mr.MULTI_POINT:
        return this.readMultiPoint();
      case Mr.MULTI_LINE_STRING:
        return this.readMultiLineString();
      case Mr.MULTI_POLYGON:
      case Mr.POLYHEDRAL_SURFACE:
      case Mr.TIN:
        return this.readMultiPolygon();
      case Mr.GEOMETRY_COLLECTION:
        return this.readGeometryCollection();
      default:
        throw new Error(
          "Unsupported WKB geometry type " + e + " is found"
        );
    }
  }
  /**
   * @param {number} expectedTypeId Expected WKB Type ID
   * @return {any} values read
   */
  readWkbBlock(e) {
    return this.readWkbPayload(this.readWkbHeader(e));
  }
  /**
   * @param {Function} reader reader function for each item
   * @param {number} [expectedTypeId] Expected WKB Type ID
   * @return {any} values read
   */
  readWkbCollection(e, t) {
    const r = this.readUint32(), n = [];
    for (let s = 0; s < r; s++) {
      const a = e.call(this, t);
      a && n.push(a);
    }
    return n;
  }
  /**
   * @return {Array<import('../coordinate.js').Coordinate>} coords for MultiPoint
   */
  readMultiPoint() {
    return this.readWkbCollection(this.readWkbBlock, Mr.POINT);
  }
  /**
   * @return {Array<Array<import('../coordinate.js').Coordinate>>} coords for MultiLineString like
   */
  readMultiLineString() {
    return this.readWkbCollection(
      this.readWkbBlock,
      Mr.LINE_STRING
    );
  }
  /**
   * @return {Array<Array<Array<import('../coordinate.js').Coordinate>>>} coords for MultiPolygon like
   */
  readMultiPolygon() {
    return this.readWkbCollection(this.readWkbBlock, Mr.POLYGON);
  }
  /**
   * @return {Array<import('../geom/Geometry.js').default>} array of geometries
   */
  readGeometryCollection() {
    return this.readWkbCollection(this.readGeometry);
  }
  /**
   * @return {import('../geom/Geometry.js').default} geometry
   */
  readGeometry() {
    const e = this.readWkbHeader(), t = this.readWkbPayload(e);
    switch (e) {
      case Mr.POINT:
        return new gr(
          /** @type {import('../coordinate.js').Coordinate} */
          t,
          this.layout_
        );
      case Mr.LINE_STRING:
        return new Gr(
          /** @type {Array<import('../coordinate.js').Coordinate>} */
          t,
          this.layout_
        );
      case Mr.POLYGON:
      case Mr.TRIANGLE:
        return new Li(
          /** @type {Array<Array<import('../coordinate.js').Coordinate>>} */
          t,
          this.layout_
        );
      case Mr.MULTI_POINT:
        return new ta(
          /** @type {Array<import('../coordinate.js').Coordinate>} */
          t,
          this.layout_
        );
      case Mr.MULTI_LINE_STRING:
        return new In(
          /** @type {Array<Array<import('../coordinate.js').Coordinate>>} */
          t,
          this.layout_
        );
      case Mr.MULTI_POLYGON:
      case Mr.POLYHEDRAL_SURFACE:
      case Mr.TIN:
        return new Rn(
          /** @type {Array<Array<Array<import('../coordinate.js').Coordinate>>>} */
          t,
          this.layout_
        );
      case Mr.GEOMETRY_COLLECTION:
        return new _n(
          /** @type {Array<import('../geom/Geometry.js').default>} */
          t
        );
      default:
        return null;
    }
  }
  /**
   * @return {number|null} SRID in the EWKB. `null` if not defined.
   */
  getSrid() {
    return this.srid_;
  }
}
class hre {
  /**
   * @type {Object}
   * @property {string} [layout] geometryLayout
   * @property {boolean} [littleEndian=true] littleEndian
   * @property {boolean} [ewkb=true] Whether writes in EWKB format
   * @property {Object} [nodata] NoData value for each axes
   * @param {Object} opts options
   */
  constructor(e) {
    e = e || {}, this.layout_ = e.layout, this.isLittleEndian_ = e.littleEndian !== !1, this.isEWKB_ = e.ewkb !== !1, this.writeQueue_ = [], this.nodata_ = Object.assign({ X: 0, Y: 0, Z: 0, M: 0 }, e.nodata);
  }
  /**
   * @param {number} value value
   */
  writeUint8(e) {
    this.writeQueue_.push([1, e]);
  }
  /**
   * @param {number} value value
   */
  writeUint32(e) {
    this.writeQueue_.push([4, e]);
  }
  /**
   * @param {number} value value
   */
  writeDouble(e) {
    this.writeQueue_.push([8, e]);
  }
  /**
   * @param {import('../coordinate.js').Coordinate} coords coords
   * @param {import("../geom/Geometry.js").GeometryLayout} layout layout
   */
  writePoint(e, t) {
    const r = Object.assign.apply(
      null,
      t.split("").map((n, s) => ({ [n]: e[s] }))
    );
    for (const n of this.layout_)
      this.writeDouble(
        n in r ? r[n] : this.nodata_[n]
      );
  }
  /**
   * @param {Array<import('../coordinate.js').Coordinate>} coords coords
   * @param {import("../geom/Geometry.js").GeometryLayout} layout layout
   */
  writeLineString(e, t) {
    this.writeUint32(e.length);
    for (let r = 0; r < e.length; r++)
      this.writePoint(e[r], t);
  }
  /**
   * @param {Array<Array<import('../coordinate.js').Coordinate>>} rings rings
   * @param {import("../geom/Geometry.js").GeometryLayout} layout layout
   */
  writePolygon(e, t) {
    this.writeUint32(e.length);
    for (let r = 0; r < e.length; r++)
      this.writeLineString(e[r], t);
  }
  /**
   * @param {number} wkbType WKB Type ID
   * @param {number} [srid] SRID
   */
  writeWkbHeader(e, t) {
    e %= 1e3, this.layout_.includes("Z") && (e += this.isEWKB_ ? 2147483648 : 1e3), this.layout_.includes("M") && (e += this.isEWKB_ ? 1073741824 : 2e3), this.isEWKB_ && Number.isInteger(t) && (e |= 536870912), this.writeUint8(this.isLittleEndian_ ? 1 : 0), this.writeUint32(e), this.isEWKB_ && Number.isInteger(t) && this.writeUint32(t);
  }
  /**
   * @param {Array<import('../coordinate.js').Coordinate>} coords coords
   * @param {import("../geom/Geometry.js").GeometryLayout} layout layout
   */
  writeMultiPoint(e, t) {
    this.writeUint32(e.length);
    for (let r = 0; r < e.length; r++)
      this.writeWkbHeader(1), this.writePoint(e[r], t);
  }
  /**
   * @param {Array<Array<import('../coordinate.js').Coordinate>>} coords coords
   * @param {import("../geom/Geometry.js").GeometryLayout} layout layout
   */
  writeMultiLineString(e, t) {
    this.writeUint32(e.length);
    for (let r = 0; r < e.length; r++)
      this.writeWkbHeader(2), this.writeLineString(e[r], t);
  }
  /**
   * @param {Array<Array<Array<import('../coordinate.js').Coordinate>>>} coords coords
   * @param {import("../geom/Geometry.js").GeometryLayout} layout layout
   */
  writeMultiPolygon(e, t) {
    this.writeUint32(e.length);
    for (let r = 0; r < e.length; r++)
      this.writeWkbHeader(3), this.writePolygon(e[r], t);
  }
  /**
   * @param {Array<import('../geom/Geometry.js').default>} geometries geometries
   */
  writeGeometryCollection(e) {
    this.writeUint32(e.length);
    for (let t = 0; t < e.length; t++)
      this.writeGeometry(e[t]);
  }
  /**
   * @param {import("../geom/Geometry.js").default} geom geometry
   * @param {import("../geom/Geometry.js").GeometryLayout} [layout] layout
   * @return {import("../geom/Geometry.js").GeometryLayout} minumum layout made by common axes
   */
  findMinimumLayout(e, t = "XYZM") {
    const r = (n, s) => n === s ? n : n === "XYZM" ? s : s === "XYZM" ? n : "XY";
    if (e instanceof Ea)
      return r(e.getLayout(), t);
    if (e instanceof _n) {
      const n = e.getGeometriesArray();
      for (let s = 0; s < n.length && t !== "XY"; s++)
        t = this.findMinimumLayout(n[s], t);
    }
    return t;
  }
  /**
   * @param {import("../geom/Geometry.js").default} geom geometry
   * @param {number} [srid] SRID
   */
  writeGeometry(e, t) {
    const r = {
      Point: Mr.POINT,
      LineString: Mr.LINE_STRING,
      Polygon: Mr.POLYGON,
      MultiPoint: Mr.MULTI_POINT,
      MultiLineString: Mr.MULTI_LINE_STRING,
      MultiPolygon: Mr.MULTI_POLYGON,
      GeometryCollection: Mr.GEOMETRY_COLLECTION
    }, n = e.getType(), s = r[n];
    if (!s)
      throw new Error("GeometryType " + n + " is not supported");
    this.layout_ || (this.layout_ = this.findMinimumLayout(e)), this.writeWkbHeader(s, t), e instanceof Ea ? {
      Point: this.writePoint,
      LineString: this.writeLineString,
      Polygon: this.writePolygon,
      MultiPoint: this.writeMultiPoint,
      MultiLineString: this.writeMultiLineString,
      MultiPolygon: this.writeMultiPolygon
    }[n].call(this, e.getCoordinates(), e.getLayout()) : e instanceof _n && this.writeGeometryCollection(e.getGeometriesArray());
  }
  getBuffer() {
    const e = this.writeQueue_.reduce((s, a) => s + a[0], 0), t = new ArrayBuffer(e), r = new DataView(t);
    let n = 0;
    return this.writeQueue_.forEach((s) => {
      switch (s[0]) {
        case 1:
          r.setUint8(n, s[1]);
          break;
        case 4:
          r.setUint32(n, s[1], this.isLittleEndian_);
          break;
        case 8:
          r.setFloat64(n, s[1], this.isLittleEndian_);
          break;
      }
      n += s[0];
    }), t;
  }
}
class cre extends bg {
  /**
   * @param {Options} [options] Optional configuration object.
   */
  constructor(e) {
    super(), e = e || {}, this.splitCollection = !!e.splitCollection, this.viewCache_ = null, this.hex_ = e.hex !== !1, this.littleEndian_ = e.littleEndian !== !1, this.ewkb_ = e.ewkb !== !1, this.layout_ = e.geometryLayout, this.nodataZ_ = e.nodataZ || 0, this.nodataM_ = e.nodataM || 0, this.srid_ = e.srid;
  }
  /**
   * @return {import("./Feature.js").Type} Format.
   */
  getType() {
    return this.hex_ ? "text" : "arraybuffer";
  }
  /**
   * Read a single feature from a source.
   *
   * @param {string|ArrayBuffer|ArrayBufferView} source Source.
   * @param {import("./Feature.js").ReadOptions} [options] Read options.
   * @return {import("../Feature.js").default} Feature.
   * @api
   */
  readFeature(e, t) {
    return new qt({
      geometry: this.readGeometry(e, t)
    });
  }
  /**
   * Read all features from a source.
   *
   * @param {string|ArrayBuffer|ArrayBufferView} source Source.
   * @param {import("./Feature.js").ReadOptions} [options] Read options.
   * @return {Array<import("../Feature.js").default>} Features.
   * @api
   */
  readFeatures(e, t) {
    let r = [];
    const n = this.readGeometry(e, t);
    return this.splitCollection && n instanceof _n ? r = n.getGeometriesArray() : r = [n], r.map((s) => new qt({ geometry: s }));
  }
  /**
   * Read a single geometry from a source.
   *
   * @param {string|ArrayBuffer|ArrayBufferView} source Source.
   * @param {import("./Feature.js").ReadOptions} [options] Read options.
   * @return {import("../geom/Geometry.js").default} Geometry.
   * @api
   */
  readGeometry(e, t) {
    const r = YT(e);
    if (!r)
      return null;
    const s = new WT(r).readGeometry();
    return this.viewCache_ = r, t = this.getReadOptions(e, t), this.viewCache_ = null, ui(s, !1, t);
  }
  /**
   * Read the projection from a source.
   *
   * @param {string|ArrayBuffer|ArrayBufferView} source Source.
   * @return {import("../proj/Projection.js").default|undefined} Projection.
   * @api
   */
  readProjection(e) {
    const t = this.viewCache_ || YT(e);
    if (!t)
      return;
    const r = new WT(t);
    return r.readWkbHeader(), r.getSrid() && Ct("EPSG:" + r.getSrid()) || void 0;
  }
  /**
   * Encode a feature in this format.
   *
   * @param {import("../Feature.js").default} feature Feature.
   * @param {import("./Feature.js").WriteOptions} [options] Write options.
   * @return {string|ArrayBuffer} Result.
   * @api
   */
  writeFeature(e, t) {
    return this.writeGeometry(e.getGeometry(), t);
  }
  /**
   * Encode an array of features in this format.
   *
   * @param {Array<import("../Feature.js").default>} features Features.
   * @param {import("./Feature.js").WriteOptions} [options] Write options.
   * @return {string|ArrayBuffer} Result.
   * @api
   */
  writeFeatures(e, t) {
    return this.writeGeometry(
      new _n(e.map((r) => r.getGeometry())),
      t
    );
  }
  /**
   * Write a single geometry in this format.
   *
   * @param {import("../geom/Geometry.js").default} geometry Geometry.
   * @param {import("./Feature.js").WriteOptions} [options] Write options.
   * @return {string|ArrayBuffer} Result.
   * @api
   */
  writeGeometry(e, t) {
    t = this.adaptOptions(t);
    const r = new hre({
      layout: this.layout_,
      littleEndian: this.littleEndian_,
      ewkb: this.ewkb_,
      nodata: {
        Z: this.nodataZ_,
        M: this.nodataM_
      }
    });
    let n = Number.isInteger(this.srid_) ? Number(this.srid_) : null;
    if (this.srid_ !== !1 && !Number.isInteger(this.srid_)) {
      const a = t.dataProjection && Ct(t.dataProjection);
      if (a) {
        const o = a.getCode();
        o.startsWith("EPSG:") && (n = Number(o.substring(5)));
      }
    }
    r.writeGeometry(
      ui(e, !0, t),
      n
    );
    const s = r.getBuffer();
    return this.hex_ ? ure(s) : s;
  }
}
function ure(i) {
  const e = new Uint8Array(i);
  return Array.from(e.values()).map((t) => (t < 16 ? "0" : "") + Number(t).toString(16).toUpperCase()).join("");
}
function fre(i) {
  const e = new Uint8Array(i.length / 2);
  for (let t = 0; t < i.length / 2; t++)
    e[t] = parseInt(i.substr(t * 2, 2), 16);
  return new DataView(e.buffer);
}
function YT(i) {
  return typeof i == "string" ? fre(i) : ArrayBuffer.isView(i) ? i instanceof DataView ? i : new DataView(i.buffer, i.byteOffset, i.byteLength) : i instanceof ArrayBuffer ? new DataView(i) : null;
}
const dre = cre, gre = {
  POINT: gr,
  LINESTRING: Gr,
  POLYGON: Li,
  MULTIPOINT: ta,
  MULTILINESTRING: In,
  MULTIPOLYGON: Rn
}, JN = "EMPTY", eP = "Z", tP = "M", pre = "ZM", Tr = {
  START: 0,
  TEXT: 1,
  LEFT_PAREN: 2,
  RIGHT_PAREN: 3,
  NUMBER: 4,
  COMMA: 5,
  EOF: 6
}, mre = {
  Point: "POINT",
  LineString: "LINESTRING",
  Polygon: "POLYGON",
  MultiPoint: "MULTIPOINT",
  MultiLineString: "MULTILINESTRING",
  MultiPolygon: "MULTIPOLYGON",
  GeometryCollection: "GEOMETRYCOLLECTION",
  Circle: "CIRCLE"
};
class vre {
  /**
   * @param {string} wkt WKT string.
   */
  constructor(e) {
    this.wkt = e, this.index_ = -1;
  }
  /**
   * @param {string} c Character.
   * @return {boolean} Whether the character is alphabetic.
   * @private
   */
  isAlpha_(e) {
    return e >= "a" && e <= "z" || e >= "A" && e <= "Z";
  }
  /**
   * @param {string} c Character.
   * @param {boolean} [decimal] Whether the string number
   *     contains a dot, i.e. is a decimal number.
   * @return {boolean} Whether the character is numeric.
   * @private
   */
  isNumeric_(e, t) {
    return t = t !== void 0 ? t : !1, e >= "0" && e <= "9" || e == "." && !t;
  }
  /**
   * @param {string} c Character.
   * @return {boolean} Whether the character is whitespace.
   * @private
   */
  isWhiteSpace_(e) {
    return e == " " || e == "	" || e == "\r" || e == `
`;
  }
  /**
   * @return {string} Next string character.
   * @private
   */
  nextChar_() {
    return this.wkt.charAt(++this.index_);
  }
  /**
   * Fetch and return the next token.
   * @return {Token} Next string token.
   */
  nextToken() {
    const e = this.nextChar_(), t = this.index_;
    let r = e, n;
    if (e == "(")
      n = Tr.LEFT_PAREN;
    else if (e == ",")
      n = Tr.COMMA;
    else if (e == ")")
      n = Tr.RIGHT_PAREN;
    else if (this.isNumeric_(e) || e == "-")
      n = Tr.NUMBER, r = this.readNumber_();
    else if (this.isAlpha_(e))
      n = Tr.TEXT, r = this.readText_();
    else {
      if (this.isWhiteSpace_(e))
        return this.nextToken();
      if (e === "")
        n = Tr.EOF;
      else
        throw new Error("Unexpected character: " + e);
    }
    return { position: t, value: r, type: n };
  }
  /**
   * @return {number} Numeric token value.
   * @private
   */
  readNumber_() {
    let e;
    const t = this.index_;
    let r = !1, n = !1;
    do
      e == "." ? r = !0 : (e == "e" || e == "E") && (n = !0), e = this.nextChar_();
    while (this.isNumeric_(e, r) || // if we haven't detected a scientific number before, 'e' or 'E'
    // hint that we should continue to read
    !n && (e == "e" || e == "E") || // once we know that we have a scientific number, both '-' and '+'
    // are allowed
    n && (e == "-" || e == "+"));
    return parseFloat(this.wkt.substring(t, this.index_--));
  }
  /**
   * @return {string} String token value.
   * @private
   */
  readText_() {
    let e;
    const t = this.index_;
    do
      e = this.nextChar_();
    while (this.isAlpha_(e));
    return this.wkt.substring(t, this.index_--).toUpperCase();
  }
}
let yre = class {
  /**
   * @param {Lexer} lexer The lexer.
   */
  constructor(e) {
    this.lexer_ = e, this.token_ = {
      position: 0,
      type: Tr.START
    }, this.layout_ = "XY";
  }
  /**
   * Fetch the next token form the lexer and replace the active token.
   * @private
   */
  consume_() {
    this.token_ = this.lexer_.nextToken();
  }
  /**
   * Tests if the given type matches the type of the current token.
   * @param {TokenType} type Token type.
   * @return {boolean} Whether the token matches the given type.
   */
  isTokenType(e) {
    return this.token_.type == e;
  }
  /**
   * If the given type matches the current token, consume it.
   * @param {TokenType} type Token type.
   * @return {boolean} Whether the token matches the given type.
   */
  match(e) {
    const t = this.isTokenType(e);
    return t && this.consume_(), t;
  }
  /**
   * Try to parse the tokens provided by the lexer.
   * @return {import("../geom/Geometry.js").default} The geometry.
   */
  parse() {
    return this.consume_(), this.parseGeometry_();
  }
  /**
   * Try to parse the dimensional info.
   * @return {import("../geom/Geometry.js").GeometryLayout} The layout.
   * @private
   */
  parseGeometryLayout_() {
    let e = "XY";
    const t = this.token_;
    if (this.isTokenType(Tr.TEXT)) {
      const r = t.value;
      r === eP ? e = "XYZ" : r === tP ? e = "XYM" : r === pre && (e = "XYZM"), e !== "XY" && this.consume_();
    }
    return e;
  }
  /**
   * @return {Array<import("../geom/Geometry.js").default>} A collection of geometries.
   * @private
   */
  parseGeometryCollectionText_() {
    if (this.match(Tr.LEFT_PAREN)) {
      const e = [];
      do
        e.push(this.parseGeometry_());
      while (this.match(Tr.COMMA));
      if (this.match(Tr.RIGHT_PAREN))
        return e;
    }
    throw new Error(this.formatErrorMessage_());
  }
  /**
   * @return {Array<number>} All values in a point.
   * @private
   */
  parsePointText_() {
    if (this.match(Tr.LEFT_PAREN)) {
      const e = this.parsePoint_();
      if (this.match(Tr.RIGHT_PAREN))
        return e;
    }
    throw new Error(this.formatErrorMessage_());
  }
  /**
   * @return {Array<Array<number>>} All points in a linestring.
   * @private
   */
  parseLineStringText_() {
    if (this.match(Tr.LEFT_PAREN)) {
      const e = this.parsePointList_();
      if (this.match(Tr.RIGHT_PAREN))
        return e;
    }
    throw new Error(this.formatErrorMessage_());
  }
  /**
   * @return {Array<Array<Array<number>>>} All points in a polygon.
   * @private
   */
  parsePolygonText_() {
    if (this.match(Tr.LEFT_PAREN)) {
      const e = this.parseLineStringTextList_();
      if (this.match(Tr.RIGHT_PAREN))
        return e;
    }
    throw new Error(this.formatErrorMessage_());
  }
  /**
   * @return {Array<Array<number>>} All points in a multipoint.
   * @private
   */
  parseMultiPointText_() {
    if (this.match(Tr.LEFT_PAREN)) {
      let e;
      if (this.token_.type == Tr.LEFT_PAREN ? e = this.parsePointTextList_() : e = this.parsePointList_(), this.match(Tr.RIGHT_PAREN))
        return e;
    }
    throw new Error(this.formatErrorMessage_());
  }
  /**
   * @return {Array<Array<Array<number>>>} All linestring points
   *                                          in a multilinestring.
   * @private
   */
  parseMultiLineStringText_() {
    if (this.match(Tr.LEFT_PAREN)) {
      const e = this.parseLineStringTextList_();
      if (this.match(Tr.RIGHT_PAREN))
        return e;
    }
    throw new Error(this.formatErrorMessage_());
  }
  /**
   * @return {Array<Array<Array<Array<number>>>>} All polygon points in a multipolygon.
   * @private
   */
  parseMultiPolygonText_() {
    if (this.match(Tr.LEFT_PAREN)) {
      const e = this.parsePolygonTextList_();
      if (this.match(Tr.RIGHT_PAREN))
        return e;
    }
    throw new Error(this.formatErrorMessage_());
  }
  /**
   * @return {Array<number>} A point.
   * @private
   */
  parsePoint_() {
    const e = [], t = this.layout_.length;
    for (let r = 0; r < t; ++r) {
      const n = this.token_;
      if (this.match(Tr.NUMBER))
        e.push(
          /** @type {number} */
          n.value
        );
      else
        break;
    }
    if (e.length == t)
      return e;
    throw new Error(this.formatErrorMessage_());
  }
  /**
   * @return {Array<Array<number>>} An array of points.
   * @private
   */
  parsePointList_() {
    const e = [this.parsePoint_()];
    for (; this.match(Tr.COMMA); )
      e.push(this.parsePoint_());
    return e;
  }
  /**
   * @return {Array<Array<number>>} An array of points.
   * @private
   */
  parsePointTextList_() {
    const e = [this.parsePointText_()];
    for (; this.match(Tr.COMMA); )
      e.push(this.parsePointText_());
    return e;
  }
  /**
   * @return {Array<Array<Array<number>>>} An array of points.
   * @private
   */
  parseLineStringTextList_() {
    const e = [this.parseLineStringText_()];
    for (; this.match(Tr.COMMA); )
      e.push(this.parseLineStringText_());
    return e;
  }
  /**
   * @return {Array<Array<Array<Array<number>>>>} An array of points.
   * @private
   */
  parsePolygonTextList_() {
    const e = [this.parsePolygonText_()];
    for (; this.match(Tr.COMMA); )
      e.push(this.parsePolygonText_());
    return e;
  }
  /**
   * @return {boolean} Whether the token implies an empty geometry.
   * @private
   */
  isEmptyGeometry_() {
    const e = this.isTokenType(Tr.TEXT) && this.token_.value == JN;
    return e && this.consume_(), e;
  }
  /**
   * Create an error message for an unexpected token error.
   * @return {string} Error message.
   * @private
   */
  formatErrorMessage_() {
    return "Unexpected `" + this.token_.value + "` at position " + this.token_.position + " in `" + this.lexer_.wkt + "`";
  }
  /**
   * @return {import("../geom/Geometry.js").default} The geometry.
   * @private
   */
  parseGeometry_() {
    const e = this.token_;
    if (this.match(Tr.TEXT)) {
      const t = (
        /** @type {string} */
        e.value
      );
      this.layout_ = this.parseGeometryLayout_();
      const r = this.isEmptyGeometry_();
      if (t == "GEOMETRYCOLLECTION") {
        if (r)
          return new _n([]);
        const a = this.parseGeometryCollectionText_();
        return new _n(a);
      }
      const n = gre[t];
      if (!n)
        throw new Error("Invalid geometry type: " + t);
      let s;
      if (r)
        t == "POINT" ? s = [NaN, NaN] : s = [];
      else
        switch (t) {
          case "POINT": {
            s = this.parsePointText_();
            break;
          }
          case "LINESTRING": {
            s = this.parseLineStringText_();
            break;
          }
          case "POLYGON": {
            s = this.parsePolygonText_();
            break;
          }
          case "MULTIPOINT": {
            s = this.parseMultiPointText_();
            break;
          }
          case "MULTILINESTRING": {
            s = this.parseMultiLineStringText_();
            break;
          }
          case "MULTIPOLYGON": {
            s = this.parseMultiPolygonText_();
            break;
          }
        }
      return new n(s, this.layout_);
    }
    throw new Error(this.formatErrorMessage_());
  }
};
class _re extends FB {
  /**
   * @param {Options} [options] Options.
   */
  constructor(e) {
    super(), e = e || {}, this.splitCollection_ = e.splitCollection !== void 0 ? e.splitCollection : !1;
  }
  /**
   * Parse a WKT string.
   * @param {string} wkt WKT string.
   * @return {import("../geom/Geometry.js").default}
   *     The geometry created.
   * @private
   */
  parse_(e) {
    const t = new vre(e);
    return new yre(t).parse();
  }
  /**
   * @protected
   * @param {string} text Text.
   * @param {import("./Feature.js").ReadOptions} [options] Read options.
   * @return {import("../Feature.js").default} Feature.
   */
  readFeatureFromText(e, t) {
    const r = this.readGeometryFromText(e, t), n = new qt();
    return n.setGeometry(r), n;
  }
  /**
   * @param {string} text Text.
   * @param {import("./Feature.js").ReadOptions} [options] Read options.
   * @protected
   * @return {Array<Feature>} Features.
   */
  readFeaturesFromText(e, t) {
    let r = [];
    const n = this.readGeometryFromText(e, t);
    this.splitCollection_ && n.getType() == "GeometryCollection" ? r = /** @type {GeometryCollection} */
    n.getGeometriesArray() : r = [n];
    const s = [];
    for (let a = 0, o = r.length; a < o; ++a) {
      const A = new qt();
      A.setGeometry(r[a]), s.push(A);
    }
    return s;
  }
  /**
   * @param {string} text Text.
   * @param {import("./Feature.js").ReadOptions} [options] Read options.
   * @protected
   * @return {import("../geom/Geometry.js").default} Geometry.
   */
  readGeometryFromText(e, t) {
    const r = this.parse_(e);
    return ui(r, !1, t);
  }
  /**
   * @param {import("../Feature.js").default} feature Features.
   * @param {import("./Feature.js").WriteOptions} [options] Write options.
   * @protected
   * @return {string} Text.
   */
  writeFeatureText(e, t) {
    const r = e.getGeometry();
    return r ? this.writeGeometryText(r, t) : "";
  }
  /**
   * @param {Array<import("../Feature.js").default>} features Features.
   * @param {import("./Feature.js").WriteOptions} [options] Write options.
   * @protected
   * @return {string} Text.
   */
  writeFeaturesText(e, t) {
    if (e.length == 1)
      return this.writeFeatureText(e[0], t);
    const r = [];
    for (let s = 0, a = e.length; s < a; ++s)
      r.push(e[s].getGeometry());
    const n = new _n(r);
    return this.writeGeometryText(n, t);
  }
  /**
   * @param {import("../geom/Geometry.js").default} geometry Geometry.
   * @param {import("./Feature.js").WriteOptions} [options] Write options.
   * @protected
   * @return {string} Text.
   */
  writeGeometryText(e, t) {
    return nP(ui(e, !0, t));
  }
}
function rP(i) {
  const e = i.getCoordinates();
  return e.length === 0 ? "" : e.join(" ");
}
function wre(i) {
  const e = [], t = i.getPoints();
  for (let r = 0, n = t.length; r < n; ++r)
    e.push("(" + rP(t[r]) + ")");
  return e.join(",");
}
function xre(i) {
  const e = [], t = i.getGeometries();
  for (let r = 0, n = t.length; r < n; ++r)
    e.push(nP(t[r]));
  return e.join(",");
}
function GB(i) {
  const e = i.getCoordinates(), t = [];
  for (let r = 0, n = e.length; r < n; ++r)
    t.push(e[r].join(" "));
  return t.join(",");
}
function Cre(i) {
  const e = [], t = i.getLineStrings();
  for (let r = 0, n = t.length; r < n; ++r)
    e.push("(" + GB(t[r]) + ")");
  return e.join(",");
}
function iP(i) {
  const e = [], t = i.getLinearRings();
  for (let r = 0, n = t.length; r < n; ++r)
    e.push("(" + GB(t[r]) + ")");
  return e.join(",");
}
function Ere(i) {
  const e = [], t = i.getPolygons();
  for (let r = 0, n = t.length; r < n; ++r)
    e.push("(" + iP(t[r]) + ")");
  return e.join(",");
}
function Bre(i) {
  const e = i.getLayout();
  let t = "";
  return (e === "XYZ" || e === "XYZM") && (t += eP), (e === "XYM" || e === "XYZM") && (t += tP), t;
}
const bre = {
  Point: rP,
  LineString: GB,
  Polygon: iP,
  MultiPoint: wre,
  MultiLineString: Cre,
  MultiPolygon: Ere,
  GeometryCollection: xre
};
function nP(i) {
  const e = i.getType(), t = bre[e], r = t(i);
  let n = mre[e];
  if (typeof /** @type {?} */
  i.getFlatCoordinates == "function") {
    const s = Bre(
      /** @type {import("../geom/SimpleGeometry.js").default} */
      i
    );
    s.length > 0 && (n += " " + s);
  }
  return r.length === 0 ? n + " " + JN : n + "(" + r + ")";
}
const Sre = _re, Mn = [null, "http://www.opengis.net/wms"], Tre = we(Mn, {
  Service: J(Wre),
  Capability: J(Xre)
}), Fre = we(Mn, {
  Request: J(rie),
  Exception: J(Jre),
  Layer: J(eie)
});
class Lre extends NB {
  constructor() {
    super(), this.version = void 0;
  }
  /**
   * @param {Element} node Node.
   * @return {Object} Object
   */
  readFromNode(e) {
    this.version = e.getAttribute("version").trim();
    const t = Se(
      {
        version: this.version
      },
      Tre,
      e,
      []
    );
    return t || null;
  }
}
const Ire = we(Mn, {
  Name: J(Me),
  Title: J(Me),
  Abstract: J(Me),
  KeywordList: J(AP),
  OnlineResource: J(Qu),
  ContactInformation: J(Yre),
  Fees: J(Me),
  AccessConstraints: J(Me),
  LayerLimit: J(Hi),
  MaxWidth: J(Hi),
  MaxHeight: J(Hi)
}), Rre = we(Mn, {
  ContactPersonPrimary: J(qre),
  ContactPosition: J(Me),
  ContactAddress: J(Zre),
  ContactVoiceTelephone: J(Me),
  ContactFacsimileTelephone: J(Me),
  ContactElectronicMailAddress: J(Me)
}), Mre = we(Mn, {
  ContactPerson: J(Me),
  ContactOrganization: J(Me)
}), Nre = we(Mn, {
  AddressType: J(Me),
  Address: J(Me),
  City: J(Me),
  StateOrProvince: J(Me),
  PostCode: J(Me),
  Country: J(Me)
}), Pre = we(Mn, {
  Format: ht(Me)
}), sP = we(Mn, {
  Name: J(Me),
  Title: J(Me),
  Abstract: J(Me),
  KeywordList: J(AP),
  CRS: Jr(Me),
  EX_GeographicBoundingBox: J(
    zre
  ),
  BoundingBox: Jr(jre),
  Dimension: Jr(tie),
  Attribution: J(Kre),
  AuthorityURL: Jr(sie),
  Identifier: Jr(Me),
  MetadataURL: Jr(aie),
  DataURL: Jr(Yo),
  FeatureListURL: Jr(Yo),
  Style: Jr(oie),
  MinScaleDenominator: J(xr),
  MaxScaleDenominator: J(xr),
  Layer: Jr(aP)
}), Ore = we(Mn, {
  Title: J(Me),
  OnlineResource: J(Qu),
  LogoURL: J(oP)
}), Ure = we(Mn, {
  westBoundLongitude: J(xr),
  eastBoundLongitude: J(xr),
  southBoundLatitude: J(xr),
  northBoundLatitude: J(xr)
}), Qre = we(Mn, {
  GetCapabilities: J(y_),
  GetMap: J(y_),
  GetFeatureInfo: J(y_)
}), Dre = we(Mn, {
  Format: Jr(Me),
  DCPType: Jr(iie)
}), kre = we(Mn, {
  HTTP: J(nie)
}), Hre = we(Mn, {
  Get: J(Yo),
  Post: J(Yo)
}), Gre = we(Mn, {
  Name: J(Me),
  Title: J(Me),
  Abstract: J(Me),
  LegendURL: Jr(oP),
  StyleSheetURL: J(Yo),
  StyleURL: J(Yo)
}), $re = we(Mn, {
  Format: J(Me),
  OnlineResource: J(Qu)
}), Vre = we(Mn, {
  Keyword: ht(Me)
});
function Kre(i, e) {
  return Se({}, Ore, i, e);
}
function jre(i, e) {
  const t = [
    Oo(i.getAttribute("minx")),
    Oo(i.getAttribute("miny")),
    Oo(i.getAttribute("maxx")),
    Oo(i.getAttribute("maxy"))
  ], r = [
    Oo(i.getAttribute("resx")),
    Oo(i.getAttribute("resy"))
  ];
  return {
    crs: i.getAttribute("CRS"),
    extent: t,
    res: r
  };
}
function zre(i, e) {
  const t = Se(
    {},
    Ure,
    i,
    e
  );
  if (!t)
    return;
  const r = (
    /** @type {number|undefined} */
    t.westBoundLongitude
  ), n = (
    /** @type {number|undefined} */
    t.southBoundLatitude
  ), s = (
    /** @type {number|undefined} */
    t.eastBoundLongitude
  ), a = (
    /** @type {number|undefined} */
    t.northBoundLatitude
  );
  if (!(r === void 0 || n === void 0 || s === void 0 || a === void 0))
    return [
      r,
      n,
      s,
      a
    ];
}
function Xre(i, e) {
  return Se({}, Fre, i, e);
}
function Wre(i, e) {
  return Se({}, Ire, i, e);
}
function Yre(i, e) {
  return Se({}, Rre, i, e);
}
function qre(i, e) {
  return Se({}, Mre, i, e);
}
function Zre(i, e) {
  return Se({}, Nre, i, e);
}
function Jre(i, e) {
  return Se([], Pre, i, e);
}
function eie(i, e) {
  const t = Se({}, sP, i, e);
  return t.Layer === void 0 ? Object.assign(t, aP(i, e)) : t;
}
function aP(i, e) {
  const t = (
    /**  @type {!Object<string,*>} */
    e[e.length - 1]
  ), r = Se({}, sP, i, e);
  if (!r)
    return;
  let n = ah(i.getAttribute("queryable"));
  n === void 0 && (n = t.queryable), r.queryable = n !== void 0 ? n : !1;
  let s = Do(i.getAttribute("cascaded"));
  s === void 0 && (s = t.cascaded), r.cascaded = s;
  let a = ah(i.getAttribute("opaque"));
  a === void 0 && (a = t.opaque), r.opaque = a !== void 0 ? a : !1;
  let o = ah(i.getAttribute("noSubsets"));
  o === void 0 && (o = t.noSubsets), r.noSubsets = o !== void 0 ? o : !1;
  let A = Oo(i.getAttribute("fixedWidth"));
  A || (A = t.fixedWidth), r.fixedWidth = A;
  let l = Oo(i.getAttribute("fixedHeight"));
  return l || (l = t.fixedHeight), r.fixedHeight = l, ["Style", "CRS", "AuthorityURL"].forEach(function(u) {
    if (u in t) {
      const f = r[u] || [];
      r[u] = f.concat(t[u]);
    }
  }), [
    "EX_GeographicBoundingBox",
    "BoundingBox",
    "Dimension",
    "Attribution",
    "MinScaleDenominator",
    "MaxScaleDenominator"
  ].forEach(function(u) {
    if (!(u in r)) {
      const f = t[u];
      r[u] = f;
    }
  }), r;
}
function tie(i, e) {
  return {
    name: i.getAttribute("name"),
    units: i.getAttribute("units"),
    unitSymbol: i.getAttribute("unitSymbol"),
    default: i.getAttribute("default"),
    multipleValues: ah(i.getAttribute("multipleValues")),
    nearestValue: ah(i.getAttribute("nearestValue")),
    current: ah(i.getAttribute("current")),
    values: Me(i)
  };
}
function Yo(i, e) {
  return Se({}, $re, i, e);
}
function rie(i, e) {
  return Se({}, Qre, i, e);
}
function iie(i, e) {
  return Se({}, kre, i, e);
}
function nie(i, e) {
  return Se({}, Hre, i, e);
}
function y_(i, e) {
  return Se({}, Dre, i, e);
}
function oP(i, e) {
  const t = Yo(i, e);
  if (t) {
    const r = [
      Do(i.getAttribute("width")),
      Do(i.getAttribute("height"))
    ];
    return t.size = r, t;
  }
}
function sie(i, e) {
  const t = Yo(i, e);
  if (t)
    return t.name = i.getAttribute("name"), t;
}
function aie(i, e) {
  const t = Yo(i, e);
  if (t)
    return t.type = i.getAttribute("type"), t;
}
function oie(i, e) {
  return Se({}, Gre, i, e);
}
function AP(i, e) {
  return Se([], Vre, i, e);
}
const Aie = Lre, lie = "_feature", hie = "_layer";
class cie extends Tg {
  /**
   * @param {Options} [options] Options.
   */
  constructor(e) {
    super(), e = e || {}, this.featureNS_ = "http://mapserver.gis.umn.edu/mapserver", this.gmlFormat_ = new Uu(), this.layers_ = e.layers ? e.layers : null;
  }
  /**
   * @return {Array<string>|null} layers
   */
  getLayers() {
    return this.layers_;
  }
  /**
   * @param {Array<string>|null} layers Layers to parse.
   */
  setLayers(e) {
    this.layers_ = e;
  }
  /**
   * @param {Element} node Node.
   * @param {Array<*>} objectStack Object stack.
   * @return {Array<import("../Feature.js").default>} Features.
   * @private
   */
  readFeatures_(e, t) {
    e.setAttribute("namespaceURI", this.featureNS_);
    const r = e.localName;
    let n = [];
    if (e.childNodes.length === 0)
      return n;
    if (r == "msGMLOutput")
      for (let s = 0, a = e.childNodes.length; s < a; s++) {
        const o = e.childNodes[s];
        if (o.nodeType !== Node.ELEMENT_NODE)
          continue;
        const A = (
          /** @type {Element} */
          o
        ), l = t[0], h = hie, c = A.localName.replace(h, "");
        if (this.layers_ && !this.layers_.includes(c))
          continue;
        const u = c + lie;
        l.featureType = u, l.featureNS = this.featureNS_;
        const f = {};
        f[u] = ht(
          this.gmlFormat_.readFeatureElement,
          this.gmlFormat_
        );
        const g = we(
          [l.featureNS, null],
          f
        );
        A.setAttribute("namespaceURI", this.featureNS_);
        const p = Se(
          [],
          // @ts-ignore
          g,
          A,
          t,
          this.gmlFormat_
        );
        p && Er(n, p);
      }
    if (r == "FeatureCollection") {
      const s = Se(
        [],
        this.gmlFormat_.FEATURE_COLLECTION_PARSERS,
        e,
        [{}],
        this.gmlFormat_
      );
      s && (n = s);
    }
    return n;
  }
  /**
   * @protected
   * @param {Element} node Node.
   * @param {import("./Feature.js").ReadOptions} [options] Options.
   * @return {Array<import("../Feature.js").default>} Features.
   */
  readFeaturesFromNode(e, t) {
    const r = {};
    return t && Object.assign(r, this.getReadOptions(e, t)), this.readFeatures_(e, [r]);
  }
}
const uie = cie, io = [null, "http://www.opengis.net/wmts/1.0"], ku = [null, "http://www.opengis.net/ows/1.1"], fie = we(io, {
  Contents: J(Bie)
});
class die extends NB {
  constructor() {
    super(), this.owsParser_ = new zN();
  }
  /**
   * @param {Element} node Node.
   * @return {Object} Object
   */
  readFromNode(e) {
    let t = e.getAttribute("version");
    t && (t = t.trim());
    let r = this.owsParser_.readFromNode(e);
    return r ? (r.version = t, r = Se(
      r,
      fie,
      e,
      []
    ), r || null) : null;
  }
}
const gie = we(io, {
  Layer: Jr(bie),
  TileMatrixSet: Jr(Sie)
}), pie = we(
  io,
  {
    Style: Jr(Tie),
    Format: Jr(Me),
    TileMatrixSetLink: Jr(Fie),
    Dimension: Jr(Lie),
    ResourceURL: Jr(Iie)
  },
  we(ku, {
    Title: J(Me),
    Abstract: J(Me),
    WGS84BoundingBox: J(lP),
    Identifier: J(Me)
  })
), mie = we(
  io,
  {
    LegendURL: Jr(Rie)
  },
  we(ku, {
    Title: J(Me),
    Identifier: J(Me)
  })
), vie = we(io, {
  TileMatrixSet: J(Me),
  TileMatrixSetLimits: J(Nie)
}), yie = we(io, {
  TileMatrixLimits: ht(Pie)
}), _ie = we(io, {
  TileMatrix: J(Me),
  MinTileRow: J(Hi),
  MaxTileRow: J(Hi),
  MinTileCol: J(Hi),
  MaxTileCol: J(Hi)
}), wie = we(
  io,
  {
    Default: J(Me),
    Value: Jr(Me)
  },
  we(ku, {
    Identifier: J(Me)
  })
), xie = we(ku, {
  LowerCorner: ht(zx),
  UpperCorner: ht(zx)
}), Cie = we(
  io,
  {
    WellKnownScaleSet: J(Me),
    TileMatrix: Jr(Mie)
  },
  we(ku, {
    SupportedCRS: J(Me),
    Identifier: J(Me),
    BoundingBox: J(lP)
  })
), Eie = we(
  io,
  {
    TopLeftCorner: J(zx),
    ScaleDenominator: J(xr),
    TileWidth: J(Hi),
    TileHeight: J(Hi),
    MatrixWidth: J(Hi),
    MatrixHeight: J(Hi)
  },
  we(ku, {
    Identifier: J(Me)
  })
);
function Bie(i, e) {
  return Se({}, gie, i, e);
}
function bie(i, e) {
  return Se({}, pie, i, e);
}
function Sie(i, e) {
  return Se({}, Cie, i, e);
}
function Tie(i, e) {
  const t = Se({}, mie, i, e);
  if (!t)
    return;
  const r = i.getAttribute("isDefault") === "true";
  return t.isDefault = r, t;
}
function Fie(i, e) {
  return Se({}, vie, i, e);
}
function Lie(i, e) {
  return Se({}, wie, i, e);
}
function Iie(i, e) {
  const t = i.getAttribute("format"), r = i.getAttribute("template"), n = i.getAttribute("resourceType"), s = {};
  return t && (s.format = t), r && (s.template = r), n && (s.resourceType = n), s;
}
function lP(i, e) {
  const t = Se(
    [],
    xie,
    i,
    e
  );
  if (t.length == 2)
    return Xi(t);
}
function Rie(i, e) {
  const t = {};
  return t.format = i.getAttribute("format"), t.href = Qu(i), t;
}
function zx(i, e) {
  const t = Me(i).split(/\s+/);
  if (!t || t.length != 2)
    return;
  const r = +t[0], n = +t[1];
  if (!(isNaN(r) || isNaN(n)))
    return [r, n];
}
function Mie(i, e) {
  return Se({}, Eie, i, e);
}
function Nie(i, e) {
  return Se([], yie, i, e);
}
function Pie(i, e) {
  return Se({}, _ie, i, e);
}
const Oie = die, Uie = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  EsriJSON: wq,
  GML: Xq,
  GPX: SZ,
  GeoJSON: Uq,
  IGC: NZ,
  IIIFInfo: lK,
  KML: vee,
  MVT: $ee,
  OWS: zN,
  Polyline: Ite,
  TopoJSON: $te,
  WFS: lre,
  WKB: dre,
  WKT: Sre,
  WMSCapabilities: Aie,
  WMSGetFeatureInfo: uie,
  WMTSCapabilities: Oie
}, Symbol.toStringTag, { value: "Module" }));
function qT(i) {
  if (qT.installed) {
    console.error("OPENLAYERS MAP ALREADY INSTALLED");
    return;
  }
  qT.installed = !0, i.use(v$), i.use(aj), i.use(Fj), i.use(xW), i.use(QW), i.use(AY), i.use(IY), i.use(tq), console.log("installed!"), i.provide("ol-feature", qt), i.provide("ol-geom", rq), i.provide("ol-animations", TD), i.provide("ol-format", Uie), i.provide("ol-loadingstrategy", ZV), i.provide("ol-selectconditions", K6), i.provide("ol-extent", WQ);
}
/*!
 * html2canvas 1.4.1 <https://html2canvas.hertzen.com>
 * Copyright (c) 2022 Niklas von Hertzen <https://hertzen.com>
 * Released under MIT License
 */
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
var Xx = function(i, e) {
  return Xx = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(t, r) {
    t.__proto__ = r;
  } || function(t, r) {
    for (var n in r)
      Object.prototype.hasOwnProperty.call(r, n) && (t[n] = r[n]);
  }, Xx(i, e);
};
function La(i, e) {
  if (typeof e != "function" && e !== null)
    throw new TypeError("Class extends value " + String(e) + " is not a constructor or null");
  Xx(i, e);
  function t() {
    this.constructor = i;
  }
  i.prototype = e === null ? Object.create(e) : (t.prototype = e.prototype, new t());
}
var Wx = function() {
  return Wx = Object.assign || function(e) {
    for (var t, r = 1, n = arguments.length; r < n; r++) {
      t = arguments[r];
      for (var s in t)
        Object.prototype.hasOwnProperty.call(t, s) && (e[s] = t[s]);
    }
    return e;
  }, Wx.apply(this, arguments);
};
function Zn(i, e, t, r) {
  function n(s) {
    return s instanceof t ? s : new t(function(a) {
      a(s);
    });
  }
  return new (t || (t = Promise))(function(s, a) {
    function o(h) {
      try {
        l(r.next(h));
      } catch (c) {
        a(c);
      }
    }
    function A(h) {
      try {
        l(r.throw(h));
      } catch (c) {
        a(c);
      }
    }
    function l(h) {
      h.done ? s(h.value) : n(h.value).then(o, A);
    }
    l((r = r.apply(i, e || [])).next());
  });
}
function Gn(i, e) {
  var t = { label: 0, sent: function() {
    if (s[0] & 1)
      throw s[1];
    return s[1];
  }, trys: [], ops: [] }, r, n, s, a;
  return a = { next: o(0), throw: o(1), return: o(2) }, typeof Symbol == "function" && (a[Symbol.iterator] = function() {
    return this;
  }), a;
  function o(l) {
    return function(h) {
      return A([l, h]);
    };
  }
  function A(l) {
    if (r)
      throw new TypeError("Generator is already executing.");
    for (; t; )
      try {
        if (r = 1, n && (s = l[0] & 2 ? n.return : l[0] ? n.throw || ((s = n.return) && s.call(n), 0) : n.next) && !(s = s.call(n, l[1])).done)
          return s;
        switch (n = 0, s && (l = [l[0] & 2, s.value]), l[0]) {
          case 0:
          case 1:
            s = l;
            break;
          case 4:
            return t.label++, { value: l[1], done: !1 };
          case 5:
            t.label++, n = l[1], l = [0];
            continue;
          case 7:
            l = t.ops.pop(), t.trys.pop();
            continue;
          default:
            if (s = t.trys, !(s = s.length > 0 && s[s.length - 1]) && (l[0] === 6 || l[0] === 2)) {
              t = 0;
              continue;
            }
            if (l[0] === 3 && (!s || l[1] > s[0] && l[1] < s[3])) {
              t.label = l[1];
              break;
            }
            if (l[0] === 6 && t.label < s[1]) {
              t.label = s[1], s = l;
              break;
            }
            if (s && t.label < s[2]) {
              t.label = s[2], t.ops.push(l);
              break;
            }
            s[2] && t.ops.pop(), t.trys.pop();
            continue;
        }
        l = e.call(i, t);
      } catch (h) {
        l = [6, h], n = 0;
      } finally {
        r = s = 0;
      }
    if (l[0] & 5)
      throw l[1];
    return { value: l[0] ? l[1] : void 0, done: !0 };
  }
}
function r0(i, e, t) {
  if (t || arguments.length === 2)
    for (var r = 0, n = e.length, s; r < n; r++)
      (s || !(r in e)) && (s || (s = Array.prototype.slice.call(e, 0, r)), s[r] = e[r]);
  return i.concat(s || e);
}
var qo = (
  /** @class */
  function() {
    function i(e, t, r, n) {
      this.left = e, this.top = t, this.width = r, this.height = n;
    }
    return i.prototype.add = function(e, t, r, n) {
      return new i(this.left + e, this.top + t, this.width + r, this.height + n);
    }, i.fromClientRect = function(e, t) {
      return new i(t.left + e.windowBounds.left, t.top + e.windowBounds.top, t.width, t.height);
    }, i.fromDOMRectList = function(e, t) {
      var r = Array.from(t).find(function(n) {
        return n.width !== 0;
      });
      return r ? new i(r.left + e.windowBounds.left, r.top + e.windowBounds.top, r.width, r.height) : i.EMPTY;
    }, i.EMPTY = new i(0, 0, 0, 0), i;
  }()
), cy = function(i, e) {
  return qo.fromClientRect(i, e.getBoundingClientRect());
}, Qie = function(i) {
  var e = i.body, t = i.documentElement;
  if (!e || !t)
    throw new Error("Unable to get document size");
  var r = Math.max(Math.max(e.scrollWidth, t.scrollWidth), Math.max(e.offsetWidth, t.offsetWidth), Math.max(e.clientWidth, t.clientWidth)), n = Math.max(Math.max(e.scrollHeight, t.scrollHeight), Math.max(e.offsetHeight, t.offsetHeight), Math.max(e.clientHeight, t.clientHeight));
  return new qo(0, 0, r, n);
}, uy = function(i) {
  for (var e = [], t = 0, r = i.length; t < r; ) {
    var n = i.charCodeAt(t++);
    if (n >= 55296 && n <= 56319 && t < r) {
      var s = i.charCodeAt(t++);
      (s & 64512) === 56320 ? e.push(((n & 1023) << 10) + (s & 1023) + 65536) : (e.push(n), t--);
    } else
      e.push(n);
  }
  return e;
}, Oi = function() {
  for (var i = [], e = 0; e < arguments.length; e++)
    i[e] = arguments[e];
  if (String.fromCodePoint)
    return String.fromCodePoint.apply(String, i);
  var t = i.length;
  if (!t)
    return "";
  for (var r = [], n = -1, s = ""; ++n < t; ) {
    var a = i[n];
    a <= 65535 ? r.push(a) : (a -= 65536, r.push((a >> 10) + 55296, a % 1024 + 56320)), (n + 1 === t || r.length > 16384) && (s += String.fromCharCode.apply(String, r), r.length = 0);
  }
  return s;
}, ZT = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", Die = typeof Uint8Array > "u" ? [] : new Uint8Array(256);
for (var i0 = 0; i0 < ZT.length; i0++)
  Die[ZT.charCodeAt(i0)] = i0;
var JT = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", ed = typeof Uint8Array > "u" ? [] : new Uint8Array(256);
for (var n0 = 0; n0 < JT.length; n0++)
  ed[JT.charCodeAt(n0)] = n0;
var kie = function(i) {
  var e = i.length * 0.75, t = i.length, r, n = 0, s, a, o, A;
  i[i.length - 1] === "=" && (e--, i[i.length - 2] === "=" && e--);
  var l = typeof ArrayBuffer < "u" && typeof Uint8Array < "u" && typeof Uint8Array.prototype.slice < "u" ? new ArrayBuffer(e) : new Array(e), h = Array.isArray(l) ? l : new Uint8Array(l);
  for (r = 0; r < t; r += 4)
    s = ed[i.charCodeAt(r)], a = ed[i.charCodeAt(r + 1)], o = ed[i.charCodeAt(r + 2)], A = ed[i.charCodeAt(r + 3)], h[n++] = s << 2 | a >> 4, h[n++] = (a & 15) << 4 | o >> 2, h[n++] = (o & 3) << 6 | A & 63;
  return l;
}, Hie = function(i) {
  for (var e = i.length, t = [], r = 0; r < e; r += 2)
    t.push(i[r + 1] << 8 | i[r]);
  return t;
}, Gie = function(i) {
  for (var e = i.length, t = [], r = 0; r < e; r += 4)
    t.push(i[r + 3] << 24 | i[r + 2] << 16 | i[r + 1] << 8 | i[r]);
  return t;
}, oh = 5, $B = 6 + 5, __ = 2, $ie = $B - oh, hP = 65536 >> oh, Vie = 1 << oh, w_ = Vie - 1, Kie = 1024 >> oh, jie = hP + Kie, zie = jie, Xie = 32, Wie = zie + Xie, Yie = 65536 >> $B, qie = 1 << $ie, Zie = qie - 1, eF = function(i, e, t) {
  return i.slice ? i.slice(e, t) : new Uint16Array(Array.prototype.slice.call(i, e, t));
}, Jie = function(i, e, t) {
  return i.slice ? i.slice(e, t) : new Uint32Array(Array.prototype.slice.call(i, e, t));
}, ene = function(i, e) {
  var t = kie(i), r = Array.isArray(t) ? Gie(t) : new Uint32Array(t), n = Array.isArray(t) ? Hie(t) : new Uint16Array(t), s = 24, a = eF(n, s / 2, r[4] / 2), o = r[5] === 2 ? eF(n, (s + r[4]) / 2) : Jie(r, Math.ceil((s + r[4]) / 4));
  return new tne(r[0], r[1], r[2], r[3], a, o);
}, tne = (
  /** @class */
  function() {
    function i(e, t, r, n, s, a) {
      this.initialValue = e, this.errorValue = t, this.highStart = r, this.highValueIndex = n, this.index = s, this.data = a;
    }
    return i.prototype.get = function(e) {
      var t;
      if (e >= 0) {
        if (e < 55296 || e > 56319 && e <= 65535)
          return t = this.index[e >> oh], t = (t << __) + (e & w_), this.data[t];
        if (e <= 65535)
          return t = this.index[hP + (e - 55296 >> oh)], t = (t << __) + (e & w_), this.data[t];
        if (e < this.highStart)
          return t = Wie - Yie + (e >> $B), t = this.index[t], t += e >> oh & Zie, t = this.index[t], t = (t << __) + (e & w_), this.data[t];
        if (e <= 1114111)
          return this.data[this.highValueIndex];
      }
      return this.errorValue;
    }, i;
  }()
), tF = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", rne = typeof Uint8Array > "u" ? [] : new Uint8Array(256);
for (var s0 = 0; s0 < tF.length; s0++)
  rne[tF.charCodeAt(s0)] = s0;
var ine = "KwAAAAAAAAAACA4AUD0AADAgAAACAAAAAAAIABAAGABAAEgAUABYAGAAaABgAGgAYgBqAF8AZwBgAGgAcQB5AHUAfQCFAI0AlQCdAKIAqgCyALoAYABoAGAAaABgAGgAwgDKAGAAaADGAM4A0wDbAOEA6QDxAPkAAQEJAQ8BFwF1AH0AHAEkASwBNAE6AUIBQQFJAVEBWQFhAWgBcAF4ATAAgAGGAY4BlQGXAZ8BpwGvAbUBvQHFAc0B0wHbAeMB6wHxAfkBAQIJAvEBEQIZAiECKQIxAjgCQAJGAk4CVgJeAmQCbAJ0AnwCgQKJApECmQKgAqgCsAK4ArwCxAIwAMwC0wLbAjAA4wLrAvMC+AIAAwcDDwMwABcDHQMlAy0DNQN1AD0DQQNJA0kDSQNRA1EDVwNZA1kDdQB1AGEDdQBpA20DdQN1AHsDdQCBA4kDkQN1AHUAmQOhA3UAdQB1AHUAdQB1AHUAdQB1AHUAdQB1AHUAdQB1AHUAdQB1AKYDrgN1AHUAtgO+A8YDzgPWAxcD3gPjA+sD8wN1AHUA+wMDBAkEdQANBBUEHQQlBCoEFwMyBDgEYABABBcDSARQBFgEYARoBDAAcAQzAXgEgASIBJAEdQCXBHUAnwSnBK4EtgS6BMIEyAR1AHUAdQB1AHUAdQCVANAEYABgAGAAYABgAGAAYABgANgEYADcBOQEYADsBPQE/AQEBQwFFAUcBSQFLAU0BWQEPAVEBUsFUwVbBWAAYgVgAGoFcgV6BYIFigWRBWAAmQWfBaYFYABgAGAAYABgAKoFYACxBbAFuQW6BcEFwQXHBcEFwQXPBdMF2wXjBeoF8gX6BQIGCgYSBhoGIgYqBjIGOgZgAD4GRgZMBmAAUwZaBmAAYABgAGAAYABgAGAAYABgAGAAYABgAGIGYABpBnAGYABgAGAAYABgAGAAYABgAGAAYAB4Bn8GhQZgAGAAYAB1AHcDFQSLBmAAYABgAJMGdQA9A3UAmwajBqsGqwaVALMGuwbDBjAAywbSBtIG1QbSBtIG0gbSBtIG0gbdBuMG6wbzBvsGAwcLBxMHAwcbByMHJwcsBywHMQcsB9IGOAdAB0gHTgfSBkgHVgfSBtIG0gbSBtIG0gbSBtIG0gbSBiwHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAdgAGAALAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAdbB2MHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsB2kH0gZwB64EdQB1AHUAdQB1AHUAdQB1AHUHfQdgAIUHjQd1AHUAlQedB2AAYAClB6sHYACzB7YHvgfGB3UAzgfWBzMB3gfmB1EB7gf1B/0HlQENAQUIDQh1ABUIHQglCBcDLQg1CD0IRQhNCEEDUwh1AHUAdQBbCGMIZAhlCGYIZwhoCGkIYwhkCGUIZghnCGgIaQhjCGQIZQhmCGcIaAhpCGMIZAhlCGYIZwhoCGkIYwhkCGUIZghnCGgIaQhjCGQIZQhmCGcIaAhpCGMIZAhlCGYIZwhoCGkIYwhkCGUIZghnCGgIaQhjCGQIZQhmCGcIaAhpCGMIZAhlCGYIZwhoCGkIYwhkCGUIZghnCGgIaQhjCGQIZQhmCGcIaAhpCGMIZAhlCGYIZwhoCGkIYwhkCGUIZghnCGgIaQhjCGQIZQhmCGcIaAhpCGMIZAhlCGYIZwhoCGkIYwhkCGUIZghnCGgIaQhjCGQIZQhmCGcIaAhpCGMIZAhlCGYIZwhoCGkIYwhkCGUIZghnCGgIaQhjCGQIZQhmCGcIaAhpCGMIZAhlCGYIZwhoCGkIYwhkCGUIZghnCGgIaQhjCGQIZQhmCGcIaAhpCGMIZAhlCGYIZwhoCGkIYwhkCGUIZghnCGgIaQhjCGQIZQhmCGcIaAhpCGMIZAhlCGYIZwhoCGkIYwhkCGUIZghnCGgIaQhjCGQIZQhmCGcIaAhpCGMIZAhlCGYIZwhoCGkIYwhkCGUIZghnCGgIaQhjCGQIZQhmCGcIaAhpCGMIZAhlCGYIZwhoCGkIYwhkCGUIZghnCGgIaQhjCGQIZQhmCGcIaAhpCGMIZAhlCGYIZwhoCGkIYwhkCGUIZghnCGgIaQhjCGQIZQhmCGcIaAhpCGMIZAhlCGYIZwhoCGkIYwhkCGUIZghnCGgIaQhjCGQIZQhmCGcIaAhpCGMIZAhlCGYIZwhoCGkIYwhkCGUIZghnCGgIaQhjCGQIZQhmCGcIaAhpCGMIZAhlCGYIZwhoCGkIYwhkCGUIZghnCGgIaQhjCGQIZQhmCGcIaAhpCGMIZAhlCGYIZwhoCGkIYwhkCGUIZghnCGgIcAh3CHoIMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwAIIIggiCCIIIggiCCIIIggiCCIIIggiCCIIIggiCCIIIggiCCIIIggiCCIIIggiCCIIIggiCCIIIggiCCIIIgggwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAALAcsBywHLAcsBywHLAcsBywHLAcsB4oILAcsB44I0gaWCJ4Ipgh1AHUAqgiyCHUAdQB1AHUAdQB1AHUAdQB1AHUAtwh8AXUAvwh1AMUIyQjRCNkI4AjoCHUAdQB1AO4I9gj+CAYJDgkTCS0HGwkjCYIIggiCCIIIggiCCIIIggiCCIIIggiCCIIIggiCCIIIggiCCIIIggiCCIIIggiCCIIIggiCCIIIggiCCIIIggiAAIAAAAFAAYABgAGIAXwBgAHEAdQBFAJUAogCyAKAAYABgAEIA4ABGANMA4QDxAMEBDwE1AFwBLAE6AQEBUQF4QkhCmEKoQrhCgAHIQsAB0MLAAcABwAHAAeDC6ABoAHDCwMMAAcABwAHAAdDDGMMAAcAB6MM4wwjDWMNow3jDaABoAGgAaABoAGgAaABoAGgAaABoAGgAaABoAGgAaABoAGgAaABoAEjDqABWw6bDqABpg6gAaABoAHcDvwOPA+gAaABfA/8DvwO/A78DvwO/A78DvwO/A78DvwO/A78DvwO/A78DvwO/A78DvwO/A78DvwO/A78DvwO/A78DpcPAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcAB9cPKwkyCToJMAB1AHUAdQBCCUoJTQl1AFUJXAljCWcJawkwADAAMAAwAHMJdQB2CX4JdQCECYoJjgmWCXUAngkwAGAAYABxAHUApgn3A64JtAl1ALkJdQDACTAAMAAwADAAdQB1AHUAdQB1AHUAdQB1AHUAowYNBMUIMAAwADAAMADICcsJ0wnZCRUE4QkwAOkJ8An4CTAAMAB1AAAKvwh1AAgKDwoXCh8KdQAwACcKLgp1ADYKqAmICT4KRgowADAAdQB1AE4KMAB1AFYKdQBeCnUAZQowADAAMAAwADAAMAAwADAAMAAVBHUAbQowADAAdQC5CXUKMAAwAHwBxAijBogEMgF9CoQKiASMCpQKmgqIBKIKqgquCogEDQG2Cr4KxgrLCjAAMADTCtsKCgHjCusK8Qr5CgELMAAwADAAMAB1AIsECQsRC3UANAEZCzAAMAAwADAAMAB1ACELKQswAHUANAExCzkLdQBBC0kLMABRC1kLMAAwADAAMAAwADAAdQBhCzAAMAAwAGAAYABpC3ELdwt/CzAAMACHC4sLkwubC58Lpwt1AK4Ltgt1APsDMAAwADAAMAAwADAAMAAwAL4LwwvLC9IL1wvdCzAAMADlC+kL8Qv5C/8LSQswADAAMAAwADAAMAAwADAAMAAHDDAAMAAwADAAMAAODBYMHgx1AHUAdQB1AHUAdQB1AHUAdQB1AHUAdQB1AHUAdQB1AHUAdQB1AHUAdQB1AHUAdQB1AHUAdQB1ACYMMAAwADAAdQB1AHUALgx1AHUAdQB1AHUAdQA2DDAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwAHUAdQB1AHUAdQB1AHUAdQB1AHUAdQB1AHUAdQB1AHUAdQB1AD4MdQBGDHUAdQB1AHUAdQB1AEkMdQB1AHUAdQB1AFAMMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwAHUAdQB1AHUAdQB1AHUAdQB1AHUAdQB1AHUAdQBYDHUAdQB1AF8MMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAB1AHUAdQB1AHUAdQB1AHUAdQB1AHUAdQB1AHUAdQB1AHUA+wMVBGcMMAAwAHwBbwx1AHcMfwyHDI8MMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAYABgAJcMMAAwADAAdQB1AJ8MlQClDDAAMACtDCwHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsB7UMLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHdQB1AHUAdQB1AHUAdQB1AHUAdQB1AHUAdQB1AA0EMAC9DDAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAsBywHLAcsBywHLAcsBywHLQcwAMEMyAwsBywHLAcsBywHLAcsBywHLAcsBywHzAwwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwAHUAdQB1ANQM2QzhDDAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMABgAGAAYABgAGAAYABgAOkMYADxDGAA+AwADQYNYABhCWAAYAAODTAAMAAwADAAFg1gAGAAHg37AzAAMAAwADAAYABgACYNYAAsDTQNPA1gAEMNPg1LDWAAYABgAGAAYABgAGAAYABgAGAAUg1aDYsGVglhDV0NcQBnDW0NdQ15DWAAYABgAGAAYABgAGAAYABgAGAAYABgAGAAYABgAGAAlQCBDZUAiA2PDZcNMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAnw2nDTAAMAAwADAAMAAwAHUArw23DTAAMAAwADAAMAAwADAAMAAwADAAMAB1AL8NMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAB1AHUAdQB1AHUAdQDHDTAAYABgAM8NMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAA1w11ANwNMAAwAD0B5A0wADAAMAAwADAAMADsDfQN/A0EDgwOFA4wABsOMAAwADAAMAAwADAAMAAwANIG0gbSBtIG0gbSBtIG0gYjDigOwQUuDsEFMw7SBjoO0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIGQg5KDlIOVg7SBtIGXg5lDm0OdQ7SBtIGfQ6EDooOjQ6UDtIGmg6hDtIG0gaoDqwO0ga0DrwO0gZgAGAAYADEDmAAYAAkBtIGzA5gANIOYADaDokO0gbSBt8O5w7SBu8O0gb1DvwO0gZgAGAAxA7SBtIG0gbSBtIGYABgAGAAYAAED2AAsAUMD9IG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIGFA8sBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAccD9IGLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHJA8sBywHLAcsBywHLAccDywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywPLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAc0D9IG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIGLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAccD9IG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIGFA8sBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHPA/SBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gYUD0QPlQCVAJUAMAAwADAAMACVAJUAlQCVAJUAlQCVAEwPMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAA//8EAAQABAAEAAQABAAEAAQABAANAAMAAQABAAIABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQACgATABcAHgAbABoAHgAXABYAEgAeABsAGAAPABgAHABLAEsASwBLAEsASwBLAEsASwBLABgAGAAeAB4AHgATAB4AUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQABYAGwASAB4AHgAeAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAWAA0AEQAeAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArAAQABAAEAAQABAAFAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAJABYAGgAbABsAGwAeAB0AHQAeAE8AFwAeAA0AHgAeABoAGwBPAE8ADgBQAB0AHQAdAE8ATwAXAE8ATwBPABYAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAB0AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAdAFAAUABQAFAAUABQAFAAUAAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAFAAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAeAB4AHgAeAFAATwBAAE8ATwBPAEAATwBQAFAATwBQAB4AHgAeAB4AHgAeAB0AHQAdAB0AHgAdAB4ADgBQAFAAUABQAFAAHgAeAB4AHgAeAB4AHgBQAB4AUAAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4ABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAJAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAkACQAJAAkACQAJAAkABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAeAB4AHgAeAFAAHgAeAB4AKwArAFAAUABQAFAAGABQACsAKwArACsAHgAeAFAAHgBQAFAAUAArAFAAKwAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AKwAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4ABAAEAAQABAAEAAQABAAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAUAAeAB4AHgAeAB4AHgBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAYAA0AKwArAB4AHgAbACsABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQADQAEAB4ABAAEAB4ABAAEABMABAArACsAKwArACsAKwArACsAVgBWAFYAVgBWAFYAVgBWAFYAVgBWAFYAVgBWAFYAVgBWAFYAVgBWAFYAVgBWAFYAVgBWAFYAKwArACsAKwBWAFYAVgBWAB4AHgArACsAKwArACsAKwArACsAKwArACsAHgAeAB4AHgAeAB4AHgAeAB4AGgAaABoAGAAYAB4AHgAEAAQABAAEAAQABAAEAAQABAAEAAQAEwAEACsAEwATAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABABLAEsASwBLAEsASwBLAEsASwBLABoAGQAZAB4AUABQAAQAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQABMAUAAEAAQABAAEAAQABAAEAB4AHgAEAAQABAAEAAQABABQAFAABAAEAB4ABAAEAAQABABQAFAASwBLAEsASwBLAEsASwBLAEsASwBQAFAAUAAeAB4AUAAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AKwAeAFAABABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAABAAEAAQABAAEAAQABAAEAAQABAAEAFAAKwArACsAKwArACsAKwArACsAKwArACsAKwArAEsASwBLAEsASwBLAEsASwBLAEsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAABAAEAAQABAAEAAQABAAEAAQAUABQAB4AHgAYABMAUAArACsABAAbABsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAAEAFAABAAEAAQABAAEAFAABAAEAAQAUAAEAAQABAAEAAQAKwArAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAArACsAHgArAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArAFAAUABQAFAAUABQAFAAUABQAFAAKwArACsAKwArACsAKwArACsAKwArAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAB4ABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAAQABAAEAFAABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQAUAAEAAQABAAEAAQABAAEAFAAUABQAFAAUABQAFAAUABQAFAABAAEAA0ADQBLAEsASwBLAEsASwBLAEsASwBLAB4AUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAArAFAAUABQAFAAUABQAFAAUAArACsAUABQACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwBQAFAAUABQAFAAUABQACsAUAArACsAKwBQAFAAUABQACsAKwAEAFAABAAEAAQABAAEAAQABAArACsABAAEACsAKwAEAAQABABQACsAKwArACsAKwArACsAKwAEACsAKwArACsAUABQACsAUABQAFAABAAEACsAKwBLAEsASwBLAEsASwBLAEsASwBLAFAAUAAaABoAUABQAFAAUABQAEwAHgAbAFAAHgAEACsAKwAEAAQABAArAFAAUABQAFAAUABQACsAKwArACsAUABQACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwBQAFAAUABQAFAAUABQACsAUABQACsAUABQACsAUABQACsAKwAEACsABAAEAAQABAAEACsAKwArACsABAAEACsAKwAEAAQABAArACsAKwAEACsAKwArACsAKwArACsAUABQAFAAUAArAFAAKwArACsAKwArACsAKwBLAEsASwBLAEsASwBLAEsASwBLAAQABABQAFAAUAAEAB4AKwArACsAKwArACsAKwArACsAKwAEAAQABAArAFAAUABQAFAAUABQAFAAUABQACsAUABQAFAAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwBQAFAAUABQAFAAUABQACsAUABQACsAUABQAFAAUABQACsAKwAEAFAABAAEAAQABAAEAAQABAAEACsABAAEAAQAKwAEAAQABAArACsAUAArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwBQAFAABAAEACsAKwBLAEsASwBLAEsASwBLAEsASwBLAB4AGwArACsAKwArACsAKwArAFAABAAEAAQABAAEAAQAKwAEAAQABAArAFAAUABQAFAAUABQAFAAUAArACsAUABQACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAAQABAAEAAQABAArACsABAAEACsAKwAEAAQABAArACsAKwArACsAKwArAAQABAAEACsAKwArACsAUABQACsAUABQAFAABAAEACsAKwBLAEsASwBLAEsASwBLAEsASwBLAB4AUABQAFAAUABQAFAAUAArACsAKwArACsAKwArACsAKwArAAQAUAArAFAAUABQAFAAUABQACsAKwArAFAAUABQACsAUABQAFAAUAArACsAKwBQAFAAKwBQACsAUABQACsAKwArAFAAUAArACsAKwBQAFAAUAArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwArAAQABAAEAAQABAArACsAKwAEAAQABAArAAQABAAEAAQAKwArAFAAKwArACsAKwArACsABAArACsAKwArACsAKwArACsAKwArAEsASwBLAEsASwBLAEsASwBLAEsAUABQAFAAHgAeAB4AHgAeAB4AGwAeACsAKwArACsAKwAEAAQABAAEAAQAUABQAFAAUABQAFAAUABQACsAUABQAFAAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwArACsAUAAEAAQABAAEAAQABAAEACsABAAEAAQAKwAEAAQABAAEACsAKwArACsAKwArACsABAAEACsAUABQAFAAKwArACsAKwArAFAAUAAEAAQAKwArAEsASwBLAEsASwBLAEsASwBLAEsAKwArACsAKwArACsAKwAOAFAAUABQAFAAUABQAFAAHgBQAAQABAAEAA4AUABQAFAAUABQAFAAUABQACsAUABQAFAAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArAFAAUABQAFAAUABQAFAAUABQAFAAKwBQAFAAUABQAFAAKwArAAQAUAAEAAQABAAEAAQABAAEACsABAAEAAQAKwAEAAQABAAEACsAKwArACsAKwArACsABAAEACsAKwArACsAKwArACsAUAArAFAAUAAEAAQAKwArAEsASwBLAEsASwBLAEsASwBLAEsAKwBQAFAAKwArACsAKwArACsAKwArACsAKwArACsAKwAEAAQABAAEAFAAUABQAFAAUABQAFAAUABQACsAUABQAFAAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAABAAEAFAABAAEAAQABAAEAAQABAArAAQABAAEACsABAAEAAQABABQAB4AKwArACsAKwBQAFAAUAAEAFAAUABQAFAAUABQAFAAUABQAFAABAAEACsAKwBLAEsASwBLAEsASwBLAEsASwBLAFAAUABQAFAAUABQAFAAUABQABoAUABQAFAAUABQAFAAKwAEAAQABAArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArAFAAUABQAFAAUABQAFAAUABQACsAUAArACsAUABQAFAAUABQAFAAUAArACsAKwAEACsAKwArACsABAAEAAQABAAEAAQAKwAEACsABAAEAAQABAAEAAQABAAEACsAKwArACsAKwArAEsASwBLAEsASwBLAEsASwBLAEsAKwArAAQABAAeACsAKwArACsAKwArACsAKwArACsAKwArAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXAAqAFwAXAAqACoAKgAqACoAKgAqACsAKwArACsAGwBcAFwAXABcAFwAXABcACoAKgAqACoAKgAqACoAKgAeAEsASwBLAEsASwBLAEsASwBLAEsADQANACsAKwArACsAKwBcAFwAKwBcACsAXABcAFwAXABcACsAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcACsAXAArAFwAXABcAFwAXABcAFwAXABcAFwAKgBcAFwAKgAqACoAKgAqACoAKgAqACoAXAArACsAXABcAFwAXABcACsAXAArACoAKgAqACoAKgAqACsAKwBLAEsASwBLAEsASwBLAEsASwBLACsAKwBcAFwAXABcAFAADgAOAA4ADgAeAA4ADgAJAA4ADgANAAkAEwATABMAEwATAAkAHgATAB4AHgAeAAQABAAeAB4AHgAeAB4AHgBLAEsASwBLAEsASwBLAEsASwBLAFAAUABQAFAAUABQAFAAUABQAFAADQAEAB4ABAAeAAQAFgARABYAEQAEAAQAUABQAFAAUABQAFAAUABQACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwArACsAKwAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQADQAEAAQABAAEAAQADQAEAAQAUABQAFAAUABQAAQABAAEAAQABAAEAAQABAAEAAQABAArAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAArAA0ADQAeAB4AHgAeAB4AHgAEAB4AHgAeAB4AHgAeACsAHgAeAA4ADgANAA4AHgAeAB4AHgAeAAkACQArACsAKwArACsAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcACoAKgAqACoAKgAqACoAKgAqACoAKgAqACoAKgAqACoAKgAqACoAKgBcAEsASwBLAEsASwBLAEsASwBLAEsADQANAB4AHgAeAB4AXABcAFwAXABcAFwAKgAqACoAKgBcAFwAXABcACoAKgAqAFwAKgAqACoAXABcACoAKgAqACoAKgAqACoAXABcAFwAKgAqACoAKgBcAFwAXABcAFwAXABcAFwAXABcAFwAXABcACoAKgAqACoAKgAqACoAKgAqACoAKgAqAFwAKgBLAEsASwBLAEsASwBLAEsASwBLACoAKgAqACoAKgAqAFAAUABQAFAAUABQACsAUAArACsAKwArACsAUAArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAHgBQAFAAUABQAFgAWABYAFgAWABYAFgAWABYAFgAWABYAFgAWABYAFgAWABYAFgAWABYAFgAWABYAFgAWABYAFgAWABYAFgAWABZAFkAWQBZAFkAWQBZAFkAWQBZAFkAWQBZAFkAWQBZAFkAWQBZAFkAWQBZAFkAWQBZAFkAWQBZAFkAWQBZAFkAWgBaAFoAWgBaAFoAWgBaAFoAWgBaAFoAWgBaAFoAWgBaAFoAWgBaAFoAWgBaAFoAWgBaAFoAWgBaAFoAWgBaAFAAUABQAFAAUABQAFAAUABQACsAUABQAFAAUAArACsAUABQAFAAUABQAFAAUAArAFAAKwBQAFAAUABQACsAKwBQAFAAUABQAFAAUABQAFAAUAArAFAAUABQAFAAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArAFAAUABQAFAAKwArAFAAUABQAFAAUABQAFAAKwBQACsAUABQAFAAUAArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwBQAFAAUABQACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsABAAEAAQAHgANAB4AHgAeAB4AHgAeAB4AUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAHgAeAB4AHgAeAB4AHgAeAB4AHgArACsAKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwBQAFAAUABQAFAAUAArACsADQBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAHgAeAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAANAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAWABEAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAA0ADQANAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwBQAFAAUABQAAQABAAEACsAKwArACsAKwArACsAKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAANAA0AKwArACsAKwArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAABAAEACsAKwArACsAKwArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwBQAFAAUAArAAQABAArACsAKwArACsAKwArACsAKwArACsAKwBcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAKgAqACoAKgAqACoAKgAqACoAKgAqACoAKgAqACoAKgAqACoAKgAqAA0ADQAVAFwADQAeAA0AGwBcACoAKwArAEsASwBLAEsASwBLAEsASwBLAEsAKwArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAKwAeAB4AEwATAA0ADQAOAB4AEwATAB4ABAAEAAQACQArAEsASwBLAEsASwBLAEsASwBLAEsAKwArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAKwArAFAAUABQAFAAUAAEAAQAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAAQAUAArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwAEAAQABAAEAAQABAAEAAQABAAEAAQABAArACsAKwArAAQABAAEAAQABAAEAAQABAAEAAQABAAEACsAKwArACsAHgArACsAKwATABMASwBLAEsASwBLAEsASwBLAEsASwBcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXAArACsAXABcAFwAXABcACsAKwArACsAKwArACsAKwArACsAKwBcAFwAXABcAFwAXABcAFwAXABcAFwAXAArACsAKwArAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcACsAKwArACsAKwArAEsASwBLAEsASwBLAEsASwBLAEsAXAArACsAKwAqACoAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAAQABAAEAAQABAArACsAHgAeAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcACoAKgAqACoAKgAqACoAKgAqACoAKwAqACoAKgAqACoAKgAqACoAKgAqACoAKgAqACoAKgAqACoAKgAqACoAKgAqACoAKgAqACoAKgAqACoAKwArAAQASwBLAEsASwBLAEsASwBLAEsASwArACsAKwArACsAKwBLAEsASwBLAEsASwBLAEsASwBLACsAKwArACsAKwArACoAKgAqACoAKgAqACoAXAAqACoAKgAqACoAKgArACsABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsABAAEAAQABAAEAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAAQABAAEAAQABABQAFAAUABQAFAAUABQACsAKwArACsASwBLAEsASwBLAEsASwBLAEsASwANAA0AHgANAA0ADQANAB4AHgAeAB4AHgAeAB4AHgAeAB4ABAAEAAQABAAEAAQABAAEAAQAHgAeAB4AHgAeAB4AHgAeAB4AKwArACsABAAEAAQAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAABAAEAAQABAAEAAQABAAEAAQABAAEAAQABABQAFAASwBLAEsASwBLAEsASwBLAEsASwBQAFAAUABQAFAAUABQAFAABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEACsAKwArACsAKwArACsAKwAeAB4AHgAeAFAAUABQAFAABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEACsAKwArAA0ADQANAA0ADQBLAEsASwBLAEsASwBLAEsASwBLACsAKwArAFAAUABQAEsASwBLAEsASwBLAEsASwBLAEsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAA0ADQBQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwBQAFAAUAAeAB4AHgAeAB4AHgAeAB4AKwArACsAKwArACsAKwArAAQABAAEAB4ABAAEAAQABAAEAAQABAAEAAQABAAEAAQABABQAFAAUABQAAQAUABQAFAAUABQAFAABABQAFAABAAEAAQAUAArACsAKwArACsABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEACsABAAEAAQABAAEAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AKwArAFAAUABQAFAAUABQACsAKwBQAFAAUABQAFAAUABQAFAAKwBQACsAUAArAFAAKwAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeACsAKwAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgArAB4AHgAeAB4AHgAeAB4AHgBQAB4AHgAeAFAAUABQACsAHgAeAB4AHgAeAB4AHgAeAB4AHgBQAFAAUABQACsAKwAeAB4AHgAeAB4AHgArAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AKwArAFAAUABQACsAHgAeAB4AHgAeAB4AHgAOAB4AKwANAA0ADQANAA0ADQANAAkADQANAA0ACAAEAAsABAAEAA0ACQANAA0ADAAdAB0AHgAXABcAFgAXABcAFwAWABcAHQAdAB4AHgAUABQAFAANAAEAAQAEAAQABAAEAAQACQAaABoAGgAaABoAGgAaABoAHgAXABcAHQAVABUAHgAeAB4AHgAeAB4AGAAWABEAFQAVABUAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4ADQAeAA0ADQANAA0AHgANAA0ADQAHAB4AHgAeAB4AKwAEAAQABAAEAAQABAAEAAQABAAEAFAAUAArACsATwBQAFAAUABQAFAAHgAeAB4AFgARAE8AUABPAE8ATwBPAFAAUABQAFAAUAAeAB4AHgAWABEAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwArABsAGwAbABsAGwAbABsAGgAbABsAGwAbABsAGwAbABsAGwAbABsAGwAbABsAGgAbABsAGwAbABoAGwAbABoAGwAbABsAGwAbABsAGwAbABsAGwAbABsAGwAbABsAGwAbAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQAHgAeAFAAGgAeAB0AHgBQAB4AGgAeAB4AHgAeAB4AHgAeAB4AHgBPAB4AUAAbAB4AHgBQAFAAUABQAFAAHgAeAB4AHQAdAB4AUAAeAFAAHgBQAB4AUABPAFAAUAAeAB4AHgAeAB4AHgAeAFAAUABQAFAAUAAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAFAAHgBQAFAAUABQAE8ATwBQAFAAUABQAFAATwBQAFAATwBQAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBPAFAAUABQAFAATwBPAE8ATwBPAE8ATwBPAE8ATwBQAFAAUABQAFAAUABQAFAAUAAeAB4AUABQAFAAUABPAB4AHgArACsAKwArAB0AHQAdAB0AHQAdAB0AHQAdAB0AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB0AHgAdAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAdAB4AHQAdAB4AHgAeAB0AHQAeAB4AHQAeAB4AHgAdAB4AHQAbABsAHgAdAB4AHgAeAB4AHQAeAB4AHQAdAB0AHQAeAB4AHQAeAB0AHgAdAB0AHQAdAB0AHQAeAB0AHgAeAB4AHgAeAB0AHQAdAB0AHgAeAB4AHgAdAB0AHgAeAB4AHgAeAB4AHgAeAB4AHgAdAB4AHgAeAB0AHgAeAB4AHgAeAB0AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAdAB0AHgAeAB0AHQAdAB0AHgAeAB0AHQAeAB4AHQAdAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB0AHQAeAB4AHQAdAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHQAeAB4AHgAdAB4AHgAeAB4AHgAeAB4AHQAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB0AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AFAAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeABYAEQAWABEAHgAeAB4AHgAeAB4AHQAeAB4AHgAeAB4AHgAeACUAJQAeAB4AHgAeAB4AHgAeAB4AHgAWABEAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AJQAlACUAJQAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBPAFAAHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHgAeAB4AHgAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAeAB4AHQAdAB0AHQAeAB4AHgAeAB4AHgAeAB4AHgAeAB0AHQAeAB0AHQAdAB0AHQAdAB0AHgAeAB4AHgAeAB4AHgAeAB0AHQAeAB4AHQAdAB4AHgAeAB4AHQAdAB4AHgAeAB4AHQAdAB0AHgAeAB0AHgAeAB0AHQAdAB0AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAdAB0AHQAdAB4AHgAeAB4AHgAeAB4AHgAeAB0AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAlACUAJQAlAB4AHQAdAB4AHgAdAB4AHgAeAB4AHQAdAB4AHgAeAB4AJQAlAB0AHQAlAB4AJQAlACUAIAAlACUAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAlACUAJQAeAB4AHgAeAB0AHgAdAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAdAB0AHgAdAB0AHQAeAB0AJQAdAB0AHgAdAB0AHgAdAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeACUAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHQAdAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAlACUAJQAlACUAJQAlACUAJQAlACUAJQAdAB0AHQAdACUAHgAlACUAJQAdACUAJQAdAB0AHQAlACUAHQAdACUAHQAdACUAJQAlAB4AHQAeAB4AHgAeAB0AHQAlAB0AHQAdAB0AHQAdACUAJQAlACUAJQAdACUAJQAgACUAHQAdACUAJQAlACUAJQAlACUAJQAeAB4AHgAlACUAIAAgACAAIAAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB0AHgAeAB4AFwAXABcAFwAXABcAHgATABMAJQAeAB4AHgAWABEAFgARABYAEQAWABEAFgARABYAEQAWABEATwBPAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeABYAEQAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAWABEAFgARABYAEQAWABEAFgARAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AFgARABYAEQAWABEAFgARABYAEQAWABEAFgARABYAEQAWABEAFgARABYAEQAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAWABEAFgARAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AFgARAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAdAB0AHQAdAB0AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgArACsAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AKwAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AUABQAFAAUAAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAEAAQABAAeAB4AKwArACsAKwArABMADQANAA0AUAATAA0AUABQAFAAUABQAFAAUABQACsAKwArACsAKwArACsAUAANACsAKwArACsAKwArACsAKwArACsAKwArACsAKwAEAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAKwArACsAKwBQAFAAUABQAFAAUABQACsAUABQAFAAUABQAFAAUAArAFAAUABQAFAAUABQAFAAKwBQAFAAUABQAFAAUABQACsAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXAA0ADQANAA0ADQANAA0ADQAeAA0AFgANAB4AHgAXABcAHgAeABcAFwAWABEAFgARABYAEQAWABEADQANAA0ADQATAFAADQANAB4ADQANAB4AHgAeAB4AHgAMAAwADQANAA0AHgANAA0AFgANAA0ADQANAA0ADQANAA0AHgANAB4ADQANAB4AHgAeACsAKwArACsAKwArACsAKwArACsAKwArACsAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACsAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAKwArACsAKwArACsAKwArACsAKwArACsAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwAlACUAJQAlACUAJQAlACUAJQAlACUAJQArACsAKwArAA0AEQARACUAJQBHAFcAVwAWABEAFgARABYAEQAWABEAFgARACUAJQAWABEAFgARABYAEQAWABEAFQAWABEAEQAlAFcAVwBXAFcAVwBXAFcAVwBXAAQABAAEAAQABAAEACUAVwBXAFcAVwA2ACUAJQBXAFcAVwBHAEcAJQAlACUAKwBRAFcAUQBXAFEAVwBRAFcAUQBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFEAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBRAFcAUQBXAFEAVwBXAFcAVwBXAFcAUQBXAFcAVwBXAFcAVwBRAFEAKwArAAQABAAVABUARwBHAFcAFQBRAFcAUQBXAFEAVwBRAFcAUQBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFEAVwBRAFcAUQBXAFcAVwBXAFcAVwBRAFcAVwBXAFcAVwBXAFEAUQBXAFcAVwBXABUAUQBHAEcAVwArACsAKwArACsAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAKwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAKwAlACUAVwBXAFcAVwAlACUAJQAlACUAJQAlACUAJQAlACsAKwArACsAKwArACsAKwArACsAKwArAFEAUQBRAFEAUQBRAFEAUQBRAFEAUQBRAFEAUQBRAFEAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQArAFcAVwBXAFcAVwBXAFcAVwBXAFcAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQBPAE8ATwBPAE8ATwBPAE8AJQBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXACUAJQAlAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAEcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAKwArACsAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQArACsAKwArACsAKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAADQATAA0AUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABLAEsASwBLAEsASwBLAEsASwBLAFAAUAArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAFAABAAEAAQABAAeAAQABAAEAAQABAAEAAQABAAEAAQAHgBQAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AUABQAAQABABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAAQABAAeAA0ADQANAA0ADQArACsAKwArACsAKwArACsAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAFAAUABQAFAAUABQAFAAUABQAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AUAAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgBQAB4AHgAeAB4AHgAeAFAAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgArACsAHgAeAB4AHgAeAB4AHgAeAB4AKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwAeAB4AUABQAFAAUABQAFAAUABQAFAAUABQAAQAUABQAFAABABQAFAAUABQAAQAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAAQABAAEAAQABAAeAB4AHgAeAAQAKwArACsAUABQAFAAUABQAFAAHgAeABoAHgArACsAKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAADgAOABMAEwArACsAKwArACsAKwArACsABAAEAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAAQABAAEAAQABAAEACsAKwArACsAKwArACsAKwANAA0ASwBLAEsASwBLAEsASwBLAEsASwArACsAKwArACsAKwAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABABQAFAAUABQAFAAUAAeAB4AHgBQAA4AUABQAAQAUABQAFAAUABQAFAABAAEAAQABAAEAAQABAAEAA0ADQBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQAKwArACsAKwArACsAKwArACsAKwArAB4AWABYAFgAWABYAFgAWABYAFgAWABYAFgAWABYAFgAWABYAFgAWABYAFgAWABYAFgAWABYAFgAWABYACsAKwArAAQAHgAeAB4AHgAeAB4ADQANAA0AHgAeAB4AHgArAFAASwBLAEsASwBLAEsASwBLAEsASwArACsAKwArAB4AHgBcAFwAXABcAFwAKgBcAFwAXABcAFwAXABcAFwAXABcAEsASwBLAEsASwBLAEsASwBLAEsAXABcAFwAXABcACsAUABQAFAAUABQAFAAUABQAFAABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEACsAKwArACsAKwArACsAKwArAFAAUABQAAQAUABQAFAAUABQAFAAUABQAAQABAArACsASwBLAEsASwBLAEsASwBLAEsASwArACsAHgANAA0ADQBcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAKgAqACoAXAAqACoAKgBcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXAAqAFwAKgAqACoAXABcACoAKgBcAFwAXABcAFwAKgAqAFwAKgBcACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArAFwAXABcACoAKgBQAFAAUABQAFAAUABQAFAAUABQAFAABAAEAAQABAAEAA0ADQBQAFAAUAAEAAQAKwArACsAKwArACsAKwArACsAKwBQAFAAUABQAFAAUAArACsAUABQAFAAUABQAFAAKwArAFAAUABQAFAAUABQACsAKwArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAKwBQAFAAUABQAFAAUABQACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAHgAeACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAAEAAQABAAEAAQADQAEAAQAKwArAEsASwBLAEsASwBLAEsASwBLAEsAKwArACsAKwArACsAVABVAFUAVQBVAFUAVQBVAFUAVQBVAFUAVQBVAFUAVQBVAFUAVQBVAFUAVQBVAFUAVQBVAFUAVQBUAFUAVQBVAFUAVQBVAFUAVQBVAFUAVQBVAFUAVQBVAFUAVQBVAFUAVQBVAFUAVQBVAFUAVQBVACsAKwArACsAKwArACsAKwArACsAKwArAFkAWQBZAFkAWQBZAFkAWQBZAFkAWQBZAFkAWQBZAFkAWQBZAFkAKwArACsAKwBaAFoAWgBaAFoAWgBaAFoAWgBaAFoAWgBaAFoAWgBaAFoAWgBaAFoAWgBaAFoAWgBaAFoAWgBaAFoAKwArACsAKwAGAAYABgAGAAYABgAGAAYABgAGAAYABgAGAAYABgAGAAYABgAGAAYABgAGAAYABgAGAAYABgAGAAYABgAGAAYAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXACUAJQBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAJQAlACUAJQAlACUAUABQAFAAUABQAFAAUAArACsAKwArACsAKwArACsAKwArACsAKwBQAFAAUABQAFAAKwArACsAKwArAFYABABWAFYAVgBWAFYAVgBWAFYAVgBWAB4AVgBWAFYAVgBWAFYAVgBWAFYAVgBWAFYAVgArAFYAVgBWAFYAVgArAFYAKwBWAFYAKwBWAFYAKwBWAFYAVgBWAFYAVgBWAFYAVgBWAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAEQAWAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUAAaAB4AKwArAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQAGAARABEAGAAYABMAEwAWABEAFAArACsAKwArACsAKwAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEACUAJQAlACUAJQAWABEAFgARABYAEQAWABEAFgARABYAEQAlACUAFgARACUAJQAlACUAJQAlACUAEQAlABEAKwAVABUAEwATACUAFgARABYAEQAWABEAJQAlACUAJQAlACUAJQAlACsAJQAbABoAJQArACsAKwArAFAAUABQAFAAUAArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwArAAcAKwATACUAJQAbABoAJQAlABYAEQAlACUAEQAlABEAJQBXAFcAVwBXAFcAVwBXAFcAVwBXABUAFQAlACUAJQATACUAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXABYAJQARACUAJQAlAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwAWACUAEQAlABYAEQARABYAEQARABUAVwBRAFEAUQBRAFEAUQBRAFEAUQBRAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAEcARwArACsAVwBXAFcAVwBXAFcAKwArAFcAVwBXAFcAVwBXACsAKwBXAFcAVwBXAFcAVwArACsAVwBXAFcAKwArACsAGgAbACUAJQAlABsAGwArAB4AHgAeAB4AHgAeAB4AKwArACsAKwArACsAKwArACsAKwAEAAQABAAQAB0AKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwBQAFAAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsADQANAA0AKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwArAB4AHgAeAB4AHgAeAB4AHgAeAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgBQAFAAHgAeAB4AKwAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAAQAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwAEAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAABAAEAAQABAAEACsAKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArAA0AUABQAFAAUAArACsAKwArAFAAUABQAFAAUABQAFAAUAANAFAAUABQAFAAUAArACsAKwArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwArACsAKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwArACsAKwArACsAKwArACsAKwAeACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAUABQAFAAUABQAFAAKwArAFAAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArAFAAUAArACsAKwBQACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwANAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAeAB4AUABQAFAAUABQAFAAUAArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArAFAAUAArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwArAA0AUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwArACsAKwAeAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwArACsAUABQAFAAUABQAAQABAAEACsABAAEACsAKwArACsAKwAEAAQABAAEAFAAUABQAFAAKwBQAFAAUAArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwArAAQABAAEACsAKwArACsABABQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAKwArAA0ADQANAA0ADQANAA0ADQAeACsAKwArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAeAFAAUABQAFAAUABQAFAAUAAeAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAAQABAArACsAKwArAFAAUABQAFAAUAANAA0ADQANAA0ADQAUACsAKwArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwArACsADQANAA0ADQANAA0ADQBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAKwArAB4AHgAeAB4AKwArACsAKwArACsAKwArACsAKwArACsAUABQAFAAUABQAFAAUAArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwArACsAKwArACsAKwArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAKwArAFAAUABQAFAAUABQAAQABAAEAAQAKwArACsAKwArACsAKwArAEsASwBLAEsASwBLAEsASwBLAEsAKwArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUAArAAQABAANACsAKwBQAFAAKwArACsAKwArACsAKwArACsAKwArACsAKwArAFAAUABQAFAAUABQAAQABAAEAAQABAAEAAQABAAEAAQABABQAFAAUABQAB4AHgAeAB4AHgArACsAKwArACsAKwAEAAQABAAEAAQABAAEAA0ADQAeAB4AHgAeAB4AKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAEsASwBLAEsASwBLAEsASwBLAEsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsABABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAAQABAAEAAQABAAEAAQABAAEAAQABAAeAB4AHgANAA0ADQANACsAKwArACsAKwArACsAKwArACsAKwAeACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwArACsAKwArACsAKwBLAEsASwBLAEsASwBLAEsASwBLACsAKwArACsAKwArAFAAUABQAFAAUABQAFAABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEACsASwBLAEsASwBLAEsASwBLAEsASwANAA0ADQANAFAABAAEAFAAKwArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAABAAeAA4AUAArACsAKwArACsAKwArACsAKwAEAFAAUABQAFAADQANAB4ADQAEAAQABAAEAB4ABAAEAEsASwBLAEsASwBLAEsASwBLAEsAUAAOAFAADQANAA0AKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwArACsAKwArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAAEAAQABAAEAAQABAAEAAQABAANAA0AHgANAA0AHgAEACsAUABQAFAAUABQAFAAUAArAFAAKwBQAFAAUABQACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwBQAFAAUABQAFAAUABQAFAAUABQAA0AKwArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAAEAAQABAAEAAQABAAEAAQAKwArACsAKwArAEsASwBLAEsASwBLAEsASwBLAEsAKwArACsAKwArACsABAAEAAQABAArAFAAUABQAFAAUABQAFAAUAArACsAUABQACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwBQAFAAUABQAFAAUABQACsAUABQACsAUABQAFAAUABQACsABAAEAFAABAAEAAQABAAEAAQABAArACsABAAEACsAKwAEAAQABAArACsAUAArACsAKwArACsAKwAEACsAKwArACsAKwBQAFAAUABQAFAABAAEACsAKwAEAAQABAAEAAQABAAEACsAKwArAAQABAAEAAQABAArACsAKwArACsAKwArACsAKwArACsABAAEAAQABAAEAAQABABQAFAAUABQAA0ADQANAA0AHgBLAEsASwBLAEsASwBLAEsASwBLAA0ADQArAB4ABABQAFAAUAArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwAEAAQABAAEAFAAUAAeAFAAKwArACsAKwArACsAKwArAEsASwBLAEsASwBLAEsASwBLAEsAKwArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAABAAEAAQABAAEAAQABAArACsABAAEAAQABAAEAAQABAAEAAQADgANAA0AEwATAB4AHgAeAA0ADQANAA0ADQANAA0ADQANAA0ADQANAA0ADQANAFAAUABQAFAABAAEACsAKwAEAA0ADQAeAFAAKwArACsAKwArACsAKwArACsAKwArAEsASwBLAEsASwBLAEsASwBLAEsAKwArACsAKwArACsADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAFAAKwArACsAKwArACsAKwBLAEsASwBLAEsASwBLAEsASwBLACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAKwArACoAKgAqACoAKgAqACoAKgAqACoAKgAqACoAKgAqACsAKwArACsASwBLAEsASwBLAEsASwBLAEsASwBcAFwADQANAA0AKgBQAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAeACsAKwArACsASwBLAEsASwBLAEsASwBLAEsASwBQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAKwArACsAKwArACsAKwBQAFAAUABQAFAAUABQAFAAKwArAFAAKwArAFAAUABQAFAAUABQAFAAUAArAFAAUAArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAABAAEAAQABAAEAAQAKwAEAAQAKwArAAQABAAEAAQAUAAEAFAABAAEAA0ADQANACsAKwArACsAKwArACsAKwArAEsASwBLAEsASwBLAEsASwBLAEsAKwArACsAKwArACsAUABQAFAAUABQAFAAUABQACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAABAAEAAQABAAEAAQABAArACsABAAEAAQABAAEAAQABABQAA4AUAAEACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArAFAABAAEAAQABAAEAAQABAAEAAQABABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAAEAAQABAAEAFAABAAEAAQABAAOAB4ADQANAA0ADQAOAB4ABAArACsAKwArACsAKwArACsAUAAEAAQABAAEAAQABAAEAAQABAAEAAQAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAA0ADQANAFAADgAOAA4ADQANACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwBQAFAAUABQAFAAUABQAFAAUAArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAABAAEAAQABAAEAAQABAAEACsABAAEAAQABAAEAAQABAAEAFAADQANAA0ADQANACsAKwArACsAKwArACsAKwArACsASwBLAEsASwBLAEsASwBLAEsASwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwAOABMAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwArAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAArAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAArACsAKwArACsAKwArACsAKwBQAFAAUABQAFAAUABQACsAUABQACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAAEAAQABAArACsAKwAEACsABAAEACsABAAEAAQABAAEAAQABABQAAQAKwArACsAKwArACsAKwArAEsASwBLAEsASwBLAEsASwBLAEsAKwArACsAKwArACsAUABQAFAAUABQAFAAKwBQAFAAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAAEAAQAKwAEAAQAKwAEAAQABAAEAAQAUAArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAABAAEAAQABAAeAB4AKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwBQACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAB4AHgAeAB4AHgAeAB4AHgAaABoAGgAaAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgArACsAKwArACsAKwArACsAKwArACsAKwArAA0AUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsADQANAA0ADQANACsAKwArACsAKwArACsAKwArACsAKwBQAFAAUABQACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAASABIAEgAQwBDAEMAUABQAFAAUABDAFAAUABQAEgAQwBIAEMAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAASABDAEMAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwAJAAkACQAJAAkACQAJABYAEQArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABIAEMAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArAEsASwBLAEsASwBLAEsASwBLAEsAKwArACsAKwANAA0AKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwArAAQABAAEAAQABAANACsAKwArACsAKwArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAAEAAQABAAEAA0ADQANAB4AHgAeAB4AHgAeAFAAUABQAFAADQAeACsAKwArACsAKwArACsAKwArACsASwBLAEsASwBLAEsASwBLAEsASwArAFAAUABQAFAAUABQAFAAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAANAA0AHgAeACsAKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAKwArACsAKwAEAFAABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQAKwArACsAKwArACsAKwAEAAQABAAEAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAARwBHABUARwAJACsAKwArACsAKwArACsAKwArACsAKwAEAAQAKwArACsAKwArACsAKwArACsAKwArACsAKwArAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXACsAKwArACsAKwArACsAKwBXAFcAVwBXAFcAVwBXAFcAVwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAUQBRAFEAKwArACsAKwArACsAKwArACsAKwArACsAKwBRAFEAUQBRACsAKwArACsAKwArACsAKwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUAArACsAHgAEAAQADQAEAAQABAAEACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgArACsAKwArACsAKwArACsAKwArAB4AHgAeAB4AHgAeAB4AKwArAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAAQABAAEAAQABAAeAB4AHgAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAB4AHgAEAAQABAAEAAQABAAEAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4ABAAEAAQABAAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4ABAAEAAQAHgArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwArACsAKwArACsAKwArACsAKwArAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgArACsAKwArACsAKwArACsAKwAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgArAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AKwBQAFAAKwArAFAAKwArAFAAUAArACsAUABQAFAAUAArAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeACsAUAArAFAAUABQAFAAUABQAFAAKwAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AKwBQAFAAUABQACsAKwBQAFAAUABQAFAAUABQAFAAKwBQAFAAUABQAFAAUABQACsAHgAeAFAAUABQAFAAUAArAFAAKwArACsAUABQAFAAUABQAFAAUAArAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAHgBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgBQAFAAUABQAFAAUABQAFAAUABQAFAAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAB4AHgAeAB4AHgAeAB4AHgAeACsAKwBLAEsASwBLAEsASwBLAEsASwBLAEsASwBLAEsASwBLAEsASwBLAEsASwBLAEsASwBLAEsASwBLAEsASwBLAEsASwBLAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAeAB4AHgAeAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAeAB4AHgAeAB4AHgAeAB4ABAAeAB4AHgAeAB4AHgAeAB4AHgAeAAQAHgAeAA0ADQANAA0AHgArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwAEAAQABAAEAAQAKwAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArAAQABAAEAAQABAAEAAQAKwAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQAKwArAAQABAAEAAQABAAEAAQAKwAEAAQAKwAEAAQABAAEAAQAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwAEAAQABAAEAAQABAAEAFAAUABQAFAAUABQAFAAKwArAEsASwBLAEsASwBLAEsASwBLAEsAKwArACsAKwBQAB4AKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAAEAEsASwBLAEsASwBLAEsASwBLAEsAKwArACsAKwArABsAUABQAFAAUABQACsAKwBQAFAAUABQAFAAUABQAFAAUAAEAAQABAAEAAQABAAEACsAKwArACsAKwArACsAKwArAB4AHgAeAB4ABAAEAAQABAAEAAQABABQACsAKwArACsASwBLAEsASwBLAEsASwBLAEsASwArACsAKwArABYAFgArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAGgBQAFAAUAAaAFAAUABQAFAAKwArACsAKwArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAeAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwBQAFAAUABQACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwBQAFAAKwBQACsAKwBQACsAUABQAFAAUABQAFAAUABQAFAAUAArAFAAUABQAFAAKwBQACsAUAArACsAKwArACsAKwBQACsAKwArACsAUAArAFAAKwBQACsAUABQAFAAKwBQAFAAKwBQACsAKwBQACsAUAArAFAAKwBQACsAUAArAFAAUAArAFAAKwArAFAAUABQAFAAKwBQAFAAUABQAFAAUABQACsAUABQAFAAUAArAFAAUABQAFAAKwBQACsAUABQAFAAUABQAFAAUABQAFAAUAArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAUABQAFAAKwBQAFAAUABQAFAAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwAeAB4AKwArACsAKwArACsAKwArACsAKwArACsAKwArAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBPAE8AJQAlACUAHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHgAeAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB4AHgAeACUAJQAlAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQApACkAKQApACkAKQApACkAKQApACkAKQApACkAKQApACkAKQApACkAKQApACkAKQApACkAJQAlACUAJQAlACAAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAeAB4AJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlAB4AHgAlACUAJQAlACUAHgAlACUAJQAlACUAIAAgACAAJQAlACAAJQAlACAAIAAgACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACEAIQAhACEAIQAlACUAIAAgACUAJQAgACAAIAAgACAAIAAgACAAIAAgACAAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAJQAlACUAIAAlACUAJQAlACAAIAAgACUAIAAgACAAJQAlACUAJQAlACUAJQAgACUAIAAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAHgAlAB4AJQAeACUAJQAlACUAJQAgACUAJQAlACUAHgAlAB4AHgAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlAB4AHgAeAB4AHgAeAB4AJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAeAB4AHgAeAB4AHgAeAB4AHgAeACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACAAIAAlACUAJQAlACAAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACAAJQAlACUAJQAgACAAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAHgAeAB4AHgAeAB4AHgAeACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAeAB4AHgAeAB4AHgAlACUAJQAlACUAJQAlACAAIAAgACUAJQAlACAAIAAgACAAIAAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeABcAFwAXABUAFQAVAB4AHgAeAB4AJQAlACUAIAAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACAAIAAgACUAJQAlACUAJQAlACUAJQAlACAAJQAlACUAJQAlACUAJQAlACUAJQAlACAAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AJQAlACUAJQAlACUAJQAlACUAJQAlACUAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AJQAlACUAJQAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeACUAJQAlACUAJQAlACUAJQAeAB4AHgAeAB4AHgAeAB4AHgAeACUAJQAlACUAJQAlAB4AHgAeAB4AHgAeAB4AHgAlACUAJQAlACUAJQAlACUAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAgACUAJQAgACUAJQAlACUAJQAlACUAJQAgACAAIAAgACAAIAAgACAAJQAlACUAJQAlACUAIAAlACUAJQAlACUAJQAlACUAJQAgACAAIAAgACAAIAAgACAAIAAgACUAJQAgACAAIAAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAgACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACAAIAAlACAAIAAlACAAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAgACAAIAAlACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAJQAlAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AKwAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArAEsASwBLAEsASwBLAEsASwBLAEsAKwArACsAKwArACsAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAKwArAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXACUAJQBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwAlACUAJQAlACUAJQAlACUAJQAlACUAVwBXACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAKwAEACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArAA==", rF = 50, nne = 1, cP = 2, uP = 3, sne = 4, ane = 5, iF = 7, fP = 8, nF = 9, qA = 10, Yx = 11, sF = 12, qx = 13, one = 14, td = 15, Zx = 16, a0 = 17, Of = 18, Ane = 19, aF = 20, Jx = 21, Uf = 22, x_ = 23, uc = 24, Is = 25, rd = 26, id = 27, fc = 28, lne = 29, Vl = 30, hne = 31, o0 = 32, A0 = 33, eC = 34, tC = 35, rC = 36, Jd = 37, iC = 38, em = 39, tm = 40, C_ = 41, dP = 42, cne = 43, une = [9001, 65288], gP = "!", hr = "", l0 = "", nC = ene(ine), To = [Vl, rC], sC = [nne, cP, uP, ane], pP = [qA, fP], oF = [id, rd], fne = sC.concat(pP), AF = [iC, em, tm, eC, tC], dne = [td, qx], gne = function(i, e) {
  e === void 0 && (e = "strict");
  var t = [], r = [], n = [];
  return i.forEach(function(s, a) {
    var o = nC.get(s);
    if (o > rF ? (n.push(!0), o -= rF) : n.push(!1), ["normal", "auto", "loose"].indexOf(e) !== -1 && [8208, 8211, 12316, 12448].indexOf(s) !== -1)
      return r.push(a), t.push(Zx);
    if (o === sne || o === Yx) {
      if (a === 0)
        return r.push(a), t.push(Vl);
      var A = t[a - 1];
      return fne.indexOf(A) === -1 ? (r.push(r[a - 1]), t.push(A)) : (r.push(a), t.push(Vl));
    }
    if (r.push(a), o === hne)
      return t.push(e === "strict" ? Jx : Jd);
    if (o === dP || o === lne)
      return t.push(Vl);
    if (o === cne)
      return s >= 131072 && s <= 196605 || s >= 196608 && s <= 262141 ? t.push(Jd) : t.push(Vl);
    t.push(o);
  }), [r, t, n];
}, E_ = function(i, e, t, r) {
  var n = r[t];
  if (Array.isArray(i) ? i.indexOf(n) !== -1 : i === n)
    for (var s = t; s <= r.length; ) {
      s++;
      var a = r[s];
      if (a === e)
        return !0;
      if (a !== qA)
        break;
    }
  if (n === qA)
    for (var s = t; s > 0; ) {
      s--;
      var o = r[s];
      if (Array.isArray(i) ? i.indexOf(o) !== -1 : i === o)
        for (var A = t; A <= r.length; ) {
          A++;
          var a = r[A];
          if (a === e)
            return !0;
          if (a !== qA)
            break;
        }
      if (o !== qA)
        break;
    }
  return !1;
}, lF = function(i, e) {
  for (var t = i; t >= 0; ) {
    var r = e[t];
    if (r === qA)
      t--;
    else
      return r;
  }
  return 0;
}, pne = function(i, e, t, r, n) {
  if (t[r] === 0)
    return hr;
  var s = r - 1;
  if (Array.isArray(n) && n[s] === !0)
    return hr;
  var a = s - 1, o = s + 1, A = e[s], l = a >= 0 ? e[a] : 0, h = e[o];
  if (A === cP && h === uP)
    return hr;
  if (sC.indexOf(A) !== -1)
    return gP;
  if (sC.indexOf(h) !== -1 || pP.indexOf(h) !== -1)
    return hr;
  if (lF(s, e) === fP)
    return l0;
  if (nC.get(i[s]) === Yx || (A === o0 || A === A0) && nC.get(i[o]) === Yx || A === iF || h === iF || A === nF || [qA, qx, td].indexOf(A) === -1 && h === nF || [a0, Of, Ane, uc, fc].indexOf(h) !== -1 || lF(s, e) === Uf || E_(x_, Uf, s, e) || E_([a0, Of], Jx, s, e) || E_(sF, sF, s, e))
    return hr;
  if (A === qA)
    return l0;
  if (A === x_ || h === x_)
    return hr;
  if (h === Zx || A === Zx)
    return l0;
  if ([qx, td, Jx].indexOf(h) !== -1 || A === one || l === rC && dne.indexOf(A) !== -1 || A === fc && h === rC || h === aF || To.indexOf(h) !== -1 && A === Is || To.indexOf(A) !== -1 && h === Is || A === id && [Jd, o0, A0].indexOf(h) !== -1 || [Jd, o0, A0].indexOf(A) !== -1 && h === rd || To.indexOf(A) !== -1 && oF.indexOf(h) !== -1 || oF.indexOf(A) !== -1 && To.indexOf(h) !== -1 || // (PR | PO)  ( OP | HY )? NU
  [id, rd].indexOf(A) !== -1 && (h === Is || [Uf, td].indexOf(h) !== -1 && e[o + 1] === Is) || // ( OP | HY )  NU
  [Uf, td].indexOf(A) !== -1 && h === Is || // NU 	(NU | SY | IS)
  A === Is && [Is, fc, uc].indexOf(h) !== -1)
    return hr;
  if ([Is, fc, uc, a0, Of].indexOf(h) !== -1)
    for (var c = s; c >= 0; ) {
      var u = e[c];
      if (u === Is)
        return hr;
      if ([fc, uc].indexOf(u) !== -1)
        c--;
      else
        break;
    }
  if ([id, rd].indexOf(h) !== -1)
    for (var c = [a0, Of].indexOf(A) !== -1 ? a : s; c >= 0; ) {
      var u = e[c];
      if (u === Is)
        return hr;
      if ([fc, uc].indexOf(u) !== -1)
        c--;
      else
        break;
    }
  if (iC === A && [iC, em, eC, tC].indexOf(h) !== -1 || [em, eC].indexOf(A) !== -1 && [em, tm].indexOf(h) !== -1 || [tm, tC].indexOf(A) !== -1 && h === tm || AF.indexOf(A) !== -1 && [aF, rd].indexOf(h) !== -1 || AF.indexOf(h) !== -1 && A === id || To.indexOf(A) !== -1 && To.indexOf(h) !== -1 || A === uc && To.indexOf(h) !== -1 || To.concat(Is).indexOf(A) !== -1 && h === Uf && une.indexOf(i[o]) === -1 || To.concat(Is).indexOf(h) !== -1 && A === Of)
    return hr;
  if (A === C_ && h === C_) {
    for (var f = t[s], g = 1; f > 0 && (f--, e[f] === C_); )
      g++;
    if (g % 2 !== 0)
      return hr;
  }
  return A === o0 && h === A0 ? hr : l0;
}, mne = function(i, e) {
  e || (e = { lineBreak: "normal", wordBreak: "normal" });
  var t = gne(i, e.lineBreak), r = t[0], n = t[1], s = t[2];
  (e.wordBreak === "break-all" || e.wordBreak === "break-word") && (n = n.map(function(o) {
    return [Is, Vl, dP].indexOf(o) !== -1 ? Jd : o;
  }));
  var a = e.wordBreak === "keep-all" ? s.map(function(o, A) {
    return o && i[A] >= 19968 && i[A] <= 40959;
  }) : void 0;
  return [r, n, a];
}, vne = (
  /** @class */
  function() {
    function i(e, t, r, n) {
      this.codePoints = e, this.required = t === gP, this.start = r, this.end = n;
    }
    return i.prototype.slice = function() {
      return Oi.apply(void 0, this.codePoints.slice(this.start, this.end));
    }, i;
  }()
), yne = function(i, e) {
  var t = uy(i), r = mne(t, e), n = r[0], s = r[1], a = r[2], o = t.length, A = 0, l = 0;
  return {
    next: function() {
      if (l >= o)
        return { done: !0, value: null };
      for (var h = hr; l < o && (h = pne(t, s, n, ++l, a)) === hr; )
        ;
      if (h !== hr || l === o) {
        var c = new vne(t, h, A, l);
        return A = l, { value: c, done: !1 };
      }
      return { done: !0, value: null };
    }
  };
}, _ne = 1 << 0, wne = 1 << 1, Fg = 1 << 2, hF = 1 << 3, hv = 10, cF = 47, yd = 92, xne = 9, Cne = 32, h0 = 34, Qf = 61, Ene = 35, Bne = 36, bne = 37, c0 = 39, u0 = 40, Df = 41, Sne = 95, fs = 45, Tne = 33, Fne = 60, Lne = 62, Ine = 64, Rne = 91, Mne = 93, Nne = 61, Pne = 123, f0 = 63, One = 125, uF = 124, Une = 126, Qne = 128, fF = 65533, B_ = 42, Yl = 43, Dne = 44, kne = 58, Hne = 59, eg = 46, Gne = 0, $ne = 8, Vne = 11, Kne = 14, jne = 31, zne = 127, Pa = -1, mP = 48, vP = 97, yP = 101, Xne = 102, Wne = 117, Yne = 122, _P = 65, wP = 69, xP = 70, qne = 85, Zne = 90, Vn = function(i) {
  return i >= mP && i <= 57;
}, Jne = function(i) {
  return i >= 55296 && i <= 57343;
}, dc = function(i) {
  return Vn(i) || i >= _P && i <= xP || i >= vP && i <= Xne;
}, ese = function(i) {
  return i >= vP && i <= Yne;
}, tse = function(i) {
  return i >= _P && i <= Zne;
}, rse = function(i) {
  return ese(i) || tse(i);
}, ise = function(i) {
  return i >= Qne;
}, d0 = function(i) {
  return i === hv || i === xne || i === Cne;
}, cv = function(i) {
  return rse(i) || ise(i) || i === Sne;
}, dF = function(i) {
  return cv(i) || Vn(i) || i === fs;
}, nse = function(i) {
  return i >= Gne && i <= $ne || i === Vne || i >= Kne && i <= jne || i === zne;
}, GA = function(i, e) {
  return i !== yd ? !1 : e !== hv;
}, g0 = function(i, e, t) {
  return i === fs ? cv(e) || GA(e, t) : cv(i) ? !0 : !!(i === yd && GA(i, e));
}, b_ = function(i, e, t) {
  return i === Yl || i === fs ? Vn(e) ? !0 : e === eg && Vn(t) : Vn(i === eg ? e : i);
}, sse = function(i) {
  var e = 0, t = 1;
  (i[e] === Yl || i[e] === fs) && (i[e] === fs && (t = -1), e++);
  for (var r = []; Vn(i[e]); )
    r.push(i[e++]);
  var n = r.length ? parseInt(Oi.apply(void 0, r), 10) : 0;
  i[e] === eg && e++;
  for (var s = []; Vn(i[e]); )
    s.push(i[e++]);
  var a = s.length, o = a ? parseInt(Oi.apply(void 0, s), 10) : 0;
  (i[e] === wP || i[e] === yP) && e++;
  var A = 1;
  (i[e] === Yl || i[e] === fs) && (i[e] === fs && (A = -1), e++);
  for (var l = []; Vn(i[e]); )
    l.push(i[e++]);
  var h = l.length ? parseInt(Oi.apply(void 0, l), 10) : 0;
  return t * (n + o * Math.pow(10, -a)) * Math.pow(10, A * h);
}, ase = {
  type: 2
  /* LEFT_PARENTHESIS_TOKEN */
}, ose = {
  type: 3
  /* RIGHT_PARENTHESIS_TOKEN */
}, Ase = {
  type: 4
  /* COMMA_TOKEN */
}, lse = {
  type: 13
  /* SUFFIX_MATCH_TOKEN */
}, hse = {
  type: 8
  /* PREFIX_MATCH_TOKEN */
}, cse = {
  type: 21
  /* COLUMN_TOKEN */
}, use = {
  type: 9
  /* DASH_MATCH_TOKEN */
}, fse = {
  type: 10
  /* INCLUDE_MATCH_TOKEN */
}, dse = {
  type: 11
  /* LEFT_CURLY_BRACKET_TOKEN */
}, gse = {
  type: 12
  /* RIGHT_CURLY_BRACKET_TOKEN */
}, pse = {
  type: 14
  /* SUBSTRING_MATCH_TOKEN */
}, p0 = {
  type: 23
  /* BAD_URL_TOKEN */
}, mse = {
  type: 1
  /* BAD_STRING_TOKEN */
}, vse = {
  type: 25
  /* CDO_TOKEN */
}, yse = {
  type: 24
  /* CDC_TOKEN */
}, _se = {
  type: 26
  /* COLON_TOKEN */
}, wse = {
  type: 27
  /* SEMICOLON_TOKEN */
}, xse = {
  type: 28
  /* LEFT_SQUARE_BRACKET_TOKEN */
}, Cse = {
  type: 29
  /* RIGHT_SQUARE_BRACKET_TOKEN */
}, Ese = {
  type: 31
  /* WHITESPACE_TOKEN */
}, aC = {
  type: 32
  /* EOF_TOKEN */
}, CP = (
  /** @class */
  function() {
    function i() {
      this._value = [];
    }
    return i.prototype.write = function(e) {
      this._value = this._value.concat(uy(e));
    }, i.prototype.read = function() {
      for (var e = [], t = this.consumeToken(); t !== aC; )
        e.push(t), t = this.consumeToken();
      return e;
    }, i.prototype.consumeToken = function() {
      var e = this.consumeCodePoint();
      switch (e) {
        case h0:
          return this.consumeStringToken(h0);
        case Ene:
          var t = this.peekCodePoint(0), r = this.peekCodePoint(1), n = this.peekCodePoint(2);
          if (dF(t) || GA(r, n)) {
            var s = g0(t, r, n) ? wne : _ne, a = this.consumeName();
            return { type: 5, value: a, flags: s };
          }
          break;
        case Bne:
          if (this.peekCodePoint(0) === Qf)
            return this.consumeCodePoint(), lse;
          break;
        case c0:
          return this.consumeStringToken(c0);
        case u0:
          return ase;
        case Df:
          return ose;
        case B_:
          if (this.peekCodePoint(0) === Qf)
            return this.consumeCodePoint(), pse;
          break;
        case Yl:
          if (b_(e, this.peekCodePoint(0), this.peekCodePoint(1)))
            return this.reconsumeCodePoint(e), this.consumeNumericToken();
          break;
        case Dne:
          return Ase;
        case fs:
          var o = e, A = this.peekCodePoint(0), l = this.peekCodePoint(1);
          if (b_(o, A, l))
            return this.reconsumeCodePoint(e), this.consumeNumericToken();
          if (g0(o, A, l))
            return this.reconsumeCodePoint(e), this.consumeIdentLikeToken();
          if (A === fs && l === Lne)
            return this.consumeCodePoint(), this.consumeCodePoint(), yse;
          break;
        case eg:
          if (b_(e, this.peekCodePoint(0), this.peekCodePoint(1)))
            return this.reconsumeCodePoint(e), this.consumeNumericToken();
          break;
        case cF:
          if (this.peekCodePoint(0) === B_)
            for (this.consumeCodePoint(); ; ) {
              var h = this.consumeCodePoint();
              if (h === B_ && (h = this.consumeCodePoint(), h === cF))
                return this.consumeToken();
              if (h === Pa)
                return this.consumeToken();
            }
          break;
        case kne:
          return _se;
        case Hne:
          return wse;
        case Fne:
          if (this.peekCodePoint(0) === Tne && this.peekCodePoint(1) === fs && this.peekCodePoint(2) === fs)
            return this.consumeCodePoint(), this.consumeCodePoint(), vse;
          break;
        case Ine:
          var c = this.peekCodePoint(0), u = this.peekCodePoint(1), f = this.peekCodePoint(2);
          if (g0(c, u, f)) {
            var a = this.consumeName();
            return { type: 7, value: a };
          }
          break;
        case Rne:
          return xse;
        case yd:
          if (GA(e, this.peekCodePoint(0)))
            return this.reconsumeCodePoint(e), this.consumeIdentLikeToken();
          break;
        case Mne:
          return Cse;
        case Nne:
          if (this.peekCodePoint(0) === Qf)
            return this.consumeCodePoint(), hse;
          break;
        case Pne:
          return dse;
        case One:
          return gse;
        case Wne:
        case qne:
          var g = this.peekCodePoint(0), p = this.peekCodePoint(1);
          return g === Yl && (dc(p) || p === f0) && (this.consumeCodePoint(), this.consumeUnicodeRangeToken()), this.reconsumeCodePoint(e), this.consumeIdentLikeToken();
        case uF:
          if (this.peekCodePoint(0) === Qf)
            return this.consumeCodePoint(), use;
          if (this.peekCodePoint(0) === uF)
            return this.consumeCodePoint(), cse;
          break;
        case Une:
          if (this.peekCodePoint(0) === Qf)
            return this.consumeCodePoint(), fse;
          break;
        case Pa:
          return aC;
      }
      return d0(e) ? (this.consumeWhiteSpace(), Ese) : Vn(e) ? (this.reconsumeCodePoint(e), this.consumeNumericToken()) : cv(e) ? (this.reconsumeCodePoint(e), this.consumeIdentLikeToken()) : { type: 6, value: Oi(e) };
    }, i.prototype.consumeCodePoint = function() {
      var e = this._value.shift();
      return typeof e > "u" ? -1 : e;
    }, i.prototype.reconsumeCodePoint = function(e) {
      this._value.unshift(e);
    }, i.prototype.peekCodePoint = function(e) {
      return e >= this._value.length ? -1 : this._value[e];
    }, i.prototype.consumeUnicodeRangeToken = function() {
      for (var e = [], t = this.consumeCodePoint(); dc(t) && e.length < 6; )
        e.push(t), t = this.consumeCodePoint();
      for (var r = !1; t === f0 && e.length < 6; )
        e.push(t), t = this.consumeCodePoint(), r = !0;
      if (r) {
        var n = parseInt(Oi.apply(void 0, e.map(function(A) {
          return A === f0 ? mP : A;
        })), 16), s = parseInt(Oi.apply(void 0, e.map(function(A) {
          return A === f0 ? xP : A;
        })), 16);
        return { type: 30, start: n, end: s };
      }
      var a = parseInt(Oi.apply(void 0, e), 16);
      if (this.peekCodePoint(0) === fs && dc(this.peekCodePoint(1))) {
        this.consumeCodePoint(), t = this.consumeCodePoint();
        for (var o = []; dc(t) && o.length < 6; )
          o.push(t), t = this.consumeCodePoint();
        var s = parseInt(Oi.apply(void 0, o), 16);
        return { type: 30, start: a, end: s };
      } else
        return { type: 30, start: a, end: a };
    }, i.prototype.consumeIdentLikeToken = function() {
      var e = this.consumeName();
      return e.toLowerCase() === "url" && this.peekCodePoint(0) === u0 ? (this.consumeCodePoint(), this.consumeUrlToken()) : this.peekCodePoint(0) === u0 ? (this.consumeCodePoint(), { type: 19, value: e }) : { type: 20, value: e };
    }, i.prototype.consumeUrlToken = function() {
      var e = [];
      if (this.consumeWhiteSpace(), this.peekCodePoint(0) === Pa)
        return { type: 22, value: "" };
      var t = this.peekCodePoint(0);
      if (t === c0 || t === h0) {
        var r = this.consumeStringToken(this.consumeCodePoint());
        return r.type === 0 && (this.consumeWhiteSpace(), this.peekCodePoint(0) === Pa || this.peekCodePoint(0) === Df) ? (this.consumeCodePoint(), { type: 22, value: r.value }) : (this.consumeBadUrlRemnants(), p0);
      }
      for (; ; ) {
        var n = this.consumeCodePoint();
        if (n === Pa || n === Df)
          return { type: 22, value: Oi.apply(void 0, e) };
        if (d0(n))
          return this.consumeWhiteSpace(), this.peekCodePoint(0) === Pa || this.peekCodePoint(0) === Df ? (this.consumeCodePoint(), { type: 22, value: Oi.apply(void 0, e) }) : (this.consumeBadUrlRemnants(), p0);
        if (n === h0 || n === c0 || n === u0 || nse(n))
          return this.consumeBadUrlRemnants(), p0;
        if (n === yd)
          if (GA(n, this.peekCodePoint(0)))
            e.push(this.consumeEscapedCodePoint());
          else
            return this.consumeBadUrlRemnants(), p0;
        else
          e.push(n);
      }
    }, i.prototype.consumeWhiteSpace = function() {
      for (; d0(this.peekCodePoint(0)); )
        this.consumeCodePoint();
    }, i.prototype.consumeBadUrlRemnants = function() {
      for (; ; ) {
        var e = this.consumeCodePoint();
        if (e === Df || e === Pa)
          return;
        GA(e, this.peekCodePoint(0)) && this.consumeEscapedCodePoint();
      }
    }, i.prototype.consumeStringSlice = function(e) {
      for (var t = 5e4, r = ""; e > 0; ) {
        var n = Math.min(t, e);
        r += Oi.apply(void 0, this._value.splice(0, n)), e -= n;
      }
      return this._value.shift(), r;
    }, i.prototype.consumeStringToken = function(e) {
      var t = "", r = 0;
      do {
        var n = this._value[r];
        if (n === Pa || n === void 0 || n === e)
          return t += this.consumeStringSlice(r), { type: 0, value: t };
        if (n === hv)
          return this._value.splice(0, r), mse;
        if (n === yd) {
          var s = this._value[r + 1];
          s !== Pa && s !== void 0 && (s === hv ? (t += this.consumeStringSlice(r), r = -1, this._value.shift()) : GA(n, s) && (t += this.consumeStringSlice(r), t += Oi(this.consumeEscapedCodePoint()), r = -1));
        }
        r++;
      } while (!0);
    }, i.prototype.consumeNumber = function() {
      var e = [], t = Fg, r = this.peekCodePoint(0);
      for ((r === Yl || r === fs) && e.push(this.consumeCodePoint()); Vn(this.peekCodePoint(0)); )
        e.push(this.consumeCodePoint());
      r = this.peekCodePoint(0);
      var n = this.peekCodePoint(1);
      if (r === eg && Vn(n))
        for (e.push(this.consumeCodePoint(), this.consumeCodePoint()), t = hF; Vn(this.peekCodePoint(0)); )
          e.push(this.consumeCodePoint());
      r = this.peekCodePoint(0), n = this.peekCodePoint(1);
      var s = this.peekCodePoint(2);
      if ((r === wP || r === yP) && ((n === Yl || n === fs) && Vn(s) || Vn(n)))
        for (e.push(this.consumeCodePoint(), this.consumeCodePoint()), t = hF; Vn(this.peekCodePoint(0)); )
          e.push(this.consumeCodePoint());
      return [sse(e), t];
    }, i.prototype.consumeNumericToken = function() {
      var e = this.consumeNumber(), t = e[0], r = e[1], n = this.peekCodePoint(0), s = this.peekCodePoint(1), a = this.peekCodePoint(2);
      if (g0(n, s, a)) {
        var o = this.consumeName();
        return { type: 15, number: t, flags: r, unit: o };
      }
      return n === bne ? (this.consumeCodePoint(), { type: 16, number: t, flags: r }) : { type: 17, number: t, flags: r };
    }, i.prototype.consumeEscapedCodePoint = function() {
      var e = this.consumeCodePoint();
      if (dc(e)) {
        for (var t = Oi(e); dc(this.peekCodePoint(0)) && t.length < 6; )
          t += Oi(this.consumeCodePoint());
        d0(this.peekCodePoint(0)) && this.consumeCodePoint();
        var r = parseInt(t, 16);
        return r === 0 || Jne(r) || r > 1114111 ? fF : r;
      }
      return e === Pa ? fF : e;
    }, i.prototype.consumeName = function() {
      for (var e = ""; ; ) {
        var t = this.consumeCodePoint();
        if (dF(t))
          e += Oi(t);
        else if (GA(t, this.peekCodePoint(0)))
          e += Oi(this.consumeEscapedCodePoint());
        else
          return this.reconsumeCodePoint(t), e;
      }
    }, i;
  }()
), EP = (
  /** @class */
  function() {
    function i(e) {
      this._tokens = e;
    }
    return i.create = function(e) {
      var t = new CP();
      return t.write(e), new i(t.read());
    }, i.parseValue = function(e) {
      return i.create(e).parseComponentValue();
    }, i.parseValues = function(e) {
      return i.create(e).parseComponentValues();
    }, i.prototype.parseComponentValue = function() {
      for (var e = this.consumeToken(); e.type === 31; )
        e = this.consumeToken();
      if (e.type === 32)
        throw new SyntaxError("Error parsing CSS component value, unexpected EOF");
      this.reconsumeToken(e);
      var t = this.consumeComponentValue();
      do
        e = this.consumeToken();
      while (e.type === 31);
      if (e.type === 32)
        return t;
      throw new SyntaxError("Error parsing CSS component value, multiple values found when expecting only one");
    }, i.prototype.parseComponentValues = function() {
      for (var e = []; ; ) {
        var t = this.consumeComponentValue();
        if (t.type === 32)
          return e;
        e.push(t), e.push();
      }
    }, i.prototype.consumeComponentValue = function() {
      var e = this.consumeToken();
      switch (e.type) {
        case 11:
        case 28:
        case 2:
          return this.consumeSimpleBlock(e.type);
        case 19:
          return this.consumeFunction(e);
      }
      return e;
    }, i.prototype.consumeSimpleBlock = function(e) {
      for (var t = { type: e, values: [] }, r = this.consumeToken(); ; ) {
        if (r.type === 32 || bse(r, e))
          return t;
        this.reconsumeToken(r), t.values.push(this.consumeComponentValue()), r = this.consumeToken();
      }
    }, i.prototype.consumeFunction = function(e) {
      for (var t = {
        name: e.value,
        values: [],
        type: 18
        /* FUNCTION */
      }; ; ) {
        var r = this.consumeToken();
        if (r.type === 32 || r.type === 3)
          return t;
        this.reconsumeToken(r), t.values.push(this.consumeComponentValue());
      }
    }, i.prototype.consumeToken = function() {
      var e = this._tokens.shift();
      return typeof e > "u" ? aC : e;
    }, i.prototype.reconsumeToken = function(e) {
      this._tokens.unshift(e);
    }, i;
  }()
), Lg = function(i) {
  return i.type === 15;
}, Hu = function(i) {
  return i.type === 17;
}, Kr = function(i) {
  return i.type === 20;
}, Bse = function(i) {
  return i.type === 0;
}, oC = function(i, e) {
  return Kr(i) && i.value === e;
}, BP = function(i) {
  return i.type !== 31;
}, Cu = function(i) {
  return i.type !== 31 && i.type !== 4;
}, no = function(i) {
  var e = [], t = [];
  return i.forEach(function(r) {
    if (r.type === 4) {
      if (t.length === 0)
        throw new Error("Error parsing function args, zero tokens for arg");
      e.push(t), t = [];
      return;
    }
    r.type !== 31 && t.push(r);
  }), t.length && e.push(t), e;
}, bse = function(i, e) {
  return e === 11 && i.type === 12 || e === 28 && i.type === 29 ? !0 : e === 2 && i.type === 3;
}, ml = function(i) {
  return i.type === 17 || i.type === 15;
}, Wi = function(i) {
  return i.type === 16 || ml(i);
}, bP = function(i) {
  return i.length > 1 ? [i[0], i[1]] : [i[0]];
}, Ln = {
  type: 17,
  number: 0,
  flags: Fg
}, VB = {
  type: 16,
  number: 50,
  flags: Fg
}, ZA = {
  type: 16,
  number: 100,
  flags: Fg
}, nd = function(i, e, t) {
  var r = i[0], n = i[1];
  return [ti(r, e), ti(typeof n < "u" ? n : r, t)];
}, ti = function(i, e) {
  if (i.type === 16)
    return i.number / 100 * e;
  if (Lg(i))
    switch (i.unit) {
      case "rem":
      case "em":
        return 16 * i.number;
      case "px":
      default:
        return i.number;
    }
  return i.number;
}, SP = "deg", TP = "grad", FP = "rad", LP = "turn", fy = {
  name: "angle",
  parse: function(i, e) {
    if (e.type === 15)
      switch (e.unit) {
        case SP:
          return Math.PI * e.number / 180;
        case TP:
          return Math.PI / 200 * e.number;
        case FP:
          return e.number;
        case LP:
          return Math.PI * 2 * e.number;
      }
    throw new Error("Unsupported angle type");
  }
}, IP = function(i) {
  return i.type === 15 && (i.unit === SP || i.unit === TP || i.unit === FP || i.unit === LP);
}, RP = function(i) {
  var e = i.filter(Kr).map(function(t) {
    return t.value;
  }).join(" ");
  switch (e) {
    case "to bottom right":
    case "to right bottom":
    case "left top":
    case "top left":
      return [Ln, Ln];
    case "to top":
    case "bottom":
      return qs(0);
    case "to bottom left":
    case "to left bottom":
    case "right top":
    case "top right":
      return [Ln, ZA];
    case "to right":
    case "left":
      return qs(90);
    case "to top left":
    case "to left top":
    case "right bottom":
    case "bottom right":
      return [ZA, ZA];
    case "to bottom":
    case "top":
      return qs(180);
    case "to top right":
    case "to right top":
    case "left bottom":
    case "bottom left":
      return [ZA, Ln];
    case "to left":
    case "right":
      return qs(270);
  }
  return 0;
}, qs = function(i) {
  return Math.PI * i / 180;
}, sl = {
  name: "color",
  parse: function(i, e) {
    if (e.type === 18) {
      var t = Sse[e.name];
      if (typeof t > "u")
        throw new Error('Attempting to parse an unsupported color function "' + e.name + '"');
      return t(i, e.values);
    }
    if (e.type === 5) {
      if (e.value.length === 3) {
        var r = e.value.substring(0, 1), n = e.value.substring(1, 2), s = e.value.substring(2, 3);
        return JA(parseInt(r + r, 16), parseInt(n + n, 16), parseInt(s + s, 16), 1);
      }
      if (e.value.length === 4) {
        var r = e.value.substring(0, 1), n = e.value.substring(1, 2), s = e.value.substring(2, 3), a = e.value.substring(3, 4);
        return JA(parseInt(r + r, 16), parseInt(n + n, 16), parseInt(s + s, 16), parseInt(a + a, 16) / 255);
      }
      if (e.value.length === 6) {
        var r = e.value.substring(0, 2), n = e.value.substring(2, 4), s = e.value.substring(4, 6);
        return JA(parseInt(r, 16), parseInt(n, 16), parseInt(s, 16), 1);
      }
      if (e.value.length === 8) {
        var r = e.value.substring(0, 2), n = e.value.substring(2, 4), s = e.value.substring(4, 6), a = e.value.substring(6, 8);
        return JA(parseInt(r, 16), parseInt(n, 16), parseInt(s, 16), parseInt(a, 16) / 255);
      }
    }
    if (e.type === 20) {
      var o = Ko[e.value.toUpperCase()];
      if (typeof o < "u")
        return o;
    }
    return Ko.TRANSPARENT;
  }
}, al = function(i) {
  return (255 & i) === 0;
}, mn = function(i) {
  var e = 255 & i, t = 255 & i >> 8, r = 255 & i >> 16, n = 255 & i >> 24;
  return e < 255 ? "rgba(" + n + "," + r + "," + t + "," + e / 255 + ")" : "rgb(" + n + "," + r + "," + t + ")";
}, JA = function(i, e, t, r) {
  return (i << 24 | e << 16 | t << 8 | Math.round(r * 255) << 0) >>> 0;
}, gF = function(i, e) {
  if (i.type === 17)
    return i.number;
  if (i.type === 16) {
    var t = e === 3 ? 1 : 255;
    return e === 3 ? i.number / 100 * t : Math.round(i.number / 100 * t);
  }
  return 0;
}, pF = function(i, e) {
  var t = e.filter(Cu);
  if (t.length === 3) {
    var r = t.map(gF), n = r[0], s = r[1], a = r[2];
    return JA(n, s, a, 1);
  }
  if (t.length === 4) {
    var o = t.map(gF), n = o[0], s = o[1], a = o[2], A = o[3];
    return JA(n, s, a, A);
  }
  return 0;
};
function S_(i, e, t) {
  return t < 0 && (t += 1), t >= 1 && (t -= 1), t < 1 / 6 ? (e - i) * t * 6 + i : t < 1 / 2 ? e : t < 2 / 3 ? (e - i) * 6 * (2 / 3 - t) + i : i;
}
var mF = function(i, e) {
  var t = e.filter(Cu), r = t[0], n = t[1], s = t[2], a = t[3], o = (r.type === 17 ? qs(r.number) : fy.parse(i, r)) / (Math.PI * 2), A = Wi(n) ? n.number / 100 : 0, l = Wi(s) ? s.number / 100 : 0, h = typeof a < "u" && Wi(a) ? ti(a, 1) : 1;
  if (A === 0)
    return JA(l * 255, l * 255, l * 255, 1);
  var c = l <= 0.5 ? l * (A + 1) : l + A - l * A, u = l * 2 - c, f = S_(u, c, o + 1 / 3), g = S_(u, c, o), p = S_(u, c, o - 1 / 3);
  return JA(f * 255, g * 255, p * 255, h);
}, Sse = {
  hsl: mF,
  hsla: mF,
  rgb: pF,
  rgba: pF
}, _d = function(i, e) {
  return sl.parse(i, EP.create(e).parseComponentValue());
}, Ko = {
  ALICEBLUE: 4042850303,
  ANTIQUEWHITE: 4209760255,
  AQUA: 16777215,
  AQUAMARINE: 2147472639,
  AZURE: 4043309055,
  BEIGE: 4126530815,
  BISQUE: 4293182719,
  BLACK: 255,
  BLANCHEDALMOND: 4293643775,
  BLUE: 65535,
  BLUEVIOLET: 2318131967,
  BROWN: 2771004159,
  BURLYWOOD: 3736635391,
  CADETBLUE: 1604231423,
  CHARTREUSE: 2147418367,
  CHOCOLATE: 3530104575,
  CORAL: 4286533887,
  CORNFLOWERBLUE: 1687547391,
  CORNSILK: 4294499583,
  CRIMSON: 3692313855,
  CYAN: 16777215,
  DARKBLUE: 35839,
  DARKCYAN: 9145343,
  DARKGOLDENROD: 3095837695,
  DARKGRAY: 2846468607,
  DARKGREEN: 6553855,
  DARKGREY: 2846468607,
  DARKKHAKI: 3182914559,
  DARKMAGENTA: 2332068863,
  DARKOLIVEGREEN: 1433087999,
  DARKORANGE: 4287365375,
  DARKORCHID: 2570243327,
  DARKRED: 2332033279,
  DARKSALMON: 3918953215,
  DARKSEAGREEN: 2411499519,
  DARKSLATEBLUE: 1211993087,
  DARKSLATEGRAY: 793726975,
  DARKSLATEGREY: 793726975,
  DARKTURQUOISE: 13554175,
  DARKVIOLET: 2483082239,
  DEEPPINK: 4279538687,
  DEEPSKYBLUE: 12582911,
  DIMGRAY: 1768516095,
  DIMGREY: 1768516095,
  DODGERBLUE: 512819199,
  FIREBRICK: 2988581631,
  FLORALWHITE: 4294635775,
  FORESTGREEN: 579543807,
  FUCHSIA: 4278255615,
  GAINSBORO: 3705462015,
  GHOSTWHITE: 4177068031,
  GOLD: 4292280575,
  GOLDENROD: 3668254975,
  GRAY: 2155905279,
  GREEN: 8388863,
  GREENYELLOW: 2919182335,
  GREY: 2155905279,
  HONEYDEW: 4043305215,
  HOTPINK: 4285117695,
  INDIANRED: 3445382399,
  INDIGO: 1258324735,
  IVORY: 4294963455,
  KHAKI: 4041641215,
  LAVENDER: 3873897215,
  LAVENDERBLUSH: 4293981695,
  LAWNGREEN: 2096890111,
  LEMONCHIFFON: 4294626815,
  LIGHTBLUE: 2916673279,
  LIGHTCORAL: 4034953471,
  LIGHTCYAN: 3774873599,
  LIGHTGOLDENRODYELLOW: 4210742015,
  LIGHTGRAY: 3553874943,
  LIGHTGREEN: 2431553791,
  LIGHTGREY: 3553874943,
  LIGHTPINK: 4290167295,
  LIGHTSALMON: 4288707327,
  LIGHTSEAGREEN: 548580095,
  LIGHTSKYBLUE: 2278488831,
  LIGHTSLATEGRAY: 2005441023,
  LIGHTSLATEGREY: 2005441023,
  LIGHTSTEELBLUE: 2965692159,
  LIGHTYELLOW: 4294959359,
  LIME: 16711935,
  LIMEGREEN: 852308735,
  LINEN: 4210091775,
  MAGENTA: 4278255615,
  MAROON: 2147483903,
  MEDIUMAQUAMARINE: 1724754687,
  MEDIUMBLUE: 52735,
  MEDIUMORCHID: 3126187007,
  MEDIUMPURPLE: 2473647103,
  MEDIUMSEAGREEN: 1018393087,
  MEDIUMSLATEBLUE: 2070474495,
  MEDIUMSPRINGGREEN: 16423679,
  MEDIUMTURQUOISE: 1221709055,
  MEDIUMVIOLETRED: 3340076543,
  MIDNIGHTBLUE: 421097727,
  MINTCREAM: 4127193855,
  MISTYROSE: 4293190143,
  MOCCASIN: 4293178879,
  NAVAJOWHITE: 4292783615,
  NAVY: 33023,
  OLDLACE: 4260751103,
  OLIVE: 2155872511,
  OLIVEDRAB: 1804477439,
  ORANGE: 4289003775,
  ORANGERED: 4282712319,
  ORCHID: 3664828159,
  PALEGOLDENROD: 4008225535,
  PALEGREEN: 2566625535,
  PALETURQUOISE: 2951671551,
  PALEVIOLETRED: 3681588223,
  PAPAYAWHIP: 4293907967,
  PEACHPUFF: 4292524543,
  PERU: 3448061951,
  PINK: 4290825215,
  PLUM: 3718307327,
  POWDERBLUE: 2967529215,
  PURPLE: 2147516671,
  REBECCAPURPLE: 1714657791,
  RED: 4278190335,
  ROSYBROWN: 3163525119,
  ROYALBLUE: 1097458175,
  SADDLEBROWN: 2336560127,
  SALMON: 4202722047,
  SANDYBROWN: 4104413439,
  SEAGREEN: 780883967,
  SEASHELL: 4294307583,
  SIENNA: 2689740287,
  SILVER: 3233857791,
  SKYBLUE: 2278484991,
  SLATEBLUE: 1784335871,
  SLATEGRAY: 1887473919,
  SLATEGREY: 1887473919,
  SNOW: 4294638335,
  SPRINGGREEN: 16744447,
  STEELBLUE: 1182971135,
  TAN: 3535047935,
  TEAL: 8421631,
  THISTLE: 3636451583,
  TOMATO: 4284696575,
  TRANSPARENT: 0,
  TURQUOISE: 1088475391,
  VIOLET: 4001558271,
  WHEAT: 4125012991,
  WHITE: 4294967295,
  WHITESMOKE: 4126537215,
  YELLOW: 4294902015,
  YELLOWGREEN: 2597139199
}, Tse = {
  name: "background-clip",
  initialValue: "border-box",
  prefix: !1,
  type: 1,
  parse: function(i, e) {
    return e.map(function(t) {
      if (Kr(t))
        switch (t.value) {
          case "padding-box":
            return 1;
          case "content-box":
            return 2;
        }
      return 0;
    });
  }
}, Fse = {
  name: "background-color",
  initialValue: "transparent",
  prefix: !1,
  type: 3,
  format: "color"
}, dy = function(i, e) {
  var t = sl.parse(i, e[0]), r = e[1];
  return r && Wi(r) ? { color: t, stop: r } : { color: t, stop: null };
}, vF = function(i, e) {
  var t = i[0], r = i[i.length - 1];
  t.stop === null && (t.stop = Ln), r.stop === null && (r.stop = ZA);
  for (var n = [], s = 0, a = 0; a < i.length; a++) {
    var o = i[a].stop;
    if (o !== null) {
      var A = ti(o, e);
      A > s ? n.push(A) : n.push(s), s = A;
    } else
      n.push(null);
  }
  for (var l = null, a = 0; a < n.length; a++) {
    var h = n[a];
    if (h === null)
      l === null && (l = a);
    else if (l !== null) {
      for (var c = a - l, u = n[l - 1], f = (h - u) / (c + 1), g = 1; g <= c; g++)
        n[l + g - 1] = f * g;
      l = null;
    }
  }
  return i.map(function(p, y) {
    var v = p.color;
    return { color: v, stop: Math.max(Math.min(1, n[y] / e), 0) };
  });
}, Lse = function(i, e, t) {
  var r = e / 2, n = t / 2, s = ti(i[0], e) - r, a = n - ti(i[1], t);
  return (Math.atan2(a, s) + Math.PI * 2) % (Math.PI * 2);
}, Ise = function(i, e, t) {
  var r = typeof i == "number" ? i : Lse(i, e, t), n = Math.abs(e * Math.sin(r)) + Math.abs(t * Math.cos(r)), s = e / 2, a = t / 2, o = n / 2, A = Math.sin(r - Math.PI / 2) * o, l = Math.cos(r - Math.PI / 2) * o;
  return [n, s - l, s + l, a - A, a + A];
}, ma = function(i, e) {
  return Math.sqrt(i * i + e * e);
}, yF = function(i, e, t, r, n) {
  var s = [
    [0, 0],
    [0, e],
    [i, 0],
    [i, e]
  ];
  return s.reduce(function(a, o) {
    var A = o[0], l = o[1], h = ma(t - A, r - l);
    return (n ? h < a.optimumDistance : h > a.optimumDistance) ? {
      optimumCorner: o,
      optimumDistance: h
    } : a;
  }, {
    optimumDistance: n ? 1 / 0 : -1 / 0,
    optimumCorner: null
  }).optimumCorner;
}, Rse = function(i, e, t, r, n) {
  var s = 0, a = 0;
  switch (i.size) {
    case 0:
      i.shape === 0 ? s = a = Math.min(Math.abs(e), Math.abs(e - r), Math.abs(t), Math.abs(t - n)) : i.shape === 1 && (s = Math.min(Math.abs(e), Math.abs(e - r)), a = Math.min(Math.abs(t), Math.abs(t - n)));
      break;
    case 2:
      if (i.shape === 0)
        s = a = Math.min(ma(e, t), ma(e, t - n), ma(e - r, t), ma(e - r, t - n));
      else if (i.shape === 1) {
        var o = Math.min(Math.abs(t), Math.abs(t - n)) / Math.min(Math.abs(e), Math.abs(e - r)), A = yF(r, n, e, t, !0), l = A[0], h = A[1];
        s = ma(l - e, (h - t) / o), a = o * s;
      }
      break;
    case 1:
      i.shape === 0 ? s = a = Math.max(Math.abs(e), Math.abs(e - r), Math.abs(t), Math.abs(t - n)) : i.shape === 1 && (s = Math.max(Math.abs(e), Math.abs(e - r)), a = Math.max(Math.abs(t), Math.abs(t - n)));
      break;
    case 3:
      if (i.shape === 0)
        s = a = Math.max(ma(e, t), ma(e, t - n), ma(e - r, t), ma(e - r, t - n));
      else if (i.shape === 1) {
        var o = Math.max(Math.abs(t), Math.abs(t - n)) / Math.max(Math.abs(e), Math.abs(e - r)), c = yF(r, n, e, t, !1), l = c[0], h = c[1];
        s = ma(l - e, (h - t) / o), a = o * s;
      }
      break;
  }
  return Array.isArray(i.size) && (s = ti(i.size[0], r), a = i.size.length === 2 ? ti(i.size[1], n) : s), [s, a];
}, Mse = function(i, e) {
  var t = qs(180), r = [];
  return no(e).forEach(function(n, s) {
    if (s === 0) {
      var a = n[0];
      if (a.type === 20 && a.value === "to") {
        t = RP(n);
        return;
      } else if (IP(a)) {
        t = fy.parse(i, a);
        return;
      }
    }
    var o = dy(i, n);
    r.push(o);
  }), {
    angle: t,
    stops: r,
    type: 1
    /* LINEAR_GRADIENT */
  };
}, m0 = function(i, e) {
  var t = qs(180), r = [];
  return no(e).forEach(function(n, s) {
    if (s === 0) {
      var a = n[0];
      if (a.type === 20 && ["top", "left", "right", "bottom"].indexOf(a.value) !== -1) {
        t = RP(n);
        return;
      } else if (IP(a)) {
        t = (fy.parse(i, a) + qs(270)) % qs(360);
        return;
      }
    }
    var o = dy(i, n);
    r.push(o);
  }), {
    angle: t,
    stops: r,
    type: 1
    /* LINEAR_GRADIENT */
  };
}, Nse = function(i, e) {
  var t = qs(180), r = [], n = 1, s = 0, a = 3, o = [];
  return no(e).forEach(function(A, l) {
    var h = A[0];
    if (l === 0) {
      if (Kr(h) && h.value === "linear") {
        n = 1;
        return;
      } else if (Kr(h) && h.value === "radial") {
        n = 2;
        return;
      }
    }
    if (h.type === 18) {
      if (h.name === "from") {
        var c = sl.parse(i, h.values[0]);
        r.push({ stop: Ln, color: c });
      } else if (h.name === "to") {
        var c = sl.parse(i, h.values[0]);
        r.push({ stop: ZA, color: c });
      } else if (h.name === "color-stop") {
        var u = h.values.filter(Cu);
        if (u.length === 2) {
          var c = sl.parse(i, u[1]), f = u[0];
          Hu(f) && r.push({
            stop: { type: 16, number: f.number * 100, flags: f.flags },
            color: c
          });
        }
      }
    }
  }), n === 1 ? {
    angle: (t + qs(180)) % qs(360),
    stops: r,
    type: n
  } : { size: a, shape: s, stops: r, position: o, type: n };
}, MP = "closest-side", NP = "farthest-side", PP = "closest-corner", OP = "farthest-corner", UP = "circle", QP = "ellipse", DP = "cover", kP = "contain", Pse = function(i, e) {
  var t = 0, r = 3, n = [], s = [];
  return no(e).forEach(function(a, o) {
    var A = !0;
    if (o === 0) {
      var l = !1;
      A = a.reduce(function(c, u) {
        if (l)
          if (Kr(u))
            switch (u.value) {
              case "center":
                return s.push(VB), c;
              case "top":
              case "left":
                return s.push(Ln), c;
              case "right":
              case "bottom":
                return s.push(ZA), c;
            }
          else
            (Wi(u) || ml(u)) && s.push(u);
        else if (Kr(u))
          switch (u.value) {
            case UP:
              return t = 0, !1;
            case QP:
              return t = 1, !1;
            case "at":
              return l = !0, !1;
            case MP:
              return r = 0, !1;
            case DP:
            case NP:
              return r = 1, !1;
            case kP:
            case PP:
              return r = 2, !1;
            case OP:
              return r = 3, !1;
          }
        else if (ml(u) || Wi(u))
          return Array.isArray(r) || (r = []), r.push(u), !1;
        return c;
      }, A);
    }
    if (A) {
      var h = dy(i, a);
      n.push(h);
    }
  }), {
    size: r,
    shape: t,
    stops: n,
    position: s,
    type: 2
    /* RADIAL_GRADIENT */
  };
}, v0 = function(i, e) {
  var t = 0, r = 3, n = [], s = [];
  return no(e).forEach(function(a, o) {
    var A = !0;
    if (o === 0 ? A = a.reduce(function(h, c) {
      if (Kr(c))
        switch (c.value) {
          case "center":
            return s.push(VB), !1;
          case "top":
          case "left":
            return s.push(Ln), !1;
          case "right":
          case "bottom":
            return s.push(ZA), !1;
        }
      else if (Wi(c) || ml(c))
        return s.push(c), !1;
      return h;
    }, A) : o === 1 && (A = a.reduce(function(h, c) {
      if (Kr(c))
        switch (c.value) {
          case UP:
            return t = 0, !1;
          case QP:
            return t = 1, !1;
          case kP:
          case MP:
            return r = 0, !1;
          case NP:
            return r = 1, !1;
          case PP:
            return r = 2, !1;
          case DP:
          case OP:
            return r = 3, !1;
        }
      else if (ml(c) || Wi(c))
        return Array.isArray(r) || (r = []), r.push(c), !1;
      return h;
    }, A)), A) {
      var l = dy(i, a);
      n.push(l);
    }
  }), {
    size: r,
    shape: t,
    stops: n,
    position: s,
    type: 2
    /* RADIAL_GRADIENT */
  };
}, Ose = function(i) {
  return i.type === 1;
}, Use = function(i) {
  return i.type === 2;
}, KB = {
  name: "image",
  parse: function(i, e) {
    if (e.type === 22) {
      var t = {
        url: e.value,
        type: 0
        /* URL */
      };
      return i.cache.addImage(e.value), t;
    }
    if (e.type === 18) {
      var r = HP[e.name];
      if (typeof r > "u")
        throw new Error('Attempting to parse an unsupported image function "' + e.name + '"');
      return r(i, e.values);
    }
    throw new Error("Unsupported image type " + e.type);
  }
};
function Qse(i) {
  return !(i.type === 20 && i.value === "none") && (i.type !== 18 || !!HP[i.name]);
}
var HP = {
  "linear-gradient": Mse,
  "-moz-linear-gradient": m0,
  "-ms-linear-gradient": m0,
  "-o-linear-gradient": m0,
  "-webkit-linear-gradient": m0,
  "radial-gradient": Pse,
  "-moz-radial-gradient": v0,
  "-ms-radial-gradient": v0,
  "-o-radial-gradient": v0,
  "-webkit-radial-gradient": v0,
  "-webkit-gradient": Nse
}, Dse = {
  name: "background-image",
  initialValue: "none",
  type: 1,
  prefix: !1,
  parse: function(i, e) {
    if (e.length === 0)
      return [];
    var t = e[0];
    return t.type === 20 && t.value === "none" ? [] : e.filter(function(r) {
      return Cu(r) && Qse(r);
    }).map(function(r) {
      return KB.parse(i, r);
    });
  }
}, kse = {
  name: "background-origin",
  initialValue: "border-box",
  prefix: !1,
  type: 1,
  parse: function(i, e) {
    return e.map(function(t) {
      if (Kr(t))
        switch (t.value) {
          case "padding-box":
            return 1;
          case "content-box":
            return 2;
        }
      return 0;
    });
  }
}, Hse = {
  name: "background-position",
  initialValue: "0% 0%",
  type: 1,
  prefix: !1,
  parse: function(i, e) {
    return no(e).map(function(t) {
      return t.filter(Wi);
    }).map(bP);
  }
}, Gse = {
  name: "background-repeat",
  initialValue: "repeat",
  prefix: !1,
  type: 1,
  parse: function(i, e) {
    return no(e).map(function(t) {
      return t.filter(Kr).map(function(r) {
        return r.value;
      }).join(" ");
    }).map($se);
  }
}, $se = function(i) {
  switch (i) {
    case "no-repeat":
      return 1;
    case "repeat-x":
    case "repeat no-repeat":
      return 2;
    case "repeat-y":
    case "no-repeat repeat":
      return 3;
    case "repeat":
    default:
      return 0;
  }
}, ou;
(function(i) {
  i.AUTO = "auto", i.CONTAIN = "contain", i.COVER = "cover";
})(ou || (ou = {}));
var Vse = {
  name: "background-size",
  initialValue: "0",
  prefix: !1,
  type: 1,
  parse: function(i, e) {
    return no(e).map(function(t) {
      return t.filter(Kse);
    });
  }
}, Kse = function(i) {
  return Kr(i) || Wi(i);
}, gy = function(i) {
  return {
    name: "border-" + i + "-color",
    initialValue: "transparent",
    prefix: !1,
    type: 3,
    format: "color"
  };
}, jse = gy("top"), zse = gy("right"), Xse = gy("bottom"), Wse = gy("left"), py = function(i) {
  return {
    name: "border-radius-" + i,
    initialValue: "0 0",
    prefix: !1,
    type: 1,
    parse: function(e, t) {
      return bP(t.filter(Wi));
    }
  };
}, Yse = py("top-left"), qse = py("top-right"), Zse = py("bottom-right"), Jse = py("bottom-left"), my = function(i) {
  return {
    name: "border-" + i + "-style",
    initialValue: "solid",
    prefix: !1,
    type: 2,
    parse: function(e, t) {
      switch (t) {
        case "none":
          return 0;
        case "dashed":
          return 2;
        case "dotted":
          return 3;
        case "double":
          return 4;
      }
      return 1;
    }
  };
}, eae = my("top"), tae = my("right"), rae = my("bottom"), iae = my("left"), vy = function(i) {
  return {
    name: "border-" + i + "-width",
    initialValue: "0",
    type: 0,
    prefix: !1,
    parse: function(e, t) {
      return Lg(t) ? t.number : 0;
    }
  };
}, nae = vy("top"), sae = vy("right"), aae = vy("bottom"), oae = vy("left"), Aae = {
  name: "color",
  initialValue: "transparent",
  prefix: !1,
  type: 3,
  format: "color"
}, lae = {
  name: "direction",
  initialValue: "ltr",
  prefix: !1,
  type: 2,
  parse: function(i, e) {
    switch (e) {
      case "rtl":
        return 1;
      case "ltr":
      default:
        return 0;
    }
  }
}, hae = {
  name: "display",
  initialValue: "inline-block",
  prefix: !1,
  type: 1,
  parse: function(i, e) {
    return e.filter(Kr).reduce(
      function(t, r) {
        return t | cae(r.value);
      },
      0
      /* NONE */
    );
  }
}, cae = function(i) {
  switch (i) {
    case "block":
    case "-webkit-box":
      return 2;
    case "inline":
      return 4;
    case "run-in":
      return 8;
    case "flow":
      return 16;
    case "flow-root":
      return 32;
    case "table":
      return 64;
    case "flex":
    case "-webkit-flex":
      return 128;
    case "grid":
    case "-ms-grid":
      return 256;
    case "ruby":
      return 512;
    case "subgrid":
      return 1024;
    case "list-item":
      return 2048;
    case "table-row-group":
      return 4096;
    case "table-header-group":
      return 8192;
    case "table-footer-group":
      return 16384;
    case "table-row":
      return 32768;
    case "table-cell":
      return 65536;
    case "table-column-group":
      return 131072;
    case "table-column":
      return 262144;
    case "table-caption":
      return 524288;
    case "ruby-base":
      return 1048576;
    case "ruby-text":
      return 2097152;
    case "ruby-base-container":
      return 4194304;
    case "ruby-text-container":
      return 8388608;
    case "contents":
      return 16777216;
    case "inline-block":
      return 33554432;
    case "inline-list-item":
      return 67108864;
    case "inline-table":
      return 134217728;
    case "inline-flex":
      return 268435456;
    case "inline-grid":
      return 536870912;
  }
  return 0;
}, uae = {
  name: "float",
  initialValue: "none",
  prefix: !1,
  type: 2,
  parse: function(i, e) {
    switch (e) {
      case "left":
        return 1;
      case "right":
        return 2;
      case "inline-start":
        return 3;
      case "inline-end":
        return 4;
    }
    return 0;
  }
}, fae = {
  name: "letter-spacing",
  initialValue: "0",
  prefix: !1,
  type: 0,
  parse: function(i, e) {
    return e.type === 20 && e.value === "normal" ? 0 : e.type === 17 || e.type === 15 ? e.number : 0;
  }
}, uv;
(function(i) {
  i.NORMAL = "normal", i.STRICT = "strict";
})(uv || (uv = {}));
var dae = {
  name: "line-break",
  initialValue: "normal",
  prefix: !1,
  type: 2,
  parse: function(i, e) {
    switch (e) {
      case "strict":
        return uv.STRICT;
      case "normal":
      default:
        return uv.NORMAL;
    }
  }
}, gae = {
  name: "line-height",
  initialValue: "normal",
  prefix: !1,
  type: 4
  /* TOKEN_VALUE */
}, _F = function(i, e) {
  return Kr(i) && i.value === "normal" ? 1.2 * e : i.type === 17 ? e * i.number : Wi(i) ? ti(i, e) : e;
}, pae = {
  name: "list-style-image",
  initialValue: "none",
  type: 0,
  prefix: !1,
  parse: function(i, e) {
    return e.type === 20 && e.value === "none" ? null : KB.parse(i, e);
  }
}, mae = {
  name: "list-style-position",
  initialValue: "outside",
  prefix: !1,
  type: 2,
  parse: function(i, e) {
    switch (e) {
      case "inside":
        return 0;
      case "outside":
      default:
        return 1;
    }
  }
}, AC = {
  name: "list-style-type",
  initialValue: "none",
  prefix: !1,
  type: 2,
  parse: function(i, e) {
    switch (e) {
      case "disc":
        return 0;
      case "circle":
        return 1;
      case "square":
        return 2;
      case "decimal":
        return 3;
      case "cjk-decimal":
        return 4;
      case "decimal-leading-zero":
        return 5;
      case "lower-roman":
        return 6;
      case "upper-roman":
        return 7;
      case "lower-greek":
        return 8;
      case "lower-alpha":
        return 9;
      case "upper-alpha":
        return 10;
      case "arabic-indic":
        return 11;
      case "armenian":
        return 12;
      case "bengali":
        return 13;
      case "cambodian":
        return 14;
      case "cjk-earthly-branch":
        return 15;
      case "cjk-heavenly-stem":
        return 16;
      case "cjk-ideographic":
        return 17;
      case "devanagari":
        return 18;
      case "ethiopic-numeric":
        return 19;
      case "georgian":
        return 20;
      case "gujarati":
        return 21;
      case "gurmukhi":
        return 22;
      case "hebrew":
        return 22;
      case "hiragana":
        return 23;
      case "hiragana-iroha":
        return 24;
      case "japanese-formal":
        return 25;
      case "japanese-informal":
        return 26;
      case "kannada":
        return 27;
      case "katakana":
        return 28;
      case "katakana-iroha":
        return 29;
      case "khmer":
        return 30;
      case "korean-hangul-formal":
        return 31;
      case "korean-hanja-formal":
        return 32;
      case "korean-hanja-informal":
        return 33;
      case "lao":
        return 34;
      case "lower-armenian":
        return 35;
      case "malayalam":
        return 36;
      case "mongolian":
        return 37;
      case "myanmar":
        return 38;
      case "oriya":
        return 39;
      case "persian":
        return 40;
      case "simp-chinese-formal":
        return 41;
      case "simp-chinese-informal":
        return 42;
      case "tamil":
        return 43;
      case "telugu":
        return 44;
      case "thai":
        return 45;
      case "tibetan":
        return 46;
      case "trad-chinese-formal":
        return 47;
      case "trad-chinese-informal":
        return 48;
      case "upper-armenian":
        return 49;
      case "disclosure-open":
        return 50;
      case "disclosure-closed":
        return 51;
      case "none":
      default:
        return -1;
    }
  }
}, yy = function(i) {
  return {
    name: "margin-" + i,
    initialValue: "0",
    prefix: !1,
    type: 4
    /* TOKEN_VALUE */
  };
}, vae = yy("top"), yae = yy("right"), _ae = yy("bottom"), wae = yy("left"), xae = {
  name: "overflow",
  initialValue: "visible",
  prefix: !1,
  type: 1,
  parse: function(i, e) {
    return e.filter(Kr).map(function(t) {
      switch (t.value) {
        case "hidden":
          return 1;
        case "scroll":
          return 2;
        case "clip":
          return 3;
        case "auto":
          return 4;
        case "visible":
        default:
          return 0;
      }
    });
  }
}, Cae = {
  name: "overflow-wrap",
  initialValue: "normal",
  prefix: !1,
  type: 2,
  parse: function(i, e) {
    switch (e) {
      case "break-word":
        return "break-word";
      case "normal":
      default:
        return "normal";
    }
  }
}, _y = function(i) {
  return {
    name: "padding-" + i,
    initialValue: "0",
    prefix: !1,
    type: 3,
    format: "length-percentage"
  };
}, Eae = _y("top"), Bae = _y("right"), bae = _y("bottom"), Sae = _y("left"), Tae = {
  name: "text-align",
  initialValue: "left",
  prefix: !1,
  type: 2,
  parse: function(i, e) {
    switch (e) {
      case "right":
        return 2;
      case "center":
      case "justify":
        return 1;
      case "left":
      default:
        return 0;
    }
  }
}, Fae = {
  name: "position",
  initialValue: "static",
  prefix: !1,
  type: 2,
  parse: function(i, e) {
    switch (e) {
      case "relative":
        return 1;
      case "absolute":
        return 2;
      case "fixed":
        return 3;
      case "sticky":
        return 4;
    }
    return 0;
  }
}, Lae = {
  name: "text-shadow",
  initialValue: "none",
  type: 1,
  prefix: !1,
  parse: function(i, e) {
    return e.length === 1 && oC(e[0], "none") ? [] : no(e).map(function(t) {
      for (var r = {
        color: Ko.TRANSPARENT,
        offsetX: Ln,
        offsetY: Ln,
        blur: Ln
      }, n = 0, s = 0; s < t.length; s++) {
        var a = t[s];
        ml(a) ? (n === 0 ? r.offsetX = a : n === 1 ? r.offsetY = a : r.blur = a, n++) : r.color = sl.parse(i, a);
      }
      return r;
    });
  }
}, Iae = {
  name: "text-transform",
  initialValue: "none",
  prefix: !1,
  type: 2,
  parse: function(i, e) {
    switch (e) {
      case "uppercase":
        return 2;
      case "lowercase":
        return 1;
      case "capitalize":
        return 3;
    }
    return 0;
  }
}, Rae = {
  name: "transform",
  initialValue: "none",
  prefix: !0,
  type: 0,
  parse: function(i, e) {
    if (e.type === 20 && e.value === "none")
      return null;
    if (e.type === 18) {
      var t = Pae[e.name];
      if (typeof t > "u")
        throw new Error('Attempting to parse an unsupported transform function "' + e.name + '"');
      return t(e.values);
    }
    return null;
  }
}, Mae = function(i) {
  var e = i.filter(function(t) {
    return t.type === 17;
  }).map(function(t) {
    return t.number;
  });
  return e.length === 6 ? e : null;
}, Nae = function(i) {
  var e = i.filter(function(A) {
    return A.type === 17;
  }).map(function(A) {
    return A.number;
  }), t = e[0], r = e[1];
  e[2], e[3];
  var n = e[4], s = e[5];
  e[6], e[7], e[8], e[9], e[10], e[11];
  var a = e[12], o = e[13];
  return e[14], e[15], e.length === 16 ? [t, r, n, s, a, o] : null;
}, Pae = {
  matrix: Mae,
  matrix3d: Nae
}, wF = {
  type: 16,
  number: 50,
  flags: Fg
}, Oae = [wF, wF], Uae = {
  name: "transform-origin",
  initialValue: "50% 50%",
  prefix: !0,
  type: 1,
  parse: function(i, e) {
    var t = e.filter(Wi);
    return t.length !== 2 ? Oae : [t[0], t[1]];
  }
}, Qae = {
  name: "visible",
  initialValue: "none",
  prefix: !1,
  type: 2,
  parse: function(i, e) {
    switch (e) {
      case "hidden":
        return 1;
      case "collapse":
        return 2;
      case "visible":
      default:
        return 0;
    }
  }
}, wd;
(function(i) {
  i.NORMAL = "normal", i.BREAK_ALL = "break-all", i.KEEP_ALL = "keep-all";
})(wd || (wd = {}));
var Dae = {
  name: "word-break",
  initialValue: "normal",
  prefix: !1,
  type: 2,
  parse: function(i, e) {
    switch (e) {
      case "break-all":
        return wd.BREAK_ALL;
      case "keep-all":
        return wd.KEEP_ALL;
      case "normal":
      default:
        return wd.NORMAL;
    }
  }
}, kae = {
  name: "z-index",
  initialValue: "auto",
  prefix: !1,
  type: 0,
  parse: function(i, e) {
    if (e.type === 20)
      return { auto: !0, order: 0 };
    if (Hu(e))
      return { auto: !1, order: e.number };
    throw new Error("Invalid z-index number parsed");
  }
}, GP = {
  name: "time",
  parse: function(i, e) {
    if (e.type === 15)
      switch (e.unit.toLowerCase()) {
        case "s":
          return 1e3 * e.number;
        case "ms":
          return e.number;
      }
    throw new Error("Unsupported time type");
  }
}, Hae = {
  name: "opacity",
  initialValue: "1",
  type: 0,
  prefix: !1,
  parse: function(i, e) {
    return Hu(e) ? e.number : 1;
  }
}, Gae = {
  name: "text-decoration-color",
  initialValue: "transparent",
  prefix: !1,
  type: 3,
  format: "color"
}, $ae = {
  name: "text-decoration-line",
  initialValue: "none",
  prefix: !1,
  type: 1,
  parse: function(i, e) {
    return e.filter(Kr).map(function(t) {
      switch (t.value) {
        case "underline":
          return 1;
        case "overline":
          return 2;
        case "line-through":
          return 3;
        case "none":
          return 4;
      }
      return 0;
    }).filter(function(t) {
      return t !== 0;
    });
  }
}, Vae = {
  name: "font-family",
  initialValue: "",
  prefix: !1,
  type: 1,
  parse: function(i, e) {
    var t = [], r = [];
    return e.forEach(function(n) {
      switch (n.type) {
        case 20:
        case 0:
          t.push(n.value);
          break;
        case 17:
          t.push(n.number.toString());
          break;
        case 4:
          r.push(t.join(" ")), t.length = 0;
          break;
      }
    }), t.length && r.push(t.join(" ")), r.map(function(n) {
      return n.indexOf(" ") === -1 ? n : "'" + n + "'";
    });
  }
}, Kae = {
  name: "font-size",
  initialValue: "0",
  prefix: !1,
  type: 3,
  format: "length"
}, jae = {
  name: "font-weight",
  initialValue: "normal",
  type: 0,
  prefix: !1,
  parse: function(i, e) {
    if (Hu(e))
      return e.number;
    if (Kr(e))
      switch (e.value) {
        case "bold":
          return 700;
        case "normal":
        default:
          return 400;
      }
    return 400;
  }
}, zae = {
  name: "font-variant",
  initialValue: "none",
  type: 1,
  prefix: !1,
  parse: function(i, e) {
    return e.filter(Kr).map(function(t) {
      return t.value;
    });
  }
}, Xae = {
  name: "font-style",
  initialValue: "normal",
  prefix: !1,
  type: 2,
  parse: function(i, e) {
    switch (e) {
      case "oblique":
        return "oblique";
      case "italic":
        return "italic";
      case "normal":
      default:
        return "normal";
    }
  }
}, on = function(i, e) {
  return (i & e) !== 0;
}, Wae = {
  name: "content",
  initialValue: "none",
  type: 1,
  prefix: !1,
  parse: function(i, e) {
    if (e.length === 0)
      return [];
    var t = e[0];
    return t.type === 20 && t.value === "none" ? [] : e;
  }
}, Yae = {
  name: "counter-increment",
  initialValue: "none",
  prefix: !0,
  type: 1,
  parse: function(i, e) {
    if (e.length === 0)
      return null;
    var t = e[0];
    if (t.type === 20 && t.value === "none")
      return null;
    for (var r = [], n = e.filter(BP), s = 0; s < n.length; s++) {
      var a = n[s], o = n[s + 1];
      if (a.type === 20) {
        var A = o && Hu(o) ? o.number : 1;
        r.push({ counter: a.value, increment: A });
      }
    }
    return r;
  }
}, qae = {
  name: "counter-reset",
  initialValue: "none",
  prefix: !0,
  type: 1,
  parse: function(i, e) {
    if (e.length === 0)
      return [];
    for (var t = [], r = e.filter(BP), n = 0; n < r.length; n++) {
      var s = r[n], a = r[n + 1];
      if (Kr(s) && s.value !== "none") {
        var o = a && Hu(a) ? a.number : 0;
        t.push({ counter: s.value, reset: o });
      }
    }
    return t;
  }
}, Zae = {
  name: "duration",
  initialValue: "0s",
  prefix: !1,
  type: 1,
  parse: function(i, e) {
    return e.filter(Lg).map(function(t) {
      return GP.parse(i, t);
    });
  }
}, Jae = {
  name: "quotes",
  initialValue: "none",
  prefix: !0,
  type: 1,
  parse: function(i, e) {
    if (e.length === 0)
      return null;
    var t = e[0];
    if (t.type === 20 && t.value === "none")
      return null;
    var r = [], n = e.filter(Bse);
    if (n.length % 2 !== 0)
      return null;
    for (var s = 0; s < n.length; s += 2) {
      var a = n[s].value, o = n[s + 1].value;
      r.push({ open: a, close: o });
    }
    return r;
  }
}, xF = function(i, e, t) {
  if (!i)
    return "";
  var r = i[Math.min(e, i.length - 1)];
  return r ? t ? r.open : r.close : "";
}, eoe = {
  name: "box-shadow",
  initialValue: "none",
  type: 1,
  prefix: !1,
  parse: function(i, e) {
    return e.length === 1 && oC(e[0], "none") ? [] : no(e).map(function(t) {
      for (var r = {
        color: 255,
        offsetX: Ln,
        offsetY: Ln,
        blur: Ln,
        spread: Ln,
        inset: !1
      }, n = 0, s = 0; s < t.length; s++) {
        var a = t[s];
        oC(a, "inset") ? r.inset = !0 : ml(a) ? (n === 0 ? r.offsetX = a : n === 1 ? r.offsetY = a : n === 2 ? r.blur = a : r.spread = a, n++) : r.color = sl.parse(i, a);
      }
      return r;
    });
  }
}, toe = {
  name: "paint-order",
  initialValue: "normal",
  prefix: !1,
  type: 1,
  parse: function(i, e) {
    var t = [
      0,
      1,
      2
      /* MARKERS */
    ], r = [];
    return e.filter(Kr).forEach(function(n) {
      switch (n.value) {
        case "stroke":
          r.push(
            1
            /* STROKE */
          );
          break;
        case "fill":
          r.push(
            0
            /* FILL */
          );
          break;
        case "markers":
          r.push(
            2
            /* MARKERS */
          );
          break;
      }
    }), t.forEach(function(n) {
      r.indexOf(n) === -1 && r.push(n);
    }), r;
  }
}, roe = {
  name: "-webkit-text-stroke-color",
  initialValue: "currentcolor",
  prefix: !1,
  type: 3,
  format: "color"
}, ioe = {
  name: "-webkit-text-stroke-width",
  initialValue: "0",
  type: 0,
  prefix: !1,
  parse: function(i, e) {
    return Lg(e) ? e.number : 0;
  }
}, noe = (
  /** @class */
  function() {
    function i(e, t) {
      var r, n;
      this.animationDuration = tt(e, Zae, t.animationDuration), this.backgroundClip = tt(e, Tse, t.backgroundClip), this.backgroundColor = tt(e, Fse, t.backgroundColor), this.backgroundImage = tt(e, Dse, t.backgroundImage), this.backgroundOrigin = tt(e, kse, t.backgroundOrigin), this.backgroundPosition = tt(e, Hse, t.backgroundPosition), this.backgroundRepeat = tt(e, Gse, t.backgroundRepeat), this.backgroundSize = tt(e, Vse, t.backgroundSize), this.borderTopColor = tt(e, jse, t.borderTopColor), this.borderRightColor = tt(e, zse, t.borderRightColor), this.borderBottomColor = tt(e, Xse, t.borderBottomColor), this.borderLeftColor = tt(e, Wse, t.borderLeftColor), this.borderTopLeftRadius = tt(e, Yse, t.borderTopLeftRadius), this.borderTopRightRadius = tt(e, qse, t.borderTopRightRadius), this.borderBottomRightRadius = tt(e, Zse, t.borderBottomRightRadius), this.borderBottomLeftRadius = tt(e, Jse, t.borderBottomLeftRadius), this.borderTopStyle = tt(e, eae, t.borderTopStyle), this.borderRightStyle = tt(e, tae, t.borderRightStyle), this.borderBottomStyle = tt(e, rae, t.borderBottomStyle), this.borderLeftStyle = tt(e, iae, t.borderLeftStyle), this.borderTopWidth = tt(e, nae, t.borderTopWidth), this.borderRightWidth = tt(e, sae, t.borderRightWidth), this.borderBottomWidth = tt(e, aae, t.borderBottomWidth), this.borderLeftWidth = tt(e, oae, t.borderLeftWidth), this.boxShadow = tt(e, eoe, t.boxShadow), this.color = tt(e, Aae, t.color), this.direction = tt(e, lae, t.direction), this.display = tt(e, hae, t.display), this.float = tt(e, uae, t.cssFloat), this.fontFamily = tt(e, Vae, t.fontFamily), this.fontSize = tt(e, Kae, t.fontSize), this.fontStyle = tt(e, Xae, t.fontStyle), this.fontVariant = tt(e, zae, t.fontVariant), this.fontWeight = tt(e, jae, t.fontWeight), this.letterSpacing = tt(e, fae, t.letterSpacing), this.lineBreak = tt(e, dae, t.lineBreak), this.lineHeight = tt(e, gae, t.lineHeight), this.listStyleImage = tt(e, pae, t.listStyleImage), this.listStylePosition = tt(e, mae, t.listStylePosition), this.listStyleType = tt(e, AC, t.listStyleType), this.marginTop = tt(e, vae, t.marginTop), this.marginRight = tt(e, yae, t.marginRight), this.marginBottom = tt(e, _ae, t.marginBottom), this.marginLeft = tt(e, wae, t.marginLeft), this.opacity = tt(e, Hae, t.opacity);
      var s = tt(e, xae, t.overflow);
      this.overflowX = s[0], this.overflowY = s[s.length > 1 ? 1 : 0], this.overflowWrap = tt(e, Cae, t.overflowWrap), this.paddingTop = tt(e, Eae, t.paddingTop), this.paddingRight = tt(e, Bae, t.paddingRight), this.paddingBottom = tt(e, bae, t.paddingBottom), this.paddingLeft = tt(e, Sae, t.paddingLeft), this.paintOrder = tt(e, toe, t.paintOrder), this.position = tt(e, Fae, t.position), this.textAlign = tt(e, Tae, t.textAlign), this.textDecorationColor = tt(e, Gae, (r = t.textDecorationColor) !== null && r !== void 0 ? r : t.color), this.textDecorationLine = tt(e, $ae, (n = t.textDecorationLine) !== null && n !== void 0 ? n : t.textDecoration), this.textShadow = tt(e, Lae, t.textShadow), this.textTransform = tt(e, Iae, t.textTransform), this.transform = tt(e, Rae, t.transform), this.transformOrigin = tt(e, Uae, t.transformOrigin), this.visibility = tt(e, Qae, t.visibility), this.webkitTextStrokeColor = tt(e, roe, t.webkitTextStrokeColor), this.webkitTextStrokeWidth = tt(e, ioe, t.webkitTextStrokeWidth), this.wordBreak = tt(e, Dae, t.wordBreak), this.zIndex = tt(e, kae, t.zIndex);
    }
    return i.prototype.isVisible = function() {
      return this.display > 0 && this.opacity > 0 && this.visibility === 0;
    }, i.prototype.isTransparent = function() {
      return al(this.backgroundColor);
    }, i.prototype.isTransformed = function() {
      return this.transform !== null;
    }, i.prototype.isPositioned = function() {
      return this.position !== 0;
    }, i.prototype.isPositionedWithZIndex = function() {
      return this.isPositioned() && !this.zIndex.auto;
    }, i.prototype.isFloating = function() {
      return this.float !== 0;
    }, i.prototype.isInlineLevel = function() {
      return on(
        this.display,
        4
        /* INLINE */
      ) || on(
        this.display,
        33554432
        /* INLINE_BLOCK */
      ) || on(
        this.display,
        268435456
        /* INLINE_FLEX */
      ) || on(
        this.display,
        536870912
        /* INLINE_GRID */
      ) || on(
        this.display,
        67108864
        /* INLINE_LIST_ITEM */
      ) || on(
        this.display,
        134217728
        /* INLINE_TABLE */
      );
    }, i;
  }()
), soe = (
  /** @class */
  function() {
    function i(e, t) {
      this.content = tt(e, Wae, t.content), this.quotes = tt(e, Jae, t.quotes);
    }
    return i;
  }()
), CF = (
  /** @class */
  function() {
    function i(e, t) {
      this.counterIncrement = tt(e, Yae, t.counterIncrement), this.counterReset = tt(e, qae, t.counterReset);
    }
    return i;
  }()
), tt = function(i, e, t) {
  var r = new CP(), n = t !== null && typeof t < "u" ? t.toString() : e.initialValue;
  r.write(n);
  var s = new EP(r.read());
  switch (e.type) {
    case 2:
      var a = s.parseComponentValue();
      return e.parse(i, Kr(a) ? a.value : e.initialValue);
    case 0:
      return e.parse(i, s.parseComponentValue());
    case 1:
      return e.parse(i, s.parseComponentValues());
    case 4:
      return s.parseComponentValue();
    case 3:
      switch (e.format) {
        case "angle":
          return fy.parse(i, s.parseComponentValue());
        case "color":
          return sl.parse(i, s.parseComponentValue());
        case "image":
          return KB.parse(i, s.parseComponentValue());
        case "length":
          var o = s.parseComponentValue();
          return ml(o) ? o : Ln;
        case "length-percentage":
          var A = s.parseComponentValue();
          return Wi(A) ? A : Ln;
        case "time":
          return GP.parse(i, s.parseComponentValue());
      }
      break;
  }
}, aoe = "data-html2canvas-debug", ooe = function(i) {
  var e = i.getAttribute(aoe);
  switch (e) {
    case "all":
      return 1;
    case "clone":
      return 2;
    case "parse":
      return 3;
    case "render":
      return 4;
    default:
      return 0;
  }
}, lC = function(i, e) {
  var t = ooe(i);
  return t === 1 || e === t;
}, so = (
  /** @class */
  function() {
    function i(e, t) {
      if (this.context = e, this.textNodes = [], this.elements = [], this.flags = 0, lC(
        t,
        3
        /* PARSE */
      ))
        debugger;
      this.styles = new noe(e, window.getComputedStyle(t, null)), uC(t) && (this.styles.animationDuration.some(function(r) {
        return r > 0;
      }) && (t.style.animationDuration = "0s"), this.styles.transform !== null && (t.style.transform = "none")), this.bounds = cy(this.context, t), lC(
        t,
        4
        /* RENDER */
      ) && (this.flags |= 16);
    }
    return i;
  }()
), Aoe = "AAAAAAAAAAAAEA4AGBkAAFAaAAACAAAAAAAIABAAGAAwADgACAAQAAgAEAAIABAACAAQAAgAEAAIABAACAAQAAgAEAAIABAAQABIAEQATAAIABAACAAQAAgAEAAIABAAVABcAAgAEAAIABAACAAQAGAAaABwAHgAgACIAI4AlgAIABAAmwCjAKgAsAC2AL4AvQDFAMoA0gBPAVYBWgEIAAgACACMANoAYgFkAWwBdAF8AX0BhQGNAZUBlgGeAaMBlQGWAasBswF8AbsBwwF0AcsBYwHTAQgA2wG/AOMBdAF8AekB8QF0AfkB+wHiAHQBfAEIAAMC5gQIAAsCEgIIAAgAFgIeAggAIgIpAggAMQI5AkACygEIAAgASAJQAlgCYAIIAAgACAAKBQoFCgUTBRMFGQUrBSsFCAAIAAgACAAIAAgACAAIAAgACABdAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACABoAmgCrwGvAQgAbgJ2AggAHgEIAAgACADnAXsCCAAIAAgAgwIIAAgACAAIAAgACACKAggAkQKZAggAPADJAAgAoQKkAqwCsgK6AsICCADJAggA0AIIAAgACAAIANYC3gIIAAgACAAIAAgACABAAOYCCAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAkASoB+QIEAAgACAA8AEMCCABCBQgACABJBVAFCAAIAAgACAAIAAgACAAIAAgACABTBVoFCAAIAFoFCABfBWUFCAAIAAgACAAIAAgAbQUIAAgACAAIAAgACABzBXsFfQWFBYoFigWKBZEFigWKBYoFmAWfBaYFrgWxBbkFCAAIAAgACAAIAAgACAAIAAgACAAIAMEFCAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAMgFCADQBQgACAAIAAgACAAIAAgACAAIAAgACAAIAO4CCAAIAAgAiQAIAAgACABAAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAD0AggACAD8AggACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIANYFCAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAMDvwAIAAgAJAIIAAgACAAIAAgACAAIAAgACwMTAwgACAB9BOsEGwMjAwgAKwMyAwsFYgE3A/MEPwMIAEUDTQNRAwgAWQOsAGEDCAAIAAgACAAIAAgACABpAzQFNQU2BTcFOAU5BToFNAU1BTYFNwU4BTkFOgU0BTUFNgU3BTgFOQU6BTQFNQU2BTcFOAU5BToFNAU1BTYFNwU4BTkFOgU0BTUFNgU3BTgFOQU6BTQFNQU2BTcFOAU5BToFNAU1BTYFNwU4BTkFOgU0BTUFNgU3BTgFOQU6BTQFNQU2BTcFOAU5BToFNAU1BTYFNwU4BTkFOgU0BTUFNgU3BTgFOQU6BTQFNQU2BTcFOAU5BToFNAU1BTYFNwU4BTkFOgU0BTUFNgU3BTgFOQU6BTQFNQU2BTcFOAU5BToFNAU1BTYFNwU4BTkFOgU0BTUFNgU3BTgFOQU6BTQFNQU2BTcFOAU5BToFNAU1BTYFNwU4BTkFOgU0BTUFNgU3BTgFOQU6BTQFNQU2BTcFOAU5BToFNAU1BTYFNwU4BTkFOgU0BTUFNgU3BTgFOQU6BTQFNQU2BTcFOAU5BToFNAU1BTYFNwU4BTkFOgU0BTUFNgU3BTgFOQU6BTQFNQU2BTcFOAU5BToFNAU1BTYFNwU4BTkFOgU0BTUFNgU3BTgFOQU6BTQFNQU2BTcFOAU5BToFNAU1BTYFNwU4BTkFOgU0BTUFNgU3BTgFOQU6BTQFNQU2BTcFOAU5BToFNAU1BTYFNwU4BTkFOgU0BTUFNgU3BTgFOQU6BTQFNQU2BTcFOAU5BToFNAU1BTYFNwU4BTkFOgU0BTUFNgU3BTgFOQU6BTQFNQU2BTcFOAU5BToFNAU1BTYFNwU4BTkFOgU0BTUFNgU3BTgFOQU6BTQFNQU2BTcFOAU5BToFNAU1BTYFNwU4BTkFOgU0BTUFNgU3BTgFOQU6BTQFNQU2BTcFOAU5BToFNAU1BTYFNwU4BTkFOgU0BTUFNgU3BTgFOQU6BTQFNQU2BTcFOAU5BToFNAU1BTYFNwU4BTkFIQUoBSwFCAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACABtAwgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACABMAEwACAAIAAgACAAIABgACAAIAAgACAC/AAgACAAyAQgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACACAAIAAwAAgACAAIAAgACAAIAAgACAAIAAAARABIAAgACAAIABQASAAIAAgAIABwAEAAjgCIABsAqAC2AL0AigDQAtwC+IJIQqVAZUBWQqVAZUBlQGVAZUBlQGrC5UBlQGVAZUBlQGVAZUBlQGVAXsKlQGVAbAK6wsrDGUMpQzlDJUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAfAKAAuZA64AtwCJALoC6ADwAAgAuACgA/oEpgO6AqsD+AAIAAgAswMIAAgACAAIAIkAuwP5AfsBwwPLAwgACAAIAAgACADRA9kDCAAIAOED6QMIAAgACAAIAAgACADuA/YDCAAIAP4DyQAIAAgABgQIAAgAXQAOBAgACAAIAAgACAAIABMECAAIAAgACAAIAAgACAD8AAQBCAAIAAgAGgQiBCoECAExBAgAEAEIAAgACAAIAAgACAAIAAgACAAIAAgACAA4BAgACABABEYECAAIAAgATAQYAQgAVAQIAAgACAAIAAgACAAIAAgACAAIAFoECAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgAOQEIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAB+BAcACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAEABhgSMBAgACAAIAAgAlAQIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAwAEAAQABAADAAMAAwADAAQABAAEAAQABAAEAAQABHATAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgAdQMIAAgACAAIAAgACAAIAMkACAAIAAgAfQMIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACACFA4kDCAAIAAgACAAIAOcBCAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAIcDCAAIAAgACAAIAAgACAAIAAgACAAIAJEDCAAIAAgACADFAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACABgBAgAZgQIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgAbAQCBXIECAAIAHkECAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACABAAJwEQACjBKoEsgQIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAC6BMIECAAIAAgACAAIAAgACABmBAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgAxwQIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAGYECAAIAAgAzgQIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgAigWKBYoFigWKBYoFigWKBd0FXwUIAOIF6gXxBYoF3gT5BQAGCAaKBYoFigWKBYoFigWKBYoFigWKBYoFigXWBIoFigWKBYoFigWKBYoFigWKBYsFEAaKBYoFigWKBYoFigWKBRQGCACKBYoFigWKBQgACAAIANEECAAIABgGigUgBggAJgYIAC4GMwaKBYoF0wQ3Bj4GigWKBYoFigWKBYoFigWKBYoFigWKBYoFigUIAAgACAAIAAgACAAIAAgAigWKBYoFigWKBYoFigWKBYoFigWKBYoFigWKBYoFigWKBYoFigWKBYoFigWKBYoFigWKBYoFigWKBYoFigWLBf///////wQABAAEAAQABAAEAAQABAAEAAQAAwAEAAQAAgAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAAAAAAAAAAAAAAAAAAAAAAAAAOAAAAAAAAAAQADgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAFAAUABQAFAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAAAAUAAAAFAAUAAAAFAAUAAAAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAAEAAQABAAEAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAFAAUABQAFAAUABQAFAAUABQAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAFAAUABQAFAAUAAQAAAAUABQAFAAUABQAFAAAAAAAFAAUAAAAFAAUABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEAAAAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUABQAFAAUABQAFAAUABQAFAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUABQAFAAUABQAFAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAFAAAAAAAFAAUAAQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABwAFAAUABQAFAAAABwAHAAcAAAAHAAcABwAFAAEAAAAAAAAAAAAAAAAAAAAAAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAHAAcABwAFAAUABQAFAAcABwAFAAUAAAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAHAAAAAQABAAAAAAAAAAAAAAAFAAUABQAFAAAABwAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAHAAcABwAHAAcAAAAHAAcAAAAAAAUABQAHAAUAAQAHAAEABwAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAFAAUABQAFAAUABwABAAUABQAFAAUAAAAAAAAAAAAAAAEAAQABAAEAAQABAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABwAFAAUAAAAAAAAAAAAAAAAABQAFAAUABQAFAAUAAQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAFAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQABQANAAQABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQABAAEAAQABAAEAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAOAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAAEAAQABAAEAAQABAAEAAQABAAEAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEAAQABAAEAAQABAAEAAQABAAAAAAAAAAAAAAAAAAAAAAABQAHAAUABQAFAAAAAAAAAAcABQAFAAUABQAFAAQABAAEAAQABAAEAAQABAAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAFAAUAAAAFAAUABQAFAAUAAAAFAAUABQAAAAUABQAFAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUABQAAAAAAAAAAAAUABQAFAAcAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAHAAUAAAAHAAcABwAFAAUABQAFAAUABQAFAAUABwAHAAcABwAFAAcABwAAAAUABQAFAAUABQAFAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABwAHAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAAAAUABwAHAAUABQAFAAUAAAAAAAcABwAAAAAABwAHAAUAAAAAAAAAAAAAAAAAAAAAAAAABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAAAAAABQAFAAcAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAAABwAHAAcABQAFAAAAAAAAAAAABQAFAAAAAAAFAAUABQAAAAAAAAAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAAAAAAAAAFAAAAAAAAAAAAAAAAAAAAAAAAAAAABwAFAAUABQAFAAUAAAAFAAUABwAAAAcABwAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUABQAFAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUAAAAFAAUABwAFAAUABQAFAAAAAAAHAAcAAAAAAAcABwAFAAAAAAAAAAAAAAAAAAAABQAFAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAcABwAAAAAAAAAHAAcABwAAAAcABwAHAAUAAAAAAAAAAAAAAAAAAAAAAAAABQAAAAAAAAAAAAAAAAAAAAAABQAHAAcABwAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABwAHAAcABwAAAAUABQAFAAAABQAFAAUABQAAAAAAAAAAAAAAAAAAAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAAAAcABQAHAAcABQAHAAcAAAAFAAcABwAAAAcABwAFAAUAAAAAAAAAAAAAAAAAAAAFAAUAAAAAAAAAAAAAAAAAAAAAAAAABQAFAAcABwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAAAAUABwAAAAAAAAAAAAAAAAAAAAAAAAAAAAUAAAAAAAAAAAAFAAcABwAFAAUABQAAAAUAAAAHAAcABwAHAAcABwAHAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUAAAAHAAUABQAFAAUABQAFAAUAAAAAAAAAAAAAAAAAAAAAAAUABQAFAAUABQAFAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAAABwAFAAUABQAFAAUABQAFAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAFAAUABQAFAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAAAAUAAAAFAAAAAAAAAAAABwAHAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABwAFAAUABQAFAAUAAAAFAAUAAAAAAAAAAAAAAAUABQAFAAUABQAFAAUABQAFAAUABQAAAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAFAAUABwAFAAUABQAFAAUABQAAAAUABQAHAAcABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAHAAcABQAFAAAAAAAAAAAABQAFAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAAAAcABQAFAAAAAAAAAAAAAAAAAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAFAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAHAAUABQAFAAUABQAFAAUABwAHAAcABwAHAAcABwAHAAUABwAHAAUABQAFAAUABQAFAAUABQAFAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAFAAUABwAHAAcABwAFAAUABwAHAAcAAAAAAAAAAAAHAAcABQAHAAcABwAHAAcABwAFAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAFAAcABwAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAcABQAHAAUABQAFAAUABQAFAAUAAAAFAAAABQAAAAAABQAFAAUABQAFAAUABQAFAAcABwAHAAcABwAHAAUABQAFAAUABQAFAAUABQAFAAUAAAAAAAUABQAFAAUABQAHAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAFAAUABQAFAAUABwAFAAcABwAHAAcABwAFAAcABwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUABQAFAAUABQAFAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUABwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAHAAUABQAFAAUABwAHAAUABQAHAAUABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAcABQAFAAcABwAHAAUABwAFAAUABQAHAAcAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABwAHAAcABwAHAAcABwAHAAUABQAFAAUABQAFAAUABQAHAAcABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAFAAUAAAAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAcABQAFAAUABQAFAAUABQAAAAAAAAAAAAUAAAAAAAAAAAAAAAAABQAAAAAABwAFAAUAAAAAAAAAAAAAAAAABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAAABQAFAAUABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAFAAUABQAFAAUADgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAOAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAFAAUAAAAFAAUABQAFAAUABQAFAAUABQAFAAAAAAAAAAAABQAAAAAAAAAFAAAAAAAAAAAABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABwAHAAUABQAHAAAAAAAAAAAABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAcABwAHAAcABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUAAAAAAAAAAAAAAAAABQAFAAUABQAFAAUABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAFAAUABQAFAAUABQAFAAUABQAHAAcAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAcABwAFAAUABQAFAAcABwAFAAUABwAHAAAAAAAAAAAAAAAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAFAAUABQAFAAcABwAFAAUABwAHAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAAAAAAAAAAAAAAAAAAAAAAFAAcAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUAAAAFAAUABQAAAAAABQAFAAAAAAAAAAAAAAAFAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAcABQAFAAcABwAAAAAAAAAAAAAABwAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAcABwAFAAcABwAFAAcABwAAAAcABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAFAAUABQAAAAAAAAAAAAAAAAAFAAUABQAAAAUABQAAAAAAAAAAAAAABQAFAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUABQAAAAAAAAAAAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAcABQAHAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUABQAFAAUABwAFAAUABQAFAAUABQAFAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABwAHAAcABQAFAAUABQAFAAUABQAFAAUABwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAHAAcABwAFAAUABQAHAAcABQAHAAUABQAAAAAAAAAAAAAAAAAFAAAABwAHAAcABQAFAAUABQAFAAUABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABwAHAAcABwAAAAAABwAHAAAAAAAHAAcABwAAAAAAAAAAAAAAAAAAAAAAAAAFAAAAAAAAAAAAAAAAAAAAAAAAAAAABwAHAAAAAAAFAAUABQAFAAUABQAFAAAAAAAAAAUABQAFAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAHAAcABwAFAAUABQAFAAUABQAFAAUABwAHAAUABQAFAAcABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAHAAcABQAFAAUABQAFAAUABwAFAAcABwAFAAcABQAFAAcABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAHAAcABQAFAAUABQAAAAAABwAHAAcABwAFAAUABwAFAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAcABwAHAAUABQAFAAUABQAFAAUABQAHAAcABQAHAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABwAFAAcABwAFAAUABQAFAAUABQAHAAUAAAAAAAAAAAAAAAAAAAAAAAcABwAFAAUABQAFAAcABQAFAAUABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAHAAcABwAFAAUABQAFAAUABQAFAAUABQAHAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAHAAcABwAFAAUABQAFAAAAAAAFAAUABwAHAAcABwAFAAAAAAAAAAcAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUABQAFAAUABQAFAAUABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUAAAAAAAAAAAAAAAAAAAAAAAAABQAFAAUABQAFAAUABwAHAAUABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAcABQAFAAUABQAFAAUABQAAAAUABQAFAAUABQAFAAcABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAAAHAAUABQAFAAUABQAFAAUABwAFAAUABwAFAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAFAAUABQAFAAUAAAAAAAAABQAAAAUABQAAAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAHAAcABwAHAAcAAAAFAAUAAAAHAAcABQAHAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUABwAHAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUABQAFAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUABQAFAAUABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAAAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAAAAAAAAAAAAAAAAAAABQAFAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAcABwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAAAAUABQAFAAAAAAAFAAUABQAFAAUABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAFAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAFAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAAAAAAAAAAABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAAAAAAAAAAAAAAAAAAAAAAFAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAFAAUABQAAAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAFAAUABQAFAAUABQAAAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAAAAAABQAFAAUABQAFAAUABQAAAAUABQAAAAUABQAFAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAFAAUABQAFAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAFAAUABQAFAAUADgAOAA4ADgAOAA4ADwAPAA8ADwAPAA8ADwAPAA8ADwAPAA8ADwAPAA8ADwAPAA8ADwAPAA8ADwAPAA8ADwAPAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAcABwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABwAHAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAAAAAAAAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAKAAoACgAKAAoACgAKAAoACgAKAAoACgAKAAoACgAKAAoACgAKAAoACgAKAAoACgAMAAwADAAMAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkAAAAAAAAAAAAKAAoACgAKAAoACgAKAAoACgAKAAoACgAKAAoACgAKAAoACgAKAAoACgAKAAoACgAKAAoACgAKAAoACgAKAAoACgAAAAAAAAAAAAsADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwACwAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAAAAAADgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA4AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAOAA4ADgAOAA4ADgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADgAOAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA4ADgAAAAAAAAAAAAAAAAAAAAAADgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADgAOAA4ADgAOAA4ADgAOAA4ADgAOAAAAAAAAAAAADgAOAA4AAAAAAAAAAAAAAAAAAAAOAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADgAOAAAAAAAAAAAAAAAAAAAAAAAAAAAADgAAAAAAAAAAAAAAAAAAAAAAAAAOAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADgAOAA4ADgAAAA4ADgAOAA4ADgAOAAAADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4AAAAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAAAAAAAAAAAAAAAAAAAAAAAAAAAADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4AAAAAAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAAAA4AAAAOAAAAAAAAAAAAAAAAAA4AAAAAAAAAAAAAAAAADgAAAAAAAAAAAAAAAAAAAAAAAAAAAA4ADgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADgAAAAAADgAAAAAAAAAAAA4AAAAOAAAAAAAAAAAADgAOAA4AAAAOAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAOAA4ADgAOAA4AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAOAA4ADgAAAAAAAAAAAAAAAAAAAAAAAAAOAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAOAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAOAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAOAA4AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA4ADgAOAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADgAOAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADgAAAAAAAAAAAA4AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAOAAAADgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAOAA4ADgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA4ADgAOAA4ADgAOAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA4ADgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADgAAAAAADgAOAA4ADgAOAA4ADgAOAA4ADgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAAAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAAAAAAAAAAAAAAAAAAAAAAAAAAAADgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA4AAAAAAA4ADgAOAA4ADgAOAA4ADgAOAAAADgAOAA4ADgAAAAAAAAAAAAAAAAAAAAAAAAAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4AAAAAAAAAAAAAAAAADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAOAA4ADgAOAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADgAOAA4ADgAOAA4ADgAOAAAAAAAAAAAAAAAAAAAAAAAAAAAADgAOAA4ADgAOAA4AAAAAAAAAAAAAAAAAAAAAAA4ADgAOAA4ADgAOAA4ADgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4AAAAOAA4ADgAOAA4ADgAAAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4AAAAAAAAAAAA=", EF = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", sd = typeof Uint8Array > "u" ? [] : new Uint8Array(256);
for (var y0 = 0; y0 < EF.length; y0++)
  sd[EF.charCodeAt(y0)] = y0;
var loe = function(i) {
  var e = i.length * 0.75, t = i.length, r, n = 0, s, a, o, A;
  i[i.length - 1] === "=" && (e--, i[i.length - 2] === "=" && e--);
  var l = typeof ArrayBuffer < "u" && typeof Uint8Array < "u" && typeof Uint8Array.prototype.slice < "u" ? new ArrayBuffer(e) : new Array(e), h = Array.isArray(l) ? l : new Uint8Array(l);
  for (r = 0; r < t; r += 4)
    s = sd[i.charCodeAt(r)], a = sd[i.charCodeAt(r + 1)], o = sd[i.charCodeAt(r + 2)], A = sd[i.charCodeAt(r + 3)], h[n++] = s << 2 | a >> 4, h[n++] = (a & 15) << 4 | o >> 2, h[n++] = (o & 3) << 6 | A & 63;
  return l;
}, hoe = function(i) {
  for (var e = i.length, t = [], r = 0; r < e; r += 2)
    t.push(i[r + 1] << 8 | i[r]);
  return t;
}, coe = function(i) {
  for (var e = i.length, t = [], r = 0; r < e; r += 4)
    t.push(i[r + 3] << 24 | i[r + 2] << 16 | i[r + 1] << 8 | i[r]);
  return t;
}, Ah = 5, jB = 6 + 5, T_ = 2, uoe = jB - Ah, $P = 65536 >> Ah, foe = 1 << Ah, F_ = foe - 1, doe = 1024 >> Ah, goe = $P + doe, poe = goe, moe = 32, voe = poe + moe, yoe = 65536 >> jB, _oe = 1 << uoe, woe = _oe - 1, BF = function(i, e, t) {
  return i.slice ? i.slice(e, t) : new Uint16Array(Array.prototype.slice.call(i, e, t));
}, xoe = function(i, e, t) {
  return i.slice ? i.slice(e, t) : new Uint32Array(Array.prototype.slice.call(i, e, t));
}, Coe = function(i, e) {
  var t = loe(i), r = Array.isArray(t) ? coe(t) : new Uint32Array(t), n = Array.isArray(t) ? hoe(t) : new Uint16Array(t), s = 24, a = BF(n, s / 2, r[4] / 2), o = r[5] === 2 ? BF(n, (s + r[4]) / 2) : xoe(r, Math.ceil((s + r[4]) / 4));
  return new Eoe(r[0], r[1], r[2], r[3], a, o);
}, Eoe = (
  /** @class */
  function() {
    function i(e, t, r, n, s, a) {
      this.initialValue = e, this.errorValue = t, this.highStart = r, this.highValueIndex = n, this.index = s, this.data = a;
    }
    return i.prototype.get = function(e) {
      var t;
      if (e >= 0) {
        if (e < 55296 || e > 56319 && e <= 65535)
          return t = this.index[e >> Ah], t = (t << T_) + (e & F_), this.data[t];
        if (e <= 65535)
          return t = this.index[$P + (e - 55296 >> Ah)], t = (t << T_) + (e & F_), this.data[t];
        if (e < this.highStart)
          return t = voe - yoe + (e >> jB), t = this.index[t], t += e >> Ah & woe, t = this.index[t], t = (t << T_) + (e & F_), this.data[t];
        if (e <= 1114111)
          return this.data[this.highValueIndex];
      }
      return this.errorValue;
    }, i;
  }()
), bF = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", Boe = typeof Uint8Array > "u" ? [] : new Uint8Array(256);
for (var _0 = 0; _0 < bF.length; _0++)
  Boe[bF.charCodeAt(_0)] = _0;
var boe = 1, L_ = 2, I_ = 3, SF = 4, TF = 5, Soe = 7, FF = 8, R_ = 9, M_ = 10, LF = 11, IF = 12, RF = 13, MF = 14, N_ = 15, Toe = function(i) {
  for (var e = [], t = 0, r = i.length; t < r; ) {
    var n = i.charCodeAt(t++);
    if (n >= 55296 && n <= 56319 && t < r) {
      var s = i.charCodeAt(t++);
      (s & 64512) === 56320 ? e.push(((n & 1023) << 10) + (s & 1023) + 65536) : (e.push(n), t--);
    } else
      e.push(n);
  }
  return e;
}, Foe = function() {
  for (var i = [], e = 0; e < arguments.length; e++)
    i[e] = arguments[e];
  if (String.fromCodePoint)
    return String.fromCodePoint.apply(String, i);
  var t = i.length;
  if (!t)
    return "";
  for (var r = [], n = -1, s = ""; ++n < t; ) {
    var a = i[n];
    a <= 65535 ? r.push(a) : (a -= 65536, r.push((a >> 10) + 55296, a % 1024 + 56320)), (n + 1 === t || r.length > 16384) && (s += String.fromCharCode.apply(String, r), r.length = 0);
  }
  return s;
}, Loe = Coe(Aoe), zs = "", P_ = "", Ioe = function(i) {
  return Loe.get(i);
}, Roe = function(i, e, t) {
  var r = t - 2, n = e[r], s = e[t - 1], a = e[t];
  if (s === L_ && a === I_)
    return zs;
  if (s === L_ || s === I_ || s === SF || a === L_ || a === I_ || a === SF)
    return P_;
  if (s === FF && [FF, R_, LF, IF].indexOf(a) !== -1 || (s === LF || s === R_) && (a === R_ || a === M_) || (s === IF || s === M_) && a === M_ || a === RF || a === TF || a === Soe || s === boe)
    return zs;
  if (s === RF && a === MF) {
    for (; n === TF; )
      n = e[--r];
    if (n === MF)
      return zs;
  }
  if (s === N_ && a === N_) {
    for (var o = 0; n === N_; )
      o++, n = e[--r];
    if (o % 2 === 0)
      return zs;
  }
  return P_;
}, Moe = function(i) {
  var e = Toe(i), t = e.length, r = 0, n = 0, s = e.map(Ioe);
  return {
    next: function() {
      if (r >= t)
        return { done: !0, value: null };
      for (var a = zs; r < t && (a = Roe(e, s, ++r)) === zs; )
        ;
      if (a !== zs || r === t) {
        var o = Foe.apply(null, e.slice(n, r));
        return n = r, { value: o, done: !1 };
      }
      return { done: !0, value: null };
    }
  };
}, Noe = function(i) {
  for (var e = Moe(i), t = [], r; !(r = e.next()).done; )
    r.value && t.push(r.value.slice());
  return t;
}, Poe = function(i) {
  var e = 123;
  if (i.createRange) {
    var t = i.createRange();
    if (t.getBoundingClientRect) {
      var r = i.createElement("boundtest");
      r.style.height = e + "px", r.style.display = "block", i.body.appendChild(r), t.selectNode(r);
      var n = t.getBoundingClientRect(), s = Math.round(n.height);
      if (i.body.removeChild(r), s === e)
        return !0;
    }
  }
  return !1;
}, Ooe = function(i) {
  var e = i.createElement("boundtest");
  e.style.width = "50px", e.style.display = "block", e.style.fontSize = "12px", e.style.letterSpacing = "0px", e.style.wordSpacing = "0px", i.body.appendChild(e);
  var t = i.createRange();
  e.innerHTML = typeof "".repeat == "function" ? "&#128104;".repeat(10) : "";
  var r = e.firstChild, n = uy(r.data).map(function(A) {
    return Oi(A);
  }), s = 0, a = {}, o = n.every(function(A, l) {
    t.setStart(r, s), t.setEnd(r, s + A.length);
    var h = t.getBoundingClientRect();
    s += A.length;
    var c = h.x > a.x || h.y > a.y;
    return a = h, l === 0 ? !0 : c;
  });
  return i.body.removeChild(e), o;
}, Uoe = function() {
  return typeof new Image().crossOrigin < "u";
}, Qoe = function() {
  return typeof new XMLHttpRequest().responseType == "string";
}, Doe = function(i) {
  var e = new Image(), t = i.createElement("canvas"), r = t.getContext("2d");
  if (!r)
    return !1;
  e.src = "data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg'></svg>";
  try {
    r.drawImage(e, 0, 0), t.toDataURL();
  } catch {
    return !1;
  }
  return !0;
}, NF = function(i) {
  return i[0] === 0 && i[1] === 255 && i[2] === 0 && i[3] === 255;
}, koe = function(i) {
  var e = i.createElement("canvas"), t = 100;
  e.width = t, e.height = t;
  var r = e.getContext("2d");
  if (!r)
    return Promise.reject(!1);
  r.fillStyle = "rgb(0, 255, 0)", r.fillRect(0, 0, t, t);
  var n = new Image(), s = e.toDataURL();
  n.src = s;
  var a = hC(t, t, 0, 0, n);
  return r.fillStyle = "red", r.fillRect(0, 0, t, t), PF(a).then(function(o) {
    r.drawImage(o, 0, 0);
    var A = r.getImageData(0, 0, t, t).data;
    r.fillStyle = "red", r.fillRect(0, 0, t, t);
    var l = i.createElement("div");
    return l.style.backgroundImage = "url(" + s + ")", l.style.height = t + "px", NF(A) ? PF(hC(t, t, 0, 0, l)) : Promise.reject(!1);
  }).then(function(o) {
    return r.drawImage(o, 0, 0), NF(r.getImageData(0, 0, t, t).data);
  }).catch(function() {
    return !1;
  });
}, hC = function(i, e, t, r, n) {
  var s = "http://www.w3.org/2000/svg", a = document.createElementNS(s, "svg"), o = document.createElementNS(s, "foreignObject");
  return a.setAttributeNS(null, "width", i.toString()), a.setAttributeNS(null, "height", e.toString()), o.setAttributeNS(null, "width", "100%"), o.setAttributeNS(null, "height", "100%"), o.setAttributeNS(null, "x", t.toString()), o.setAttributeNS(null, "y", r.toString()), o.setAttributeNS(null, "externalResourcesRequired", "true"), a.appendChild(o), o.appendChild(n), a;
}, PF = function(i) {
  return new Promise(function(e, t) {
    var r = new Image();
    r.onload = function() {
      return e(r);
    }, r.onerror = t, r.src = "data:image/svg+xml;charset=utf-8," + encodeURIComponent(new XMLSerializer().serializeToString(i));
  });
}, Tn = {
  get SUPPORT_RANGE_BOUNDS() {
    var i = Poe(document);
    return Object.defineProperty(Tn, "SUPPORT_RANGE_BOUNDS", { value: i }), i;
  },
  get SUPPORT_WORD_BREAKING() {
    var i = Tn.SUPPORT_RANGE_BOUNDS && Ooe(document);
    return Object.defineProperty(Tn, "SUPPORT_WORD_BREAKING", { value: i }), i;
  },
  get SUPPORT_SVG_DRAWING() {
    var i = Doe(document);
    return Object.defineProperty(Tn, "SUPPORT_SVG_DRAWING", { value: i }), i;
  },
  get SUPPORT_FOREIGNOBJECT_DRAWING() {
    var i = typeof Array.from == "function" && typeof window.fetch == "function" ? koe(document) : Promise.resolve(!1);
    return Object.defineProperty(Tn, "SUPPORT_FOREIGNOBJECT_DRAWING", { value: i }), i;
  },
  get SUPPORT_CORS_IMAGES() {
    var i = Uoe();
    return Object.defineProperty(Tn, "SUPPORT_CORS_IMAGES", { value: i }), i;
  },
  get SUPPORT_RESPONSE_TYPE() {
    var i = Qoe();
    return Object.defineProperty(Tn, "SUPPORT_RESPONSE_TYPE", { value: i }), i;
  },
  get SUPPORT_CORS_XHR() {
    var i = "withCredentials" in new XMLHttpRequest();
    return Object.defineProperty(Tn, "SUPPORT_CORS_XHR", { value: i }), i;
  },
  get SUPPORT_NATIVE_TEXT_SEGMENTATION() {
    var i = !!(typeof Intl < "u" && Intl.Segmenter);
    return Object.defineProperty(Tn, "SUPPORT_NATIVE_TEXT_SEGMENTATION", { value: i }), i;
  }
}, xd = (
  /** @class */
  function() {
    function i(e, t) {
      this.text = e, this.bounds = t;
    }
    return i;
  }()
), Hoe = function(i, e, t, r) {
  var n = Voe(e, t), s = [], a = 0;
  return n.forEach(function(o) {
    if (t.textDecorationLine.length || o.trim().length > 0)
      if (Tn.SUPPORT_RANGE_BOUNDS) {
        var A = OF(r, a, o.length).getClientRects();
        if (A.length > 1) {
          var l = zB(o), h = 0;
          l.forEach(function(u) {
            s.push(new xd(u, qo.fromDOMRectList(i, OF(r, h + a, u.length).getClientRects()))), h += u.length;
          });
        } else
          s.push(new xd(o, qo.fromDOMRectList(i, A)));
      } else {
        var c = r.splitText(o.length);
        s.push(new xd(o, Goe(i, r))), r = c;
      }
    else
      Tn.SUPPORT_RANGE_BOUNDS || (r = r.splitText(o.length));
    a += o.length;
  }), s;
}, Goe = function(i, e) {
  var t = e.ownerDocument;
  if (t) {
    var r = t.createElement("html2canvaswrapper");
    r.appendChild(e.cloneNode(!0));
    var n = e.parentNode;
    if (n) {
      n.replaceChild(r, e);
      var s = cy(i, r);
      return r.firstChild && n.replaceChild(r.firstChild, r), s;
    }
  }
  return qo.EMPTY;
}, OF = function(i, e, t) {
  var r = i.ownerDocument;
  if (!r)
    throw new Error("Node has no owner document");
  var n = r.createRange();
  return n.setStart(i, e), n.setEnd(i, e + t), n;
}, zB = function(i) {
  if (Tn.SUPPORT_NATIVE_TEXT_SEGMENTATION) {
    var e = new Intl.Segmenter(void 0, { granularity: "grapheme" });
    return Array.from(e.segment(i)).map(function(t) {
      return t.segment;
    });
  }
  return Noe(i);
}, $oe = function(i, e) {
  if (Tn.SUPPORT_NATIVE_TEXT_SEGMENTATION) {
    var t = new Intl.Segmenter(void 0, {
      granularity: "word"
    });
    return Array.from(t.segment(i)).map(function(r) {
      return r.segment;
    });
  }
  return joe(i, e);
}, Voe = function(i, e) {
  return e.letterSpacing !== 0 ? zB(i) : $oe(i, e);
}, Koe = [32, 160, 4961, 65792, 65793, 4153, 4241], joe = function(i, e) {
  for (var t = yne(i, {
    lineBreak: e.lineBreak,
    wordBreak: e.overflowWrap === "break-word" ? "break-word" : e.wordBreak
  }), r = [], n, s = function() {
    if (n.value) {
      var a = n.value.slice(), o = uy(a), A = "";
      o.forEach(function(l) {
        Koe.indexOf(l) === -1 ? A += Oi(l) : (A.length && r.push(A), r.push(Oi(l)), A = "");
      }), A.length && r.push(A);
    }
  }; !(n = t.next()).done; )
    s();
  return r;
}, zoe = (
  /** @class */
  function() {
    function i(e, t, r) {
      this.text = Xoe(t.data, r.textTransform), this.textBounds = Hoe(e, this.text, r, t);
    }
    return i;
  }()
), Xoe = function(i, e) {
  switch (e) {
    case 1:
      return i.toLowerCase();
    case 3:
      return i.replace(Woe, Yoe);
    case 2:
      return i.toUpperCase();
    default:
      return i;
  }
}, Woe = /(^|\s|:|-|\(|\))([a-z])/g, Yoe = function(i, e, t) {
  return i.length > 0 ? e + t.toUpperCase() : i;
}, VP = (
  /** @class */
  function(i) {
    La(e, i);
    function e(t, r) {
      var n = i.call(this, t, r) || this;
      return n.src = r.currentSrc || r.src, n.intrinsicWidth = r.naturalWidth, n.intrinsicHeight = r.naturalHeight, n.context.cache.addImage(n.src), n;
    }
    return e;
  }(so)
), KP = (
  /** @class */
  function(i) {
    La(e, i);
    function e(t, r) {
      var n = i.call(this, t, r) || this;
      return n.canvas = r, n.intrinsicWidth = r.width, n.intrinsicHeight = r.height, n;
    }
    return e;
  }(so)
), jP = (
  /** @class */
  function(i) {
    La(e, i);
    function e(t, r) {
      var n = i.call(this, t, r) || this, s = new XMLSerializer(), a = cy(t, r);
      return r.setAttribute("width", a.width + "px"), r.setAttribute("height", a.height + "px"), n.svg = "data:image/svg+xml," + encodeURIComponent(s.serializeToString(r)), n.intrinsicWidth = r.width.baseVal.value, n.intrinsicHeight = r.height.baseVal.value, n.context.cache.addImage(n.svg), n;
    }
    return e;
  }(so)
), zP = (
  /** @class */
  function(i) {
    La(e, i);
    function e(t, r) {
      var n = i.call(this, t, r) || this;
      return n.value = r.value, n;
    }
    return e;
  }(so)
), cC = (
  /** @class */
  function(i) {
    La(e, i);
    function e(t, r) {
      var n = i.call(this, t, r) || this;
      return n.start = r.start, n.reversed = typeof r.reversed == "boolean" && r.reversed === !0, n;
    }
    return e;
  }(so)
), qoe = [
  {
    type: 15,
    flags: 0,
    unit: "px",
    number: 3
  }
], Zoe = [
  {
    type: 16,
    flags: 0,
    number: 50
  }
], Joe = function(i) {
  return i.width > i.height ? new qo(i.left + (i.width - i.height) / 2, i.top, i.height, i.height) : i.width < i.height ? new qo(i.left, i.top + (i.height - i.width) / 2, i.width, i.width) : i;
}, eAe = function(i) {
  var e = i.type === tAe ? new Array(i.value.length + 1).join("") : i.value;
  return e.length === 0 ? i.placeholder || "" : e;
}, fv = "checkbox", dv = "radio", tAe = "password", UF = 707406591, XB = (
  /** @class */
  function(i) {
    La(e, i);
    function e(t, r) {
      var n = i.call(this, t, r) || this;
      switch (n.type = r.type.toLowerCase(), n.checked = r.checked, n.value = eAe(r), (n.type === fv || n.type === dv) && (n.styles.backgroundColor = 3739148031, n.styles.borderTopColor = n.styles.borderRightColor = n.styles.borderBottomColor = n.styles.borderLeftColor = 2779096575, n.styles.borderTopWidth = n.styles.borderRightWidth = n.styles.borderBottomWidth = n.styles.borderLeftWidth = 1, n.styles.borderTopStyle = n.styles.borderRightStyle = n.styles.borderBottomStyle = n.styles.borderLeftStyle = 1, n.styles.backgroundClip = [
        0
        /* BORDER_BOX */
      ], n.styles.backgroundOrigin = [
        0
        /* BORDER_BOX */
      ], n.bounds = Joe(n.bounds)), n.type) {
        case fv:
          n.styles.borderTopRightRadius = n.styles.borderTopLeftRadius = n.styles.borderBottomRightRadius = n.styles.borderBottomLeftRadius = qoe;
          break;
        case dv:
          n.styles.borderTopRightRadius = n.styles.borderTopLeftRadius = n.styles.borderBottomRightRadius = n.styles.borderBottomLeftRadius = Zoe;
          break;
      }
      return n;
    }
    return e;
  }(so)
), XP = (
  /** @class */
  function(i) {
    La(e, i);
    function e(t, r) {
      var n = i.call(this, t, r) || this, s = r.options[r.selectedIndex || 0];
      return n.value = s && s.text || "", n;
    }
    return e;
  }(so)
), WP = (
  /** @class */
  function(i) {
    La(e, i);
    function e(t, r) {
      var n = i.call(this, t, r) || this;
      return n.value = r.value, n;
    }
    return e;
  }(so)
), YP = (
  /** @class */
  function(i) {
    La(e, i);
    function e(t, r) {
      var n = i.call(this, t, r) || this;
      n.src = r.src, n.width = parseInt(r.width, 10) || 0, n.height = parseInt(r.height, 10) || 0, n.backgroundColor = n.styles.backgroundColor;
      try {
        if (r.contentWindow && r.contentWindow.document && r.contentWindow.document.documentElement) {
          n.tree = ZP(t, r.contentWindow.document.documentElement);
          var s = r.contentWindow.document.documentElement ? _d(t, getComputedStyle(r.contentWindow.document.documentElement).backgroundColor) : Ko.TRANSPARENT, a = r.contentWindow.document.body ? _d(t, getComputedStyle(r.contentWindow.document.body).backgroundColor) : Ko.TRANSPARENT;
          n.backgroundColor = al(s) ? al(a) ? n.styles.backgroundColor : a : s;
        }
      } catch {
      }
      return n;
    }
    return e;
  }(so)
), rAe = ["OL", "UL", "MENU"], rm = function(i, e, t, r) {
  for (var n = e.firstChild, s = void 0; n; n = s)
    if (s = n.nextSibling, JP(n) && n.data.trim().length > 0)
      t.textNodes.push(new zoe(i, n, t.styles));
    else if (jc(n))
      if (i3(n) && n.assignedNodes)
        n.assignedNodes().forEach(function(o) {
          return rm(i, o, t, r);
        });
      else {
        var a = qP(i, n);
        a.styles.isVisible() && (iAe(n, a, r) ? a.flags |= 4 : nAe(a.styles) && (a.flags |= 2), rAe.indexOf(n.tagName) !== -1 && (a.flags |= 8), t.elements.push(a), n.slot, n.shadowRoot ? rm(i, n.shadowRoot, a, r) : !gv(n) && !e3(n) && !pv(n) && rm(i, n, a, r));
      }
}, qP = function(i, e) {
  return fC(e) ? new VP(i, e) : t3(e) ? new KP(i, e) : e3(e) ? new jP(i, e) : sAe(e) ? new zP(i, e) : aAe(e) ? new cC(i, e) : oAe(e) ? new XB(i, e) : pv(e) ? new XP(i, e) : gv(e) ? new WP(i, e) : r3(e) ? new YP(i, e) : new so(i, e);
}, ZP = function(i, e) {
  var t = qP(i, e);
  return t.flags |= 4, rm(i, e, t, t), t;
}, iAe = function(i, e, t) {
  return e.styles.isPositionedWithZIndex() || e.styles.opacity < 1 || e.styles.isTransformed() || WB(i) && t.styles.isTransparent();
}, nAe = function(i) {
  return i.isPositioned() || i.isFloating();
}, JP = function(i) {
  return i.nodeType === Node.TEXT_NODE;
}, jc = function(i) {
  return i.nodeType === Node.ELEMENT_NODE;
}, uC = function(i) {
  return jc(i) && typeof i.style < "u" && !im(i);
}, im = function(i) {
  return typeof i.className == "object";
}, sAe = function(i) {
  return i.tagName === "LI";
}, aAe = function(i) {
  return i.tagName === "OL";
}, oAe = function(i) {
  return i.tagName === "INPUT";
}, AAe = function(i) {
  return i.tagName === "HTML";
}, e3 = function(i) {
  return i.tagName === "svg";
}, WB = function(i) {
  return i.tagName === "BODY";
}, t3 = function(i) {
  return i.tagName === "CANVAS";
}, QF = function(i) {
  return i.tagName === "VIDEO";
}, fC = function(i) {
  return i.tagName === "IMG";
}, r3 = function(i) {
  return i.tagName === "IFRAME";
}, DF = function(i) {
  return i.tagName === "STYLE";
}, lAe = function(i) {
  return i.tagName === "SCRIPT";
}, gv = function(i) {
  return i.tagName === "TEXTAREA";
}, pv = function(i) {
  return i.tagName === "SELECT";
}, i3 = function(i) {
  return i.tagName === "SLOT";
}, kF = function(i) {
  return i.tagName.indexOf("-") > 0;
}, hAe = (
  /** @class */
  function() {
    function i() {
      this.counters = {};
    }
    return i.prototype.getCounterValue = function(e) {
      var t = this.counters[e];
      return t && t.length ? t[t.length - 1] : 1;
    }, i.prototype.getCounterValues = function(e) {
      var t = this.counters[e];
      return t || [];
    }, i.prototype.pop = function(e) {
      var t = this;
      e.forEach(function(r) {
        return t.counters[r].pop();
      });
    }, i.prototype.parse = function(e) {
      var t = this, r = e.counterIncrement, n = e.counterReset, s = !0;
      r !== null && r.forEach(function(o) {
        var A = t.counters[o.counter];
        A && o.increment !== 0 && (s = !1, A.length || A.push(1), A[Math.max(0, A.length - 1)] += o.increment);
      });
      var a = [];
      return s && n.forEach(function(o) {
        var A = t.counters[o.counter];
        a.push(o.counter), A || (A = t.counters[o.counter] = []), A.push(o.reset);
      }), a;
    }, i;
  }()
), HF = {
  integers: [1e3, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1],
  values: ["M", "CM", "D", "CD", "C", "XC", "L", "XL", "X", "IX", "V", "IV", "I"]
}, GF = {
  integers: [
    9e3,
    8e3,
    7e3,
    6e3,
    5e3,
    4e3,
    3e3,
    2e3,
    1e3,
    900,
    800,
    700,
    600,
    500,
    400,
    300,
    200,
    100,
    90,
    80,
    70,
    60,
    50,
    40,
    30,
    20,
    10,
    9,
    8,
    7,
    6,
    5,
    4,
    3,
    2,
    1
  ],
  values: [
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    ""
  ]
}, cAe = {
  integers: [
    1e4,
    9e3,
    8e3,
    7e3,
    6e3,
    5e3,
    4e3,
    3e3,
    2e3,
    1e3,
    400,
    300,
    200,
    100,
    90,
    80,
    70,
    60,
    50,
    40,
    30,
    20,
    19,
    18,
    17,
    16,
    15,
    10,
    9,
    8,
    7,
    6,
    5,
    4,
    3,
    2,
    1
  ],
  values: [
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    ""
  ]
}, uAe = {
  integers: [
    1e4,
    9e3,
    8e3,
    7e3,
    6e3,
    5e3,
    4e3,
    3e3,
    2e3,
    1e3,
    900,
    800,
    700,
    600,
    500,
    400,
    300,
    200,
    100,
    90,
    80,
    70,
    60,
    50,
    40,
    30,
    20,
    10,
    9,
    8,
    7,
    6,
    5,
    4,
    3,
    2,
    1
  ],
  values: [
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    ""
  ]
}, gc = function(i, e, t, r, n, s) {
  return i < e || i > t ? tg(i, n, s.length > 0) : r.integers.reduce(function(a, o, A) {
    for (; i >= o; )
      i -= o, a += r.values[A];
    return a;
  }, "") + s;
}, n3 = function(i, e, t, r) {
  var n = "";
  do
    t || i--, n = r(i) + n, i /= e;
  while (i * e >= e);
  return n;
}, Ni = function(i, e, t, r, n) {
  var s = t - e + 1;
  return (i < 0 ? "-" : "") + (n3(Math.abs(i), s, r, function(a) {
    return Oi(Math.floor(a % s) + e);
  }) + n);
}, Ml = function(i, e, t) {
  t === void 0 && (t = ". ");
  var r = e.length;
  return n3(Math.abs(i), r, !1, function(n) {
    return e[Math.floor(n % r)];
  }) + t;
}, Ic = 1 << 0, DA = 1 << 1, kA = 1 << 2, ad = 1 << 3, Fo = function(i, e, t, r, n, s) {
  if (i < -9999 || i > 9999)
    return tg(i, 4, n.length > 0);
  var a = Math.abs(i), o = n;
  if (a === 0)
    return e[0] + o;
  for (var A = 0; a > 0 && A <= 4; A++) {
    var l = a % 10;
    l === 0 && on(s, Ic) && o !== "" ? o = e[l] + o : l > 1 || l === 1 && A === 0 || l === 1 && A === 1 && on(s, DA) || l === 1 && A === 1 && on(s, kA) && i > 100 || l === 1 && A > 1 && on(s, ad) ? o = e[l] + (A > 0 ? t[A - 1] : "") + o : l === 1 && A > 0 && (o = t[A - 1] + o), a = Math.floor(a / 10);
  }
  return (i < 0 ? r : "") + o;
}, $F = "", VF = "", KF = "", O_ = "", tg = function(i, e, t) {
  var r = t ? ". " : "", n = t ? "" : "", s = t ? ", " : "", a = t ? " " : "";
  switch (e) {
    case 0:
      return "" + a;
    case 1:
      return "" + a;
    case 2:
      return "" + a;
    case 5:
      var o = Ni(i, 48, 57, !0, r);
      return o.length < 4 ? "0" + o : o;
    case 4:
      return Ml(i, "", n);
    case 6:
      return gc(i, 1, 3999, HF, 3, r).toLowerCase();
    case 7:
      return gc(i, 1, 3999, HF, 3, r);
    case 8:
      return Ni(i, 945, 969, !1, r);
    case 9:
      return Ni(i, 97, 122, !1, r);
    case 10:
      return Ni(i, 65, 90, !1, r);
    case 11:
      return Ni(i, 1632, 1641, !0, r);
    case 12:
    case 49:
      return gc(i, 1, 9999, GF, 3, r);
    case 35:
      return gc(i, 1, 9999, GF, 3, r).toLowerCase();
    case 13:
      return Ni(i, 2534, 2543, !0, r);
    case 14:
    case 30:
      return Ni(i, 6112, 6121, !0, r);
    case 15:
      return Ml(i, "", n);
    case 16:
      return Ml(i, "", n);
    case 17:
    case 48:
      return Fo(i, "", $F, "", n, DA | kA | ad);
    case 47:
      return Fo(i, "", VF, "", n, Ic | DA | kA | ad);
    case 42:
      return Fo(i, "", $F, "", n, DA | kA | ad);
    case 41:
      return Fo(i, "", VF, "", n, Ic | DA | kA | ad);
    case 26:
      return Fo(i, "", "", KF, n, 0);
    case 25:
      return Fo(i, "", "", KF, n, Ic | DA | kA);
    case 31:
      return Fo(i, "", "", O_, s, Ic | DA | kA);
    case 33:
      return Fo(i, "", "", O_, s, 0);
    case 32:
      return Fo(i, "", "", O_, s, Ic | DA | kA);
    case 18:
      return Ni(i, 2406, 2415, !0, r);
    case 20:
      return gc(i, 1, 19999, uAe, 3, r);
    case 21:
      return Ni(i, 2790, 2799, !0, r);
    case 22:
      return Ni(i, 2662, 2671, !0, r);
    case 22:
      return gc(i, 1, 10999, cAe, 3, r);
    case 23:
      return Ml(i, "");
    case 24:
      return Ml(i, "");
    case 27:
      return Ni(i, 3302, 3311, !0, r);
    case 28:
      return Ml(i, "", n);
    case 29:
      return Ml(i, "", n);
    case 34:
      return Ni(i, 3792, 3801, !0, r);
    case 37:
      return Ni(i, 6160, 6169, !0, r);
    case 38:
      return Ni(i, 4160, 4169, !0, r);
    case 39:
      return Ni(i, 2918, 2927, !0, r);
    case 40:
      return Ni(i, 1776, 1785, !0, r);
    case 43:
      return Ni(i, 3046, 3055, !0, r);
    case 44:
      return Ni(i, 3174, 3183, !0, r);
    case 45:
      return Ni(i, 3664, 3673, !0, r);
    case 46:
      return Ni(i, 3872, 3881, !0, r);
    case 3:
    default:
      return Ni(i, 48, 57, !0, r);
  }
}, s3 = "data-html2canvas-ignore", jF = (
  /** @class */
  function() {
    function i(e, t, r) {
      if (this.context = e, this.options = r, this.scrolledElements = [], this.referenceElement = t, this.counters = new hAe(), this.quoteDepth = 0, !t.ownerDocument)
        throw new Error("Cloned element does not have an owner document");
      this.documentElement = this.cloneNode(t.ownerDocument.documentElement, !1);
    }
    return i.prototype.toIFrame = function(e, t) {
      var r = this, n = fAe(e, t);
      if (!n.contentWindow)
        return Promise.reject("Unable to find iframe window");
      var s = e.defaultView.pageXOffset, a = e.defaultView.pageYOffset, o = n.contentWindow, A = o.document, l = pAe(n).then(function() {
        return Zn(r, void 0, void 0, function() {
          var h, c;
          return Gn(this, function(u) {
            switch (u.label) {
              case 0:
                return this.scrolledElements.forEach(_Ae), o && (o.scrollTo(t.left, t.top), /(iPad|iPhone|iPod)/g.test(navigator.userAgent) && (o.scrollY !== t.top || o.scrollX !== t.left) && (this.context.logger.warn("Unable to restore scroll position for cloned document"), this.context.windowBounds = this.context.windowBounds.add(o.scrollX - t.left, o.scrollY - t.top, 0, 0))), h = this.options.onclone, c = this.clonedReferenceElement, typeof c > "u" ? [2, Promise.reject("Error finding the " + this.referenceElement.nodeName + " in the cloned document")] : A.fonts && A.fonts.ready ? [4, A.fonts.ready] : [3, 2];
              case 1:
                u.sent(), u.label = 2;
              case 2:
                return /(AppleWebKit)/g.test(navigator.userAgent) ? [4, gAe(A)] : [3, 4];
              case 3:
                u.sent(), u.label = 4;
              case 4:
                return typeof h == "function" ? [2, Promise.resolve().then(function() {
                  return h(A, c);
                }).then(function() {
                  return n;
                })] : [2, n];
            }
          });
        });
      });
      return A.open(), A.write(vAe(document.doctype) + "<html></html>"), yAe(this.referenceElement.ownerDocument, s, a), A.replaceChild(A.adoptNode(this.documentElement), A.documentElement), A.close(), l;
    }, i.prototype.createElementClone = function(e) {
      if (lC(
        e,
        2
        /* CLONE */
      ))
        debugger;
      if (t3(e))
        return this.createCanvasClone(e);
      if (QF(e))
        return this.createVideoClone(e);
      if (DF(e))
        return this.createStyleClone(e);
      var t = e.cloneNode(!1);
      return fC(t) && (fC(e) && e.currentSrc && e.currentSrc !== e.src && (t.src = e.currentSrc, t.srcset = ""), t.loading === "lazy" && (t.loading = "eager")), kF(t) ? this.createCustomElementClone(t) : t;
    }, i.prototype.createCustomElementClone = function(e) {
      var t = document.createElement("html2canvascustomelement");
      return U_(e.style, t), t;
    }, i.prototype.createStyleClone = function(e) {
      try {
        var t = e.sheet;
        if (t && t.cssRules) {
          var r = [].slice.call(t.cssRules, 0).reduce(function(s, a) {
            return a && typeof a.cssText == "string" ? s + a.cssText : s;
          }, ""), n = e.cloneNode(!1);
          return n.textContent = r, n;
        }
      } catch (s) {
        if (this.context.logger.error("Unable to access cssRules property", s), s.name !== "SecurityError")
          throw s;
      }
      return e.cloneNode(!1);
    }, i.prototype.createCanvasClone = function(e) {
      var t;
      if (this.options.inlineImages && e.ownerDocument) {
        var r = e.ownerDocument.createElement("img");
        try {
          return r.src = e.toDataURL(), r;
        } catch {
          this.context.logger.info("Unable to inline canvas contents, canvas is tainted", e);
        }
      }
      var n = e.cloneNode(!1);
      try {
        n.width = e.width, n.height = e.height;
        var s = e.getContext("2d"), a = n.getContext("2d");
        if (a)
          if (!this.options.allowTaint && s)
            a.putImageData(s.getImageData(0, 0, e.width, e.height), 0, 0);
          else {
            var o = (t = e.getContext("webgl2")) !== null && t !== void 0 ? t : e.getContext("webgl");
            if (o) {
              var A = o.getContextAttributes();
              (A == null ? void 0 : A.preserveDrawingBuffer) === !1 && this.context.logger.warn("Unable to clone WebGL context as it has preserveDrawingBuffer=false", e);
            }
            a.drawImage(e, 0, 0);
          }
        return n;
      } catch {
        this.context.logger.info("Unable to clone canvas as it is tainted", e);
      }
      return n;
    }, i.prototype.createVideoClone = function(e) {
      var t = e.ownerDocument.createElement("canvas");
      t.width = e.offsetWidth, t.height = e.offsetHeight;
      var r = t.getContext("2d");
      try {
        return r && (r.drawImage(e, 0, 0, t.width, t.height), this.options.allowTaint || r.getImageData(0, 0, t.width, t.height)), t;
      } catch {
        this.context.logger.info("Unable to clone video as it is tainted", e);
      }
      var n = e.ownerDocument.createElement("canvas");
      return n.width = e.offsetWidth, n.height = e.offsetHeight, n;
    }, i.prototype.appendChildNode = function(e, t, r) {
      (!jc(t) || !lAe(t) && !t.hasAttribute(s3) && (typeof this.options.ignoreElements != "function" || !this.options.ignoreElements(t))) && (!this.options.copyStyles || !jc(t) || !DF(t)) && e.appendChild(this.cloneNode(t, r));
    }, i.prototype.cloneChildNodes = function(e, t, r) {
      for (var n = this, s = e.shadowRoot ? e.shadowRoot.firstChild : e.firstChild; s; s = s.nextSibling)
        if (jc(s) && i3(s) && typeof s.assignedNodes == "function") {
          var a = s.assignedNodes();
          a.length && a.forEach(function(o) {
            return n.appendChildNode(t, o, r);
          });
        } else
          this.appendChildNode(t, s, r);
    }, i.prototype.cloneNode = function(e, t) {
      if (JP(e))
        return document.createTextNode(e.data);
      if (!e.ownerDocument)
        return e.cloneNode(!1);
      var r = e.ownerDocument.defaultView;
      if (r && jc(e) && (uC(e) || im(e))) {
        var n = this.createElementClone(e);
        n.style.transitionProperty = "none";
        var s = r.getComputedStyle(e), a = r.getComputedStyle(e, ":before"), o = r.getComputedStyle(e, ":after");
        this.referenceElement === e && uC(n) && (this.clonedReferenceElement = n), WB(n) && CAe(n);
        var A = this.counters.parse(new CF(this.context, s)), l = this.resolvePseudoContent(e, n, a, Cd.BEFORE);
        kF(e) && (t = !0), QF(e) || this.cloneChildNodes(e, n, t), l && n.insertBefore(l, n.firstChild);
        var h = this.resolvePseudoContent(e, n, o, Cd.AFTER);
        return h && n.appendChild(h), this.counters.pop(A), (s && (this.options.copyStyles || im(e)) && !r3(e) || t) && U_(s, n), (e.scrollTop !== 0 || e.scrollLeft !== 0) && this.scrolledElements.push([n, e.scrollLeft, e.scrollTop]), (gv(e) || pv(e)) && (gv(n) || pv(n)) && (n.value = e.value), n;
      }
      return e.cloneNode(!1);
    }, i.prototype.resolvePseudoContent = function(e, t, r, n) {
      var s = this;
      if (r) {
        var a = r.content, o = t.ownerDocument;
        if (!(!o || !a || a === "none" || a === "-moz-alt-content" || r.display === "none")) {
          this.counters.parse(new CF(this.context, r));
          var A = new soe(this.context, r), l = o.createElement("html2canvaspseudoelement");
          U_(r, l), A.content.forEach(function(c) {
            if (c.type === 0)
              l.appendChild(o.createTextNode(c.value));
            else if (c.type === 22) {
              var u = o.createElement("img");
              u.src = c.value, u.style.opacity = "1", l.appendChild(u);
            } else if (c.type === 18) {
              if (c.name === "attr") {
                var f = c.values.filter(Kr);
                f.length && l.appendChild(o.createTextNode(e.getAttribute(f[0].value) || ""));
              } else if (c.name === "counter") {
                var g = c.values.filter(Cu), p = g[0], y = g[1];
                if (p && Kr(p)) {
                  var v = s.counters.getCounterValue(p.value), w = y && Kr(y) ? AC.parse(s.context, y.value) : 3;
                  l.appendChild(o.createTextNode(tg(v, w, !1)));
                }
              } else if (c.name === "counters") {
                var C = c.values.filter(Cu), p = C[0], E = C[1], y = C[2];
                if (p && Kr(p)) {
                  var S = s.counters.getCounterValues(p.value), M = y && Kr(y) ? AC.parse(s.context, y.value) : 3, T = E && E.type === 0 ? E.value : "", F = S.map(function(I) {
                    return tg(I, M, !1);
                  }).join(T);
                  l.appendChild(o.createTextNode(F));
                }
              }
            } else if (c.type === 20)
              switch (c.value) {
                case "open-quote":
                  l.appendChild(o.createTextNode(xF(A.quotes, s.quoteDepth++, !0)));
                  break;
                case "close-quote":
                  l.appendChild(o.createTextNode(xF(A.quotes, --s.quoteDepth, !1)));
                  break;
                default:
                  l.appendChild(o.createTextNode(c.value));
              }
          }), l.className = dC + " " + gC;
          var h = n === Cd.BEFORE ? " " + dC : " " + gC;
          return im(t) ? t.className.baseValue += h : t.className += h, l;
        }
      }
    }, i.destroy = function(e) {
      return e.parentNode ? (e.parentNode.removeChild(e), !0) : !1;
    }, i;
  }()
), Cd;
(function(i) {
  i[i.BEFORE = 0] = "BEFORE", i[i.AFTER = 1] = "AFTER";
})(Cd || (Cd = {}));
var fAe = function(i, e) {
  var t = i.createElement("iframe");
  return t.className = "html2canvas-container", t.style.visibility = "hidden", t.style.position = "fixed", t.style.left = "-10000px", t.style.top = "0px", t.style.border = "0", t.width = e.width.toString(), t.height = e.height.toString(), t.scrolling = "no", t.setAttribute(s3, "true"), i.body.appendChild(t), t;
}, dAe = function(i) {
  return new Promise(function(e) {
    if (i.complete) {
      e();
      return;
    }
    if (!i.src) {
      e();
      return;
    }
    i.onload = e, i.onerror = e;
  });
}, gAe = function(i) {
  return Promise.all([].slice.call(i.images, 0).map(dAe));
}, pAe = function(i) {
  return new Promise(function(e, t) {
    var r = i.contentWindow;
    if (!r)
      return t("No window assigned for iframe");
    var n = r.document;
    r.onload = i.onload = function() {
      r.onload = i.onload = null;
      var s = setInterval(function() {
        n.body.childNodes.length > 0 && n.readyState === "complete" && (clearInterval(s), e(i));
      }, 50);
    };
  });
}, mAe = [
  "all",
  "d",
  "content"
  // Safari shows pseudoelements if content is set
], U_ = function(i, e) {
  for (var t = i.length - 1; t >= 0; t--) {
    var r = i.item(t);
    mAe.indexOf(r) === -1 && e.style.setProperty(r, i.getPropertyValue(r));
  }
  return e;
}, vAe = function(i) {
  var e = "";
  return i && (e += "<!DOCTYPE ", i.name && (e += i.name), i.internalSubset && (e += i.internalSubset), i.publicId && (e += '"' + i.publicId + '"'), i.systemId && (e += '"' + i.systemId + '"'), e += ">"), e;
}, yAe = function(i, e, t) {
  i && i.defaultView && (e !== i.defaultView.pageXOffset || t !== i.defaultView.pageYOffset) && i.defaultView.scrollTo(e, t);
}, _Ae = function(i) {
  var e = i[0], t = i[1], r = i[2];
  e.scrollLeft = t, e.scrollTop = r;
}, wAe = ":before", xAe = ":after", dC = "___html2canvas___pseudoelement_before", gC = "___html2canvas___pseudoelement_after", zF = `{
    content: "" !important;
    display: none !important;
}`, CAe = function(i) {
  EAe(i, "." + dC + wAe + zF + `
         .` + gC + xAe + zF);
}, EAe = function(i, e) {
  var t = i.ownerDocument;
  if (t) {
    var r = t.createElement("style");
    r.textContent = e, i.appendChild(r);
  }
}, a3 = (
  /** @class */
  function() {
    function i() {
    }
    return i.getOrigin = function(e) {
      var t = i._link;
      return t ? (t.href = e, t.href = t.href, t.protocol + t.hostname + t.port) : "about:blank";
    }, i.isSameOrigin = function(e) {
      return i.getOrigin(e) === i._origin;
    }, i.setContext = function(e) {
      i._link = e.document.createElement("a"), i._origin = i.getOrigin(e.location.href);
    }, i._origin = "about:blank", i;
  }()
), BAe = (
  /** @class */
  function() {
    function i(e, t) {
      this.context = e, this._options = t, this._cache = {};
    }
    return i.prototype.addImage = function(e) {
      var t = Promise.resolve();
      return this.has(e) || (D_(e) || FAe(e)) && (this._cache[e] = this.loadImage(e)).catch(function() {
      }), t;
    }, i.prototype.match = function(e) {
      return this._cache[e];
    }, i.prototype.loadImage = function(e) {
      return Zn(this, void 0, void 0, function() {
        var t, r, n, s, a = this;
        return Gn(this, function(o) {
          switch (o.label) {
            case 0:
              return t = a3.isSameOrigin(e), r = !Q_(e) && this._options.useCORS === !0 && Tn.SUPPORT_CORS_IMAGES && !t, n = !Q_(e) && !t && !D_(e) && typeof this._options.proxy == "string" && Tn.SUPPORT_CORS_XHR && !r, !t && this._options.allowTaint === !1 && !Q_(e) && !D_(e) && !n && !r ? [
                2
                /*return*/
              ] : (s = e, n ? [4, this.proxy(s)] : [3, 2]);
            case 1:
              s = o.sent(), o.label = 2;
            case 2:
              return this.context.logger.debug("Added image " + e.substring(0, 256)), [4, new Promise(function(A, l) {
                var h = new Image();
                h.onload = function() {
                  return A(h);
                }, h.onerror = l, (LAe(s) || r) && (h.crossOrigin = "anonymous"), h.src = s, h.complete === !0 && setTimeout(function() {
                  return A(h);
                }, 500), a._options.imageTimeout > 0 && setTimeout(function() {
                  return l("Timed out (" + a._options.imageTimeout + "ms) loading image");
                }, a._options.imageTimeout);
              })];
            case 3:
              return [2, o.sent()];
          }
        });
      });
    }, i.prototype.has = function(e) {
      return typeof this._cache[e] < "u";
    }, i.prototype.keys = function() {
      return Promise.resolve(Object.keys(this._cache));
    }, i.prototype.proxy = function(e) {
      var t = this, r = this._options.proxy;
      if (!r)
        throw new Error("No proxy defined");
      var n = e.substring(0, 256);
      return new Promise(function(s, a) {
        var o = Tn.SUPPORT_RESPONSE_TYPE ? "blob" : "text", A = new XMLHttpRequest();
        A.onload = function() {
          if (A.status === 200)
            if (o === "text")
              s(A.response);
            else {
              var c = new FileReader();
              c.addEventListener("load", function() {
                return s(c.result);
              }, !1), c.addEventListener("error", function(u) {
                return a(u);
              }, !1), c.readAsDataURL(A.response);
            }
          else
            a("Failed to proxy resource " + n + " with status code " + A.status);
        }, A.onerror = a;
        var l = r.indexOf("?") > -1 ? "&" : "?";
        if (A.open("GET", "" + r + l + "url=" + encodeURIComponent(e) + "&responseType=" + o), o !== "text" && A instanceof XMLHttpRequest && (A.responseType = o), t._options.imageTimeout) {
          var h = t._options.imageTimeout;
          A.timeout = h, A.ontimeout = function() {
            return a("Timed out (" + h + "ms) proxying " + n);
          };
        }
        A.send();
      });
    }, i;
  }()
), bAe = /^data:image\/svg\+xml/i, SAe = /^data:image\/.*;base64,/i, TAe = /^data:image\/.*/i, FAe = function(i) {
  return Tn.SUPPORT_SVG_DRAWING || !IAe(i);
}, Q_ = function(i) {
  return TAe.test(i);
}, LAe = function(i) {
  return SAe.test(i);
}, D_ = function(i) {
  return i.substr(0, 4) === "blob";
}, IAe = function(i) {
  return i.substr(-3).toLowerCase() === "svg" || bAe.test(i);
}, Ye = (
  /** @class */
  function() {
    function i(e, t) {
      this.type = 0, this.x = e, this.y = t;
    }
    return i.prototype.add = function(e, t) {
      return new i(this.x + e, this.y + t);
    }, i;
  }()
), pc = function(i, e, t) {
  return new Ye(i.x + (e.x - i.x) * t, i.y + (e.y - i.y) * t);
}, w0 = (
  /** @class */
  function() {
    function i(e, t, r, n) {
      this.type = 1, this.start = e, this.startControl = t, this.endControl = r, this.end = n;
    }
    return i.prototype.subdivide = function(e, t) {
      var r = pc(this.start, this.startControl, e), n = pc(this.startControl, this.endControl, e), s = pc(this.endControl, this.end, e), a = pc(r, n, e), o = pc(n, s, e), A = pc(a, o, e);
      return t ? new i(this.start, r, a, A) : new i(A, o, s, this.end);
    }, i.prototype.add = function(e, t) {
      return new i(this.start.add(e, t), this.startControl.add(e, t), this.endControl.add(e, t), this.end.add(e, t));
    }, i.prototype.reverse = function() {
      return new i(this.end, this.endControl, this.startControl, this.start);
    }, i;
  }()
), Ws = function(i) {
  return i.type === 1;
}, RAe = (
  /** @class */
  function() {
    function i(e) {
      var t = e.styles, r = e.bounds, n = nd(t.borderTopLeftRadius, r.width, r.height), s = n[0], a = n[1], o = nd(t.borderTopRightRadius, r.width, r.height), A = o[0], l = o[1], h = nd(t.borderBottomRightRadius, r.width, r.height), c = h[0], u = h[1], f = nd(t.borderBottomLeftRadius, r.width, r.height), g = f[0], p = f[1], y = [];
      y.push((s + A) / r.width), y.push((g + c) / r.width), y.push((a + p) / r.height), y.push((l + u) / r.height);
      var v = Math.max.apply(Math, y);
      v > 1 && (s /= v, a /= v, A /= v, l /= v, c /= v, u /= v, g /= v, p /= v);
      var w = r.width - A, C = r.height - u, E = r.width - c, S = r.height - p, M = t.borderTopWidth, T = t.borderRightWidth, F = t.borderBottomWidth, k = t.borderLeftWidth, $ = ti(t.paddingTop, e.bounds.width), I = ti(t.paddingRight, e.bounds.width), L = ti(t.paddingBottom, e.bounds.width), P = ti(t.paddingLeft, e.bounds.width);
      this.topLeftBorderDoubleOuterBox = s > 0 || a > 0 ? hi(r.left + k / 3, r.top + M / 3, s - k / 3, a - M / 3, Rr.TOP_LEFT) : new Ye(r.left + k / 3, r.top + M / 3), this.topRightBorderDoubleOuterBox = s > 0 || a > 0 ? hi(r.left + w, r.top + M / 3, A - T / 3, l - M / 3, Rr.TOP_RIGHT) : new Ye(r.left + r.width - T / 3, r.top + M / 3), this.bottomRightBorderDoubleOuterBox = c > 0 || u > 0 ? hi(r.left + E, r.top + C, c - T / 3, u - F / 3, Rr.BOTTOM_RIGHT) : new Ye(r.left + r.width - T / 3, r.top + r.height - F / 3), this.bottomLeftBorderDoubleOuterBox = g > 0 || p > 0 ? hi(r.left + k / 3, r.top + S, g - k / 3, p - F / 3, Rr.BOTTOM_LEFT) : new Ye(r.left + k / 3, r.top + r.height - F / 3), this.topLeftBorderDoubleInnerBox = s > 0 || a > 0 ? hi(r.left + k * 2 / 3, r.top + M * 2 / 3, s - k * 2 / 3, a - M * 2 / 3, Rr.TOP_LEFT) : new Ye(r.left + k * 2 / 3, r.top + M * 2 / 3), this.topRightBorderDoubleInnerBox = s > 0 || a > 0 ? hi(r.left + w, r.top + M * 2 / 3, A - T * 2 / 3, l - M * 2 / 3, Rr.TOP_RIGHT) : new Ye(r.left + r.width - T * 2 / 3, r.top + M * 2 / 3), this.bottomRightBorderDoubleInnerBox = c > 0 || u > 0 ? hi(r.left + E, r.top + C, c - T * 2 / 3, u - F * 2 / 3, Rr.BOTTOM_RIGHT) : new Ye(r.left + r.width - T * 2 / 3, r.top + r.height - F * 2 / 3), this.bottomLeftBorderDoubleInnerBox = g > 0 || p > 0 ? hi(r.left + k * 2 / 3, r.top + S, g - k * 2 / 3, p - F * 2 / 3, Rr.BOTTOM_LEFT) : new Ye(r.left + k * 2 / 3, r.top + r.height - F * 2 / 3), this.topLeftBorderStroke = s > 0 || a > 0 ? hi(r.left + k / 2, r.top + M / 2, s - k / 2, a - M / 2, Rr.TOP_LEFT) : new Ye(r.left + k / 2, r.top + M / 2), this.topRightBorderStroke = s > 0 || a > 0 ? hi(r.left + w, r.top + M / 2, A - T / 2, l - M / 2, Rr.TOP_RIGHT) : new Ye(r.left + r.width - T / 2, r.top + M / 2), this.bottomRightBorderStroke = c > 0 || u > 0 ? hi(r.left + E, r.top + C, c - T / 2, u - F / 2, Rr.BOTTOM_RIGHT) : new Ye(r.left + r.width - T / 2, r.top + r.height - F / 2), this.bottomLeftBorderStroke = g > 0 || p > 0 ? hi(r.left + k / 2, r.top + S, g - k / 2, p - F / 2, Rr.BOTTOM_LEFT) : new Ye(r.left + k / 2, r.top + r.height - F / 2), this.topLeftBorderBox = s > 0 || a > 0 ? hi(r.left, r.top, s, a, Rr.TOP_LEFT) : new Ye(r.left, r.top), this.topRightBorderBox = A > 0 || l > 0 ? hi(r.left + w, r.top, A, l, Rr.TOP_RIGHT) : new Ye(r.left + r.width, r.top), this.bottomRightBorderBox = c > 0 || u > 0 ? hi(r.left + E, r.top + C, c, u, Rr.BOTTOM_RIGHT) : new Ye(r.left + r.width, r.top + r.height), this.bottomLeftBorderBox = g > 0 || p > 0 ? hi(r.left, r.top + S, g, p, Rr.BOTTOM_LEFT) : new Ye(r.left, r.top + r.height), this.topLeftPaddingBox = s > 0 || a > 0 ? hi(r.left + k, r.top + M, Math.max(0, s - k), Math.max(0, a - M), Rr.TOP_LEFT) : new Ye(r.left + k, r.top + M), this.topRightPaddingBox = A > 0 || l > 0 ? hi(r.left + Math.min(w, r.width - T), r.top + M, w > r.width + T ? 0 : Math.max(0, A - T), Math.max(0, l - M), Rr.TOP_RIGHT) : new Ye(r.left + r.width - T, r.top + M), this.bottomRightPaddingBox = c > 0 || u > 0 ? hi(r.left + Math.min(E, r.width - k), r.top + Math.min(C, r.height - F), Math.max(0, c - T), Math.max(0, u - F), Rr.BOTTOM_RIGHT) : new Ye(r.left + r.width - T, r.top + r.height - F), this.bottomLeftPaddingBox = g > 0 || p > 0 ? hi(r.left + k, r.top + Math.min(S, r.height - F), Math.max(0, g - k), Math.max(0, p - F), Rr.BOTTOM_LEFT) : new Ye(r.left + k, r.top + r.height - F), this.topLeftContentBox = s > 0 || a > 0 ? hi(r.left + k + P, r.top + M + $, Math.max(0, s - (k + P)), Math.max(0, a - (M + $)), Rr.TOP_LEFT) : new Ye(r.left + k + P, r.top + M + $), this.topRightContentBox = A > 0 || l > 0 ? hi(r.left + Math.min(w, r.width + k + P), r.top + M + $, w > r.width + k + P ? 0 : A - k + P, l - (M + $), Rr.TOP_RIGHT) : new Ye(r.left + r.width - (T + I), r.top + M + $), this.bottomRightContentBox = c > 0 || u > 0 ? hi(r.left + Math.min(E, r.width - (k + P)), r.top + Math.min(C, r.height + M + $), Math.max(0, c - (T + I)), u - (F + L), Rr.BOTTOM_RIGHT) : new Ye(r.left + r.width - (T + I), r.top + r.height - (F + L)), this.bottomLeftContentBox = g > 0 || p > 0 ? hi(r.left + k + P, r.top + S, Math.max(0, g - (k + P)), p - (F + L), Rr.BOTTOM_LEFT) : new Ye(r.left + k + P, r.top + r.height - (F + L));
    }
    return i;
  }()
), Rr;
(function(i) {
  i[i.TOP_LEFT = 0] = "TOP_LEFT", i[i.TOP_RIGHT = 1] = "TOP_RIGHT", i[i.BOTTOM_RIGHT = 2] = "BOTTOM_RIGHT", i[i.BOTTOM_LEFT = 3] = "BOTTOM_LEFT";
})(Rr || (Rr = {}));
var hi = function(i, e, t, r, n) {
  var s = 4 * ((Math.sqrt(2) - 1) / 3), a = t * s, o = r * s, A = i + t, l = e + r;
  switch (n) {
    case Rr.TOP_LEFT:
      return new w0(new Ye(i, l), new Ye(i, l - o), new Ye(A - a, e), new Ye(A, e));
    case Rr.TOP_RIGHT:
      return new w0(new Ye(i, e), new Ye(i + a, e), new Ye(A, l - o), new Ye(A, l));
    case Rr.BOTTOM_RIGHT:
      return new w0(new Ye(A, e), new Ye(A, e + o), new Ye(i + a, l), new Ye(i, l));
    case Rr.BOTTOM_LEFT:
    default:
      return new w0(new Ye(A, l), new Ye(A - a, l), new Ye(i, e + o), new Ye(i, e));
  }
}, mv = function(i) {
  return [i.topLeftBorderBox, i.topRightBorderBox, i.bottomRightBorderBox, i.bottomLeftBorderBox];
}, MAe = function(i) {
  return [
    i.topLeftContentBox,
    i.topRightContentBox,
    i.bottomRightContentBox,
    i.bottomLeftContentBox
  ];
}, vv = function(i) {
  return [
    i.topLeftPaddingBox,
    i.topRightPaddingBox,
    i.bottomRightPaddingBox,
    i.bottomLeftPaddingBox
  ];
}, NAe = (
  /** @class */
  function() {
    function i(e, t, r) {
      this.offsetX = e, this.offsetY = t, this.matrix = r, this.type = 0, this.target = 6;
    }
    return i;
  }()
), x0 = (
  /** @class */
  function() {
    function i(e, t) {
      this.path = e, this.target = t, this.type = 1;
    }
    return i;
  }()
), PAe = (
  /** @class */
  function() {
    function i(e) {
      this.opacity = e, this.type = 2, this.target = 6;
    }
    return i;
  }()
), OAe = function(i) {
  return i.type === 0;
}, o3 = function(i) {
  return i.type === 1;
}, UAe = function(i) {
  return i.type === 2;
}, XF = function(i, e) {
  return i.length === e.length ? i.some(function(t, r) {
    return t === e[r];
  }) : !1;
}, QAe = function(i, e, t, r, n) {
  return i.map(function(s, a) {
    switch (a) {
      case 0:
        return s.add(e, t);
      case 1:
        return s.add(e + r, t);
      case 2:
        return s.add(e + r, t + n);
      case 3:
        return s.add(e, t + n);
    }
    return s;
  });
}, A3 = (
  /** @class */
  function() {
    function i(e) {
      this.element = e, this.inlineLevel = [], this.nonInlineLevel = [], this.negativeZIndex = [], this.zeroOrAutoZIndexOrTransformedOrOpacity = [], this.positiveZIndex = [], this.nonPositionedFloats = [], this.nonPositionedInlineLevel = [];
    }
    return i;
  }()
), l3 = (
  /** @class */
  function() {
    function i(e, t) {
      if (this.container = e, this.parent = t, this.effects = [], this.curves = new RAe(this.container), this.container.styles.opacity < 1 && this.effects.push(new PAe(this.container.styles.opacity)), this.container.styles.transform !== null) {
        var r = this.container.bounds.left + this.container.styles.transformOrigin[0].number, n = this.container.bounds.top + this.container.styles.transformOrigin[1].number, s = this.container.styles.transform;
        this.effects.push(new NAe(r, n, s));
      }
      if (this.container.styles.overflowX !== 0) {
        var a = mv(this.curves), o = vv(this.curves);
        XF(a, o) ? this.effects.push(new x0(
          a,
          6
          /* CONTENT */
        )) : (this.effects.push(new x0(
          a,
          2
          /* BACKGROUND_BORDERS */
        )), this.effects.push(new x0(
          o,
          4
          /* CONTENT */
        )));
      }
    }
    return i.prototype.getEffects = function(e) {
      for (var t = [
        2,
        3
        /* FIXED */
      ].indexOf(this.container.styles.position) === -1, r = this.parent, n = this.effects.slice(0); r; ) {
        var s = r.effects.filter(function(A) {
          return !o3(A);
        });
        if (t || r.container.styles.position !== 0 || !r.parent) {
          if (n.unshift.apply(n, s), t = [
            2,
            3
            /* FIXED */
          ].indexOf(r.container.styles.position) === -1, r.container.styles.overflowX !== 0) {
            var a = mv(r.curves), o = vv(r.curves);
            XF(a, o) || n.unshift(new x0(
              o,
              6
              /* CONTENT */
            ));
          }
        } else
          n.unshift.apply(n, s);
        r = r.parent;
      }
      return n.filter(function(A) {
        return on(A.target, e);
      });
    }, i;
  }()
), pC = function(i, e, t, r) {
  i.container.elements.forEach(function(n) {
    var s = on(
      n.flags,
      4
      /* CREATES_REAL_STACKING_CONTEXT */
    ), a = on(
      n.flags,
      2
      /* CREATES_STACKING_CONTEXT */
    ), o = new l3(n, i);
    on(
      n.styles.display,
      2048
      /* LIST_ITEM */
    ) && r.push(o);
    var A = on(
      n.flags,
      8
      /* IS_LIST_OWNER */
    ) ? [] : r;
    if (s || a) {
      var l = s || n.styles.isPositioned() ? t : e, h = new A3(o);
      if (n.styles.isPositioned() || n.styles.opacity < 1 || n.styles.isTransformed()) {
        var c = n.styles.zIndex.order;
        if (c < 0) {
          var u = 0;
          l.negativeZIndex.some(function(g, p) {
            return c > g.element.container.styles.zIndex.order ? (u = p, !1) : u > 0;
          }), l.negativeZIndex.splice(u, 0, h);
        } else if (c > 0) {
          var f = 0;
          l.positiveZIndex.some(function(g, p) {
            return c >= g.element.container.styles.zIndex.order ? (f = p + 1, !1) : f > 0;
          }), l.positiveZIndex.splice(f, 0, h);
        } else
          l.zeroOrAutoZIndexOrTransformedOrOpacity.push(h);
      } else
        n.styles.isFloating() ? l.nonPositionedFloats.push(h) : l.nonPositionedInlineLevel.push(h);
      pC(o, h, s ? h : t, A);
    } else
      n.styles.isInlineLevel() ? e.inlineLevel.push(o) : e.nonInlineLevel.push(o), pC(o, e, t, A);
    on(
      n.flags,
      8
      /* IS_LIST_OWNER */
    ) && h3(n, A);
  });
}, h3 = function(i, e) {
  for (var t = i instanceof cC ? i.start : 1, r = i instanceof cC ? i.reversed : !1, n = 0; n < e.length; n++) {
    var s = e[n];
    s.container instanceof zP && typeof s.container.value == "number" && s.container.value !== 0 && (t = s.container.value), s.listValue = tg(t, s.container.styles.listStyleType, !0), t += r ? -1 : 1;
  }
}, DAe = function(i) {
  var e = new l3(i, null), t = new A3(e), r = [];
  return pC(e, t, t, r), h3(e.container, r), t;
}, WF = function(i, e) {
  switch (e) {
    case 0:
      return Zs(i.topLeftBorderBox, i.topLeftPaddingBox, i.topRightBorderBox, i.topRightPaddingBox);
    case 1:
      return Zs(i.topRightBorderBox, i.topRightPaddingBox, i.bottomRightBorderBox, i.bottomRightPaddingBox);
    case 2:
      return Zs(i.bottomRightBorderBox, i.bottomRightPaddingBox, i.bottomLeftBorderBox, i.bottomLeftPaddingBox);
    case 3:
    default:
      return Zs(i.bottomLeftBorderBox, i.bottomLeftPaddingBox, i.topLeftBorderBox, i.topLeftPaddingBox);
  }
}, kAe = function(i, e) {
  switch (e) {
    case 0:
      return Zs(i.topLeftBorderBox, i.topLeftBorderDoubleOuterBox, i.topRightBorderBox, i.topRightBorderDoubleOuterBox);
    case 1:
      return Zs(i.topRightBorderBox, i.topRightBorderDoubleOuterBox, i.bottomRightBorderBox, i.bottomRightBorderDoubleOuterBox);
    case 2:
      return Zs(i.bottomRightBorderBox, i.bottomRightBorderDoubleOuterBox, i.bottomLeftBorderBox, i.bottomLeftBorderDoubleOuterBox);
    case 3:
    default:
      return Zs(i.bottomLeftBorderBox, i.bottomLeftBorderDoubleOuterBox, i.topLeftBorderBox, i.topLeftBorderDoubleOuterBox);
  }
}, HAe = function(i, e) {
  switch (e) {
    case 0:
      return Zs(i.topLeftBorderDoubleInnerBox, i.topLeftPaddingBox, i.topRightBorderDoubleInnerBox, i.topRightPaddingBox);
    case 1:
      return Zs(i.topRightBorderDoubleInnerBox, i.topRightPaddingBox, i.bottomRightBorderDoubleInnerBox, i.bottomRightPaddingBox);
    case 2:
      return Zs(i.bottomRightBorderDoubleInnerBox, i.bottomRightPaddingBox, i.bottomLeftBorderDoubleInnerBox, i.bottomLeftPaddingBox);
    case 3:
    default:
      return Zs(i.bottomLeftBorderDoubleInnerBox, i.bottomLeftPaddingBox, i.topLeftBorderDoubleInnerBox, i.topLeftPaddingBox);
  }
}, GAe = function(i, e) {
  switch (e) {
    case 0:
      return C0(i.topLeftBorderStroke, i.topRightBorderStroke);
    case 1:
      return C0(i.topRightBorderStroke, i.bottomRightBorderStroke);
    case 2:
      return C0(i.bottomRightBorderStroke, i.bottomLeftBorderStroke);
    case 3:
    default:
      return C0(i.bottomLeftBorderStroke, i.topLeftBorderStroke);
  }
}, C0 = function(i, e) {
  var t = [];
  return Ws(i) ? t.push(i.subdivide(0.5, !1)) : t.push(i), Ws(e) ? t.push(e.subdivide(0.5, !0)) : t.push(e), t;
}, Zs = function(i, e, t, r) {
  var n = [];
  return Ws(i) ? n.push(i.subdivide(0.5, !1)) : n.push(i), Ws(t) ? n.push(t.subdivide(0.5, !0)) : n.push(t), Ws(r) ? n.push(r.subdivide(0.5, !0).reverse()) : n.push(r), Ws(e) ? n.push(e.subdivide(0.5, !1).reverse()) : n.push(e), n;
}, c3 = function(i) {
  var e = i.bounds, t = i.styles;
  return e.add(t.borderLeftWidth, t.borderTopWidth, -(t.borderRightWidth + t.borderLeftWidth), -(t.borderTopWidth + t.borderBottomWidth));
}, yv = function(i) {
  var e = i.styles, t = i.bounds, r = ti(e.paddingLeft, t.width), n = ti(e.paddingRight, t.width), s = ti(e.paddingTop, t.width), a = ti(e.paddingBottom, t.width);
  return t.add(r + e.borderLeftWidth, s + e.borderTopWidth, -(e.borderRightWidth + e.borderLeftWidth + r + n), -(e.borderTopWidth + e.borderBottomWidth + s + a));
}, $Ae = function(i, e) {
  return i === 0 ? e.bounds : i === 2 ? yv(e) : c3(e);
}, VAe = function(i, e) {
  return i === 0 ? e.bounds : i === 2 ? yv(e) : c3(e);
}, k_ = function(i, e, t) {
  var r = $Ae(Rc(i.styles.backgroundOrigin, e), i), n = VAe(Rc(i.styles.backgroundClip, e), i), s = KAe(Rc(i.styles.backgroundSize, e), t, r), a = s[0], o = s[1], A = nd(Rc(i.styles.backgroundPosition, e), r.width - a, r.height - o), l = jAe(Rc(i.styles.backgroundRepeat, e), A, s, r, n), h = Math.round(r.left + A[0]), c = Math.round(r.top + A[1]);
  return [l, h, c, a, o];
}, mc = function(i) {
  return Kr(i) && i.value === ou.AUTO;
}, E0 = function(i) {
  return typeof i == "number";
}, KAe = function(i, e, t) {
  var r = e[0], n = e[1], s = e[2], a = i[0], o = i[1];
  if (!a)
    return [0, 0];
  if (Wi(a) && o && Wi(o))
    return [ti(a, t.width), ti(o, t.height)];
  var A = E0(s);
  if (Kr(a) && (a.value === ou.CONTAIN || a.value === ou.COVER)) {
    if (E0(s)) {
      var l = t.width / t.height;
      return l < s != (a.value === ou.COVER) ? [t.width, t.width / s] : [t.height * s, t.height];
    }
    return [t.width, t.height];
  }
  var h = E0(r), c = E0(n), u = h || c;
  if (mc(a) && (!o || mc(o))) {
    if (h && c)
      return [r, n];
    if (!A && !u)
      return [t.width, t.height];
    if (u && A) {
      var f = h ? r : n * s, g = c ? n : r / s;
      return [f, g];
    }
    var p = h ? r : t.width, y = c ? n : t.height;
    return [p, y];
  }
  if (A) {
    var v = 0, w = 0;
    return Wi(a) ? v = ti(a, t.width) : Wi(o) && (w = ti(o, t.height)), mc(a) ? v = w * s : (!o || mc(o)) && (w = v / s), [v, w];
  }
  var C = null, E = null;
  if (Wi(a) ? C = ti(a, t.width) : o && Wi(o) && (E = ti(o, t.height)), C !== null && (!o || mc(o)) && (E = h && c ? C / r * n : t.height), E !== null && mc(a) && (C = h && c ? E / n * r : t.width), C !== null && E !== null)
    return [C, E];
  throw new Error("Unable to calculate background-size for element");
}, Rc = function(i, e) {
  var t = i[e];
  return typeof t > "u" ? i[0] : t;
}, jAe = function(i, e, t, r, n) {
  var s = e[0], a = e[1], o = t[0], A = t[1];
  switch (i) {
    case 2:
      return [
        new Ye(Math.round(r.left), Math.round(r.top + a)),
        new Ye(Math.round(r.left + r.width), Math.round(r.top + a)),
        new Ye(Math.round(r.left + r.width), Math.round(A + r.top + a)),
        new Ye(Math.round(r.left), Math.round(A + r.top + a))
      ];
    case 3:
      return [
        new Ye(Math.round(r.left + s), Math.round(r.top)),
        new Ye(Math.round(r.left + s + o), Math.round(r.top)),
        new Ye(Math.round(r.left + s + o), Math.round(r.height + r.top)),
        new Ye(Math.round(r.left + s), Math.round(r.height + r.top))
      ];
    case 1:
      return [
        new Ye(Math.round(r.left + s), Math.round(r.top + a)),
        new Ye(Math.round(r.left + s + o), Math.round(r.top + a)),
        new Ye(Math.round(r.left + s + o), Math.round(r.top + a + A)),
        new Ye(Math.round(r.left + s), Math.round(r.top + a + A))
      ];
    default:
      return [
        new Ye(Math.round(n.left), Math.round(n.top)),
        new Ye(Math.round(n.left + n.width), Math.round(n.top)),
        new Ye(Math.round(n.left + n.width), Math.round(n.height + n.top)),
        new Ye(Math.round(n.left), Math.round(n.height + n.top))
      ];
  }
}, zAe = "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7", YF = "Hidden Text", XAe = (
  /** @class */
  function() {
    function i(e) {
      this._data = {}, this._document = e;
    }
    return i.prototype.parseMetrics = function(e, t) {
      var r = this._document.createElement("div"), n = this._document.createElement("img"), s = this._document.createElement("span"), a = this._document.body;
      r.style.visibility = "hidden", r.style.fontFamily = e, r.style.fontSize = t, r.style.margin = "0", r.style.padding = "0", r.style.whiteSpace = "nowrap", a.appendChild(r), n.src = zAe, n.width = 1, n.height = 1, n.style.margin = "0", n.style.padding = "0", n.style.verticalAlign = "baseline", s.style.fontFamily = e, s.style.fontSize = t, s.style.margin = "0", s.style.padding = "0", s.appendChild(this._document.createTextNode(YF)), r.appendChild(s), r.appendChild(n);
      var o = n.offsetTop - s.offsetTop + 2;
      r.removeChild(s), r.appendChild(this._document.createTextNode(YF)), r.style.lineHeight = "normal", n.style.verticalAlign = "super";
      var A = n.offsetTop - r.offsetTop + 2;
      return a.removeChild(r), { baseline: o, middle: A };
    }, i.prototype.getMetrics = function(e, t) {
      var r = e + " " + t;
      return typeof this._data[r] > "u" && (this._data[r] = this.parseMetrics(e, t)), this._data[r];
    }, i;
  }()
), u3 = (
  /** @class */
  function() {
    function i(e, t) {
      this.context = e, this.options = t;
    }
    return i;
  }()
), WAe = 1e4, YAe = (
  /** @class */
  function(i) {
    La(e, i);
    function e(t, r) {
      var n = i.call(this, t, r) || this;
      return n._activeEffects = [], n.canvas = r.canvas ? r.canvas : document.createElement("canvas"), n.ctx = n.canvas.getContext("2d"), r.canvas || (n.canvas.width = Math.floor(r.width * r.scale), n.canvas.height = Math.floor(r.height * r.scale), n.canvas.style.width = r.width + "px", n.canvas.style.height = r.height + "px"), n.fontMetrics = new XAe(document), n.ctx.scale(n.options.scale, n.options.scale), n.ctx.translate(-r.x, -r.y), n.ctx.textBaseline = "bottom", n._activeEffects = [], n.context.logger.debug("Canvas renderer initialized (" + r.width + "x" + r.height + ") with scale " + r.scale), n;
    }
    return e.prototype.applyEffects = function(t) {
      for (var r = this; this._activeEffects.length; )
        this.popEffect();
      t.forEach(function(n) {
        return r.applyEffect(n);
      });
    }, e.prototype.applyEffect = function(t) {
      this.ctx.save(), UAe(t) && (this.ctx.globalAlpha = t.opacity), OAe(t) && (this.ctx.translate(t.offsetX, t.offsetY), this.ctx.transform(t.matrix[0], t.matrix[1], t.matrix[2], t.matrix[3], t.matrix[4], t.matrix[5]), this.ctx.translate(-t.offsetX, -t.offsetY)), o3(t) && (this.path(t.path), this.ctx.clip()), this._activeEffects.push(t);
    }, e.prototype.popEffect = function() {
      this._activeEffects.pop(), this.ctx.restore();
    }, e.prototype.renderStack = function(t) {
      return Zn(this, void 0, void 0, function() {
        var r;
        return Gn(this, function(n) {
          switch (n.label) {
            case 0:
              return r = t.element.container.styles, r.isVisible() ? [4, this.renderStackContent(t)] : [3, 2];
            case 1:
              n.sent(), n.label = 2;
            case 2:
              return [
                2
                /*return*/
              ];
          }
        });
      });
    }, e.prototype.renderNode = function(t) {
      return Zn(this, void 0, void 0, function() {
        return Gn(this, function(r) {
          switch (r.label) {
            case 0:
              if (on(
                t.container.flags,
                16
                /* DEBUG_RENDER */
              ))
                debugger;
              return t.container.styles.isVisible() ? [4, this.renderNodeBackgroundAndBorders(t)] : [3, 3];
            case 1:
              return r.sent(), [4, this.renderNodeContent(t)];
            case 2:
              r.sent(), r.label = 3;
            case 3:
              return [
                2
                /*return*/
              ];
          }
        });
      });
    }, e.prototype.renderTextWithLetterSpacing = function(t, r, n) {
      var s = this;
      if (r === 0)
        this.ctx.fillText(t.text, t.bounds.left, t.bounds.top + n);
      else {
        var a = zB(t.text);
        a.reduce(function(o, A) {
          return s.ctx.fillText(A, o, t.bounds.top + n), o + s.ctx.measureText(A).width;
        }, t.bounds.left);
      }
    }, e.prototype.createFontStyle = function(t) {
      var r = t.fontVariant.filter(function(a) {
        return a === "normal" || a === "small-caps";
      }).join(""), n = tle(t.fontFamily).join(", "), s = Lg(t.fontSize) ? "" + t.fontSize.number + t.fontSize.unit : t.fontSize.number + "px";
      return [
        [t.fontStyle, r, t.fontWeight, s, n].join(" "),
        n,
        s
      ];
    }, e.prototype.renderTextNode = function(t, r) {
      return Zn(this, void 0, void 0, function() {
        var n, s, a, o, A, l, h, c, u = this;
        return Gn(this, function(f) {
          return n = this.createFontStyle(r), s = n[0], a = n[1], o = n[2], this.ctx.font = s, this.ctx.direction = r.direction === 1 ? "rtl" : "ltr", this.ctx.textAlign = "left", this.ctx.textBaseline = "alphabetic", A = this.fontMetrics.getMetrics(a, o), l = A.baseline, h = A.middle, c = r.paintOrder, t.textBounds.forEach(function(g) {
            c.forEach(function(p) {
              switch (p) {
                case 0:
                  u.ctx.fillStyle = mn(r.color), u.renderTextWithLetterSpacing(g, r.letterSpacing, l);
                  var y = r.textShadow;
                  y.length && g.text.trim().length && (y.slice(0).reverse().forEach(function(v) {
                    u.ctx.shadowColor = mn(v.color), u.ctx.shadowOffsetX = v.offsetX.number * u.options.scale, u.ctx.shadowOffsetY = v.offsetY.number * u.options.scale, u.ctx.shadowBlur = v.blur.number, u.renderTextWithLetterSpacing(g, r.letterSpacing, l);
                  }), u.ctx.shadowColor = "", u.ctx.shadowOffsetX = 0, u.ctx.shadowOffsetY = 0, u.ctx.shadowBlur = 0), r.textDecorationLine.length && (u.ctx.fillStyle = mn(r.textDecorationColor || r.color), r.textDecorationLine.forEach(function(v) {
                    switch (v) {
                      case 1:
                        u.ctx.fillRect(g.bounds.left, Math.round(g.bounds.top + l), g.bounds.width, 1);
                        break;
                      case 2:
                        u.ctx.fillRect(g.bounds.left, Math.round(g.bounds.top), g.bounds.width, 1);
                        break;
                      case 3:
                        u.ctx.fillRect(g.bounds.left, Math.ceil(g.bounds.top + h), g.bounds.width, 1);
                        break;
                    }
                  }));
                  break;
                case 1:
                  r.webkitTextStrokeWidth && g.text.trim().length && (u.ctx.strokeStyle = mn(r.webkitTextStrokeColor), u.ctx.lineWidth = r.webkitTextStrokeWidth, u.ctx.lineJoin = window.chrome ? "miter" : "round", u.ctx.strokeText(g.text, g.bounds.left, g.bounds.top + l)), u.ctx.strokeStyle = "", u.ctx.lineWidth = 0, u.ctx.lineJoin = "miter";
                  break;
              }
            });
          }), [
            2
            /*return*/
          ];
        });
      });
    }, e.prototype.renderReplacedElement = function(t, r, n) {
      if (n && t.intrinsicWidth > 0 && t.intrinsicHeight > 0) {
        var s = yv(t), a = vv(r);
        this.path(a), this.ctx.save(), this.ctx.clip(), this.ctx.drawImage(n, 0, 0, t.intrinsicWidth, t.intrinsicHeight, s.left, s.top, s.width, s.height), this.ctx.restore();
      }
    }, e.prototype.renderNodeContent = function(t) {
      return Zn(this, void 0, void 0, function() {
        var r, n, s, a, o, A, w, w, l, h, c, u, E, f, g, S, p, y, v, w, C, E, S;
        return Gn(this, function(M) {
          switch (M.label) {
            case 0:
              this.applyEffects(t.getEffects(
                4
                /* CONTENT */
              )), r = t.container, n = t.curves, s = r.styles, a = 0, o = r.textNodes, M.label = 1;
            case 1:
              return a < o.length ? (A = o[a], [4, this.renderTextNode(A, s)]) : [3, 4];
            case 2:
              M.sent(), M.label = 3;
            case 3:
              return a++, [3, 1];
            case 4:
              if (!(r instanceof VP))
                return [3, 8];
              M.label = 5;
            case 5:
              return M.trys.push([5, 7, , 8]), [4, this.context.cache.match(r.src)];
            case 6:
              return w = M.sent(), this.renderReplacedElement(r, n, w), [3, 8];
            case 7:
              return M.sent(), this.context.logger.error("Error loading image " + r.src), [3, 8];
            case 8:
              if (r instanceof KP && this.renderReplacedElement(r, n, r.canvas), !(r instanceof jP))
                return [3, 12];
              M.label = 9;
            case 9:
              return M.trys.push([9, 11, , 12]), [4, this.context.cache.match(r.svg)];
            case 10:
              return w = M.sent(), this.renderReplacedElement(r, n, w), [3, 12];
            case 11:
              return M.sent(), this.context.logger.error("Error loading svg " + r.svg.substring(0, 255)), [3, 12];
            case 12:
              return r instanceof YP && r.tree ? (l = new e(this.context, {
                scale: this.options.scale,
                backgroundColor: r.backgroundColor,
                x: 0,
                y: 0,
                width: r.width,
                height: r.height
              }), [4, l.render(r.tree)]) : [3, 14];
            case 13:
              h = M.sent(), r.width && r.height && this.ctx.drawImage(h, 0, 0, r.width, r.height, r.bounds.left, r.bounds.top, r.bounds.width, r.bounds.height), M.label = 14;
            case 14:
              if (r instanceof XB && (c = Math.min(r.bounds.width, r.bounds.height), r.type === fv ? r.checked && (this.ctx.save(), this.path([
                new Ye(r.bounds.left + c * 0.39363, r.bounds.top + c * 0.79),
                new Ye(r.bounds.left + c * 0.16, r.bounds.top + c * 0.5549),
                new Ye(r.bounds.left + c * 0.27347, r.bounds.top + c * 0.44071),
                new Ye(r.bounds.left + c * 0.39694, r.bounds.top + c * 0.5649),
                new Ye(r.bounds.left + c * 0.72983, r.bounds.top + c * 0.23),
                new Ye(r.bounds.left + c * 0.84, r.bounds.top + c * 0.34085),
                new Ye(r.bounds.left + c * 0.39363, r.bounds.top + c * 0.79)
              ]), this.ctx.fillStyle = mn(UF), this.ctx.fill(), this.ctx.restore()) : r.type === dv && r.checked && (this.ctx.save(), this.ctx.beginPath(), this.ctx.arc(r.bounds.left + c / 2, r.bounds.top + c / 2, c / 4, 0, Math.PI * 2, !0), this.ctx.fillStyle = mn(UF), this.ctx.fill(), this.ctx.restore())), qAe(r) && r.value.length) {
                switch (u = this.createFontStyle(s), E = u[0], f = u[1], g = this.fontMetrics.getMetrics(E, f).baseline, this.ctx.font = E, this.ctx.fillStyle = mn(s.color), this.ctx.textBaseline = "alphabetic", this.ctx.textAlign = JAe(r.styles.textAlign), S = yv(r), p = 0, r.styles.textAlign) {
                  case 1:
                    p += S.width / 2;
                    break;
                  case 2:
                    p += S.width;
                    break;
                }
                y = S.add(p, 0, 0, -S.height / 2 + 1), this.ctx.save(), this.path([
                  new Ye(S.left, S.top),
                  new Ye(S.left + S.width, S.top),
                  new Ye(S.left + S.width, S.top + S.height),
                  new Ye(S.left, S.top + S.height)
                ]), this.ctx.clip(), this.renderTextWithLetterSpacing(new xd(r.value, y), s.letterSpacing, g), this.ctx.restore(), this.ctx.textBaseline = "alphabetic", this.ctx.textAlign = "left";
              }
              if (!on(
                r.styles.display,
                2048
                /* LIST_ITEM */
              ))
                return [3, 20];
              if (r.styles.listStyleImage === null)
                return [3, 19];
              if (v = r.styles.listStyleImage, v.type !== 0)
                return [3, 18];
              w = void 0, C = v.url, M.label = 15;
            case 15:
              return M.trys.push([15, 17, , 18]), [4, this.context.cache.match(C)];
            case 16:
              return w = M.sent(), this.ctx.drawImage(w, r.bounds.left - (w.width + 10), r.bounds.top), [3, 18];
            case 17:
              return M.sent(), this.context.logger.error("Error loading list-style-image " + C), [3, 18];
            case 18:
              return [3, 20];
            case 19:
              t.listValue && r.styles.listStyleType !== -1 && (E = this.createFontStyle(s)[0], this.ctx.font = E, this.ctx.fillStyle = mn(s.color), this.ctx.textBaseline = "middle", this.ctx.textAlign = "right", S = new qo(r.bounds.left, r.bounds.top + ti(r.styles.paddingTop, r.bounds.width), r.bounds.width, _F(s.lineHeight, s.fontSize.number) / 2 + 1), this.renderTextWithLetterSpacing(new xd(t.listValue, S), s.letterSpacing, _F(s.lineHeight, s.fontSize.number) / 2 + 2), this.ctx.textBaseline = "bottom", this.ctx.textAlign = "left"), M.label = 20;
            case 20:
              return [
                2
                /*return*/
              ];
          }
        });
      });
    }, e.prototype.renderStackContent = function(t) {
      return Zn(this, void 0, void 0, function() {
        var r, n, v, s, a, v, o, A, v, l, h, v, c, u, v, f, g, v, p, y, v;
        return Gn(this, function(w) {
          switch (w.label) {
            case 0:
              if (on(
                t.element.container.flags,
                16
                /* DEBUG_RENDER */
              ))
                debugger;
              return [4, this.renderNodeBackgroundAndBorders(t.element)];
            case 1:
              w.sent(), r = 0, n = t.negativeZIndex, w.label = 2;
            case 2:
              return r < n.length ? (v = n[r], [4, this.renderStack(v)]) : [3, 5];
            case 3:
              w.sent(), w.label = 4;
            case 4:
              return r++, [3, 2];
            case 5:
              return [4, this.renderNodeContent(t.element)];
            case 6:
              w.sent(), s = 0, a = t.nonInlineLevel, w.label = 7;
            case 7:
              return s < a.length ? (v = a[s], [4, this.renderNode(v)]) : [3, 10];
            case 8:
              w.sent(), w.label = 9;
            case 9:
              return s++, [3, 7];
            case 10:
              o = 0, A = t.nonPositionedFloats, w.label = 11;
            case 11:
              return o < A.length ? (v = A[o], [4, this.renderStack(v)]) : [3, 14];
            case 12:
              w.sent(), w.label = 13;
            case 13:
              return o++, [3, 11];
            case 14:
              l = 0, h = t.nonPositionedInlineLevel, w.label = 15;
            case 15:
              return l < h.length ? (v = h[l], [4, this.renderStack(v)]) : [3, 18];
            case 16:
              w.sent(), w.label = 17;
            case 17:
              return l++, [3, 15];
            case 18:
              c = 0, u = t.inlineLevel, w.label = 19;
            case 19:
              return c < u.length ? (v = u[c], [4, this.renderNode(v)]) : [3, 22];
            case 20:
              w.sent(), w.label = 21;
            case 21:
              return c++, [3, 19];
            case 22:
              f = 0, g = t.zeroOrAutoZIndexOrTransformedOrOpacity, w.label = 23;
            case 23:
              return f < g.length ? (v = g[f], [4, this.renderStack(v)]) : [3, 26];
            case 24:
              w.sent(), w.label = 25;
            case 25:
              return f++, [3, 23];
            case 26:
              p = 0, y = t.positiveZIndex, w.label = 27;
            case 27:
              return p < y.length ? (v = y[p], [4, this.renderStack(v)]) : [3, 30];
            case 28:
              w.sent(), w.label = 29;
            case 29:
              return p++, [3, 27];
            case 30:
              return [
                2
                /*return*/
              ];
          }
        });
      });
    }, e.prototype.mask = function(t) {
      this.ctx.beginPath(), this.ctx.moveTo(0, 0), this.ctx.lineTo(this.canvas.width, 0), this.ctx.lineTo(this.canvas.width, this.canvas.height), this.ctx.lineTo(0, this.canvas.height), this.ctx.lineTo(0, 0), this.formatPath(t.slice(0).reverse()), this.ctx.closePath();
    }, e.prototype.path = function(t) {
      this.ctx.beginPath(), this.formatPath(t), this.ctx.closePath();
    }, e.prototype.formatPath = function(t) {
      var r = this;
      t.forEach(function(n, s) {
        var a = Ws(n) ? n.start : n;
        s === 0 ? r.ctx.moveTo(a.x, a.y) : r.ctx.lineTo(a.x, a.y), Ws(n) && r.ctx.bezierCurveTo(n.startControl.x, n.startControl.y, n.endControl.x, n.endControl.y, n.end.x, n.end.y);
      });
    }, e.prototype.renderRepeat = function(t, r, n, s) {
      this.path(t), this.ctx.fillStyle = r, this.ctx.translate(n, s), this.ctx.fill(), this.ctx.translate(-n, -s);
    }, e.prototype.resizeImage = function(t, r, n) {
      var s;
      if (t.width === r && t.height === n)
        return t;
      var a = (s = this.canvas.ownerDocument) !== null && s !== void 0 ? s : document, o = a.createElement("canvas");
      o.width = Math.max(1, r), o.height = Math.max(1, n);
      var A = o.getContext("2d");
      return A.drawImage(t, 0, 0, t.width, t.height, 0, 0, r, n), o;
    }, e.prototype.renderBackgroundImage = function(t) {
      return Zn(this, void 0, void 0, function() {
        var r, n, s, a, o, A;
        return Gn(this, function(l) {
          switch (l.label) {
            case 0:
              r = t.styles.backgroundImage.length - 1, n = function(h) {
                var c, u, f, $, W, q, P, Q, F, g, $, W, q, P, Q, p, y, v, w, C, E, S, M, T, F, k, $, I, L, P, Q, X, W, q, Z, oe, ne, me, b, H, V, j;
                return Gn(this, function(ie) {
                  switch (ie.label) {
                    case 0:
                      if (h.type !== 0)
                        return [3, 5];
                      c = void 0, u = h.url, ie.label = 1;
                    case 1:
                      return ie.trys.push([1, 3, , 4]), [4, s.context.cache.match(u)];
                    case 2:
                      return c = ie.sent(), [3, 4];
                    case 3:
                      return ie.sent(), s.context.logger.error("Error loading background-image " + u), [3, 4];
                    case 4:
                      return c && (f = k_(t, r, [
                        c.width,
                        c.height,
                        c.width / c.height
                      ]), $ = f[0], W = f[1], q = f[2], P = f[3], Q = f[4], F = s.ctx.createPattern(s.resizeImage(c, P, Q), "repeat"), s.renderRepeat($, F, W, q)), [3, 6];
                    case 5:
                      Ose(h) ? (g = k_(t, r, [null, null, null]), $ = g[0], W = g[1], q = g[2], P = g[3], Q = g[4], p = Ise(h.angle, P, Q), y = p[0], v = p[1], w = p[2], C = p[3], E = p[4], S = document.createElement("canvas"), S.width = P, S.height = Q, M = S.getContext("2d"), T = M.createLinearGradient(v, C, w, E), vF(h.stops, y).forEach(function(ue) {
                        return T.addColorStop(ue.stop, mn(ue.color));
                      }), M.fillStyle = T, M.fillRect(0, 0, P, Q), P > 0 && Q > 0 && (F = s.ctx.createPattern(S, "repeat"), s.renderRepeat($, F, W, q))) : Use(h) && (k = k_(t, r, [
                        null,
                        null,
                        null
                      ]), $ = k[0], I = k[1], L = k[2], P = k[3], Q = k[4], X = h.position.length === 0 ? [VB] : h.position, W = ti(X[0], P), q = ti(X[X.length - 1], Q), Z = Rse(h, W, q, P, Q), oe = Z[0], ne = Z[1], oe > 0 && ne > 0 && (me = s.ctx.createRadialGradient(I + W, L + q, 0, I + W, L + q, oe), vF(h.stops, oe * 2).forEach(function(ue) {
                        return me.addColorStop(ue.stop, mn(ue.color));
                      }), s.path($), s.ctx.fillStyle = me, oe !== ne ? (b = t.bounds.left + 0.5 * t.bounds.width, H = t.bounds.top + 0.5 * t.bounds.height, V = ne / oe, j = 1 / V, s.ctx.save(), s.ctx.translate(b, H), s.ctx.transform(1, 0, 0, V, 0, 0), s.ctx.translate(-b, -H), s.ctx.fillRect(I, j * (L - H) + H, P, Q * j), s.ctx.restore()) : s.ctx.fill())), ie.label = 6;
                    case 6:
                      return r--, [
                        2
                        /*return*/
                      ];
                  }
                });
              }, s = this, a = 0, o = t.styles.backgroundImage.slice(0).reverse(), l.label = 1;
            case 1:
              return a < o.length ? (A = o[a], [5, n(A)]) : [3, 4];
            case 2:
              l.sent(), l.label = 3;
            case 3:
              return a++, [3, 1];
            case 4:
              return [
                2
                /*return*/
              ];
          }
        });
      });
    }, e.prototype.renderSolidBorder = function(t, r, n) {
      return Zn(this, void 0, void 0, function() {
        return Gn(this, function(s) {
          return this.path(WF(n, r)), this.ctx.fillStyle = mn(t), this.ctx.fill(), [
            2
            /*return*/
          ];
        });
      });
    }, e.prototype.renderDoubleBorder = function(t, r, n, s) {
      return Zn(this, void 0, void 0, function() {
        var a, o;
        return Gn(this, function(A) {
          switch (A.label) {
            case 0:
              return r < 3 ? [4, this.renderSolidBorder(t, n, s)] : [3, 2];
            case 1:
              return A.sent(), [
                2
                /*return*/
              ];
            case 2:
              return a = kAe(s, n), this.path(a), this.ctx.fillStyle = mn(t), this.ctx.fill(), o = HAe(s, n), this.path(o), this.ctx.fill(), [
                2
                /*return*/
              ];
          }
        });
      });
    }, e.prototype.renderNodeBackgroundAndBorders = function(t) {
      return Zn(this, void 0, void 0, function() {
        var r, n, s, a, o, A, l, h, c = this;
        return Gn(this, function(u) {
          switch (u.label) {
            case 0:
              return this.applyEffects(t.getEffects(
                2
                /* BACKGROUND_BORDERS */
              )), r = t.container.styles, n = !al(r.backgroundColor) || r.backgroundImage.length, s = [
                { style: r.borderTopStyle, color: r.borderTopColor, width: r.borderTopWidth },
                { style: r.borderRightStyle, color: r.borderRightColor, width: r.borderRightWidth },
                { style: r.borderBottomStyle, color: r.borderBottomColor, width: r.borderBottomWidth },
                { style: r.borderLeftStyle, color: r.borderLeftColor, width: r.borderLeftWidth }
              ], a = ZAe(Rc(r.backgroundClip, 0), t.curves), n || r.boxShadow.length ? (this.ctx.save(), this.path(a), this.ctx.clip(), al(r.backgroundColor) || (this.ctx.fillStyle = mn(r.backgroundColor), this.ctx.fill()), [4, this.renderBackgroundImage(t.container)]) : [3, 2];
            case 1:
              u.sent(), this.ctx.restore(), r.boxShadow.slice(0).reverse().forEach(function(f) {
                c.ctx.save();
                var g = mv(t.curves), p = f.inset ? 0 : WAe, y = QAe(g, -p + (f.inset ? 1 : -1) * f.spread.number, (f.inset ? 1 : -1) * f.spread.number, f.spread.number * (f.inset ? -2 : 2), f.spread.number * (f.inset ? -2 : 2));
                f.inset ? (c.path(g), c.ctx.clip(), c.mask(y)) : (c.mask(g), c.ctx.clip(), c.path(y)), c.ctx.shadowOffsetX = f.offsetX.number + p, c.ctx.shadowOffsetY = f.offsetY.number, c.ctx.shadowColor = mn(f.color), c.ctx.shadowBlur = f.blur.number, c.ctx.fillStyle = f.inset ? mn(f.color) : "rgba(0,0,0,1)", c.ctx.fill(), c.ctx.restore();
              }), u.label = 2;
            case 2:
              o = 0, A = 0, l = s, u.label = 3;
            case 3:
              return A < l.length ? (h = l[A], h.style !== 0 && !al(h.color) && h.width > 0 ? h.style !== 2 ? [3, 5] : [4, this.renderDashedDottedBorder(
                h.color,
                h.width,
                o,
                t.curves,
                2
                /* DASHED */
              )] : [3, 11]) : [3, 13];
            case 4:
              return u.sent(), [3, 11];
            case 5:
              return h.style !== 3 ? [3, 7] : [4, this.renderDashedDottedBorder(
                h.color,
                h.width,
                o,
                t.curves,
                3
                /* DOTTED */
              )];
            case 6:
              return u.sent(), [3, 11];
            case 7:
              return h.style !== 4 ? [3, 9] : [4, this.renderDoubleBorder(h.color, h.width, o, t.curves)];
            case 8:
              return u.sent(), [3, 11];
            case 9:
              return [4, this.renderSolidBorder(h.color, o, t.curves)];
            case 10:
              u.sent(), u.label = 11;
            case 11:
              o++, u.label = 12;
            case 12:
              return A++, [3, 3];
            case 13:
              return [
                2
                /*return*/
              ];
          }
        });
      });
    }, e.prototype.renderDashedDottedBorder = function(t, r, n, s, a) {
      return Zn(this, void 0, void 0, function() {
        var o, A, l, h, c, u, f, g, p, y, v, w, C, E, S, M, S, M;
        return Gn(this, function(T) {
          return this.ctx.save(), o = GAe(s, n), A = WF(s, n), a === 2 && (this.path(A), this.ctx.clip()), Ws(A[0]) ? (l = A[0].start.x, h = A[0].start.y) : (l = A[0].x, h = A[0].y), Ws(A[1]) ? (c = A[1].end.x, u = A[1].end.y) : (c = A[1].x, u = A[1].y), n === 0 || n === 2 ? f = Math.abs(l - c) : f = Math.abs(h - u), this.ctx.beginPath(), a === 3 ? this.formatPath(o) : this.formatPath(A.slice(0, 2)), g = r < 3 ? r * 3 : r * 2, p = r < 3 ? r * 2 : r, a === 3 && (g = r, p = r), y = !0, f <= g * 2 ? y = !1 : f <= g * 2 + p ? (v = f / (2 * g + p), g *= v, p *= v) : (w = Math.floor((f + p) / (g + p)), C = (f - w * g) / (w - 1), E = (f - (w + 1) * g) / w, p = E <= 0 || Math.abs(p - C) < Math.abs(p - E) ? C : E), y && (a === 3 ? this.ctx.setLineDash([0, g + p]) : this.ctx.setLineDash([g, p])), a === 3 ? (this.ctx.lineCap = "round", this.ctx.lineWidth = r) : this.ctx.lineWidth = r * 2 + 1.1, this.ctx.strokeStyle = mn(t), this.ctx.stroke(), this.ctx.setLineDash([]), a === 2 && (Ws(A[0]) && (S = A[3], M = A[0], this.ctx.beginPath(), this.formatPath([new Ye(S.end.x, S.end.y), new Ye(M.start.x, M.start.y)]), this.ctx.stroke()), Ws(A[1]) && (S = A[1], M = A[2], this.ctx.beginPath(), this.formatPath([new Ye(S.end.x, S.end.y), new Ye(M.start.x, M.start.y)]), this.ctx.stroke())), this.ctx.restore(), [
            2
            /*return*/
          ];
        });
      });
    }, e.prototype.render = function(t) {
      return Zn(this, void 0, void 0, function() {
        var r;
        return Gn(this, function(n) {
          switch (n.label) {
            case 0:
              return this.options.backgroundColor && (this.ctx.fillStyle = mn(this.options.backgroundColor), this.ctx.fillRect(this.options.x, this.options.y, this.options.width, this.options.height)), r = DAe(t), [4, this.renderStack(r)];
            case 1:
              return n.sent(), this.applyEffects([]), [2, this.canvas];
          }
        });
      });
    }, e;
  }(u3)
), qAe = function(i) {
  return i instanceof WP || i instanceof XP ? !0 : i instanceof XB && i.type !== dv && i.type !== fv;
}, ZAe = function(i, e) {
  switch (i) {
    case 0:
      return mv(e);
    case 2:
      return MAe(e);
    case 1:
    default:
      return vv(e);
  }
}, JAe = function(i) {
  switch (i) {
    case 1:
      return "center";
    case 2:
      return "right";
    case 0:
    default:
      return "left";
  }
}, ele = ["-apple-system", "system-ui"], tle = function(i) {
  return /iPhone OS 15_(0|1)/.test(window.navigator.userAgent) ? i.filter(function(e) {
    return ele.indexOf(e) === -1;
  }) : i;
}, rle = (
  /** @class */
  function(i) {
    La(e, i);
    function e(t, r) {
      var n = i.call(this, t, r) || this;
      return n.canvas = r.canvas ? r.canvas : document.createElement("canvas"), n.ctx = n.canvas.getContext("2d"), n.options = r, n.canvas.width = Math.floor(r.width * r.scale), n.canvas.height = Math.floor(r.height * r.scale), n.canvas.style.width = r.width + "px", n.canvas.style.height = r.height + "px", n.ctx.scale(n.options.scale, n.options.scale), n.ctx.translate(-r.x, -r.y), n.context.logger.debug("EXPERIMENTAL ForeignObject renderer initialized (" + r.width + "x" + r.height + " at " + r.x + "," + r.y + ") with scale " + r.scale), n;
    }
    return e.prototype.render = function(t) {
      return Zn(this, void 0, void 0, function() {
        var r, n;
        return Gn(this, function(s) {
          switch (s.label) {
            case 0:
              return r = hC(this.options.width * this.options.scale, this.options.height * this.options.scale, this.options.scale, this.options.scale, t), [4, ile(r)];
            case 1:
              return n = s.sent(), this.options.backgroundColor && (this.ctx.fillStyle = mn(this.options.backgroundColor), this.ctx.fillRect(0, 0, this.options.width * this.options.scale, this.options.height * this.options.scale)), this.ctx.drawImage(n, -this.options.x * this.options.scale, -this.options.y * this.options.scale), [2, this.canvas];
          }
        });
      });
    }, e;
  }(u3)
), ile = function(i) {
  return new Promise(function(e, t) {
    var r = new Image();
    r.onload = function() {
      e(r);
    }, r.onerror = t, r.src = "data:image/svg+xml;charset=utf-8," + encodeURIComponent(new XMLSerializer().serializeToString(i));
  });
}, nle = (
  /** @class */
  function() {
    function i(e) {
      var t = e.id, r = e.enabled;
      this.id = t, this.enabled = r, this.start = Date.now();
    }
    return i.prototype.debug = function() {
      for (var e = [], t = 0; t < arguments.length; t++)
        e[t] = arguments[t];
      this.enabled && (typeof window < "u" && window.console && typeof console.debug == "function" ? console.debug.apply(console, r0([this.id, this.getTime() + "ms"], e)) : this.info.apply(this, e));
    }, i.prototype.getTime = function() {
      return Date.now() - this.start;
    }, i.prototype.info = function() {
      for (var e = [], t = 0; t < arguments.length; t++)
        e[t] = arguments[t];
      this.enabled && typeof window < "u" && window.console && typeof console.info == "function" && console.info.apply(console, r0([this.id, this.getTime() + "ms"], e));
    }, i.prototype.warn = function() {
      for (var e = [], t = 0; t < arguments.length; t++)
        e[t] = arguments[t];
      this.enabled && (typeof window < "u" && window.console && typeof console.warn == "function" ? console.warn.apply(console, r0([this.id, this.getTime() + "ms"], e)) : this.info.apply(this, e));
    }, i.prototype.error = function() {
      for (var e = [], t = 0; t < arguments.length; t++)
        e[t] = arguments[t];
      this.enabled && (typeof window < "u" && window.console && typeof console.error == "function" ? console.error.apply(console, r0([this.id, this.getTime() + "ms"], e)) : this.info.apply(this, e));
    }, i.instances = {}, i;
  }()
), sle = (
  /** @class */
  function() {
    function i(e, t) {
      var r;
      this.windowBounds = t, this.instanceName = "#" + i.instanceCount++, this.logger = new nle({ id: this.instanceName, enabled: e.logging }), this.cache = (r = e.cache) !== null && r !== void 0 ? r : new BAe(this, e);
    }
    return i.instanceCount = 1, i;
  }()
), ale = function(i, e) {
  return e === void 0 && (e = {}), ole(i, e);
};
typeof window < "u" && a3.setContext(window);
var ole = function(i, e) {
  return Zn(void 0, void 0, void 0, function() {
    var t, r, n, s, a, o, A, l, h, c, u, f, g, p, y, v, w, C, E, S, T, M, T, F, k, $, I, L, P, Q, X, W, q, Z, oe, ne, me, b, H, V;
    return Gn(this, function(j) {
      switch (j.label) {
        case 0:
          if (!i || typeof i != "object")
            return [2, Promise.reject("Invalid element provided as first argument")];
          if (t = i.ownerDocument, !t)
            throw new Error("Element is not attached to a Document");
          if (r = t.defaultView, !r)
            throw new Error("Document is not attached to a Window");
          return n = {
            allowTaint: (F = e.allowTaint) !== null && F !== void 0 ? F : !1,
            imageTimeout: (k = e.imageTimeout) !== null && k !== void 0 ? k : 15e3,
            proxy: e.proxy,
            useCORS: ($ = e.useCORS) !== null && $ !== void 0 ? $ : !1
          }, s = Wx({ logging: (I = e.logging) !== null && I !== void 0 ? I : !0, cache: e.cache }, n), a = {
            windowWidth: (L = e.windowWidth) !== null && L !== void 0 ? L : r.innerWidth,
            windowHeight: (P = e.windowHeight) !== null && P !== void 0 ? P : r.innerHeight,
            scrollX: (Q = e.scrollX) !== null && Q !== void 0 ? Q : r.pageXOffset,
            scrollY: (X = e.scrollY) !== null && X !== void 0 ? X : r.pageYOffset
          }, o = new qo(a.scrollX, a.scrollY, a.windowWidth, a.windowHeight), A = new sle(s, o), l = (W = e.foreignObjectRendering) !== null && W !== void 0 ? W : !1, h = {
            allowTaint: (q = e.allowTaint) !== null && q !== void 0 ? q : !1,
            onclone: e.onclone,
            ignoreElements: e.ignoreElements,
            inlineImages: l,
            copyStyles: l
          }, A.logger.debug("Starting document clone with size " + o.width + "x" + o.height + " scrolled to " + -o.left + "," + -o.top), c = new jF(A, i, h), u = c.clonedReferenceElement, u ? [4, c.toIFrame(t, o)] : [2, Promise.reject("Unable to find element in cloned iframe")];
        case 1:
          return f = j.sent(), g = WB(u) || AAe(u) ? Qie(u.ownerDocument) : cy(A, u), p = g.width, y = g.height, v = g.left, w = g.top, C = Ale(A, u, e.backgroundColor), E = {
            canvas: e.canvas,
            backgroundColor: C,
            scale: (oe = (Z = e.scale) !== null && Z !== void 0 ? Z : r.devicePixelRatio) !== null && oe !== void 0 ? oe : 1,
            x: ((ne = e.x) !== null && ne !== void 0 ? ne : 0) + v,
            y: ((me = e.y) !== null && me !== void 0 ? me : 0) + w,
            width: (b = e.width) !== null && b !== void 0 ? b : Math.ceil(p),
            height: (H = e.height) !== null && H !== void 0 ? H : Math.ceil(y)
          }, l ? (A.logger.debug("Document cloned, using foreign object rendering"), T = new rle(A, E), [4, T.render(u)]) : [3, 3];
        case 2:
          return S = j.sent(), [3, 5];
        case 3:
          return A.logger.debug("Document cloned, element located at " + v + "," + w + " with size " + p + "x" + y + " using computed rendering"), A.logger.debug("Starting DOM parsing"), M = ZP(A, u), C === M.styles.backgroundColor && (M.styles.backgroundColor = Ko.TRANSPARENT), A.logger.debug("Starting renderer for element at " + E.x + "," + E.y + " with size " + E.width + "x" + E.height), T = new YAe(A, E), [4, T.render(M)];
        case 4:
          S = j.sent(), j.label = 5;
        case 5:
          return (!((V = e.removeContainer) !== null && V !== void 0) || V) && (jF.destroy(f) || A.logger.error("Cannot detach cloned iframe as it is not in the DOM anymore")), A.logger.debug("Finished rendering"), [2, S];
      }
    });
  });
}, Ale = function(i, e, t) {
  var r = e.ownerDocument, n = r.documentElement ? _d(i, getComputedStyle(r.documentElement).backgroundColor) : Ko.TRANSPARENT, s = r.body ? _d(i, getComputedStyle(r.body).backgroundColor) : Ko.TRANSPARENT, a = typeof t == "string" ? _d(i, t) : t === null ? Ko.TRANSPARENT : 4294967295;
  return e === r.documentElement ? al(n) ? al(s) ? a : s : n : a;
};
const lle = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  default: ale
}, Symbol.toStringTag, { value: "Module" }));
/*! @license DOMPurify 2.3.5 | (c) Cure53 and other contributors | Released under the Apache license 2.0 and Mozilla Public License 2.0 | github.com/cure53/DOMPurify/blob/2.3.5/LICENSE */
function hle(i) {
  if (Array.isArray(i)) {
    for (var e = 0, t = Array(i.length); e < i.length; e++)
      t[e] = i[e];
    return t;
  } else
    return Array.from(i);
}
var cle = Object.hasOwnProperty, qF = Object.setPrototypeOf, ule = Object.isFrozen, fle = Object.getPrototypeOf, dle = Object.getOwnPropertyDescriptor, ss = Object.freeze, Zo = Object.seal, gle = Object.create, f3 = typeof Reflect < "u" && Reflect, _v = f3.apply, mC = f3.construct;
_v || (_v = function(e, t, r) {
  return e.apply(t, r);
});
ss || (ss = function(e) {
  return e;
});
Zo || (Zo = function(e) {
  return e;
});
mC || (mC = function(e, t) {
  return new (Function.prototype.bind.apply(e, [null].concat(hle(t))))();
});
var ple = ba(Array.prototype.forEach), ZF = ba(Array.prototype.pop), kf = ba(Array.prototype.push), nm = ba(String.prototype.toLowerCase), JF = ba(String.prototype.match), OA = ba(String.prototype.replace), mle = ba(String.prototype.indexOf), vle = ba(String.prototype.trim), Ls = ba(RegExp.prototype.test), H_ = yle(TypeError);
function ba(i) {
  return function(e) {
    for (var t = arguments.length, r = Array(t > 1 ? t - 1 : 0), n = 1; n < t; n++)
      r[n - 1] = arguments[n];
    return _v(i, e, r);
  };
}
function yle(i) {
  return function() {
    for (var e = arguments.length, t = Array(e), r = 0; r < e; r++)
      t[r] = arguments[r];
    return mC(i, t);
  };
}
function rr(i, e) {
  qF && qF(i, null);
  for (var t = e.length; t--; ) {
    var r = e[t];
    if (typeof r == "string") {
      var n = nm(r);
      n !== r && (ule(e) || (e[t] = n), r = n);
    }
    i[r] = !0;
  }
  return i;
}
function Nl(i) {
  var e = gle(null), t = void 0;
  for (t in i)
    _v(cle, i, [t]) && (e[t] = i[t]);
  return e;
}
function B0(i, e) {
  for (; i !== null; ) {
    var t = dle(i, e);
    if (t) {
      if (t.get)
        return ba(t.get);
      if (typeof t.value == "function")
        return ba(t.value);
    }
    i = fle(i);
  }
  function r(n) {
    return console.warn("fallback value for", n), null;
  }
  return r;
}
var eL = ss(["a", "abbr", "acronym", "address", "area", "article", "aside", "audio", "b", "bdi", "bdo", "big", "blink", "blockquote", "body", "br", "button", "canvas", "caption", "center", "cite", "code", "col", "colgroup", "content", "data", "datalist", "dd", "decorator", "del", "details", "dfn", "dialog", "dir", "div", "dl", "dt", "element", "em", "fieldset", "figcaption", "figure", "font", "footer", "form", "h1", "h2", "h3", "h4", "h5", "h6", "head", "header", "hgroup", "hr", "html", "i", "img", "input", "ins", "kbd", "label", "legend", "li", "main", "map", "mark", "marquee", "menu", "menuitem", "meter", "nav", "nobr", "ol", "optgroup", "option", "output", "p", "picture", "pre", "progress", "q", "rp", "rt", "ruby", "s", "samp", "section", "select", "shadow", "small", "source", "spacer", "span", "strike", "strong", "style", "sub", "summary", "sup", "table", "tbody", "td", "template", "textarea", "tfoot", "th", "thead", "time", "tr", "track", "tt", "u", "ul", "var", "video", "wbr"]), G_ = ss(["svg", "a", "altglyph", "altglyphdef", "altglyphitem", "animatecolor", "animatemotion", "animatetransform", "circle", "clippath", "defs", "desc", "ellipse", "filter", "font", "g", "glyph", "glyphref", "hkern", "image", "line", "lineargradient", "marker", "mask", "metadata", "mpath", "path", "pattern", "polygon", "polyline", "radialgradient", "rect", "stop", "style", "switch", "symbol", "text", "textpath", "title", "tref", "tspan", "view", "vkern"]), $_ = ss(["feBlend", "feColorMatrix", "feComponentTransfer", "feComposite", "feConvolveMatrix", "feDiffuseLighting", "feDisplacementMap", "feDistantLight", "feFlood", "feFuncA", "feFuncB", "feFuncG", "feFuncR", "feGaussianBlur", "feImage", "feMerge", "feMergeNode", "feMorphology", "feOffset", "fePointLight", "feSpecularLighting", "feSpotLight", "feTile", "feTurbulence"]), _le = ss(["animate", "color-profile", "cursor", "discard", "fedropshadow", "font-face", "font-face-format", "font-face-name", "font-face-src", "font-face-uri", "foreignobject", "hatch", "hatchpath", "mesh", "meshgradient", "meshpatch", "meshrow", "missing-glyph", "script", "set", "solidcolor", "unknown", "use"]), V_ = ss(["math", "menclose", "merror", "mfenced", "mfrac", "mglyph", "mi", "mlabeledtr", "mmultiscripts", "mn", "mo", "mover", "mpadded", "mphantom", "mroot", "mrow", "ms", "mspace", "msqrt", "mstyle", "msub", "msup", "msubsup", "mtable", "mtd", "mtext", "mtr", "munder", "munderover"]), wle = ss(["maction", "maligngroup", "malignmark", "mlongdiv", "mscarries", "mscarry", "msgroup", "mstack", "msline", "msrow", "semantics", "annotation", "annotation-xml", "mprescripts", "none"]), tL = ss(["#text"]), rL = ss(["accept", "action", "align", "alt", "autocapitalize", "autocomplete", "autopictureinpicture", "autoplay", "background", "bgcolor", "border", "capture", "cellpadding", "cellspacing", "checked", "cite", "class", "clear", "color", "cols", "colspan", "controls", "controlslist", "coords", "crossorigin", "datetime", "decoding", "default", "dir", "disabled", "disablepictureinpicture", "disableremoteplayback", "download", "draggable", "enctype", "enterkeyhint", "face", "for", "headers", "height", "hidden", "high", "href", "hreflang", "id", "inputmode", "integrity", "ismap", "kind", "label", "lang", "list", "loading", "loop", "low", "max", "maxlength", "media", "method", "min", "minlength", "multiple", "muted", "name", "nonce", "noshade", "novalidate", "nowrap", "open", "optimum", "pattern", "placeholder", "playsinline", "poster", "preload", "pubdate", "radiogroup", "readonly", "rel", "required", "rev", "reversed", "role", "rows", "rowspan", "spellcheck", "scope", "selected", "shape", "size", "sizes", "span", "srclang", "start", "src", "srcset", "step", "style", "summary", "tabindex", "title", "translate", "type", "usemap", "valign", "value", "width", "xmlns", "slot"]), K_ = ss(["accent-height", "accumulate", "additive", "alignment-baseline", "ascent", "attributename", "attributetype", "azimuth", "basefrequency", "baseline-shift", "begin", "bias", "by", "class", "clip", "clippathunits", "clip-path", "clip-rule", "color", "color-interpolation", "color-interpolation-filters", "color-profile", "color-rendering", "cx", "cy", "d", "dx", "dy", "diffuseconstant", "direction", "display", "divisor", "dur", "edgemode", "elevation", "end", "fill", "fill-opacity", "fill-rule", "filter", "filterunits", "flood-color", "flood-opacity", "font-family", "font-size", "font-size-adjust", "font-stretch", "font-style", "font-variant", "font-weight", "fx", "fy", "g1", "g2", "glyph-name", "glyphref", "gradientunits", "gradienttransform", "height", "href", "id", "image-rendering", "in", "in2", "k", "k1", "k2", "k3", "k4", "kerning", "keypoints", "keysplines", "keytimes", "lang", "lengthadjust", "letter-spacing", "kernelmatrix", "kernelunitlength", "lighting-color", "local", "marker-end", "marker-mid", "marker-start", "markerheight", "markerunits", "markerwidth", "maskcontentunits", "maskunits", "max", "mask", "media", "method", "mode", "min", "name", "numoctaves", "offset", "operator", "opacity", "order", "orient", "orientation", "origin", "overflow", "paint-order", "path", "pathlength", "patterncontentunits", "patterntransform", "patternunits", "points", "preservealpha", "preserveaspectratio", "primitiveunits", "r", "rx", "ry", "radius", "refx", "refy", "repeatcount", "repeatdur", "restart", "result", "rotate", "scale", "seed", "shape-rendering", "specularconstant", "specularexponent", "spreadmethod", "startoffset", "stddeviation", "stitchtiles", "stop-color", "stop-opacity", "stroke-dasharray", "stroke-dashoffset", "stroke-linecap", "stroke-linejoin", "stroke-miterlimit", "stroke-opacity", "stroke", "stroke-width", "style", "surfacescale", "systemlanguage", "tabindex", "targetx", "targety", "transform", "transform-origin", "text-anchor", "text-decoration", "text-rendering", "textlength", "type", "u1", "u2", "unicode", "values", "viewbox", "visibility", "version", "vert-adv-y", "vert-origin-x", "vert-origin-y", "width", "word-spacing", "wrap", "writing-mode", "xchannelselector", "ychannelselector", "x", "x1", "x2", "xmlns", "y", "y1", "y2", "z", "zoomandpan"]), iL = ss(["accent", "accentunder", "align", "bevelled", "close", "columnsalign", "columnlines", "columnspan", "denomalign", "depth", "dir", "display", "displaystyle", "encoding", "fence", "frame", "height", "href", "id", "largeop", "length", "linethickness", "lspace", "lquote", "mathbackground", "mathcolor", "mathsize", "mathvariant", "maxsize", "minsize", "movablelimits", "notation", "numalign", "open", "rowalign", "rowlines", "rowspacing", "rowspan", "rspace", "rquote", "scriptlevel", "scriptminsize", "scriptsizemultiplier", "selection", "separator", "separators", "stretchy", "subscriptshift", "supscriptshift", "symmetric", "voffset", "width", "xmlns"]), b0 = ss(["xlink:href", "xml:id", "xlink:title", "xml:space", "xmlns:xlink"]), xle = Zo(/\{\{[\s\S]*|[\s\S]*\}\}/gm), Cle = Zo(/<%[\s\S]*|[\s\S]*%>/gm), Ele = Zo(/^data-[\-\w.\u00B7-\uFFFF]/), Ble = Zo(/^aria-[\-\w]+$/), ble = Zo(
  /^(?:(?:(?:f|ht)tps?|mailto|tel|callto|cid|xmpp):|[^a-z]|[a-z+.\-]+(?:[^a-z+.\-:]|$))/i
  // eslint-disable-line no-useless-escape
), Sle = Zo(/^(?:\w+script|data):/i), Tle = Zo(
  /[\u0000-\u0020\u00A0\u1680\u180E\u2000-\u2029\u205F\u3000]/g
  // eslint-disable-line no-control-regex
), od = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(i) {
  return typeof i;
} : function(i) {
  return i && typeof Symbol == "function" && i.constructor === Symbol && i !== Symbol.prototype ? "symbol" : typeof i;
};
function Oa(i) {
  if (Array.isArray(i)) {
    for (var e = 0, t = Array(i.length); e < i.length; e++)
      t[e] = i[e];
    return t;
  } else
    return Array.from(i);
}
var Fle = function() {
  return typeof window > "u" ? null : window;
}, Lle = function(e, t) {
  if ((typeof e > "u" ? "undefined" : od(e)) !== "object" || typeof e.createPolicy != "function")
    return null;
  var r = null, n = "data-tt-policy-suffix";
  t.currentScript && t.currentScript.hasAttribute(n) && (r = t.currentScript.getAttribute(n));
  var s = "dompurify" + (r ? "#" + r : "");
  try {
    return e.createPolicy(s, {
      createHTML: function(o) {
        return o;
      }
    });
  } catch {
    return console.warn("TrustedTypes policy " + s + " could not be created."), null;
  }
};
function d3() {
  var i = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : Fle(), e = function(he) {
    return d3(he);
  };
  if (e.version = "2.3.5", e.removed = [], !i || !i.document || i.document.nodeType !== 9)
    return e.isSupported = !1, e;
  var t = i.document, r = i.document, n = i.DocumentFragment, s = i.HTMLTemplateElement, a = i.Node, o = i.Element, A = i.NodeFilter, l = i.NamedNodeMap, h = l === void 0 ? i.NamedNodeMap || i.MozNamedAttrMap : l, c = i.HTMLFormElement, u = i.DOMParser, f = i.trustedTypes, g = o.prototype, p = B0(g, "cloneNode"), y = B0(g, "nextSibling"), v = B0(g, "childNodes"), w = B0(g, "parentNode");
  if (typeof s == "function") {
    var C = r.createElement("template");
    C.content && C.content.ownerDocument && (r = C.content.ownerDocument);
  }
  var E = Lle(f, t), S = E ? E.createHTML("") : "", M = r, T = M.implementation, F = M.createNodeIterator, k = M.createDocumentFragment, $ = M.getElementsByTagName, I = t.importNode, L = {};
  try {
    L = Nl(r).documentMode ? r.documentMode : {};
  } catch {
  }
  var P = {};
  e.isSupported = typeof w == "function" && T && typeof T.createHTMLDocument < "u" && L !== 9;
  var Q = xle, X = Cle, W = Ele, q = Ble, Z = Sle, oe = Tle, ne = ble, me = null, b = rr({}, [].concat(Oa(eL), Oa(G_), Oa($_), Oa(V_), Oa(tL))), H = null, V = rr({}, [].concat(Oa(rL), Oa(K_), Oa(iL), Oa(b0))), j = Object.seal(Object.create(null, {
    tagNameCheck: {
      writable: !0,
      configurable: !1,
      enumerable: !0,
      value: null
    },
    attributeNameCheck: {
      writable: !0,
      configurable: !1,
      enumerable: !0,
      value: null
    },
    allowCustomizedBuiltInElements: {
      writable: !0,
      configurable: !1,
      enumerable: !0,
      value: !1
    }
  })), ie = null, ue = null, fe = !0, ee = !0, xe = !1, Ee = !1, Ue = !1, ke = !1, We = !1, ve = !1, Y = !1, mt = !1, Ze = !0, Fe = !0, Re = !1, De = {}, Le = null, Ge = rr({}, ["annotation-xml", "audio", "colgroup", "desc", "foreignobject", "head", "iframe", "math", "mi", "mn", "mo", "ms", "mtext", "noembed", "noframes", "noscript", "plaintext", "script", "style", "svg", "template", "thead", "title", "video", "xmp"]), ze = null, ft = rr({}, ["audio", "video", "img", "source", "image", "track"]), Et = null, Mt = rr({}, ["alt", "class", "for", "id", "label", "name", "pattern", "placeholder", "role", "summary", "title", "value", "style", "xmlns"]), Ut = "http://www.w3.org/1998/Math/MathML", At = "http://www.w3.org/2000/svg", vt = "http://www.w3.org/1999/xhtml", Ne = vt, Qr = !1, kt = void 0, fn = ["application/xhtml+xml", "text/html"], Ar = "text/html", Zt = void 0, ii = null, Jt = r.createElement("form"), rn = function(he) {
    return he instanceof RegExp || he instanceof Function;
  }, ar = function(he) {
    ii && ii === he || ((!he || (typeof he > "u" ? "undefined" : od(he)) !== "object") && (he = {}), he = Nl(he), me = "ALLOWED_TAGS" in he ? rr({}, he.ALLOWED_TAGS) : b, H = "ALLOWED_ATTR" in he ? rr({}, he.ALLOWED_ATTR) : V, Et = "ADD_URI_SAFE_ATTR" in he ? rr(Nl(Mt), he.ADD_URI_SAFE_ATTR) : Mt, ze = "ADD_DATA_URI_TAGS" in he ? rr(Nl(ft), he.ADD_DATA_URI_TAGS) : ft, Le = "FORBID_CONTENTS" in he ? rr({}, he.FORBID_CONTENTS) : Ge, ie = "FORBID_TAGS" in he ? rr({}, he.FORBID_TAGS) : {}, ue = "FORBID_ATTR" in he ? rr({}, he.FORBID_ATTR) : {}, De = "USE_PROFILES" in he ? he.USE_PROFILES : !1, fe = he.ALLOW_ARIA_ATTR !== !1, ee = he.ALLOW_DATA_ATTR !== !1, xe = he.ALLOW_UNKNOWN_PROTOCOLS || !1, Ee = he.SAFE_FOR_TEMPLATES || !1, Ue = he.WHOLE_DOCUMENT || !1, ve = he.RETURN_DOM || !1, Y = he.RETURN_DOM_FRAGMENT || !1, mt = he.RETURN_TRUSTED_TYPE || !1, We = he.FORCE_BODY || !1, Ze = he.SANITIZE_DOM !== !1, Fe = he.KEEP_CONTENT !== !1, Re = he.IN_PLACE || !1, ne = he.ALLOWED_URI_REGEXP || ne, Ne = he.NAMESPACE || vt, he.CUSTOM_ELEMENT_HANDLING && rn(he.CUSTOM_ELEMENT_HANDLING.tagNameCheck) && (j.tagNameCheck = he.CUSTOM_ELEMENT_HANDLING.tagNameCheck), he.CUSTOM_ELEMENT_HANDLING && rn(he.CUSTOM_ELEMENT_HANDLING.attributeNameCheck) && (j.attributeNameCheck = he.CUSTOM_ELEMENT_HANDLING.attributeNameCheck), he.CUSTOM_ELEMENT_HANDLING && typeof he.CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements == "boolean" && (j.allowCustomizedBuiltInElements = he.CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements), kt = // eslint-disable-next-line unicorn/prefer-includes
    fn.indexOf(he.PARSER_MEDIA_TYPE) === -1 ? kt = Ar : kt = he.PARSER_MEDIA_TYPE, Zt = kt === "application/xhtml+xml" ? function(Pe) {
      return Pe;
    } : nm, Ee && (ee = !1), Y && (ve = !0), De && (me = rr({}, [].concat(Oa(tL))), H = [], De.html === !0 && (rr(me, eL), rr(H, rL)), De.svg === !0 && (rr(me, G_), rr(H, K_), rr(H, b0)), De.svgFilters === !0 && (rr(me, $_), rr(H, K_), rr(H, b0)), De.mathMl === !0 && (rr(me, V_), rr(H, iL), rr(H, b0))), he.ADD_TAGS && (me === b && (me = Nl(me)), rr(me, he.ADD_TAGS)), he.ADD_ATTR && (H === V && (H = Nl(H)), rr(H, he.ADD_ATTR)), he.ADD_URI_SAFE_ATTR && rr(Et, he.ADD_URI_SAFE_ATTR), he.FORBID_CONTENTS && (Le === Ge && (Le = Nl(Le)), rr(Le, he.FORBID_CONTENTS)), Fe && (me["#text"] = !0), Ue && rr(me, ["html", "head", "body"]), me.table && (rr(me, ["tbody"]), delete ie.tbody), ss && ss(he), ii = he);
  }, Ai = rr({}, ["mi", "mo", "mn", "ms", "mtext"]), yr = rr({}, ["foreignobject", "desc", "title", "annotation-xml"]), Lr = rr({}, G_);
  rr(Lr, $_), rr(Lr, _le);
  var bt = rr({}, V_);
  rr(bt, wle);
  var Ot = function(he) {
    var Pe = w(he);
    (!Pe || !Pe.tagName) && (Pe = {
      namespaceURI: vt,
      tagName: "template"
    });
    var Ke = nm(he.tagName), er = nm(Pe.tagName);
    if (he.namespaceURI === At)
      return Pe.namespaceURI === vt ? Ke === "svg" : Pe.namespaceURI === Ut ? Ke === "svg" && (er === "annotation-xml" || Ai[er]) : !!Lr[Ke];
    if (he.namespaceURI === Ut)
      return Pe.namespaceURI === vt ? Ke === "math" : Pe.namespaceURI === At ? Ke === "math" && yr[er] : !!bt[Ke];
    if (he.namespaceURI === vt) {
      if (Pe.namespaceURI === At && !yr[er] || Pe.namespaceURI === Ut && !Ai[er])
        return !1;
      var Dr = rr({}, ["title", "style", "font", "a", "script"]);
      return !bt[Ke] && (Dr[Ke] || !Lr[Ke]);
    }
    return !1;
  }, li = function(he) {
    kf(e.removed, { element: he });
    try {
      he.parentNode.removeChild(he);
    } catch {
      try {
        he.outerHTML = S;
      } catch {
        he.remove();
      }
    }
  }, _r = function(he, Pe) {
    try {
      kf(e.removed, {
        attribute: Pe.getAttributeNode(he),
        from: Pe
      });
    } catch {
      kf(e.removed, {
        attribute: null,
        from: Pe
      });
    }
    if (Pe.removeAttribute(he), he === "is" && !H[he])
      if (ve || Y)
        try {
          li(Pe);
        } catch {
        }
      else
        try {
          Pe.setAttribute(he, "");
        } catch {
        }
  }, di = function(he) {
    var Pe = void 0, Ke = void 0;
    if (We)
      he = "<remove></remove>" + he;
    else {
      var er = JF(he, /^[\r\n\t ]+/);
      Ke = er && er[0];
    }
    kt === "application/xhtml+xml" && (he = '<html xmlns="http://www.w3.org/1999/xhtml"><head></head><body>' + he + "</body></html>");
    var Dr = E ? E.createHTML(he) : he;
    if (Ne === vt)
      try {
        Pe = new u().parseFromString(Dr, kt);
      } catch {
      }
    if (!Pe || !Pe.documentElement) {
      Pe = T.createDocument(Ne, "template", null);
      try {
        Pe.documentElement.innerHTML = Qr ? "" : Dr;
      } catch {
      }
    }
    var Xr = Pe.body || Pe.documentElement;
    return he && Ke && Xr.insertBefore(r.createTextNode(Ke), Xr.childNodes[0] || null), Ne === vt ? $.call(Pe, Ue ? "html" : "body")[0] : Ue ? Pe.documentElement : Xr;
  }, zr = function(he) {
    return F.call(he.ownerDocument || he, he, A.SHOW_ELEMENT | A.SHOW_COMMENT | A.SHOW_TEXT, null, !1);
  }, gt = function(he) {
    return he instanceof c && (typeof he.nodeName != "string" || typeof he.textContent != "string" || typeof he.removeChild != "function" || !(he.attributes instanceof h) || typeof he.removeAttribute != "function" || typeof he.setAttribute != "function" || typeof he.namespaceURI != "string" || typeof he.insertBefore != "function");
  }, Ci = function(he) {
    return (typeof a > "u" ? "undefined" : od(a)) === "object" ? he instanceof a : he && (typeof he > "u" ? "undefined" : od(he)) === "object" && typeof he.nodeType == "number" && typeof he.nodeName == "string";
  }, fr = function(he, Pe, Ke) {
    P[he] && ple(P[he], function(er) {
      er.call(e, Pe, Ke, ii);
    });
  }, Ir = function(he) {
    var Pe = void 0;
    if (fr("beforeSanitizeElements", he, null), gt(he) || JF(he.nodeName, /[\u0080-\uFFFF]/))
      return li(he), !0;
    var Ke = Zt(he.nodeName);
    if (fr("uponSanitizeElement", he, {
      tagName: Ke,
      allowedTags: me
    }), !Ci(he.firstElementChild) && (!Ci(he.content) || !Ci(he.content.firstElementChild)) && Ls(/<[/\w]/g, he.innerHTML) && Ls(/<[/\w]/g, he.textContent) || Ke === "select" && Ls(/<template/i, he.innerHTML))
      return li(he), !0;
    if (!me[Ke] || ie[Ke]) {
      if (Fe && !Le[Ke]) {
        var er = w(he) || he.parentNode, Dr = v(he) || he.childNodes;
        if (Dr && er)
          for (var Xr = Dr.length, si = Xr - 1; si >= 0; --si)
            er.insertBefore(p(Dr[si], !0), y(he));
      }
      return !ie[Ke] && ni(Ke) && (j.tagNameCheck instanceof RegExp && Ls(j.tagNameCheck, Ke) || j.tagNameCheck instanceof Function && j.tagNameCheck(Ke)) ? !1 : (li(he), !0);
    }
    return he instanceof o && !Ot(he) || (Ke === "noscript" || Ke === "noembed") && Ls(/<\/no(script|embed)/i, he.innerHTML) ? (li(he), !0) : (Ee && he.nodeType === 3 && (Pe = he.textContent, Pe = OA(Pe, Q, " "), Pe = OA(Pe, X, " "), he.textContent !== Pe && (kf(e.removed, { element: he.cloneNode() }), he.textContent = Pe)), fr("afterSanitizeElements", he, null), !1);
  }, Cr = function(he, Pe, Ke) {
    if (Ze && (Pe === "id" || Pe === "name") && (Ke in r || Ke in Jt))
      return !1;
    if (!(ee && !ue[Pe] && Ls(W, Pe))) {
      if (!(fe && Ls(q, Pe))) {
        if (!H[Pe] || ue[Pe]) {
          if (
            // First condition does a very basic check if a) it's basically a valid custom element tagname AND
            // b) if the tagName passes whatever the user has configured for CUSTOM_ELEMENT_HANDLING.tagNameCheck
            // and c) if the attribute name passes whatever the user has configured for CUSTOM_ELEMENT_HANDLING.attributeNameCheck
            !(ni(he) && (j.tagNameCheck instanceof RegExp && Ls(j.tagNameCheck, he) || j.tagNameCheck instanceof Function && j.tagNameCheck(he)) && (j.attributeNameCheck instanceof RegExp && Ls(j.attributeNameCheck, Pe) || j.attributeNameCheck instanceof Function && j.attributeNameCheck(Pe)) || // Alternative, second condition checks if it's an `is`-attribute, AND
            // the value passes whatever the user has configured for CUSTOM_ELEMENT_HANDLING.tagNameCheck
            Pe === "is" && j.allowCustomizedBuiltInElements && (j.tagNameCheck instanceof RegExp && Ls(j.tagNameCheck, Ke) || j.tagNameCheck instanceof Function && j.tagNameCheck(Ke)))
          )
            return !1;
        } else if (!Et[Pe]) {
          if (!Ls(ne, OA(Ke, oe, ""))) {
            if (!((Pe === "src" || Pe === "xlink:href" || Pe === "href") && he !== "script" && mle(Ke, "data:") === 0 && ze[he])) {
              if (!(xe && !Ls(Z, OA(Ke, oe, "")))) {
                if (Ke)
                  return !1;
              }
            }
          }
        }
      }
    }
    return !0;
  }, ni = function(he) {
    return he.indexOf("-") > 0;
  }, Nn = function(he) {
    var Pe = void 0, Ke = void 0, er = void 0, Dr = void 0;
    fr("beforeSanitizeAttributes", he, null);
    var Xr = he.attributes;
    if (Xr) {
      var si = {
        attrName: "",
        attrValue: "",
        keepAttr: !0,
        allowedAttributes: H
      };
      for (Dr = Xr.length; Dr--; ) {
        Pe = Xr[Dr];
        var ia = Pe, nn = ia.name, co = ia.namespaceURI;
        if (Ke = vle(Pe.value), er = Zt(nn), si.attrName = er, si.attrValue = Ke, si.keepAttr = !0, si.forceKeepAttr = void 0, fr("uponSanitizeAttribute", he, si), Ke = si.attrValue, !si.forceKeepAttr && (_r(nn, he), !!si.keepAttr)) {
          if (Ls(/\/>/i, Ke)) {
            _r(nn, he);
            continue;
          }
          Ee && (Ke = OA(Ke, Q, " "), Ke = OA(Ke, X, " "));
          var cA = Zt(he.nodeName);
          if (Cr(cA, er, Ke))
            try {
              co ? he.setAttributeNS(co, nn, Ke) : he.setAttribute(nn, Ke), ZF(e.removed);
            } catch {
            }
        }
      }
      fr("afterSanitizeAttributes", he, null);
    }
  }, hA = function nt(he) {
    var Pe = void 0, Ke = zr(he);
    for (fr("beforeSanitizeShadowDOM", he, null); Pe = Ke.nextNode(); )
      fr("uponSanitizeShadowNode", Pe, null), !Ir(Pe) && (Pe.content instanceof n && nt(Pe.content), Nn(Pe));
    fr("afterSanitizeShadowDOM", he, null);
  };
  return e.sanitize = function(nt, he) {
    var Pe = void 0, Ke = void 0, er = void 0, Dr = void 0, Xr = void 0;
    if (Qr = !nt, Qr && (nt = "<!-->"), typeof nt != "string" && !Ci(nt)) {
      if (typeof nt.toString != "function")
        throw H_("toString is not a function");
      if (nt = nt.toString(), typeof nt != "string")
        throw H_("dirty is not a string, aborting");
    }
    if (!e.isSupported) {
      if (od(i.toStaticHTML) === "object" || typeof i.toStaticHTML == "function") {
        if (typeof nt == "string")
          return i.toStaticHTML(nt);
        if (Ci(nt))
          return i.toStaticHTML(nt.outerHTML);
      }
      return nt;
    }
    if (ke || ar(he), e.removed = [], typeof nt == "string" && (Re = !1), Re) {
      if (nt.nodeName) {
        var si = Zt(nt.nodeName);
        if (!me[si] || ie[si])
          throw H_("root node is forbidden and cannot be sanitized in-place");
      }
    } else if (nt instanceof a)
      Pe = di("<!---->"), Ke = Pe.ownerDocument.importNode(nt, !0), Ke.nodeType === 1 && Ke.nodeName === "BODY" || Ke.nodeName === "HTML" ? Pe = Ke : Pe.appendChild(Ke);
    else {
      if (!ve && !Ee && !Ue && // eslint-disable-next-line unicorn/prefer-includes
      nt.indexOf("<") === -1)
        return E && mt ? E.createHTML(nt) : nt;
      if (Pe = di(nt), !Pe)
        return ve ? null : mt ? S : "";
    }
    Pe && We && li(Pe.firstChild);
    for (var ia = zr(Re ? nt : Pe); er = ia.nextNode(); )
      er.nodeType === 3 && er === Dr || Ir(er) || (er.content instanceof n && hA(er.content), Nn(er), Dr = er);
    if (Dr = null, Re)
      return nt;
    if (ve) {
      if (Y)
        for (Xr = k.call(Pe.ownerDocument); Pe.firstChild; )
          Xr.appendChild(Pe.firstChild);
      else
        Xr = Pe;
      return H.shadowroot && (Xr = I.call(t, Xr, !0)), Xr;
    }
    var nn = Ue ? Pe.outerHTML : Pe.innerHTML;
    return Ee && (nn = OA(nn, Q, " "), nn = OA(nn, X, " ")), E && mt ? E.createHTML(nn) : nn;
  }, e.setConfig = function(nt) {
    ar(nt), ke = !0;
  }, e.clearConfig = function() {
    ii = null, ke = !1;
  }, e.isValidAttribute = function(nt, he, Pe) {
    ii || ar({});
    var Ke = Zt(nt), er = Zt(he);
    return Cr(Ke, er, Pe);
  }, e.addHook = function(nt, he) {
    typeof he == "function" && (P[nt] = P[nt] || [], kf(P[nt], he));
  }, e.removeHook = function(nt) {
    P[nt] && ZF(P[nt]);
  }, e.removeHooks = function(nt) {
    P[nt] && (P[nt] = []);
  }, e.removeAllHooks = function() {
    P = {};
  }, e;
}
var Ile = d3();
const Rle = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  default: Ile
}, Symbol.toStringTag, { value: "Module" }));
var S0 = function(i) {
  return i && i.Math == Math && i;
}, Kt = (
  // eslint-disable-next-line es/no-global-this -- safe
  S0(typeof globalThis == "object" && globalThis) || S0(typeof window == "object" && window) || // eslint-disable-next-line no-restricted-globals -- safe
  S0(typeof self == "object" && self) || S0(typeof Uo == "object" && Uo) || // eslint-disable-next-line no-new-func -- fallback
  function() {
    return this;
  }() || Function("return this")()
), Gu = {}, tn = function(i) {
  try {
    return !!i();
  } catch {
    return !0;
  }
}, Mle = tn, AA = !Mle(function() {
  return Object.defineProperty({}, 1, { get: function() {
    return 7;
  } })[1] != 7;
}), Nle = tn, wy = !Nle(function() {
  var i = function() {
  }.bind();
  return typeof i != "function" || i.hasOwnProperty("prototype");
}), Ple = wy, T0 = Function.prototype.call, Ds = Ple ? T0.bind(T0) : function() {
  return T0.apply(T0, arguments);
}, g3 = {}, p3 = {}.propertyIsEnumerable, m3 = Object.getOwnPropertyDescriptor, Ole = m3 && !p3.call({ 1: 2 }, 1);
g3.f = Ole ? function(e) {
  var t = m3(this, e);
  return !!t && t.enumerable;
} : p3;
var xy = function(i, e) {
  return {
    enumerable: !(i & 1),
    configurable: !(i & 2),
    writable: !(i & 4),
    value: e
  };
}, v3 = wy, y3 = Function.prototype, Ule = y3.bind, vC = y3.call, Qle = v3 && Ule.bind(vC, vC), ri = v3 ? function(i) {
  return i && Qle(i);
} : function(i) {
  return i && function() {
    return vC.apply(i, arguments);
  };
}, _3 = ri, Dle = _3({}.toString), kle = _3("".slice), $u = function(i) {
  return kle(Dle(i), 8, -1);
}, Hle = Kt, Gle = ri, $le = tn, Vle = $u, j_ = Hle.Object, Kle = Gle("".split), w3 = $le(function() {
  return !j_("z").propertyIsEnumerable(0);
}) ? function(i) {
  return Vle(i) == "String" ? Kle(i, "") : j_(i);
} : j_, jle = Kt, zle = jle.TypeError, ao = function(i) {
  if (i == null)
    throw zle("Can't call method on " + i);
  return i;
}, Xle = w3, Wle = ao, Ig = function(i) {
  return Xle(Wle(i));
}, un = function(i) {
  return typeof i == "function";
}, Yle = un, wl = function(i) {
  return typeof i == "object" ? i !== null : Yle(i);
}, z_ = Kt, qle = un, Zle = function(i) {
  return qle(i) ? i : void 0;
}, Rh = function(i, e) {
  return arguments.length < 2 ? Zle(z_[i]) : z_[i] && z_[i][e];
}, Jle = ri, Cy = Jle({}.isPrototypeOf), ehe = Rh, Ey = ehe("navigator", "userAgent") || "", x3 = Kt, X_ = Ey, nL = x3.process, sL = x3.Deno, aL = nL && nL.versions || sL && sL.version, oL = aL && aL.v8, _a, wv;
oL && (_a = oL.split("."), wv = _a[0] > 0 && _a[0] < 4 ? 1 : +(_a[0] + _a[1]));
!wv && X_ && (_a = X_.match(/Edge\/(\d+)/), (!_a || _a[1] >= 74) && (_a = X_.match(/Chrome\/(\d+)/), _a && (wv = +_a[1])));
var YB = wv, AL = YB, the = tn, C3 = !!Object.getOwnPropertySymbols && !the(function() {
  var i = Symbol();
  return !String(i) || !(Object(i) instanceof Symbol) || // Chrome 38-40 symbols are not inherited from DOM collections prototypes to instances
  !Symbol.sham && AL && AL < 41;
}), rhe = C3, E3 = rhe && !Symbol.sham && typeof Symbol.iterator == "symbol", ihe = Kt, nhe = Rh, she = un, ahe = Cy, ohe = E3, Ahe = ihe.Object, B3 = ohe ? function(i) {
  return typeof i == "symbol";
} : function(i) {
  var e = nhe("Symbol");
  return she(e) && ahe(e.prototype, Ahe(i));
}, lhe = Kt, hhe = lhe.String, By = function(i) {
  try {
    return hhe(i);
  } catch {
    return "Object";
  }
}, che = Kt, uhe = un, fhe = By, dhe = che.TypeError, Vu = function(i) {
  if (uhe(i))
    return i;
  throw dhe(fhe(i) + " is not a function");
}, ghe = Vu, Ku = function(i, e) {
  var t = i[e];
  return t == null ? void 0 : ghe(t);
}, phe = Kt, W_ = Ds, Y_ = un, q_ = wl, mhe = phe.TypeError, vhe = function(i, e) {
  var t, r;
  if (e === "string" && Y_(t = i.toString) && !q_(r = W_(t, i)) || Y_(t = i.valueOf) && !q_(r = W_(t, i)) || e !== "string" && Y_(t = i.toString) && !q_(r = W_(t, i)))
    return r;
  throw mhe("Can't convert object to primitive value");
}, rg = {}, yhe = {
  get exports() {
    return rg;
  },
  set exports(i) {
    rg = i;
  }
}, lL = Kt, _he = Object.defineProperty, qB = function(i, e) {
  try {
    _he(lL, i, { value: e, configurable: !0, writable: !0 });
  } catch {
    lL[i] = e;
  }
  return e;
}, whe = Kt, xhe = qB, hL = "__core-js_shared__", Che = whe[hL] || xhe(hL, {}), ZB = Che, cL = ZB;
(yhe.exports = function(i, e) {
  return cL[i] || (cL[i] = e !== void 0 ? e : {});
})("versions", []).push({
  version: "3.20.3",
  mode: "global",
  copyright: " 2014-2022 Denis Pushkarev (zloirock.ru)",
  license: "https://github.com/zloirock/core-js/blob/v3.20.3/LICENSE",
  source: "https://github.com/zloirock/core-js"
});
var Ehe = Kt, Bhe = ao, bhe = Ehe.Object, by = function(i) {
  return bhe(Bhe(i));
}, She = ri, The = by, Fhe = She({}.hasOwnProperty), oo = Object.hasOwn || function(e, t) {
  return Fhe(The(e), t);
}, Lhe = ri, Ihe = 0, Rhe = Math.random(), Mhe = Lhe(1 .toString), b3 = function(i) {
  return "Symbol(" + (i === void 0 ? "" : i) + ")_" + Mhe(++Ihe + Rhe, 36);
}, Nhe = Kt, Phe = rg, uL = oo, Ohe = b3, fL = C3, S3 = E3, vc = Phe("wks"), lh = Nhe.Symbol, dL = lh && lh.for, Uhe = S3 ? lh : lh && lh.withoutSetter || Ohe, Bn = function(i) {
  if (!uL(vc, i) || !(fL || typeof vc[i] == "string")) {
    var e = "Symbol." + i;
    fL && uL(lh, i) ? vc[i] = lh[i] : S3 && dL ? vc[i] = dL(e) : vc[i] = Uhe(e);
  }
  return vc[i];
}, Qhe = Kt, Dhe = Ds, gL = wl, pL = B3, khe = Ku, Hhe = vhe, Ghe = Bn, $he = Qhe.TypeError, Vhe = Ghe("toPrimitive"), Khe = function(i, e) {
  if (!gL(i) || pL(i))
    return i;
  var t = khe(i, Vhe), r;
  if (t) {
    if (e === void 0 && (e = "default"), r = Dhe(t, i, e), !gL(r) || pL(r))
      return r;
    throw $he("Can't convert object to primitive value");
  }
  return e === void 0 && (e = "number"), Hhe(i, e);
}, jhe = Khe, zhe = B3, JB = function(i) {
  var e = jhe(i, "string");
  return zhe(e) ? e : e + "";
}, Xhe = Kt, mL = wl, yC = Xhe.document, Whe = mL(yC) && mL(yC.createElement), Sy = function(i) {
  return Whe ? yC.createElement(i) : {};
}, Yhe = AA, qhe = tn, Zhe = Sy, T3 = !Yhe && !qhe(function() {
  return Object.defineProperty(Zhe("div"), "a", {
    get: function() {
      return 7;
    }
  }).a != 7;
}), Jhe = AA, ece = Ds, tce = g3, rce = xy, ice = Ig, nce = JB, sce = oo, ace = T3, vL = Object.getOwnPropertyDescriptor;
Gu.f = Jhe ? vL : function(e, t) {
  if (e = ice(e), t = nce(t), ace)
    try {
      return vL(e, t);
    } catch {
    }
  if (sce(e, t))
    return rce(!ece(tce.f, e, t), e[t]);
};
var lA = {}, oce = AA, Ace = tn, F3 = oce && Ace(function() {
  return Object.defineProperty(function() {
  }, "prototype", {
    value: 42,
    writable: !1
  }).prototype != 42;
}), L3 = Kt, lce = wl, hce = L3.String, cce = L3.TypeError, Yn = function(i) {
  if (lce(i))
    return i;
  throw cce(hce(i) + " is not an object");
}, uce = Kt, fce = AA, dce = T3, gce = F3, F0 = Yn, yL = JB, pce = uce.TypeError, Z_ = Object.defineProperty, mce = Object.getOwnPropertyDescriptor, J_ = "enumerable", ew = "configurable", tw = "writable";
lA.f = fce ? gce ? function(e, t, r) {
  if (F0(e), t = yL(t), F0(r), typeof e == "function" && t === "prototype" && "value" in r && tw in r && !r[tw]) {
    var n = mce(e, t);
    n && n[tw] && (e[t] = r.value, r = {
      configurable: ew in r ? r[ew] : n[ew],
      enumerable: J_ in r ? r[J_] : n[J_],
      writable: !1
    });
  }
  return Z_(e, t, r);
} : Z_ : function(e, t, r) {
  if (F0(e), t = yL(t), F0(r), dce)
    try {
      return Z_(e, t, r);
    } catch {
    }
  if ("get" in r || "set" in r)
    throw pce("Accessors not supported");
  return "value" in r && (e[t] = r.value), e;
};
var vce = AA, yce = lA, _ce = xy, ju = vce ? function(i, e, t) {
  return yce.f(i, e, _ce(1, t));
} : function(i, e, t) {
  return i[e] = t, i;
}, Jo = {}, wce = {
  get exports() {
    return Jo;
  },
  set exports(i) {
    Jo = i;
  }
}, xce = ri, Cce = un, _C = ZB, Ece = xce(Function.toString);
Cce(_C.inspectSource) || (_C.inspectSource = function(i) {
  return Ece(i);
});
var Ty = _C.inspectSource, Bce = Kt, bce = un, Sce = Ty, _L = Bce.WeakMap, Tce = bce(_L) && /native code/.test(Sce(_L)), Fce = rg, Lce = b3, wL = Fce("keys"), eb = function(i) {
  return wL[i] || (wL[i] = Lce(i));
}, tb = {}, Ice = Tce, I3 = Kt, rw = ri, Rce = wl, Mce = ju, iw = oo, nw = ZB, Nce = eb, Pce = tb, xL = "Object already initialized", wC = I3.TypeError, Oce = I3.WeakMap, xv, ig, Cv, Uce = function(i) {
  return Cv(i) ? ig(i) : xv(i, {});
}, Qce = function(i) {
  return function(e) {
    var t;
    if (!Rce(e) || (t = ig(e)).type !== i)
      throw wC("Incompatible receiver, " + i + " required");
    return t;
  };
};
if (Ice || nw.state) {
  var Pl = nw.state || (nw.state = new Oce()), Dce = rw(Pl.get), CL = rw(Pl.has), kce = rw(Pl.set);
  xv = function(i, e) {
    if (CL(Pl, i))
      throw new wC(xL);
    return e.facade = i, kce(Pl, i, e), e;
  }, ig = function(i) {
    return Dce(Pl, i) || {};
  }, Cv = function(i) {
    return CL(Pl, i);
  };
} else {
  var yc = Nce("state");
  Pce[yc] = !0, xv = function(i, e) {
    if (iw(i, yc))
      throw new wC(xL);
    return e.facade = i, Mce(i, yc, e), e;
  }, ig = function(i) {
    return iw(i, yc) ? i[yc] : {};
  }, Cv = function(i) {
    return iw(i, yc);
  };
}
var Fy = {
  set: xv,
  get: ig,
  has: Cv,
  enforce: Uce,
  getterFor: Qce
}, xC = AA, Hce = oo, R3 = Function.prototype, Gce = xC && Object.getOwnPropertyDescriptor, rb = Hce(R3, "name"), $ce = rb && function() {
}.name === "something", Vce = rb && (!xC || xC && Gce(R3, "name").configurable), Ly = {
  EXISTS: rb,
  PROPER: $ce,
  CONFIGURABLE: Vce
}, Kce = Kt, EL = un, jce = oo, BL = ju, zce = qB, Xce = Ty, M3 = Fy, Wce = Ly.CONFIGURABLE, Yce = M3.get, qce = M3.enforce, Zce = String(String).split("String");
(wce.exports = function(i, e, t, r) {
  var n = r ? !!r.unsafe : !1, s = r ? !!r.enumerable : !1, a = r ? !!r.noTargetGet : !1, o = r && r.name !== void 0 ? r.name : e, A;
  if (EL(t) && (String(o).slice(0, 7) === "Symbol(" && (o = "[" + String(o).replace(/^Symbol\(([^)]*)\)/, "$1") + "]"), (!jce(t, "name") || Wce && t.name !== o) && BL(t, "name", o), A = qce(t), A.source || (A.source = Zce.join(typeof o == "string" ? o : ""))), i === Kce) {
    s ? i[e] = t : zce(e, t);
    return;
  } else
    n ? !a && i[e] && (s = !0) : delete i[e];
  s ? i[e] = t : BL(i, e, t);
})(Function.prototype, "toString", function() {
  return EL(this) && Yce(this).source || Xce(this);
});
var N3 = {}, Jce = Math.ceil, eue = Math.floor, Iy = function(i) {
  var e = +i;
  return e !== e || e === 0 ? 0 : (e > 0 ? eue : Jce)(e);
}, tue = Iy, rue = Math.max, iue = Math.min, P3 = function(i, e) {
  var t = tue(i);
  return t < 0 ? rue(t + e, 0) : iue(t, e);
}, nue = Iy, sue = Math.min, zu = function(i) {
  return i > 0 ? sue(nue(i), 9007199254740991) : 0;
}, aue = zu, Ry = function(i) {
  return aue(i.length);
}, oue = Ig, Aue = P3, lue = Ry, bL = function(i) {
  return function(e, t, r) {
    var n = oue(e), s = lue(n), a = Aue(r, s), o;
    if (i && t != t) {
      for (; s > a; )
        if (o = n[a++], o != o)
          return !0;
    } else
      for (; s > a; a++)
        if ((i || a in n) && n[a] === t)
          return i || a || 0;
    return !i && -1;
  };
}, O3 = {
  // `Array.prototype.includes` method
  // https://tc39.es/ecma262/#sec-array.prototype.includes
  includes: bL(!0),
  // `Array.prototype.indexOf` method
  // https://tc39.es/ecma262/#sec-array.prototype.indexof
  indexOf: bL(!1)
}, hue = ri, sw = oo, cue = Ig, uue = O3.indexOf, fue = tb, SL = hue([].push), U3 = function(i, e) {
  var t = cue(i), r = 0, n = [], s;
  for (s in t)
    !sw(fue, s) && sw(t, s) && SL(n, s);
  for (; e.length > r; )
    sw(t, s = e[r++]) && (~uue(n, s) || SL(n, s));
  return n;
}, ib = [
  "constructor",
  "hasOwnProperty",
  "isPrototypeOf",
  "propertyIsEnumerable",
  "toLocaleString",
  "toString",
  "valueOf"
], due = U3, gue = ib, pue = gue.concat("length", "prototype");
N3.f = Object.getOwnPropertyNames || function(e) {
  return due(e, pue);
};
var Q3 = {};
Q3.f = Object.getOwnPropertySymbols;
var mue = Rh, vue = ri, yue = N3, _ue = Q3, wue = Yn, xue = vue([].concat), Cue = mue("Reflect", "ownKeys") || function(e) {
  var t = yue.f(wue(e)), r = _ue.f;
  return r ? xue(t, r(e)) : t;
}, TL = oo, Eue = Cue, Bue = Gu, bue = lA, Sue = function(i, e, t) {
  for (var r = Eue(e), n = bue.f, s = Bue.f, a = 0; a < r.length; a++) {
    var o = r[a];
    !TL(i, o) && !(t && TL(t, o)) && n(i, o, s(e, o));
  }
}, Tue = tn, Fue = un, Lue = /#|\.prototype\./, Rg = function(i, e) {
  var t = Rue[Iue(i)];
  return t == Nue ? !0 : t == Mue ? !1 : Fue(e) ? Tue(e) : !!e;
}, Iue = Rg.normalize = function(i) {
  return String(i).replace(Lue, ".").toLowerCase();
}, Rue = Rg.data = {}, Mue = Rg.NATIVE = "N", Nue = Rg.POLYFILL = "P", D3 = Rg, aw = Kt, Pue = Gu.f, Oue = ju, Uue = Jo, Que = qB, Due = Sue, kue = D3, Ao = function(i, e) {
  var t = i.target, r = i.global, n = i.stat, s, a, o, A, l, h;
  if (r ? a = aw : n ? a = aw[t] || Que(t, {}) : a = (aw[t] || {}).prototype, a)
    for (o in e) {
      if (l = e[o], i.noTargetGet ? (h = Pue(a, o), A = h && h.value) : A = a[o], s = kue(r ? o : t + (n ? "." : "#") + o, i.forced), !s && A !== void 0) {
        if (typeof l == typeof A)
          continue;
        Due(l, A);
      }
      (i.sham || A && A.sham) && Oue(l, "sham", !0), Uue(a, o, l, i);
    }
}, Hue = Kt, Gue = Hue.Promise, $ue = Jo, Vue = function(i, e, t) {
  for (var r in e)
    $ue(i, r, e[r], t);
  return i;
}, k3 = Kt, Kue = un, jue = k3.String, zue = k3.TypeError, Xue = function(i) {
  if (typeof i == "object" || Kue(i))
    return i;
  throw zue("Can't set " + jue(i) + " as a prototype");
}, Wue = ri, Yue = Yn, que = Xue, H3 = Object.setPrototypeOf || ("__proto__" in {} ? function() {
  var i = !1, e = {}, t;
  try {
    t = Wue(Object.getOwnPropertyDescriptor(Object.prototype, "__proto__").set), t(e, []), i = e instanceof Array;
  } catch {
  }
  return function(n, s) {
    return Yue(n), que(s), i ? t(n, s) : n.__proto__ = s, n;
  };
}() : void 0), Zue = lA.f, Jue = oo, efe = Bn, FL = efe("toStringTag"), nb = function(i, e, t) {
  i && !t && (i = i.prototype), i && !Jue(i, FL) && Zue(i, FL, { configurable: !0, value: e });
}, tfe = Rh, rfe = lA, ife = Bn, nfe = AA, LL = ife("species"), sfe = function(i) {
  var e = tfe(i), t = rfe.f;
  nfe && e && !e[LL] && t(e, LL, {
    configurable: !0,
    get: function() {
      return this;
    }
  });
}, afe = Kt, ofe = Cy, Afe = afe.TypeError, lfe = function(i, e) {
  if (ofe(e, i))
    return i;
  throw Afe("Incorrect invocation");
}, IL = ri, hfe = Vu, cfe = wy, ufe = IL(IL.bind), sb = function(i, e) {
  return hfe(i), e === void 0 ? i : cfe ? ufe(i, e) : function() {
    return i.apply(e, arguments);
  };
}, Mg = {}, ffe = Bn, dfe = Mg, gfe = ffe("iterator"), pfe = Array.prototype, mfe = function(i) {
  return i !== void 0 && (dfe.Array === i || pfe[gfe] === i);
}, vfe = Bn, yfe = vfe("toStringTag"), G3 = {};
G3[yfe] = "z";
var _fe = String(G3) === "[object z]", wfe = Kt, xfe = _fe, Cfe = un, sm = $u, Efe = Bn, Bfe = Efe("toStringTag"), bfe = wfe.Object, Sfe = sm(function() {
  return arguments;
}()) == "Arguments", Tfe = function(i, e) {
  try {
    return i[e];
  } catch {
  }
}, ab = xfe ? sm : function(i) {
  var e, t, r;
  return i === void 0 ? "Undefined" : i === null ? "Null" : typeof (t = Tfe(e = bfe(i), Bfe)) == "string" ? t : Sfe ? sm(e) : (r = sm(e)) == "Object" && Cfe(e.callee) ? "Arguments" : r;
}, Ffe = ab, RL = Ku, Lfe = Mg, Ife = Bn, Rfe = Ife("iterator"), $3 = function(i) {
  if (i != null)
    return RL(i, Rfe) || RL(i, "@@iterator") || Lfe[Ffe(i)];
}, Mfe = Kt, Nfe = Ds, Pfe = Vu, Ofe = Yn, Ufe = By, Qfe = $3, Dfe = Mfe.TypeError, kfe = function(i, e) {
  var t = arguments.length < 2 ? Qfe(i) : e;
  if (Pfe(t))
    return Ofe(Nfe(t, i));
  throw Dfe(Ufe(i) + " is not iterable");
}, Hfe = Ds, ML = Yn, Gfe = Ku, $fe = function(i, e, t) {
  var r, n;
  ML(i);
  try {
    if (r = Gfe(i, "return"), !r) {
      if (e === "throw")
        throw t;
      return t;
    }
    r = Hfe(r, i);
  } catch (s) {
    n = !0, r = s;
  }
  if (e === "throw")
    throw t;
  if (n)
    throw r;
  return ML(r), t;
}, Vfe = Kt, Kfe = sb, jfe = Ds, zfe = Yn, Xfe = By, Wfe = mfe, Yfe = Ry, NL = Cy, qfe = kfe, Zfe = $3, PL = $fe, Jfe = Vfe.TypeError, am = function(i, e) {
  this.stopped = i, this.result = e;
}, OL = am.prototype, ede = function(i, e, t) {
  var r = t && t.that, n = !!(t && t.AS_ENTRIES), s = !!(t && t.IS_ITERATOR), a = !!(t && t.INTERRUPTED), o = Kfe(e, r), A, l, h, c, u, f, g, p = function(v) {
    return A && PL(A, "normal", v), new am(!0, v);
  }, y = function(v) {
    return n ? (zfe(v), a ? o(v[0], v[1], p) : o(v[0], v[1])) : a ? o(v, p) : o(v);
  };
  if (s)
    A = i;
  else {
    if (l = Zfe(i), !l)
      throw Jfe(Xfe(i) + " is not iterable");
    if (Wfe(l)) {
      for (h = 0, c = Yfe(i); c > h; h++)
        if (u = y(i[h]), u && NL(OL, u))
          return u;
      return new am(!1);
    }
    A = qfe(i, l);
  }
  for (f = A.next; !(g = jfe(f, A)).done; ) {
    try {
      u = y(g.value);
    } catch (v) {
      PL(A, "throw", v);
    }
    if (typeof u == "object" && u && NL(OL, u))
      return u;
  }
  return new am(!1);
}, tde = Bn, V3 = tde("iterator"), K3 = !1;
try {
  var rde = 0, UL = {
    next: function() {
      return { done: !!rde++ };
    },
    return: function() {
      K3 = !0;
    }
  };
  UL[V3] = function() {
    return this;
  }, Array.from(UL, function() {
    throw 2;
  });
} catch {
}
var ide = function(i, e) {
  if (!e && !K3)
    return !1;
  var t = !1;
  try {
    var r = {};
    r[V3] = function() {
      return {
        next: function() {
          return { done: t = !0 };
        }
      };
    }, i(r);
  } catch {
  }
  return t;
}, nde = ri, sde = tn, j3 = un, ade = ab, ode = Rh, Ade = Ty, z3 = function() {
}, lde = [], X3 = ode("Reflect", "construct"), ob = /^\s*(?:class|function)\b/, hde = nde(ob.exec), cde = !ob.exec(z3), Hf = function(e) {
  if (!j3(e))
    return !1;
  try {
    return X3(z3, lde, e), !0;
  } catch {
    return !1;
  }
}, W3 = function(e) {
  if (!j3(e))
    return !1;
  switch (ade(e)) {
    case "AsyncFunction":
    case "GeneratorFunction":
    case "AsyncGeneratorFunction":
      return !1;
  }
  try {
    return cde || !!hde(ob, Ade(e));
  } catch {
    return !0;
  }
};
W3.sham = !0;
var ude = !X3 || sde(function() {
  var i;
  return Hf(Hf.call) || !Hf(Object) || !Hf(function() {
    i = !0;
  }) || i;
}) ? W3 : Hf, fde = Kt, dde = ude, gde = By, pde = fde.TypeError, mde = function(i) {
  if (dde(i))
    return i;
  throw pde(gde(i) + " is not a constructor");
}, QL = Yn, vde = mde, yde = Bn, _de = yde("species"), Y3 = function(i, e) {
  var t = QL(i).constructor, r;
  return t === void 0 || (r = QL(t)[_de]) == null ? e : vde(r);
}, wde = wy, q3 = Function.prototype, DL = q3.apply, kL = q3.call, Ab = typeof Reflect == "object" && Reflect.apply || (wde ? kL.bind(DL) : function() {
  return kL.apply(DL, arguments);
}), xde = Rh, Z3 = xde("document", "documentElement"), Cde = ri, Ede = Cde([].slice), Bde = Ey, J3 = /(?:ipad|iphone|ipod).*applewebkit/i.test(Bde), bde = $u, Sde = Kt, My = bde(Sde.process) == "process", Us = Kt, Tde = Ab, Fde = sb, HL = un, Lde = oo, Ide = tn, GL = Z3, Rde = Ede, $L = Sy, Mde = J3, Nde = My, CC = Us.setImmediate, EC = Us.clearImmediate, Pde = Us.process, ow = Us.Dispatch, Ode = Us.Function, VL = Us.MessageChannel, Ude = Us.String, Aw = 0, Ed = {}, KL = "onreadystatechange", ng, Ol, lw, hw;
try {
  ng = Us.location;
} catch {
}
var lb = function(i) {
  if (Lde(Ed, i)) {
    var e = Ed[i];
    delete Ed[i], e();
  }
}, cw = function(i) {
  return function() {
    lb(i);
  };
}, jL = function(i) {
  lb(i.data);
}, zL = function(i) {
  Us.postMessage(Ude(i), ng.protocol + "//" + ng.host);
};
(!CC || !EC) && (CC = function(e) {
  var t = Rde(arguments, 1);
  return Ed[++Aw] = function() {
    Tde(HL(e) ? e : Ode(e), void 0, t);
  }, Ol(Aw), Aw;
}, EC = function(e) {
  delete Ed[e];
}, Nde ? Ol = function(i) {
  Pde.nextTick(cw(i));
} : ow && ow.now ? Ol = function(i) {
  ow.now(cw(i));
} : VL && !Mde ? (lw = new VL(), hw = lw.port2, lw.port1.onmessage = jL, Ol = Fde(hw.postMessage, hw)) : Us.addEventListener && HL(Us.postMessage) && !Us.importScripts && ng && ng.protocol !== "file:" && !Ide(zL) ? (Ol = zL, Us.addEventListener("message", jL, !1)) : KL in $L("script") ? Ol = function(i) {
  GL.appendChild($L("script"))[KL] = function() {
    GL.removeChild(this), lb(i);
  };
} : Ol = function(i) {
  setTimeout(cw(i), 0);
});
var eO = {
  set: CC,
  clear: EC
}, Qde = Ey, Dde = Kt, kde = /ipad|iphone|ipod/i.test(Qde) && Dde.Pebble !== void 0, Hde = Ey, Gde = /web0s(?!.*chrome)/i.test(Hde), xh = Kt, XL = sb, $de = Gu.f, uw = eO.set, Vde = J3, Kde = kde, jde = Gde, fw = My, WL = xh.MutationObserver || xh.WebKitMutationObserver, YL = xh.document, qL = xh.process, L0 = xh.Promise, ZL = $de(xh, "queueMicrotask"), tO = ZL && ZL.value, Gf, Kl, Bd, Mc, dw, gw, I0, JL;
tO || (Gf = function() {
  var i, e;
  for (fw && (i = qL.domain) && i.exit(); Kl; ) {
    e = Kl.fn, Kl = Kl.next;
    try {
      e();
    } catch (t) {
      throw Kl ? Mc() : Bd = void 0, t;
    }
  }
  Bd = void 0, i && i.enter();
}, !Vde && !fw && !jde && WL && YL ? (dw = !0, gw = YL.createTextNode(""), new WL(Gf).observe(gw, { characterData: !0 }), Mc = function() {
  gw.data = dw = !dw;
}) : !Kde && L0 && L0.resolve ? (I0 = L0.resolve(void 0), I0.constructor = L0, JL = XL(I0.then, I0), Mc = function() {
  JL(Gf);
}) : fw ? Mc = function() {
  qL.nextTick(Gf);
} : (uw = XL(uw, xh), Mc = function() {
  uw(Gf);
}));
var zde = tO || function(i) {
  var e = { fn: i, next: void 0 };
  Bd && (Bd.next = e), Kl || (Kl = e, Mc()), Bd = e;
}, hb = {}, eI = Vu, Xde = function(i) {
  var e, t;
  this.promise = new i(function(r, n) {
    if (e !== void 0 || t !== void 0)
      throw TypeError("Bad Promise constructor");
    e = r, t = n;
  }), this.resolve = eI(e), this.reject = eI(t);
};
hb.f = function(i) {
  return new Xde(i);
};
var Wde = Yn, Yde = wl, qde = hb, Zde = function(i, e) {
  if (Wde(i), Yde(e) && e.constructor === i)
    return e;
  var t = qde.f(i), r = t.resolve;
  return r(e), t.promise;
}, Jde = Kt, ege = function(i, e) {
  var t = Jde.console;
  t && t.error && (arguments.length == 1 ? t.error(i) : t.error(i, e));
}, tge = function(i) {
  try {
    return { error: !1, value: i() };
  } catch (e) {
    return { error: !0, value: e };
  }
}, rO = function() {
  this.head = null, this.tail = null;
};
rO.prototype = {
  add: function(i) {
    var e = { item: i, next: null };
    this.head ? this.tail.next = e : this.head = e, this.tail = e;
  },
  get: function() {
    var i = this.head;
    if (i)
      return this.head = i.next, this.tail === i && (this.tail = null), i.item;
  }
};
var rge = rO, ige = typeof window == "object", Ny = Ao, eA = Kt, nge = Rh, tA = Ds, Ev = Gue, tI = Jo, sge = Vue, rI = H3, age = nb, oge = sfe, BC = Vu, bd = un, Age = wl, lge = lfe, hge = Ty, iI = ede, cge = ide, uge = Y3, iO = eO.set, cb = zde, fge = Zde, dge = ege, nO = hb, bC = tge, gge = rge, ub = Fy, pge = D3, mge = Bn, vge = ige, Bv = My, nI = YB, yge = mge("species"), lo = "Promise", sI = ub.getterFor(lo), _ge = ub.set, wge = ub.getterFor(lo), Gl = Ev && Ev.prototype, xa = Ev, $f = Gl, sO = eA.TypeError, SC = eA.document, fb = eA.process, Eu = nO.f, xge = Eu, Cge = !!(SC && SC.createEvent && eA.dispatchEvent), aO = bd(eA.PromiseRejectionEvent), oO = "unhandledrejection", Ege = "rejectionhandled", aI = 0, AO = 1, Bge = 2, db = 1, lO = 2, TC = !1, R0, oI, hO, AI, Ng = pge(lo, function() {
  var i = hge(xa), e = i !== String(xa);
  if (!e && nI === 66)
    return !0;
  if (nI >= 51 && /native code/.test(i))
    return !1;
  var t = new xa(function(s) {
    s(1);
  }), r = function(s) {
    s(function() {
    }, function() {
    });
  }, n = t.constructor = {};
  return n[yge] = r, TC = t.then(function() {
  }) instanceof r, TC ? !e && vge && !aO : !0;
}), bge = Ng || !cge(function(i) {
  xa.all(i).catch(function() {
  });
}), cO = function(i) {
  var e;
  return Age(i) && bd(e = i.then) ? e : !1;
}, uO = function(i, e) {
  var t = e.value, r = e.state == AO, n = r ? i.ok : i.fail, s = i.resolve, a = i.reject, o = i.domain, A, l, h;
  try {
    n ? (r || (e.rejection === lO && Tge(e), e.rejection = db), n === !0 ? A = t : (o && o.enter(), A = n(t), o && (o.exit(), h = !0)), A === i.promise ? a(sO("Promise-chain cycle")) : (l = cO(A)) ? tA(l, A, s, a) : s(A)) : a(t);
  } catch (c) {
    o && !h && o.exit(), a(c);
  }
}, fO = function(i, e) {
  i.notified || (i.notified = !0, cb(function() {
    for (var t = i.reactions, r; r = t.get(); )
      uO(r, i);
    i.notified = !1, e && !i.rejection && Sge(i);
  }));
}, dO = function(i, e, t) {
  var r, n;
  Cge ? (r = SC.createEvent("Event"), r.promise = e, r.reason = t, r.initEvent(i, !1, !0), eA.dispatchEvent(r)) : r = { promise: e, reason: t }, !aO && (n = eA["on" + i]) ? n(r) : i === oO && dge("Unhandled promise rejection", t);
}, Sge = function(i) {
  tA(iO, eA, function() {
    var e = i.facade, t = i.value, r = lI(i), n;
    if (r && (n = bC(function() {
      Bv ? fb.emit("unhandledRejection", t, e) : dO(oO, e, t);
    }), i.rejection = Bv || lI(i) ? lO : db, n.error))
      throw n.value;
  });
}, lI = function(i) {
  return i.rejection !== db && !i.parent;
}, Tge = function(i) {
  tA(iO, eA, function() {
    var e = i.facade;
    Bv ? fb.emit("rejectionHandled", e) : dO(Ege, e, i.value);
  });
}, zc = function(i, e, t) {
  return function(r) {
    i(e, r, t);
  };
}, Au = function(i, e, t) {
  i.done || (i.done = !0, t && (i = t), i.value = e, i.state = Bge, fO(i, !0));
}, FC = function(i, e, t) {
  if (!i.done) {
    i.done = !0, t && (i = t);
    try {
      if (i.facade === e)
        throw sO("Promise can't be resolved itself");
      var r = cO(e);
      r ? cb(function() {
        var n = { done: !1 };
        try {
          tA(
            r,
            e,
            zc(FC, n, i),
            zc(Au, n, i)
          );
        } catch (s) {
          Au(n, s, i);
        }
      }) : (i.value = e, i.state = AO, fO(i, !1));
    } catch (n) {
      Au({ done: !1 }, n, i);
    }
  }
};
if (Ng && (xa = function(e) {
  lge(this, $f), BC(e), tA(R0, this);
  var t = sI(this);
  try {
    e(zc(FC, t), zc(Au, t));
  } catch (r) {
    Au(t, r);
  }
}, $f = xa.prototype, R0 = function(e) {
  _ge(this, {
    type: lo,
    done: !1,
    notified: !1,
    parent: !1,
    reactions: new gge(),
    rejection: !1,
    state: aI,
    value: void 0
  });
}, R0.prototype = sge($f, {
  // `Promise.prototype.then` method
  // https://tc39.es/ecma262/#sec-promise.prototype.then
  // eslint-disable-next-line unicorn/no-thenable -- safe
  then: function(e, t) {
    var r = wge(this), n = Eu(uge(this, xa));
    return r.parent = !0, n.ok = bd(e) ? e : !0, n.fail = bd(t) && t, n.domain = Bv ? fb.domain : void 0, r.state == aI ? r.reactions.add(n) : cb(function() {
      uO(n, r);
    }), n.promise;
  },
  // `Promise.prototype.catch` method
  // https://tc39.es/ecma262/#sec-promise.prototype.catch
  catch: function(i) {
    return this.then(void 0, i);
  }
}), oI = function() {
  var i = new R0(), e = sI(i);
  this.promise = i, this.resolve = zc(FC, e), this.reject = zc(Au, e);
}, nO.f = Eu = function(i) {
  return i === xa || i === hO ? new oI(i) : xge(i);
}, bd(Ev) && Gl !== Object.prototype)) {
  AI = Gl.then, TC || (tI(Gl, "then", function(e, t) {
    var r = this;
    return new xa(function(n, s) {
      tA(AI, r, n, s);
    }).then(e, t);
  }, { unsafe: !0 }), tI(Gl, "catch", $f.catch, { unsafe: !0 }));
  try {
    delete Gl.constructor;
  } catch {
  }
  rI && rI(Gl, $f);
}
Ny({ global: !0, wrap: !0, forced: Ng }, {
  Promise: xa
});
age(xa, lo, !1);
oge(lo);
hO = nge(lo);
Ny({ target: lo, stat: !0, forced: Ng }, {
  // `Promise.reject` method
  // https://tc39.es/ecma262/#sec-promise.reject
  reject: function(e) {
    var t = Eu(this);
    return tA(t.reject, void 0, e), t.promise;
  }
});
Ny({ target: lo, stat: !0, forced: Ng }, {
  // `Promise.resolve` method
  // https://tc39.es/ecma262/#sec-promise.resolve
  resolve: function(e) {
    return fge(this, e);
  }
});
Ny({ target: lo, stat: !0, forced: bge }, {
  // `Promise.all` method
  // https://tc39.es/ecma262/#sec-promise.all
  all: function(e) {
    var t = this, r = Eu(t), n = r.resolve, s = r.reject, a = bC(function() {
      var o = BC(t.resolve), A = [], l = 0, h = 1;
      iI(e, function(c) {
        var u = l++, f = !1;
        h++, tA(o, t, c).then(function(g) {
          f || (f = !0, A[u] = g, --h || n(A));
        }, s);
      }), --h || n(A);
    });
    return a.error && s(a.value), r.promise;
  },
  // `Promise.race` method
  // https://tc39.es/ecma262/#sec-promise.race
  race: function(e) {
    var t = this, r = Eu(t), n = r.reject, s = bC(function() {
      var a = BC(t.resolve);
      iI(e, function(o) {
        tA(a, t, o).then(r.resolve, n);
      });
    });
    return s.error && n(s.value), r.promise;
  }
});
function hI(i, e, t, r, n, s, a) {
  try {
    var o = i[s](a), A = o.value;
  } catch (l) {
    t(l);
    return;
  }
  o.done ? e(A) : Promise.resolve(A).then(r, n);
}
function rA(i) {
  return function() {
    var e = this, t = arguments;
    return new Promise(function(r, n) {
      var s = i.apply(e, t);
      function a(A) {
        hI(s, r, n, a, o, "next", A);
      }
      function o(A) {
        hI(s, r, n, a, o, "throw", A);
      }
      a(void 0);
    });
  };
}
var Fge = Kt, Lge = ab, Ige = Fge.String, ho = function(i) {
  if (Lge(i) === "Symbol")
    throw TypeError("Cannot convert a Symbol value to a string");
  return Ige(i);
}, Rge = Yn, gO = function() {
  var i = Rge(this), e = "";
  return i.global && (e += "g"), i.ignoreCase && (e += "i"), i.multiline && (e += "m"), i.dotAll && (e += "s"), i.unicode && (e += "u"), i.sticky && (e += "y"), e;
}, gb = tn, Mge = Kt, pb = Mge.RegExp, mb = gb(function() {
  var i = pb("a", "y");
  return i.lastIndex = 2, i.exec("abcd") != null;
}), Nge = mb || gb(function() {
  return !pb("a", "y").sticky;
}), Pge = mb || gb(function() {
  var i = pb("^r", "gy");
  return i.lastIndex = 2, i.exec("str") != null;
}), pO = {
  BROKEN_CARET: Pge,
  MISSED_STICKY: Nge,
  UNSUPPORTED_Y: mb
}, mO = {}, Oge = U3, Uge = ib, Qge = Object.keys || function(e) {
  return Oge(e, Uge);
}, Dge = AA, kge = F3, Hge = lA, Gge = Yn, $ge = Ig, Vge = Qge;
mO.f = Dge && !kge ? Object.defineProperties : function(e, t) {
  Gge(e);
  for (var r = $ge(t), n = Vge(t), s = n.length, a = 0, o; s > a; )
    Hge.f(e, o = n[a++], r[o]);
  return e;
};
var Kge = Yn, jge = mO, cI = ib, zge = tb, Xge = Z3, Wge = Sy, Yge = eb, uI = ">", fI = "<", LC = "prototype", IC = "script", vO = Yge("IE_PROTO"), pw = function() {
}, yO = function(i) {
  return fI + IC + uI + i + fI + "/" + IC + uI;
}, dI = function(i) {
  i.write(yO("")), i.close();
  var e = i.parentWindow.Object;
  return i = null, e;
}, qge = function() {
  var i = Wge("iframe"), e = "java" + IC + ":", t;
  return i.style.display = "none", Xge.appendChild(i), i.src = String(e), t = i.contentWindow.document, t.open(), t.write(yO("document.F=Object")), t.close(), t.F;
}, M0, om = function() {
  try {
    M0 = new ActiveXObject("htmlfile");
  } catch {
  }
  om = typeof document < "u" ? document.domain && M0 ? dI(M0) : qge() : dI(M0);
  for (var i = cI.length; i--; )
    delete om[LC][cI[i]];
  return om();
};
zge[vO] = !0;
var vb = Object.create || function(e, t) {
  var r;
  return e !== null ? (pw[LC] = Kge(e), r = new pw(), pw[LC] = null, r[vO] = e) : r = om(), t === void 0 ? r : jge.f(r, t);
}, Zge = tn, Jge = Kt, epe = Jge.RegExp, tpe = Zge(function() {
  var i = epe(".", "s");
  return !(i.dotAll && i.exec(`
`) && i.flags === "s");
}), rpe = tn, ipe = Kt, npe = ipe.RegExp, spe = rpe(function() {
  var i = npe("(?<a>b)", "g");
  return i.exec("b").groups.a !== "b" || "b".replace(i, "$<a>c") !== "bc";
}), Xc = Ds, Py = ri, ape = ho, ope = gO, Ape = pO, lpe = rg, hpe = vb, cpe = Fy.get, upe = tpe, fpe = spe, dpe = lpe("native-string-replace", String.prototype.replace), bv = RegExp.prototype.exec, RC = bv, gpe = Py("".charAt), ppe = Py("".indexOf), mpe = Py("".replace), mw = Py("".slice), MC = function() {
  var i = /a/, e = /b*/g;
  return Xc(bv, i, "a"), Xc(bv, e, "a"), i.lastIndex !== 0 || e.lastIndex !== 0;
}(), _O = Ape.BROKEN_CARET, NC = /()??/.exec("")[1] !== void 0, vpe = MC || NC || _O || upe || fpe;
vpe && (RC = function(e) {
  var t = this, r = cpe(t), n = ape(e), s = r.raw, a, o, A, l, h, c, u;
  if (s)
    return s.lastIndex = t.lastIndex, a = Xc(RC, s, n), t.lastIndex = s.lastIndex, a;
  var f = r.groups, g = _O && t.sticky, p = Xc(ope, t), y = t.source, v = 0, w = n;
  if (g && (p = mpe(p, "y", ""), ppe(p, "g") === -1 && (p += "g"), w = mw(n, t.lastIndex), t.lastIndex > 0 && (!t.multiline || t.multiline && gpe(n, t.lastIndex - 1) !== `
`) && (y = "(?: " + y + ")", w = " " + w, v++), o = new RegExp("^(?:" + y + ")", p)), NC && (o = new RegExp("^" + y + "$(?!\\s)", p)), MC && (A = t.lastIndex), l = Xc(bv, g ? o : t, w), g ? l ? (l.input = mw(l.input, v), l[0] = mw(l[0], v), l.index = t.lastIndex, t.lastIndex += l[0].length) : t.lastIndex = 0 : MC && l && (t.lastIndex = t.global ? l.index + l[0].length : A), NC && l && l.length > 1 && Xc(dpe, l[0], o, function() {
    for (h = 1; h < arguments.length - 2; h++)
      arguments[h] === void 0 && (l[h] = void 0);
  }), l && f)
    for (l.groups = c = hpe(null), h = 0; h < f.length; h++)
      u = f[h], c[u[0]] = l[u[1]];
  return l;
});
var Oy = RC, ype = Ao, gI = Oy;
ype({ target: "RegExp", proto: !0, forced: /./.exec !== gI }, {
  exec: gI
});
var pI = ri, mI = Jo, _pe = Oy, vI = tn, wO = Bn, wpe = ju, xpe = wO("species"), vw = RegExp.prototype, yb = function(i, e, t, r) {
  var n = wO(i), s = !vI(function() {
    var l = {};
    return l[n] = function() {
      return 7;
    }, ""[i](l) != 7;
  }), a = s && !vI(function() {
    var l = !1, h = /a/;
    return i === "split" && (h = {}, h.constructor = {}, h.constructor[xpe] = function() {
      return h;
    }, h.flags = "", h[n] = /./[n]), h.exec = function() {
      return l = !0, null;
    }, h[n](""), !l;
  });
  if (!s || !a || t) {
    var o = pI(/./[n]), A = e(n, ""[i], function(l, h, c, u, f) {
      var g = pI(l), p = h.exec;
      return p === _pe || p === vw.exec ? s && !f ? { done: !0, value: o(h, c, u) } : { done: !0, value: g(c, h, u) } : { done: !1 };
    });
    mI(String.prototype, i, A[0]), mI(vw, n, A[1]);
  }
  r && wpe(vw[n], "sham", !0);
}, _b = ri, Cpe = Iy, Epe = ho, Bpe = ao, bpe = _b("".charAt), yI = _b("".charCodeAt), Spe = _b("".slice), _I = function(i) {
  return function(e, t) {
    var r = Epe(Bpe(e)), n = Cpe(t), s = r.length, a, o;
    return n < 0 || n >= s ? i ? "" : void 0 : (a = yI(r, n), a < 55296 || a > 56319 || n + 1 === s || (o = yI(r, n + 1)) < 56320 || o > 57343 ? i ? bpe(r, n) : a : i ? Spe(r, n, n + 2) : (a - 55296 << 10) + (o - 56320) + 65536);
  };
}, Tpe = {
  // `String.prototype.codePointAt` method
  // https://tc39.es/ecma262/#sec-string.prototype.codepointat
  codeAt: _I(!1),
  // `String.prototype.at` method
  // https://github.com/mathiasbynens/String.prototype.at
  charAt: _I(!0)
}, Fpe = Tpe.charAt, wb = function(i, e, t) {
  return e + (t ? Fpe(i, e).length : 1);
}, Lpe = Kt, wI = Ds, Ipe = Yn, Rpe = un, Mpe = $u, Npe = Oy, Ppe = Lpe.TypeError, xb = function(i, e) {
  var t = i.exec;
  if (Rpe(t)) {
    var r = wI(t, i, e);
    return r !== null && Ipe(r), r;
  }
  if (Mpe(i) === "RegExp")
    return wI(Npe, i, e);
  throw Ppe("RegExp#exec called on incompatible receiver");
}, Ope = Ds, Upe = yb, Qpe = Yn, Dpe = zu, yw = ho, kpe = ao, Hpe = Ku, Gpe = wb, xI = xb;
Upe("match", function(i, e, t) {
  return [
    // `String.prototype.match` method
    // https://tc39.es/ecma262/#sec-string.prototype.match
    function(n) {
      var s = kpe(this), a = n == null ? void 0 : Hpe(n, i);
      return a ? Ope(a, n, s) : new RegExp(n)[i](yw(s));
    },
    // `RegExp.prototype[@@match]` method
    // https://tc39.es/ecma262/#sec-regexp.prototype-@@match
    function(r) {
      var n = Qpe(this), s = yw(r), a = t(e, n, s);
      if (a.done)
        return a.value;
      if (!n.global)
        return xI(n, s);
      var o = n.unicode;
      n.lastIndex = 0;
      for (var A = [], l = 0, h; (h = xI(n, s)) !== null; ) {
        var c = yw(h[0]);
        A[l] = c, c === "" && (n.lastIndex = Gpe(s, Dpe(n.lastIndex), o)), l++;
      }
      return l === 0 ? null : A;
    }
  ];
});
var Cb = ri, $pe = by, Vpe = Math.floor, _w = Cb("".charAt), Kpe = Cb("".replace), ww = Cb("".slice), jpe = /\$([$&'`]|\d{1,2}|<[^>]*>)/g, zpe = /\$([$&'`]|\d{1,2})/g, Xpe = function(i, e, t, r, n, s) {
  var a = t + i.length, o = r.length, A = zpe;
  return n !== void 0 && (n = $pe(n), A = jpe), Kpe(s, A, function(l, h) {
    var c;
    switch (_w(h, 0)) {
      case "$":
        return "$";
      case "&":
        return i;
      case "`":
        return ww(e, 0, t);
      case "'":
        return ww(e, a);
      case "<":
        c = n[ww(h, 1, -1)];
        break;
      default:
        var u = +h;
        if (u === 0)
          return l;
        if (u > o) {
          var f = Vpe(u / 10);
          return f === 0 ? l : f <= o ? r[f - 1] === void 0 ? _w(h, 1) : r[f - 1] + _w(h, 1) : l;
        }
        c = r[u - 1];
    }
    return c === void 0 ? "" : c;
  });
}, Wpe = Ab, CI = Ds, Uy = ri, Ype = yb, qpe = tn, Zpe = Yn, Jpe = un, e0e = Iy, t0e = zu, _c = ho, r0e = ao, i0e = wb, n0e = Ku, s0e = Xpe, a0e = xb, o0e = Bn, PC = o0e("replace"), A0e = Math.max, l0e = Math.min, h0e = Uy([].concat), xw = Uy([].push), EI = Uy("".indexOf), BI = Uy("".slice), c0e = function(i) {
  return i === void 0 ? i : String(i);
}, u0e = function() {
  return "a".replace(/./, "$0") === "$0";
}(), bI = function() {
  return /./[PC] ? /./[PC]("a", "$0") === "" : !1;
}(), f0e = !qpe(function() {
  var i = /./;
  return i.exec = function() {
    var e = [];
    return e.groups = { a: "7" }, e;
  }, "".replace(i, "$<a>") !== "7";
});
Ype("replace", function(i, e, t) {
  var r = bI ? "$" : "$0";
  return [
    // `String.prototype.replace` method
    // https://tc39.es/ecma262/#sec-string.prototype.replace
    function(s, a) {
      var o = r0e(this), A = s == null ? void 0 : n0e(s, PC);
      return A ? CI(A, s, o, a) : CI(e, _c(o), s, a);
    },
    // `RegExp.prototype[@@replace]` method
    // https://tc39.es/ecma262/#sec-regexp.prototype-@@replace
    function(n, s) {
      var a = Zpe(this), o = _c(n);
      if (typeof s == "string" && EI(s, r) === -1 && EI(s, "$<") === -1) {
        var A = t(e, a, o, s);
        if (A.done)
          return A.value;
      }
      var l = Jpe(s);
      l || (s = _c(s));
      var h = a.global;
      if (h) {
        var c = a.unicode;
        a.lastIndex = 0;
      }
      for (var u = []; ; ) {
        var f = a0e(a, o);
        if (f === null || (xw(u, f), !h))
          break;
        var g = _c(f[0]);
        g === "" && (a.lastIndex = i0e(o, t0e(a.lastIndex), c));
      }
      for (var p = "", y = 0, v = 0; v < u.length; v++) {
        f = u[v];
        for (var w = _c(f[0]), C = A0e(l0e(e0e(f.index), o.length), 0), E = [], S = 1; S < f.length; S++)
          xw(E, c0e(f[S]));
        var M = f.groups;
        if (l) {
          var T = h0e([w], E, C, o);
          M !== void 0 && xw(T, M);
          var F = _c(Wpe(s, void 0, T));
        } else
          F = s0e(w, o, C, E, M, s);
        C >= y && (p += BI(o, y, C) + F, y = C + w.length);
      }
      return p + BI(o, y);
    }
  ];
}, !f0e || !u0e || bI);
var d0e = wl, g0e = $u, p0e = Bn, m0e = p0e("match"), xO = function(i) {
  var e;
  return d0e(i) && ((e = i[m0e]) !== void 0 ? !!e : g0e(i) == "RegExp");
}, v0e = Kt, y0e = xO, _0e = v0e.TypeError, Eb = function(i) {
  if (y0e(i))
    throw _0e("The method doesn't accept regular expressions");
  return i;
}, w0e = Bn, x0e = w0e("match"), Bb = function(i) {
  var e = /./;
  try {
    "/./"[i](e);
  } catch {
    try {
      return e[x0e] = !1, "/./"[i](e);
    } catch {
    }
  }
  return !1;
}, C0e = Ao, CO = ri, E0e = Gu.f, B0e = zu, SI = ho, b0e = Eb, S0e = ao, T0e = Bb, TI = CO("".startsWith), F0e = CO("".slice), L0e = Math.min, EO = T0e("startsWith"), I0e = !EO && !!function() {
  var i = E0e(String.prototype, "startsWith");
  return i && !i.writable;
}();
C0e({ target: "String", proto: !0, forced: !I0e && !EO }, {
  startsWith: function(e) {
    var t = SI(S0e(this));
    b0e(e);
    var r = B0e(L0e(arguments.length > 1 ? arguments[1] : void 0, t.length)), n = SI(e);
    return TI ? TI(t, n, r) : F0e(t, r, r + n.length) === n;
  }
});
var R0e = Bn, M0e = vb, N0e = lA, OC = R0e("unscopables"), UC = Array.prototype;
UC[OC] == null && N0e.f(UC, OC, {
  configurable: !0,
  value: M0e(null)
});
var P0e = function(i) {
  UC[OC][i] = !0;
}, O0e = tn, U0e = !O0e(function() {
  function i() {
  }
  return i.prototype.constructor = null, Object.getPrototypeOf(new i()) !== i.prototype;
}), Q0e = Kt, D0e = oo, k0e = un, H0e = by, G0e = eb, $0e = U0e, FI = G0e("IE_PROTO"), QC = Q0e.Object, V0e = QC.prototype, BO = $0e ? QC.getPrototypeOf : function(i) {
  var e = H0e(i);
  if (D0e(e, FI))
    return e[FI];
  var t = e.constructor;
  return k0e(t) && e instanceof t ? t.prototype : e instanceof QC ? V0e : null;
}, K0e = tn, j0e = un, LI = BO, z0e = Jo, X0e = Bn, DC = X0e("iterator"), bO = !1, Ch, Cw, Ew;
[].keys && (Ew = [].keys(), "next" in Ew ? (Cw = LI(LI(Ew)), Cw !== Object.prototype && (Ch = Cw)) : bO = !0);
var W0e = Ch == null || K0e(function() {
  var i = {};
  return Ch[DC].call(i) !== i;
});
W0e && (Ch = {});
j0e(Ch[DC]) || z0e(Ch, DC, function() {
  return this;
});
var SO = {
  IteratorPrototype: Ch,
  BUGGY_SAFARI_ITERATORS: bO
}, Y0e = SO.IteratorPrototype, q0e = vb, Z0e = xy, J0e = nb, eme = Mg, tme = function() {
  return this;
}, rme = function(i, e, t, r) {
  var n = e + " Iterator";
  return i.prototype = q0e(Y0e, { next: Z0e(+!r, t) }), J0e(i, n, !1), eme[n] = tme, i;
}, ime = Ao, nme = Ds, TO = Ly, sme = un, ame = rme, II = BO, RI = H3, ome = nb, Ame = ju, Bw = Jo, lme = Bn, hme = Mg, FO = SO, cme = TO.PROPER, ume = TO.CONFIGURABLE, MI = FO.IteratorPrototype, N0 = FO.BUGGY_SAFARI_ITERATORS, Vf = lme("iterator"), NI = "keys", Kf = "values", PI = "entries", fme = function() {
  return this;
}, dme = function(i, e, t, r, n, s, a) {
  ame(t, e, r);
  var o = function(v) {
    if (v === n && u)
      return u;
    if (!N0 && v in h)
      return h[v];
    switch (v) {
      case NI:
        return function() {
          return new t(this, v);
        };
      case Kf:
        return function() {
          return new t(this, v);
        };
      case PI:
        return function() {
          return new t(this, v);
        };
    }
    return function() {
      return new t(this);
    };
  }, A = e + " Iterator", l = !1, h = i.prototype, c = h[Vf] || h["@@iterator"] || n && h[n], u = !N0 && c || o(n), f = e == "Array" && h.entries || c, g, p, y;
  if (f && (g = II(f.call(new i())), g !== Object.prototype && g.next && (II(g) !== MI && (RI ? RI(g, MI) : sme(g[Vf]) || Bw(g, Vf, fme)), ome(g, A, !0))), cme && n == Kf && c && c.name !== Kf && (ume ? Ame(h, "name", Kf) : (l = !0, u = function() {
    return nme(c, this);
  })), n)
    if (p = {
      values: o(Kf),
      keys: s ? u : o(NI),
      entries: o(PI)
    }, a)
      for (y in p)
        (N0 || l || !(y in h)) && Bw(h, y, p[y]);
    else
      ime({ target: e, proto: !0, forced: N0 || l }, p);
  return h[Vf] !== u && Bw(h, Vf, u, { name: n }), hme[e] = u, p;
}, gme = Ig, bb = P0e, OI = Mg, LO = Fy, pme = lA.f, mme = dme, vme = AA, IO = "Array Iterator", yme = LO.set, _me = LO.getterFor(IO), wme = mme(Array, "Array", function(i, e) {
  yme(this, {
    type: IO,
    target: gme(i),
    // target
    index: 0,
    // next index
    kind: e
    // kind
  });
}, function() {
  var i = _me(this), e = i.target, t = i.kind, r = i.index++;
  return !e || r >= e.length ? (i.target = void 0, { value: void 0, done: !0 }) : t == "keys" ? { value: r, done: !1 } : t == "values" ? { value: e[r], done: !1 } : { value: [r, e[r]], done: !1 };
}, "values"), UI = OI.Arguments = OI.Array;
bb("keys");
bb("values");
bb("entries");
if (vme && UI.name !== "values")
  try {
    pme(UI, "name", { value: "values" });
  } catch {
  }
var xme = {
  CSSRuleList: 0,
  CSSStyleDeclaration: 0,
  CSSValueList: 0,
  ClientRectList: 0,
  DOMRectList: 0,
  DOMStringList: 0,
  DOMTokenList: 1,
  DataTransferItemList: 0,
  FileList: 0,
  HTMLAllCollection: 0,
  HTMLCollection: 0,
  HTMLFormElement: 0,
  HTMLSelectElement: 0,
  MediaList: 0,
  MimeTypeArray: 0,
  NamedNodeMap: 0,
  NodeList: 1,
  PaintRequestList: 0,
  Plugin: 0,
  PluginArray: 0,
  SVGLengthList: 0,
  SVGNumberList: 0,
  SVGPathSegList: 0,
  SVGPointList: 0,
  SVGStringList: 0,
  SVGTransformList: 0,
  SourceBufferList: 0,
  StyleSheetList: 0,
  TextTrackCueList: 0,
  TextTrackList: 0,
  TouchList: 0
}, Cme = Sy, bw = Cme("span").classList, QI = bw && bw.constructor && bw.constructor.prototype, Eme = QI === Object.prototype ? void 0 : QI, DI = Kt, RO = xme, Bme = Eme, Ad = wme, Sw = ju, MO = Bn, Tw = MO("iterator"), kI = MO("toStringTag"), Fw = Ad.values, NO = function(i, e) {
  if (i) {
    if (i[Tw] !== Fw)
      try {
        Sw(i, Tw, Fw);
      } catch {
        i[Tw] = Fw;
      }
    if (i[kI] || Sw(i, kI, e), RO[e]) {
      for (var t in Ad)
        if (i[t] !== Ad[t])
          try {
            Sw(i, t, Ad[t]);
          } catch {
            i[t] = Ad[t];
          }
    }
  }
};
for (var Lw in RO)
  NO(DI[Lw] && DI[Lw].prototype, Lw);
NO(Bme, "DOMTokenList");
function Sb(i, e, t) {
  return e in i ? Object.defineProperty(i, e, {
    value: t,
    enumerable: !0,
    configurable: !0,
    writable: !0
  }) : i[e] = t, i;
}
var bme = Kt, Sme = Vu, Tme = by, Fme = w3, Lme = Ry, Ime = bme.TypeError, HI = function(i) {
  return function(e, t, r, n) {
    Sme(t);
    var s = Tme(e), a = Fme(s), o = Lme(s), A = i ? o - 1 : 0, l = i ? -1 : 1;
    if (r < 2)
      for (; ; ) {
        if (A in a) {
          n = a[A], A += l;
          break;
        }
        if (A += l, i ? A < 0 : o <= A)
          throw Ime("Reduce of empty array with no initial value");
      }
    for (; i ? A >= 0 : o > A; A += l)
      A in a && (n = t(n, a[A], A, s));
    return n;
  };
}, Rme = {
  // `Array.prototype.reduce` method
  // https://tc39.es/ecma262/#sec-array.prototype.reduce
  left: HI(!1),
  // `Array.prototype.reduceRight` method
  // https://tc39.es/ecma262/#sec-array.prototype.reduceright
  right: HI(!0)
}, Mme = tn, PO = function(i, e) {
  var t = [][i];
  return !!t && Mme(function() {
    t.call(null, e || function() {
      throw 1;
    }, 1);
  });
}, Nme = Ao, Pme = Rme.left, Ome = PO, GI = YB, Ume = My, Qme = Ome("reduce"), Dme = !Ume && GI > 79 && GI < 83;
Nme({ target: "Array", proto: !0, forced: !Qme || Dme }, {
  reduce: function(e) {
    var t = arguments.length;
    return Pme(this, e, t, t > 1 ? arguments[1] : void 0);
  }
});
var kme = Ao, OO = ri, Hme = Gu.f, Gme = zu, $I = ho, $me = Eb, Vme = ao, Kme = Bb, VI = OO("".endsWith), jme = OO("".slice), zme = Math.min, UO = Kme("endsWith"), Xme = !UO && !!function() {
  var i = Hme(String.prototype, "endsWith");
  return i && !i.writable;
}();
kme({ target: "String", proto: !0, forced: !Xme && !UO }, {
  endsWith: function(e) {
    var t = $I(Vme(this));
    $me(e);
    var r = arguments.length > 1 ? arguments[1] : void 0, n = t.length, s = r === void 0 ? n : zme(Gme(r), n), a = $I(e);
    return VI ? VI(t, a, s) : jme(t, s - a.length, s) === a;
  }
});
var Wme = JB, Yme = lA, qme = xy, Zme = function(i, e, t) {
  var r = Wme(e);
  r in i ? Yme.f(i, r, qme(0, t)) : i[r] = t;
}, Jme = Kt, KI = P3, eve = Ry, tve = Zme, rve = Jme.Array, ive = Math.max, nve = function(i, e, t) {
  for (var r = eve(i), n = KI(e, r), s = KI(t === void 0 ? r : t, r), a = rve(ive(s - n, 0)), o = 0; n < s; n++, o++)
    tve(a, o, i[n]);
  return a.length = o, a;
}, sve = Ab, jf = Ds, Tb = ri, ave = yb, ove = xO, Ave = Yn, jI = ao, lve = Y3, hve = wb, cve = zu, Iw = ho, uve = Ku, zI = nve, XI = xb, fve = Oy, dve = pO, gve = tn, wc = dve.UNSUPPORTED_Y, WI = 4294967295, pve = Math.min, QO = [].push, mve = Tb(/./.exec), xc = Tb(QO), zf = Tb("".slice), vve = !gve(function() {
  var i = /(?:)/, e = i.exec;
  i.exec = function() {
    return e.apply(this, arguments);
  };
  var t = "ab".split(i);
  return t.length !== 2 || t[0] !== "a" || t[1] !== "b";
});
ave("split", function(i, e, t) {
  var r;
  return "abbc".split(/(b)*/)[1] == "c" || // eslint-disable-next-line regexp/no-empty-group -- required for testing
  "test".split(/(?:)/, -1).length != 4 || "ab".split(/(?:ab)*/).length != 2 || ".".split(/(.?)(.?)/).length != 4 || // eslint-disable-next-line regexp/no-empty-capturing-group, regexp/no-empty-group -- required for testing
  ".".split(/()()/).length > 1 || "".split(/.?/).length ? r = function(n, s) {
    var a = Iw(jI(this)), o = s === void 0 ? WI : s >>> 0;
    if (o === 0)
      return [];
    if (n === void 0)
      return [a];
    if (!ove(n))
      return jf(e, a, n, o);
    for (var A = [], l = (n.ignoreCase ? "i" : "") + (n.multiline ? "m" : "") + (n.unicode ? "u" : "") + (n.sticky ? "y" : ""), h = 0, c = new RegExp(n.source, l + "g"), u, f, g; (u = jf(fve, c, a)) && (f = c.lastIndex, !(f > h && (xc(A, zf(a, h, u.index)), u.length > 1 && u.index < a.length && sve(QO, A, zI(u, 1)), g = u[0].length, h = f, A.length >= o))); )
      c.lastIndex === u.index && c.lastIndex++;
    return h === a.length ? (g || !mve(c, "")) && xc(A, "") : xc(A, zf(a, h)), A.length > o ? zI(A, 0, o) : A;
  } : "0".split(void 0, 0).length ? r = function(n, s) {
    return n === void 0 && s === 0 ? [] : jf(e, this, n, s);
  } : r = e, [
    // `String.prototype.split` method
    // https://tc39.es/ecma262/#sec-string.prototype.split
    function(s, a) {
      var o = jI(this), A = s == null ? void 0 : uve(s, i);
      return A ? jf(A, s, o, a) : jf(r, Iw(o), s, a);
    },
    // `RegExp.prototype[@@split]` method
    // https://tc39.es/ecma262/#sec-regexp.prototype-@@split
    //
    // NOTE: This cannot be properly polyfilled in engines that don't support
    // the 'y' flag.
    function(n, s) {
      var a = Ave(this), o = Iw(n), A = t(r, a, o, s, r !== e);
      if (A.done)
        return A.value;
      var l = lve(a, RegExp), h = a.unicode, c = (a.ignoreCase ? "i" : "") + (a.multiline ? "m" : "") + (a.unicode ? "u" : "") + (wc ? "g" : "y"), u = new l(wc ? "^(?:" + a.source + ")" : a, c), f = s === void 0 ? WI : s >>> 0;
      if (f === 0)
        return [];
      if (o.length === 0)
        return XI(u, o) === null ? [o] : [];
      for (var g = 0, p = 0, y = []; p < o.length; ) {
        u.lastIndex = wc ? 0 : p;
        var v = XI(u, wc ? zf(o, p) : o), w;
        if (v === null || (w = pve(cve(u.lastIndex + (wc ? p : 0)), o.length)) === g)
          p = hve(o, p, h);
        else {
          if (xc(y, zf(o, g, p)), y.length === f)
            return y;
          for (var C = 1; C <= v.length - 1; C++)
            if (xc(y, v[C]), y.length === f)
              return y;
          p = g = w;
        }
      }
      return xc(y, zf(o, g)), y;
    }
  ];
}, !vve, wc);
var hh = {}, yve = {
  get exports() {
    return hh;
  },
  set exports(i) {
    hh = i;
  }
}, kC = {}, P0 = {
  get exports() {
    return kC;
  },
  set exports(i) {
    kC = i;
  }
};
(function() {
  var i, e, t, r, n, s;
  typeof performance < "u" && performance !== null && performance.now ? P0.exports = function() {
    return performance.now();
  } : typeof process < "u" && process !== null && process.hrtime ? (P0.exports = function() {
    return (i() - n) / 1e6;
  }, e = process.hrtime, i = function() {
    var a;
    return a = e(), a[0] * 1e9 + a[1];
  }, r = i(), s = process.uptime() * 1e9, n = r - s) : Date.now ? (P0.exports = function() {
    return Date.now() - t;
  }, t = Date.now()) : (P0.exports = function() {
    return (/* @__PURE__ */ new Date()).getTime() - t;
  }, t = (/* @__PURE__ */ new Date()).getTime());
}).call(Uo);
var _ve = kC, jo = typeof window > "u" ? Uo : window, O0 = ["moz", "webkit"], lu = "AnimationFrame", Bu = jo["request" + lu], sg = jo["cancel" + lu] || jo["cancelRequest" + lu];
for (var Xf = 0; !Bu && Xf < O0.length; Xf++)
  Bu = jo[O0[Xf] + "Request" + lu], sg = jo[O0[Xf] + "Cancel" + lu] || jo[O0[Xf] + "CancelRequest" + lu];
if (!Bu || !sg) {
  var Rw = 0, YI = 0, Ul = [], wve = 1e3 / 60;
  Bu = function(i) {
    if (Ul.length === 0) {
      var e = _ve(), t = Math.max(0, wve - (e - Rw));
      Rw = t + e, setTimeout(function() {
        var r = Ul.slice(0);
        Ul.length = 0;
        for (var n = 0; n < r.length; n++)
          if (!r[n].cancelled)
            try {
              r[n].callback(Rw);
            } catch (s) {
              setTimeout(function() {
                throw s;
              }, 0);
            }
      }, Math.round(t));
    }
    return Ul.push({
      handle: ++YI,
      callback: i,
      cancelled: !1
    }), YI;
  }, sg = function(i) {
    for (var e = 0; e < Ul.length; e++)
      Ul[e].handle === i && (Ul[e].cancelled = !0);
  };
}
yve.exports = function(i) {
  return Bu.call(jo, i);
};
hh.cancel = function() {
  sg.apply(jo, arguments);
};
hh.polyfill = function(i) {
  i || (i = jo), i.requestAnimationFrame = Bu, i.cancelAnimationFrame = sg;
};
var DO = `	
\v\f\r \u2028\u2029\uFEFF`, xve = ri, Cve = ao, Eve = ho, Bve = DO, qI = xve("".replace), Sv = "[" + Bve + "]", bve = RegExp("^" + Sv + Sv + "*"), Sve = RegExp(Sv + Sv + "*$"), Mw = function(i) {
  return function(e) {
    var t = Eve(Cve(e));
    return i & 1 && (t = qI(t, bve, "")), i & 2 && (t = qI(t, Sve, "")), t;
  };
}, Tve = {
  // `String.prototype.{ trimLeft, trimStart }` methods
  // https://tc39.es/ecma262/#sec-string.prototype.trimstart
  start: Mw(1),
  // `String.prototype.{ trimRight, trimEnd }` methods
  // https://tc39.es/ecma262/#sec-string.prototype.trimend
  end: Mw(2),
  // `String.prototype.trim` method
  // https://tc39.es/ecma262/#sec-string.prototype.trim
  trim: Mw(3)
}, Fve = Ly.PROPER, Lve = tn, ZI = DO, JI = "", Ive = function(i) {
  return Lve(function() {
    return !!ZI[i]() || JI[i]() !== JI || Fve && ZI[i].name !== i;
  });
}, Rve = Ao, Mve = Tve.trim, Nve = Ive;
Rve({ target: "String", proto: !0, forced: Nve("trim") }, {
  trim: function() {
    return Mve(this);
  }
});
var HC = function(i) {
  this.ok = !1, this.alpha = 1, i.charAt(0) == "#" && (i = i.substr(1, 6)), i = i.replace(/ /g, ""), i = i.toLowerCase();
  var e = {
    aliceblue: "f0f8ff",
    antiquewhite: "faebd7",
    aqua: "00ffff",
    aquamarine: "7fffd4",
    azure: "f0ffff",
    beige: "f5f5dc",
    bisque: "ffe4c4",
    black: "000000",
    blanchedalmond: "ffebcd",
    blue: "0000ff",
    blueviolet: "8a2be2",
    brown: "a52a2a",
    burlywood: "deb887",
    cadetblue: "5f9ea0",
    chartreuse: "7fff00",
    chocolate: "d2691e",
    coral: "ff7f50",
    cornflowerblue: "6495ed",
    cornsilk: "fff8dc",
    crimson: "dc143c",
    cyan: "00ffff",
    darkblue: "00008b",
    darkcyan: "008b8b",
    darkgoldenrod: "b8860b",
    darkgray: "a9a9a9",
    darkgreen: "006400",
    darkkhaki: "bdb76b",
    darkmagenta: "8b008b",
    darkolivegreen: "556b2f",
    darkorange: "ff8c00",
    darkorchid: "9932cc",
    darkred: "8b0000",
    darksalmon: "e9967a",
    darkseagreen: "8fbc8f",
    darkslateblue: "483d8b",
    darkslategray: "2f4f4f",
    darkturquoise: "00ced1",
    darkviolet: "9400d3",
    deeppink: "ff1493",
    deepskyblue: "00bfff",
    dimgray: "696969",
    dodgerblue: "1e90ff",
    feldspar: "d19275",
    firebrick: "b22222",
    floralwhite: "fffaf0",
    forestgreen: "228b22",
    fuchsia: "ff00ff",
    gainsboro: "dcdcdc",
    ghostwhite: "f8f8ff",
    gold: "ffd700",
    goldenrod: "daa520",
    gray: "808080",
    green: "008000",
    greenyellow: "adff2f",
    honeydew: "f0fff0",
    hotpink: "ff69b4",
    indianred: "cd5c5c",
    indigo: "4b0082",
    ivory: "fffff0",
    khaki: "f0e68c",
    lavender: "e6e6fa",
    lavenderblush: "fff0f5",
    lawngreen: "7cfc00",
    lemonchiffon: "fffacd",
    lightblue: "add8e6",
    lightcoral: "f08080",
    lightcyan: "e0ffff",
    lightgoldenrodyellow: "fafad2",
    lightgrey: "d3d3d3",
    lightgreen: "90ee90",
    lightpink: "ffb6c1",
    lightsalmon: "ffa07a",
    lightseagreen: "20b2aa",
    lightskyblue: "87cefa",
    lightslateblue: "8470ff",
    lightslategray: "778899",
    lightsteelblue: "b0c4de",
    lightyellow: "ffffe0",
    lime: "00ff00",
    limegreen: "32cd32",
    linen: "faf0e6",
    magenta: "ff00ff",
    maroon: "800000",
    mediumaquamarine: "66cdaa",
    mediumblue: "0000cd",
    mediumorchid: "ba55d3",
    mediumpurple: "9370d8",
    mediumseagreen: "3cb371",
    mediumslateblue: "7b68ee",
    mediumspringgreen: "00fa9a",
    mediumturquoise: "48d1cc",
    mediumvioletred: "c71585",
    midnightblue: "191970",
    mintcream: "f5fffa",
    mistyrose: "ffe4e1",
    moccasin: "ffe4b5",
    navajowhite: "ffdead",
    navy: "000080",
    oldlace: "fdf5e6",
    olive: "808000",
    olivedrab: "6b8e23",
    orange: "ffa500",
    orangered: "ff4500",
    orchid: "da70d6",
    palegoldenrod: "eee8aa",
    palegreen: "98fb98",
    paleturquoise: "afeeee",
    palevioletred: "d87093",
    papayawhip: "ffefd5",
    peachpuff: "ffdab9",
    peru: "cd853f",
    pink: "ffc0cb",
    plum: "dda0dd",
    powderblue: "b0e0e6",
    purple: "800080",
    rebeccapurple: "663399",
    red: "ff0000",
    rosybrown: "bc8f8f",
    royalblue: "4169e1",
    saddlebrown: "8b4513",
    salmon: "fa8072",
    sandybrown: "f4a460",
    seagreen: "2e8b57",
    seashell: "fff5ee",
    sienna: "a0522d",
    silver: "c0c0c0",
    skyblue: "87ceeb",
    slateblue: "6a5acd",
    slategray: "708090",
    snow: "fffafa",
    springgreen: "00ff7f",
    steelblue: "4682b4",
    tan: "d2b48c",
    teal: "008080",
    thistle: "d8bfd8",
    tomato: "ff6347",
    turquoise: "40e0d0",
    violet: "ee82ee",
    violetred: "d02090",
    wheat: "f5deb3",
    white: "ffffff",
    whitesmoke: "f5f5f5",
    yellow: "ffff00",
    yellowgreen: "9acd32"
  };
  i = e[i] || i;
  for (var t = [
    {
      re: /^rgba\((\d{1,3}),\s*(\d{1,3}),\s*(\d{1,3}),\s*((?:\d?\.)?\d)\)$/,
      example: ["rgba(123, 234, 45, 0.8)", "rgba(255,234,245,1.0)"],
      process: function(A) {
        return [
          parseInt(A[1]),
          parseInt(A[2]),
          parseInt(A[3]),
          parseFloat(A[4])
        ];
      }
    },
    {
      re: /^rgb\((\d{1,3}),\s*(\d{1,3}),\s*(\d{1,3})\)$/,
      example: ["rgb(123, 234, 45)", "rgb(255,234,245)"],
      process: function(A) {
        return [
          parseInt(A[1]),
          parseInt(A[2]),
          parseInt(A[3])
        ];
      }
    },
    {
      re: /^([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})$/,
      example: ["#00ff00", "336699"],
      process: function(A) {
        return [
          parseInt(A[1], 16),
          parseInt(A[2], 16),
          parseInt(A[3], 16)
        ];
      }
    },
    {
      re: /^([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/,
      example: ["#fb0", "f0f"],
      process: function(A) {
        return [
          parseInt(A[1] + A[1], 16),
          parseInt(A[2] + A[2], 16),
          parseInt(A[3] + A[3], 16)
        ];
      }
    }
  ], r = 0; r < t.length; r++) {
    var n = t[r].re, s = t[r].process, a = n.exec(i);
    if (a) {
      var o = s(a);
      this.r = o[0], this.g = o[1], this.b = o[2], o.length > 3 && (this.alpha = o[3]), this.ok = !0;
    }
  }
  this.r = this.r < 0 || isNaN(this.r) ? 0 : this.r > 255 ? 255 : this.r, this.g = this.g < 0 || isNaN(this.g) ? 0 : this.g > 255 ? 255 : this.g, this.b = this.b < 0 || isNaN(this.b) ? 0 : this.b > 255 ? 255 : this.b, this.alpha = this.alpha < 0 ? 0 : this.alpha > 1 || isNaN(this.alpha) ? 1 : this.alpha, this.toRGB = function() {
    return "rgb(" + this.r + ", " + this.g + ", " + this.b + ")";
  }, this.toRGBA = function() {
    return "rgba(" + this.r + ", " + this.g + ", " + this.b + ", " + this.alpha + ")";
  }, this.toHex = function() {
    var A = this.r.toString(16), l = this.g.toString(16), h = this.b.toString(16);
    return A.length == 1 && (A = "0" + A), l.length == 1 && (l = "0" + l), h.length == 1 && (h = "0" + h), "#" + A + l + h;
  }, this.getHelpXML = function() {
    for (var A = new Array(), l = 0; l < t.length; l++)
      for (var h = t[l].example, c = 0; c < h.length; c++)
        A[A.length] = h[c];
    for (var u in e)
      A[A.length] = u;
    var f = document.createElement("ul");
    f.setAttribute("id", "rgbcolor-examples");
    for (var l = 0; l < A.length; l++)
      try {
        var g = document.createElement("li"), p = new RGBColor(A[l]), y = document.createElement("div");
        y.style.cssText = "margin: 3px; border: 1px solid black; background:" + p.toHex() + "; color:" + p.toHex(), y.appendChild(document.createTextNode("test"));
        var v = document.createTextNode(
          " " + A[l] + " -> " + p.toRGB() + " -> " + p.toHex()
        );
        g.appendChild(y), g.appendChild(v), f.appendChild(g);
      } catch {
      }
    return f;
  };
}, Pve = Ao, Ove = ri, Uve = Eb, Qve = ao, eR = ho, Dve = Bb, kve = Ove("".indexOf);
Pve({ target: "String", proto: !0, forced: !Dve("includes") }, {
  includes: function(e) {
    return !!~kve(
      eR(Qve(this)),
      eR(Uve(e)),
      arguments.length > 1 ? arguments[1] : void 0
    );
  }
});
var Hve = Ao, Gve = ri, $ve = O3.indexOf, Vve = PO, GC = Gve([].indexOf), tR = !!GC && 1 / GC([1], 1, -0) < 0, Kve = Vve("indexOf");
Hve({ target: "Array", proto: !0, forced: tR || !Kve }, {
  indexOf: function(e) {
    var t = arguments.length > 1 ? arguments[1] : void 0;
    return tR ? GC(this, e, t) || 0 : $ve(this, e, t);
  }
});
var jve = $u, zve = Array.isArray || function(e) {
  return jve(e) == "Array";
}, Xve = Ao, Wve = ri, Yve = zve, qve = Wve([].reverse), rR = [1, 2];
Xve({ target: "Array", proto: !0, forced: String(rR) === String(rR.reverse()) }, {
  reverse: function() {
    return Yve(this) && (this.length = this.length), qve(this);
  }
});
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
var kO = function(i, e) {
  return (kO = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(t, r) {
    t.__proto__ = r;
  } || function(t, r) {
    for (var n in r)
      Object.prototype.hasOwnProperty.call(r, n) && (t[n] = r[n]);
  })(i, e);
};
function HO(i, e) {
  if (typeof e != "function" && e !== null)
    throw new TypeError("Class extends value " + String(e) + " is not a constructor or null");
  function t() {
    this.constructor = i;
  }
  kO(i, e), i.prototype = e === null ? Object.create(e) : (t.prototype = e.prototype, new t());
}
function Zve(i) {
  var e = "";
  Array.isArray(i) || (i = [i]);
  for (var t = 0; t < i.length; t++) {
    var r = i[t];
    if (r.type === Ie.CLOSE_PATH)
      e += "z";
    else if (r.type === Ie.HORIZ_LINE_TO)
      e += (r.relative ? "h" : "H") + r.x;
    else if (r.type === Ie.VERT_LINE_TO)
      e += (r.relative ? "v" : "V") + r.y;
    else if (r.type === Ie.MOVE_TO)
      e += (r.relative ? "m" : "M") + r.x + " " + r.y;
    else if (r.type === Ie.LINE_TO)
      e += (r.relative ? "l" : "L") + r.x + " " + r.y;
    else if (r.type === Ie.CURVE_TO)
      e += (r.relative ? "c" : "C") + r.x1 + " " + r.y1 + " " + r.x2 + " " + r.y2 + " " + r.x + " " + r.y;
    else if (r.type === Ie.SMOOTH_CURVE_TO)
      e += (r.relative ? "s" : "S") + r.x2 + " " + r.y2 + " " + r.x + " " + r.y;
    else if (r.type === Ie.QUAD_TO)
      e += (r.relative ? "q" : "Q") + r.x1 + " " + r.y1 + " " + r.x + " " + r.y;
    else if (r.type === Ie.SMOOTH_QUAD_TO)
      e += (r.relative ? "t" : "T") + r.x + " " + r.y;
    else {
      if (r.type !== Ie.ARC)
        throw new Error('Unexpected command type "' + r.type + '" at index ' + t + ".");
      e += (r.relative ? "a" : "A") + r.rX + " " + r.rY + " " + r.xRot + " " + +r.lArcFlag + " " + +r.sweepFlag + " " + r.x + " " + r.y;
    }
  }
  return e;
}
function $C(i, e) {
  var t = i[0], r = i[1];
  return [t * Math.cos(e) - r * Math.sin(e), t * Math.sin(e) + r * Math.cos(e)];
}
function va() {
  for (var i = [], e = 0; e < arguments.length; e++)
    i[e] = arguments[e];
  for (var t = 0; t < i.length; t++)
    if (typeof i[t] != "number")
      throw new Error("assertNumbers arguments[" + t + "] is not a number. " + typeof i[t] + " == typeof " + i[t]);
  return !0;
}
var $A = Math.PI;
function Nw(i, e, t) {
  i.lArcFlag = i.lArcFlag === 0 ? 0 : 1, i.sweepFlag = i.sweepFlag === 0 ? 0 : 1;
  var r = i.rX, n = i.rY, s = i.x, a = i.y;
  r = Math.abs(i.rX), n = Math.abs(i.rY);
  var o = $C([(e - s) / 2, (t - a) / 2], -i.xRot / 180 * $A), A = o[0], l = o[1], h = Math.pow(A, 2) / Math.pow(r, 2) + Math.pow(l, 2) / Math.pow(n, 2);
  1 < h && (r *= Math.sqrt(h), n *= Math.sqrt(h)), i.rX = r, i.rY = n;
  var c = Math.pow(r, 2) * Math.pow(l, 2) + Math.pow(n, 2) * Math.pow(A, 2), u = (i.lArcFlag !== i.sweepFlag ? 1 : -1) * Math.sqrt(Math.max(0, (Math.pow(r, 2) * Math.pow(n, 2) - c) / c)), f = r * l / n * u, g = -n * A / r * u, p = $C([f, g], i.xRot / 180 * $A);
  i.cX = p[0] + (e + s) / 2, i.cY = p[1] + (t + a) / 2, i.phi1 = Math.atan2((l - g) / n, (A - f) / r), i.phi2 = Math.atan2((-l - g) / n, (-A - f) / r), i.sweepFlag === 0 && i.phi2 > i.phi1 && (i.phi2 -= 2 * $A), i.sweepFlag === 1 && i.phi2 < i.phi1 && (i.phi2 += 2 * $A), i.phi1 *= 180 / $A, i.phi2 *= 180 / $A;
}
function iR(i, e, t) {
  va(i, e, t);
  var r = i * i + e * e - t * t;
  if (0 > r)
    return [];
  if (r === 0)
    return [[i * t / (i * i + e * e), e * t / (i * i + e * e)]];
  var n = Math.sqrt(r);
  return [[(i * t + e * n) / (i * i + e * e), (e * t - i * n) / (i * i + e * e)], [(i * t - e * n) / (i * i + e * e), (e * t + i * n) / (i * i + e * e)]];
}
var zi, Lo = Math.PI / 180;
function nR(i, e, t) {
  return (1 - t) * i + t * e;
}
function sR(i, e, t, r) {
  return i + Math.cos(r / 180 * $A) * e + Math.sin(r / 180 * $A) * t;
}
function aR(i, e, t, r) {
  var n = 1e-6, s = e - i, a = t - e, o = 3 * s + 3 * (r - t) - 6 * a, A = 6 * (a - s), l = 3 * s;
  return Math.abs(o) < n ? [-l / A] : function(h, c, u) {
    u === void 0 && (u = 1e-6);
    var f = h * h / 4 - c;
    if (f < -u)
      return [];
    if (f <= u)
      return [-h / 2];
    var g = Math.sqrt(f);
    return [-h / 2 - g, -h / 2 + g];
  }(A / o, l / o, n);
}
function oR(i, e, t, r, n) {
  var s = 1 - n;
  return i * (s * s * s) + e * (3 * s * s * n) + t * (3 * s * n * n) + r * (n * n * n);
}
(function(i) {
  function e() {
    return n(function(o, A, l) {
      return o.relative && (o.x1 !== void 0 && (o.x1 += A), o.y1 !== void 0 && (o.y1 += l), o.x2 !== void 0 && (o.x2 += A), o.y2 !== void 0 && (o.y2 += l), o.x !== void 0 && (o.x += A), o.y !== void 0 && (o.y += l), o.relative = !1), o;
    });
  }
  function t() {
    var o = NaN, A = NaN, l = NaN, h = NaN;
    return n(function(c, u, f) {
      return c.type & Ie.SMOOTH_CURVE_TO && (c.type = Ie.CURVE_TO, o = isNaN(o) ? u : o, A = isNaN(A) ? f : A, c.x1 = c.relative ? u - o : 2 * u - o, c.y1 = c.relative ? f - A : 2 * f - A), c.type & Ie.CURVE_TO ? (o = c.relative ? u + c.x2 : c.x2, A = c.relative ? f + c.y2 : c.y2) : (o = NaN, A = NaN), c.type & Ie.SMOOTH_QUAD_TO && (c.type = Ie.QUAD_TO, l = isNaN(l) ? u : l, h = isNaN(h) ? f : h, c.x1 = c.relative ? u - l : 2 * u - l, c.y1 = c.relative ? f - h : 2 * f - h), c.type & Ie.QUAD_TO ? (l = c.relative ? u + c.x1 : c.x1, h = c.relative ? f + c.y1 : c.y1) : (l = NaN, h = NaN), c;
    });
  }
  function r() {
    var o = NaN, A = NaN;
    return n(function(l, h, c) {
      if (l.type & Ie.SMOOTH_QUAD_TO && (l.type = Ie.QUAD_TO, o = isNaN(o) ? h : o, A = isNaN(A) ? c : A, l.x1 = l.relative ? h - o : 2 * h - o, l.y1 = l.relative ? c - A : 2 * c - A), l.type & Ie.QUAD_TO) {
        o = l.relative ? h + l.x1 : l.x1, A = l.relative ? c + l.y1 : l.y1;
        var u = l.x1, f = l.y1;
        l.type = Ie.CURVE_TO, l.x1 = ((l.relative ? 0 : h) + 2 * u) / 3, l.y1 = ((l.relative ? 0 : c) + 2 * f) / 3, l.x2 = (l.x + 2 * u) / 3, l.y2 = (l.y + 2 * f) / 3;
      } else
        o = NaN, A = NaN;
      return l;
    });
  }
  function n(o) {
    var A = 0, l = 0, h = NaN, c = NaN;
    return function(u) {
      if (isNaN(h) && !(u.type & Ie.MOVE_TO))
        throw new Error("path must start with moveto");
      var f = o(u, A, l, h, c);
      return u.type & Ie.CLOSE_PATH && (A = h, l = c), u.x !== void 0 && (A = u.relative ? A + u.x : u.x), u.y !== void 0 && (l = u.relative ? l + u.y : u.y), u.type & Ie.MOVE_TO && (h = A, c = l), f;
    };
  }
  function s(o, A, l, h, c, u) {
    return va(o, A, l, h, c, u), n(function(f, g, p, y) {
      var v = f.x1, w = f.x2, C = f.relative && !isNaN(y), E = f.x !== void 0 ? f.x : C ? 0 : g, S = f.y !== void 0 ? f.y : C ? 0 : p;
      function M(b) {
        return b * b;
      }
      f.type & Ie.HORIZ_LINE_TO && A !== 0 && (f.type = Ie.LINE_TO, f.y = f.relative ? 0 : p), f.type & Ie.VERT_LINE_TO && l !== 0 && (f.type = Ie.LINE_TO, f.x = f.relative ? 0 : g), f.x !== void 0 && (f.x = f.x * o + S * l + (C ? 0 : c)), f.y !== void 0 && (f.y = E * A + f.y * h + (C ? 0 : u)), f.x1 !== void 0 && (f.x1 = f.x1 * o + f.y1 * l + (C ? 0 : c)), f.y1 !== void 0 && (f.y1 = v * A + f.y1 * h + (C ? 0 : u)), f.x2 !== void 0 && (f.x2 = f.x2 * o + f.y2 * l + (C ? 0 : c)), f.y2 !== void 0 && (f.y2 = w * A + f.y2 * h + (C ? 0 : u));
      var T = o * h - A * l;
      if (f.xRot !== void 0 && (o !== 1 || A !== 0 || l !== 0 || h !== 1))
        if (T === 0)
          delete f.rX, delete f.rY, delete f.xRot, delete f.lArcFlag, delete f.sweepFlag, f.type = Ie.LINE_TO;
        else {
          var F = f.xRot * Math.PI / 180, k = Math.sin(F), $ = Math.cos(F), I = 1 / M(f.rX), L = 1 / M(f.rY), P = M($) * I + M(k) * L, Q = 2 * k * $ * (I - L), X = M(k) * I + M($) * L, W = P * h * h - Q * A * h + X * A * A, q = Q * (o * h + A * l) - 2 * (P * l * h + X * o * A), Z = P * l * l - Q * o * l + X * o * o, oe = (Math.atan2(q, W - Z) + Math.PI) % Math.PI / 2, ne = Math.sin(oe), me = Math.cos(oe);
          f.rX = Math.abs(T) / Math.sqrt(W * M(me) + q * ne * me + Z * M(ne)), f.rY = Math.abs(T) / Math.sqrt(W * M(ne) - q * ne * me + Z * M(me)), f.xRot = 180 * oe / Math.PI;
        }
      return f.sweepFlag !== void 0 && 0 > T && (f.sweepFlag = +!f.sweepFlag), f;
    });
  }
  function a() {
    return function(o) {
      var A = {};
      for (var l in o)
        A[l] = o[l];
      return A;
    };
  }
  i.ROUND = function(o) {
    function A(l) {
      return Math.round(l * o) / o;
    }
    return o === void 0 && (o = 1e13), va(o), function(l) {
      return l.x1 !== void 0 && (l.x1 = A(l.x1)), l.y1 !== void 0 && (l.y1 = A(l.y1)), l.x2 !== void 0 && (l.x2 = A(l.x2)), l.y2 !== void 0 && (l.y2 = A(l.y2)), l.x !== void 0 && (l.x = A(l.x)), l.y !== void 0 && (l.y = A(l.y)), l.rX !== void 0 && (l.rX = A(l.rX)), l.rY !== void 0 && (l.rY = A(l.rY)), l;
    };
  }, i.TO_ABS = e, i.TO_REL = function() {
    return n(function(o, A, l) {
      return o.relative || (o.x1 !== void 0 && (o.x1 -= A), o.y1 !== void 0 && (o.y1 -= l), o.x2 !== void 0 && (o.x2 -= A), o.y2 !== void 0 && (o.y2 -= l), o.x !== void 0 && (o.x -= A), o.y !== void 0 && (o.y -= l), o.relative = !0), o;
    });
  }, i.NORMALIZE_HVZ = function(o, A, l) {
    return o === void 0 && (o = !0), A === void 0 && (A = !0), l === void 0 && (l = !0), n(function(h, c, u, f, g) {
      if (isNaN(f) && !(h.type & Ie.MOVE_TO))
        throw new Error("path must start with moveto");
      return A && h.type & Ie.HORIZ_LINE_TO && (h.type = Ie.LINE_TO, h.y = h.relative ? 0 : u), l && h.type & Ie.VERT_LINE_TO && (h.type = Ie.LINE_TO, h.x = h.relative ? 0 : c), o && h.type & Ie.CLOSE_PATH && (h.type = Ie.LINE_TO, h.x = h.relative ? f - c : f, h.y = h.relative ? g - u : g), h.type & Ie.ARC && (h.rX === 0 || h.rY === 0) && (h.type = Ie.LINE_TO, delete h.rX, delete h.rY, delete h.xRot, delete h.lArcFlag, delete h.sweepFlag), h;
    });
  }, i.NORMALIZE_ST = t, i.QT_TO_C = r, i.INFO = n, i.SANITIZE = function(o) {
    o === void 0 && (o = 0), va(o);
    var A = NaN, l = NaN, h = NaN, c = NaN;
    return n(function(u, f, g, p, y) {
      var v = Math.abs, w = !1, C = 0, E = 0;
      if (u.type & Ie.SMOOTH_CURVE_TO && (C = isNaN(A) ? 0 : f - A, E = isNaN(l) ? 0 : g - l), u.type & (Ie.CURVE_TO | Ie.SMOOTH_CURVE_TO) ? (A = u.relative ? f + u.x2 : u.x2, l = u.relative ? g + u.y2 : u.y2) : (A = NaN, l = NaN), u.type & Ie.SMOOTH_QUAD_TO ? (h = isNaN(h) ? f : 2 * f - h, c = isNaN(c) ? g : 2 * g - c) : u.type & Ie.QUAD_TO ? (h = u.relative ? f + u.x1 : u.x1, c = u.relative ? g + u.y1 : u.y2) : (h = NaN, c = NaN), u.type & Ie.LINE_COMMANDS || u.type & Ie.ARC && (u.rX === 0 || u.rY === 0 || !u.lArcFlag) || u.type & Ie.CURVE_TO || u.type & Ie.SMOOTH_CURVE_TO || u.type & Ie.QUAD_TO || u.type & Ie.SMOOTH_QUAD_TO) {
        var S = u.x === void 0 ? 0 : u.relative ? u.x : u.x - f, M = u.y === void 0 ? 0 : u.relative ? u.y : u.y - g;
        C = isNaN(h) ? u.x1 === void 0 ? C : u.relative ? u.x : u.x1 - f : h - f, E = isNaN(c) ? u.y1 === void 0 ? E : u.relative ? u.y : u.y1 - g : c - g;
        var T = u.x2 === void 0 ? 0 : u.relative ? u.x : u.x2 - f, F = u.y2 === void 0 ? 0 : u.relative ? u.y : u.y2 - g;
        v(S) <= o && v(M) <= o && v(C) <= o && v(E) <= o && v(T) <= o && v(F) <= o && (w = !0);
      }
      return u.type & Ie.CLOSE_PATH && v(f - p) <= o && v(g - y) <= o && (w = !0), w ? [] : u;
    });
  }, i.MATRIX = s, i.ROTATE = function(o, A, l) {
    A === void 0 && (A = 0), l === void 0 && (l = 0), va(o, A, l);
    var h = Math.sin(o), c = Math.cos(o);
    return s(c, h, -h, c, A - A * c + l * h, l - A * h - l * c);
  }, i.TRANSLATE = function(o, A) {
    return A === void 0 && (A = 0), va(o, A), s(1, 0, 0, 1, o, A);
  }, i.SCALE = function(o, A) {
    return A === void 0 && (A = o), va(o, A), s(o, 0, 0, A, 0, 0);
  }, i.SKEW_X = function(o) {
    return va(o), s(1, 0, Math.atan(o), 1, 0, 0);
  }, i.SKEW_Y = function(o) {
    return va(o), s(1, Math.atan(o), 0, 1, 0, 0);
  }, i.X_AXIS_SYMMETRY = function(o) {
    return o === void 0 && (o = 0), va(o), s(-1, 0, 0, 1, o, 0);
  }, i.Y_AXIS_SYMMETRY = function(o) {
    return o === void 0 && (o = 0), va(o), s(1, 0, 0, -1, 0, o);
  }, i.A_TO_C = function() {
    return n(function(o, A, l) {
      return Ie.ARC === o.type ? function(h, c, u) {
        var f, g, p, y;
        h.cX || Nw(h, c, u);
        for (var v = Math.min(h.phi1, h.phi2), w = Math.max(h.phi1, h.phi2) - v, C = Math.ceil(w / 90), E = new Array(C), S = c, M = u, T = 0; T < C; T++) {
          var F = nR(h.phi1, h.phi2, T / C), k = nR(h.phi1, h.phi2, (T + 1) / C), $ = k - F, I = 4 / 3 * Math.tan($ * Lo / 4), L = [Math.cos(F * Lo) - I * Math.sin(F * Lo), Math.sin(F * Lo) + I * Math.cos(F * Lo)], P = L[0], Q = L[1], X = [Math.cos(k * Lo), Math.sin(k * Lo)], W = X[0], q = X[1], Z = [W + I * Math.sin(k * Lo), q - I * Math.cos(k * Lo)], oe = Z[0], ne = Z[1];
          E[T] = { relative: h.relative, type: Ie.CURVE_TO };
          var me = function(b, H) {
            var V = $C([b * h.rX, H * h.rY], h.xRot), j = V[0], ie = V[1];
            return [h.cX + j, h.cY + ie];
          };
          f = me(P, Q), E[T].x1 = f[0], E[T].y1 = f[1], g = me(oe, ne), E[T].x2 = g[0], E[T].y2 = g[1], p = me(W, q), E[T].x = p[0], E[T].y = p[1], h.relative && (E[T].x1 -= S, E[T].y1 -= M, E[T].x2 -= S, E[T].y2 -= M, E[T].x -= S, E[T].y -= M), S = (y = [E[T].x, E[T].y])[0], M = y[1];
        }
        return E;
      }(o, o.relative ? 0 : A, o.relative ? 0 : l) : o;
    });
  }, i.ANNOTATE_ARCS = function() {
    return n(function(o, A, l) {
      return o.relative && (A = 0, l = 0), Ie.ARC === o.type && Nw(o, A, l), o;
    });
  }, i.CLONE = a, i.CALCULATE_BOUNDS = function() {
    var o = function(u) {
      var f = {};
      for (var g in u)
        f[g] = u[g];
      return f;
    }, A = e(), l = r(), h = t(), c = n(function(u, f, g) {
      var p = h(l(A(o(u))));
      function y(ne) {
        ne > c.maxX && (c.maxX = ne), ne < c.minX && (c.minX = ne);
      }
      function v(ne) {
        ne > c.maxY && (c.maxY = ne), ne < c.minY && (c.minY = ne);
      }
      if (p.type & Ie.DRAWING_COMMANDS && (y(f), v(g)), p.type & Ie.HORIZ_LINE_TO && y(p.x), p.type & Ie.VERT_LINE_TO && v(p.y), p.type & Ie.LINE_TO && (y(p.x), v(p.y)), p.type & Ie.CURVE_TO) {
        y(p.x), v(p.y);
        for (var w = 0, C = aR(f, p.x1, p.x2, p.x); w < C.length; w++)
          0 < (oe = C[w]) && 1 > oe && y(oR(f, p.x1, p.x2, p.x, oe));
        for (var E = 0, S = aR(g, p.y1, p.y2, p.y); E < S.length; E++)
          0 < (oe = S[E]) && 1 > oe && v(oR(g, p.y1, p.y2, p.y, oe));
      }
      if (p.type & Ie.ARC) {
        y(p.x), v(p.y), Nw(p, f, g);
        for (var M = p.xRot / 180 * Math.PI, T = Math.cos(M) * p.rX, F = Math.sin(M) * p.rX, k = -Math.sin(M) * p.rY, $ = Math.cos(M) * p.rY, I = p.phi1 < p.phi2 ? [p.phi1, p.phi2] : -180 > p.phi2 ? [p.phi2 + 360, p.phi1 + 360] : [p.phi2, p.phi1], L = I[0], P = I[1], Q = function(ne) {
          var me = ne[0], b = ne[1], H = 180 * Math.atan2(b, me) / Math.PI;
          return H < L ? H + 360 : H;
        }, X = 0, W = iR(k, -T, 0).map(Q); X < W.length; X++)
          (oe = W[X]) > L && oe < P && y(sR(p.cX, T, k, oe));
        for (var q = 0, Z = iR($, -F, 0).map(Q); q < Z.length; q++) {
          var oe;
          (oe = Z[q]) > L && oe < P && v(sR(p.cY, F, $, oe));
        }
      }
      return u;
    });
    return c.minX = 1 / 0, c.maxX = -1 / 0, c.minY = 1 / 0, c.maxY = -1 / 0, c;
  };
})(zi || (zi = {}));
var pa, GO = function() {
  function i() {
  }
  return i.prototype.round = function(e) {
    return this.transform(zi.ROUND(e));
  }, i.prototype.toAbs = function() {
    return this.transform(zi.TO_ABS());
  }, i.prototype.toRel = function() {
    return this.transform(zi.TO_REL());
  }, i.prototype.normalizeHVZ = function(e, t, r) {
    return this.transform(zi.NORMALIZE_HVZ(e, t, r));
  }, i.prototype.normalizeST = function() {
    return this.transform(zi.NORMALIZE_ST());
  }, i.prototype.qtToC = function() {
    return this.transform(zi.QT_TO_C());
  }, i.prototype.aToC = function() {
    return this.transform(zi.A_TO_C());
  }, i.prototype.sanitize = function(e) {
    return this.transform(zi.SANITIZE(e));
  }, i.prototype.translate = function(e, t) {
    return this.transform(zi.TRANSLATE(e, t));
  }, i.prototype.scale = function(e, t) {
    return this.transform(zi.SCALE(e, t));
  }, i.prototype.rotate = function(e, t, r) {
    return this.transform(zi.ROTATE(e, t, r));
  }, i.prototype.matrix = function(e, t, r, n, s, a) {
    return this.transform(zi.MATRIX(e, t, r, n, s, a));
  }, i.prototype.skewX = function(e) {
    return this.transform(zi.SKEW_X(e));
  }, i.prototype.skewY = function(e) {
    return this.transform(zi.SKEW_Y(e));
  }, i.prototype.xSymmetry = function(e) {
    return this.transform(zi.X_AXIS_SYMMETRY(e));
  }, i.prototype.ySymmetry = function(e) {
    return this.transform(zi.Y_AXIS_SYMMETRY(e));
  }, i.prototype.annotateArcs = function() {
    return this.transform(zi.ANNOTATE_ARCS());
  }, i;
}(), Jve = function(i) {
  return i === " " || i === "	" || i === "\r" || i === `
`;
}, AR = function(i) {
  return "0".charCodeAt(0) <= i.charCodeAt(0) && i.charCodeAt(0) <= "9".charCodeAt(0);
}, eye = function(i) {
  function e() {
    var t = i.call(this) || this;
    return t.curNumber = "", t.curCommandType = -1, t.curCommandRelative = !1, t.canParseCommandOrComma = !0, t.curNumberHasExp = !1, t.curNumberHasExpDigits = !1, t.curNumberHasDecimal = !1, t.curArgs = [], t;
  }
  return HO(e, i), e.prototype.finish = function(t) {
    if (t === void 0 && (t = []), this.parse(" ", t), this.curArgs.length !== 0 || !this.canParseCommandOrComma)
      throw new SyntaxError("Unterminated command at the path end.");
    return t;
  }, e.prototype.parse = function(t, r) {
    var n = this;
    r === void 0 && (r = []);
    for (var s = function(c) {
      r.push(c), n.curArgs.length = 0, n.canParseCommandOrComma = !0;
    }, a = 0; a < t.length; a++) {
      var o = t[a], A = !(this.curCommandType !== Ie.ARC || this.curArgs.length !== 3 && this.curArgs.length !== 4 || this.curNumber.length !== 1 || this.curNumber !== "0" && this.curNumber !== "1"), l = AR(o) && (this.curNumber === "0" && o === "0" || A);
      if (!AR(o) || l)
        if (o !== "e" && o !== "E")
          if (o !== "-" && o !== "+" || !this.curNumberHasExp || this.curNumberHasExpDigits)
            if (o !== "." || this.curNumberHasExp || this.curNumberHasDecimal || A) {
              if (this.curNumber && this.curCommandType !== -1) {
                var h = Number(this.curNumber);
                if (isNaN(h))
                  throw new SyntaxError("Invalid number ending at " + a);
                if (this.curCommandType === Ie.ARC) {
                  if (this.curArgs.length === 0 || this.curArgs.length === 1) {
                    if (0 > h)
                      throw new SyntaxError('Expected positive number, got "' + h + '" at index "' + a + '"');
                  } else if ((this.curArgs.length === 3 || this.curArgs.length === 4) && this.curNumber !== "0" && this.curNumber !== "1")
                    throw new SyntaxError('Expected a flag, got "' + this.curNumber + '" at index "' + a + '"');
                }
                this.curArgs.push(h), this.curArgs.length === tye[this.curCommandType] && (Ie.HORIZ_LINE_TO === this.curCommandType ? s({ type: Ie.HORIZ_LINE_TO, relative: this.curCommandRelative, x: h }) : Ie.VERT_LINE_TO === this.curCommandType ? s({ type: Ie.VERT_LINE_TO, relative: this.curCommandRelative, y: h }) : this.curCommandType === Ie.MOVE_TO || this.curCommandType === Ie.LINE_TO || this.curCommandType === Ie.SMOOTH_QUAD_TO ? (s({ type: this.curCommandType, relative: this.curCommandRelative, x: this.curArgs[0], y: this.curArgs[1] }), Ie.MOVE_TO === this.curCommandType && (this.curCommandType = Ie.LINE_TO)) : this.curCommandType === Ie.CURVE_TO ? s({ type: Ie.CURVE_TO, relative: this.curCommandRelative, x1: this.curArgs[0], y1: this.curArgs[1], x2: this.curArgs[2], y2: this.curArgs[3], x: this.curArgs[4], y: this.curArgs[5] }) : this.curCommandType === Ie.SMOOTH_CURVE_TO ? s({ type: Ie.SMOOTH_CURVE_TO, relative: this.curCommandRelative, x2: this.curArgs[0], y2: this.curArgs[1], x: this.curArgs[2], y: this.curArgs[3] }) : this.curCommandType === Ie.QUAD_TO ? s({ type: Ie.QUAD_TO, relative: this.curCommandRelative, x1: this.curArgs[0], y1: this.curArgs[1], x: this.curArgs[2], y: this.curArgs[3] }) : this.curCommandType === Ie.ARC && s({ type: Ie.ARC, relative: this.curCommandRelative, rX: this.curArgs[0], rY: this.curArgs[1], xRot: this.curArgs[2], lArcFlag: this.curArgs[3], sweepFlag: this.curArgs[4], x: this.curArgs[5], y: this.curArgs[6] })), this.curNumber = "", this.curNumberHasExpDigits = !1, this.curNumberHasExp = !1, this.curNumberHasDecimal = !1, this.canParseCommandOrComma = !0;
              }
              if (!Jve(o))
                if (o === "," && this.canParseCommandOrComma)
                  this.canParseCommandOrComma = !1;
                else if (o !== "+" && o !== "-" && o !== ".")
                  if (l)
                    this.curNumber = o, this.curNumberHasDecimal = !1;
                  else {
                    if (this.curArgs.length !== 0)
                      throw new SyntaxError("Unterminated command at index " + a + ".");
                    if (!this.canParseCommandOrComma)
                      throw new SyntaxError('Unexpected character "' + o + '" at index ' + a + ". Command cannot follow comma");
                    if (this.canParseCommandOrComma = !1, o !== "z" && o !== "Z")
                      if (o === "h" || o === "H")
                        this.curCommandType = Ie.HORIZ_LINE_TO, this.curCommandRelative = o === "h";
                      else if (o === "v" || o === "V")
                        this.curCommandType = Ie.VERT_LINE_TO, this.curCommandRelative = o === "v";
                      else if (o === "m" || o === "M")
                        this.curCommandType = Ie.MOVE_TO, this.curCommandRelative = o === "m";
                      else if (o === "l" || o === "L")
                        this.curCommandType = Ie.LINE_TO, this.curCommandRelative = o === "l";
                      else if (o === "c" || o === "C")
                        this.curCommandType = Ie.CURVE_TO, this.curCommandRelative = o === "c";
                      else if (o === "s" || o === "S")
                        this.curCommandType = Ie.SMOOTH_CURVE_TO, this.curCommandRelative = o === "s";
                      else if (o === "q" || o === "Q")
                        this.curCommandType = Ie.QUAD_TO, this.curCommandRelative = o === "q";
                      else if (o === "t" || o === "T")
                        this.curCommandType = Ie.SMOOTH_QUAD_TO, this.curCommandRelative = o === "t";
                      else {
                        if (o !== "a" && o !== "A")
                          throw new SyntaxError('Unexpected character "' + o + '" at index ' + a + ".");
                        this.curCommandType = Ie.ARC, this.curCommandRelative = o === "a";
                      }
                    else
                      r.push({ type: Ie.CLOSE_PATH }), this.canParseCommandOrComma = !0, this.curCommandType = -1;
                  }
                else
                  this.curNumber = o, this.curNumberHasDecimal = o === ".";
            } else
              this.curNumber += o, this.curNumberHasDecimal = !0;
          else
            this.curNumber += o;
        else
          this.curNumber += o, this.curNumberHasExp = !0;
      else
        this.curNumber += o, this.curNumberHasExpDigits = this.curNumberHasExp;
    }
    return r;
  }, e.prototype.transform = function(t) {
    return Object.create(this, { parse: { value: function(r, n) {
      n === void 0 && (n = []);
      for (var s = 0, a = Object.getPrototypeOf(this).parse.call(this, r); s < a.length; s++) {
        var o = a[s], A = t(o);
        Array.isArray(A) ? n.push.apply(n, A) : n.push(A);
      }
      return n;
    } } });
  }, e;
}(GO), Ie = function(i) {
  function e(t) {
    var r = i.call(this) || this;
    return r.commands = typeof t == "string" ? e.parse(t) : t, r;
  }
  return HO(e, i), e.prototype.encode = function() {
    return e.encode(this.commands);
  }, e.prototype.getBounds = function() {
    var t = zi.CALCULATE_BOUNDS();
    return this.transform(t), t;
  }, e.prototype.transform = function(t) {
    for (var r = [], n = 0, s = this.commands; n < s.length; n++) {
      var a = t(s[n]);
      Array.isArray(a) ? r.push.apply(r, a) : r.push(a);
    }
    return this.commands = r, this;
  }, e.encode = function(t) {
    return Zve(t);
  }, e.parse = function(t) {
    var r = new eye(), n = [];
    return r.parse(t, n), r.finish(n), n;
  }, e.CLOSE_PATH = 1, e.MOVE_TO = 2, e.HORIZ_LINE_TO = 4, e.VERT_LINE_TO = 8, e.LINE_TO = 16, e.CURVE_TO = 32, e.SMOOTH_CURVE_TO = 64, e.QUAD_TO = 128, e.SMOOTH_QUAD_TO = 256, e.ARC = 512, e.LINE_COMMANDS = e.LINE_TO | e.HORIZ_LINE_TO | e.VERT_LINE_TO, e.DRAWING_COMMANDS = e.HORIZ_LINE_TO | e.VERT_LINE_TO | e.LINE_TO | e.CURVE_TO | e.SMOOTH_CURVE_TO | e.QUAD_TO | e.SMOOTH_QUAD_TO | e.ARC, e;
}(GO), tye = ((pa = {})[Ie.MOVE_TO] = 2, pa[Ie.LINE_TO] = 2, pa[Ie.HORIZ_LINE_TO] = 1, pa[Ie.VERT_LINE_TO] = 1, pa[Ie.CLOSE_PATH] = 0, pa[Ie.QUAD_TO] = 4, pa[Ie.SMOOTH_QUAD_TO] = 2, pa[Ie.CURVE_TO] = 6, pa[Ie.SMOOTH_CURVE_TO] = 4, pa[Ie.ARC] = 7, pa), rye = ri, iye = Ly.PROPER, nye = Jo, sye = Yn, aye = Cy, lR = ho, oye = tn, Aye = gO, Fb = "toString", VC = RegExp.prototype, $O = VC[Fb], lye = rye(Aye), hye = oye(function() {
  return $O.call({ source: "a", flags: "b" }) != "/a/b";
}), cye = iye && $O.name != Fb;
(hye || cye) && nye(RegExp.prototype, Fb, function() {
  var e = sye(this), t = lR(e.source), r = e.flags, n = lR(r === void 0 && aye(VC, e) && !("flags" in VC) ? lye(e) : r);
  return "/" + t + "/" + n;
}, { unsafe: !0 });
function Am(i) {
  return typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? Am = function(e) {
    return typeof e;
  } : Am = function(e) {
    return e && typeof Symbol == "function" && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e;
  }, Am(i);
}
function uye(i, e) {
  if (!(i instanceof e))
    throw new TypeError("Cannot call a class as a function");
}
var fye = [512, 512, 456, 512, 328, 456, 335, 512, 405, 328, 271, 456, 388, 335, 292, 512, 454, 405, 364, 328, 298, 271, 496, 456, 420, 388, 360, 335, 312, 292, 273, 512, 482, 454, 428, 405, 383, 364, 345, 328, 312, 298, 284, 271, 259, 496, 475, 456, 437, 420, 404, 388, 374, 360, 347, 335, 323, 312, 302, 292, 282, 273, 265, 512, 497, 482, 468, 454, 441, 428, 417, 405, 394, 383, 373, 364, 354, 345, 337, 328, 320, 312, 305, 298, 291, 284, 278, 271, 265, 259, 507, 496, 485, 475, 465, 456, 446, 437, 428, 420, 412, 404, 396, 388, 381, 374, 367, 360, 354, 347, 341, 335, 329, 323, 318, 312, 307, 302, 297, 292, 287, 282, 278, 273, 269, 265, 261, 512, 505, 497, 489, 482, 475, 468, 461, 454, 447, 441, 435, 428, 422, 417, 411, 405, 399, 394, 389, 383, 378, 373, 368, 364, 359, 354, 350, 345, 341, 337, 332, 328, 324, 320, 316, 312, 309, 305, 301, 298, 294, 291, 287, 284, 281, 278, 274, 271, 268, 265, 262, 259, 257, 507, 501, 496, 491, 485, 480, 475, 470, 465, 460, 456, 451, 446, 442, 437, 433, 428, 424, 420, 416, 412, 408, 404, 400, 396, 392, 388, 385, 381, 377, 374, 370, 367, 363, 360, 357, 354, 350, 347, 344, 341, 338, 335, 332, 329, 326, 323, 320, 318, 315, 312, 310, 307, 304, 302, 299, 297, 294, 292, 289, 287, 285, 282, 280, 278, 275, 273, 271, 269, 267, 265, 263, 261, 259], dye = [9, 11, 12, 13, 13, 14, 14, 15, 15, 15, 15, 16, 16, 16, 16, 17, 17, 17, 17, 17, 17, 17, 18, 18, 18, 18, 18, 18, 18, 18, 18, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24];
function gye(i, e, t, r, n) {
  if (typeof i == "string" && (i = document.getElementById(i)), !i || Am(i) !== "object" || !("getContext" in i))
    throw new TypeError("Expecting canvas with `getContext` method in processCanvasRGB(A) calls!");
  var s = i.getContext("2d");
  try {
    return s.getImageData(e, t, r, n);
  } catch (a) {
    throw new Error("unable to access image data: " + a);
  }
}
function pye(i, e, t, r, n, s) {
  if (!(isNaN(s) || s < 1)) {
    s |= 0;
    var a = gye(i, e, t, r, n);
    a = mye(a, e, t, r, n, s), i.getContext("2d").putImageData(a, e, t);
  }
}
function mye(i, e, t, r, n, s) {
  for (var a = i.data, o = 2 * s + 1, A = r - 1, l = n - 1, h = s + 1, c = h * (h + 1) / 2, u = new hR(), f = u, g, p = 1; p < o; p++)
    f = f.next = new hR(), p === h && (g = f);
  f.next = u;
  for (var y = null, v = null, w = 0, C = 0, E = fye[s], S = dye[s], M = 0; M < n; M++) {
    f = u;
    for (var T = a[C], F = a[C + 1], k = a[C + 2], $ = a[C + 3], I = 0; I < h; I++)
      f.r = T, f.g = F, f.b = k, f.a = $, f = f.next;
    for (var L = 0, P = 0, Q = 0, X = 0, W = h * T, q = h * F, Z = h * k, oe = h * $, ne = c * T, me = c * F, b = c * k, H = c * $, V = 1; V < h; V++) {
      var j = C + ((A < V ? A : V) << 2), ie = a[j], ue = a[j + 1], fe = a[j + 2], ee = a[j + 3], xe = h - V;
      ne += (f.r = ie) * xe, me += (f.g = ue) * xe, b += (f.b = fe) * xe, H += (f.a = ee) * xe, L += ie, P += ue, Q += fe, X += ee, f = f.next;
    }
    y = u, v = g;
    for (var Ee = 0; Ee < r; Ee++) {
      var Ue = H * E >> S;
      if (a[C + 3] = Ue, Ue !== 0) {
        var ke = 255 / Ue;
        a[C] = (ne * E >> S) * ke, a[C + 1] = (me * E >> S) * ke, a[C + 2] = (b * E >> S) * ke;
      } else
        a[C] = a[C + 1] = a[C + 2] = 0;
      ne -= W, me -= q, b -= Z, H -= oe, W -= y.r, q -= y.g, Z -= y.b, oe -= y.a;
      var We = Ee + s + 1;
      We = w + (We < A ? We : A) << 2, L += y.r = a[We], P += y.g = a[We + 1], Q += y.b = a[We + 2], X += y.a = a[We + 3], ne += L, me += P, b += Q, H += X, y = y.next;
      var ve = v, Y = ve.r, mt = ve.g, Ze = ve.b, Fe = ve.a;
      W += Y, q += mt, Z += Ze, oe += Fe, L -= Y, P -= mt, Q -= Ze, X -= Fe, v = v.next, C += 4;
    }
    w += r;
  }
  for (var Re = 0; Re < r; Re++) {
    C = Re << 2;
    var De = a[C], Le = a[C + 1], Ge = a[C + 2], ze = a[C + 3], ft = h * De, Et = h * Le, Mt = h * Ge, Ut = h * ze, At = c * De, vt = c * Le, Ne = c * Ge, Qr = c * ze;
    f = u;
    for (var kt = 0; kt < h; kt++)
      f.r = De, f.g = Le, f.b = Ge, f.a = ze, f = f.next;
    for (var fn = r, Ar = 0, Zt = 0, ii = 0, Jt = 0, rn = 1; rn <= s; rn++) {
      C = fn + Re << 2;
      var ar = h - rn;
      At += (f.r = De = a[C]) * ar, vt += (f.g = Le = a[C + 1]) * ar, Ne += (f.b = Ge = a[C + 2]) * ar, Qr += (f.a = ze = a[C + 3]) * ar, Jt += De, Ar += Le, Zt += Ge, ii += ze, f = f.next, rn < l && (fn += r);
    }
    C = Re, y = u, v = g;
    for (var Ai = 0; Ai < n; Ai++) {
      var yr = C << 2;
      a[yr + 3] = ze = Qr * E >> S, ze > 0 ? (ze = 255 / ze, a[yr] = (At * E >> S) * ze, a[yr + 1] = (vt * E >> S) * ze, a[yr + 2] = (Ne * E >> S) * ze) : a[yr] = a[yr + 1] = a[yr + 2] = 0, At -= ft, vt -= Et, Ne -= Mt, Qr -= Ut, ft -= y.r, Et -= y.g, Mt -= y.b, Ut -= y.a, yr = Re + ((yr = Ai + h) < l ? yr : l) * r << 2, At += Jt += y.r = a[yr], vt += Ar += y.g = a[yr + 1], Ne += Zt += y.b = a[yr + 2], Qr += ii += y.a = a[yr + 3], y = y.next, ft += De = v.r, Et += Le = v.g, Mt += Ge = v.b, Ut += ze = v.a, Jt -= De, Ar -= Le, Zt -= Ge, ii -= ze, v = v.next, C += r;
    }
  }
  return i;
}
var hR = (
  /**
   * Set properties.
   */
  function i() {
    uye(this, i), this.r = 0, this.g = 0, this.b = 0, this.a = 0, this.next = null;
  }
);
function vye() {
  var {
    DOMParser: i
  } = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, e = {
    window: null,
    ignoreAnimation: !0,
    ignoreMouse: !0,
    DOMParser: i,
    createCanvas(t, r) {
      return new OffscreenCanvas(t, r);
    },
    createImage(t) {
      return rA(function* () {
        var r = yield fetch(t), n = yield r.blob(), s = yield createImageBitmap(n);
        return s;
      })();
    }
  };
  return (typeof DOMParser < "u" || typeof i > "u") && Reflect.deleteProperty(e, "DOMParser"), e;
}
function yye(i) {
  var {
    DOMParser: e,
    canvas: t,
    fetch: r
  } = i;
  return {
    window: null,
    ignoreAnimation: !0,
    ignoreMouse: !0,
    DOMParser: e,
    fetch: r,
    createCanvas: t.createCanvas,
    createImage: t.loadImage
  };
}
var _ye = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  offscreen: vye,
  node: yye
});
function Mh(i) {
  return i.replace(/(?!\u3000)\s+/gm, " ");
}
function VO(i) {
  return i.replace(/^[\n \t]+/, "");
}
function KO(i) {
  return i.replace(/[\n \t]+$/, "");
}
function ps(i) {
  var e = (i || "").match(/-?(\d+(?:\.\d*(?:[eE][+-]?\d+)?)?|\.\d+)(?=\D|$)/gm) || [];
  return e.map(parseFloat);
}
var wye = /^[A-Z-]+$/;
function jO(i) {
  return wye.test(i) ? i.toLowerCase() : i;
}
function Lb(i) {
  var e = /url\(('([^']+)'|"([^"]+)"|([^'")]+))\)/.exec(i) || [];
  return e[2] || e[3] || e[4];
}
function zO(i) {
  if (!i.startsWith("rgb"))
    return i;
  var e = 3, t = i.replace(/\d+(\.\d+)?/g, (r, n) => e-- && n ? String(Math.round(parseFloat(r))) : r);
  return t;
}
var xye = /(\[[^\]]+\])/g, Cye = /(#[^\s+>~.[:]+)/g, Eye = /(\.[^\s+>~.[:]+)/g, Bye = /(::[^\s+>~.[:]+|:first-line|:first-letter|:before|:after)/gi, bye = /(:[\w-]+\([^)]*\))/gi, Sye = /(:[^\s+>~.[:]+)/g, Tye = /([^\s+>~.[:]+)/g;
function Ql(i, e) {
  var t = e.exec(i);
  return t ? [i.replace(e, " "), t.length] : [i, 0];
}
function XO(i) {
  var e = [0, 0, 0], t = i.replace(/:not\(([^)]*)\)/g, "     $1 ").replace(/{[\s\S]*/gm, " "), r = 0;
  return [t, r] = Ql(t, xye), e[1] += r, [t, r] = Ql(t, Cye), e[0] += r, [t, r] = Ql(t, Eye), e[1] += r, [t, r] = Ql(t, Bye), e[2] += r, [t, r] = Ql(t, bye), e[1] += r, [t, r] = Ql(t, Sye), e[1] += r, t = t.replace(/[*\s+>~]/g, " ").replace(/[#.]/g, " "), [t, r] = Ql(t, Tye), e[2] += r, e.join("");
}
var ch = 1e-8;
function KC(i) {
  return Math.sqrt(Math.pow(i[0], 2) + Math.pow(i[1], 2));
}
function Tv(i, e) {
  return (i[0] * e[0] + i[1] * e[1]) / (KC(i) * KC(e));
}
function jC(i, e) {
  return (i[0] * e[1] < i[1] * e[0] ? -1 : 1) * Math.acos(Tv(i, e));
}
function zC(i) {
  return i * i * i;
}
function XC(i) {
  return 3 * i * i * (1 - i);
}
function WC(i) {
  return 3 * i * (1 - i) * (1 - i);
}
function YC(i) {
  return (1 - i) * (1 - i) * (1 - i);
}
function qC(i) {
  return i * i;
}
function ZC(i) {
  return 2 * i * (1 - i);
}
function JC(i) {
  return (1 - i) * (1 - i);
}
class yt {
  constructor(e, t, r) {
    this.document = e, this.name = t, this.value = r, this.isNormalizedColor = !1;
  }
  static empty(e) {
    return new yt(e, "EMPTY", "");
  }
  split() {
    var e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : " ", {
      document: t,
      name: r
    } = this;
    return Mh(this.getString()).trim().split(e).map((n) => new yt(t, r, n));
  }
  hasValue(e) {
    var {
      value: t
    } = this;
    return t !== null && t !== "" && (e || t !== 0) && typeof t < "u";
  }
  isString(e) {
    var {
      value: t
    } = this, r = typeof t == "string";
    return !r || !e ? r : e.test(t);
  }
  isUrlDefinition() {
    return this.isString(/^url\(/);
  }
  isPixels() {
    if (!this.hasValue())
      return !1;
    var e = this.getString();
    switch (!0) {
      case e.endsWith("px"):
      case /^[0-9]+$/.test(e):
        return !0;
      default:
        return !1;
    }
  }
  setValue(e) {
    return this.value = e, this;
  }
  getValue(e) {
    return typeof e > "u" || this.hasValue() ? this.value : e;
  }
  getNumber(e) {
    if (!this.hasValue())
      return typeof e > "u" ? 0 : parseFloat(e);
    var {
      value: t
    } = this, r = parseFloat(t);
    return this.isString(/%$/) && (r /= 100), r;
  }
  getString(e) {
    return typeof e > "u" || this.hasValue() ? typeof this.value > "u" ? "" : String(this.value) : String(e);
  }
  getColor(e) {
    var t = this.getString(e);
    return this.isNormalizedColor || (this.isNormalizedColor = !0, t = zO(t), this.value = t), t;
  }
  getDpi() {
    return 96;
  }
  getRem() {
    return this.document.rootEmSize;
  }
  getEm() {
    return this.document.emSize;
  }
  getUnits() {
    return this.getString().replace(/[0-9.-]/g, "");
  }
  getPixels(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !1;
    if (!this.hasValue())
      return 0;
    var [r, n] = typeof e == "boolean" ? [void 0, e] : [e], {
      viewPort: s
    } = this.document.screen;
    switch (!0) {
      case this.isString(/vmin$/):
        return this.getNumber() / 100 * Math.min(s.computeSize("x"), s.computeSize("y"));
      case this.isString(/vmax$/):
        return this.getNumber() / 100 * Math.max(s.computeSize("x"), s.computeSize("y"));
      case this.isString(/vw$/):
        return this.getNumber() / 100 * s.computeSize("x");
      case this.isString(/vh$/):
        return this.getNumber() / 100 * s.computeSize("y");
      case this.isString(/rem$/):
        return this.getNumber() * this.getRem();
      case this.isString(/em$/):
        return this.getNumber() * this.getEm();
      case this.isString(/ex$/):
        return this.getNumber() * this.getEm() / 2;
      case this.isString(/px$/):
        return this.getNumber();
      case this.isString(/pt$/):
        return this.getNumber() * this.getDpi() * (1 / 72);
      case this.isString(/pc$/):
        return this.getNumber() * 15;
      case this.isString(/cm$/):
        return this.getNumber() * this.getDpi() / 2.54;
      case this.isString(/mm$/):
        return this.getNumber() * this.getDpi() / 25.4;
      case this.isString(/in$/):
        return this.getNumber() * this.getDpi();
      case (this.isString(/%$/) && n):
        return this.getNumber() * this.getEm();
      case this.isString(/%$/):
        return this.getNumber() * s.computeSize(r);
      default: {
        var a = this.getNumber();
        return t && a < 1 ? a * s.computeSize(r) : a;
      }
    }
  }
  getMilliseconds() {
    return this.hasValue() ? this.isString(/ms$/) ? this.getNumber() : this.getNumber() * 1e3 : 0;
  }
  getRadians() {
    if (!this.hasValue())
      return 0;
    switch (!0) {
      case this.isString(/deg$/):
        return this.getNumber() * (Math.PI / 180);
      case this.isString(/grad$/):
        return this.getNumber() * (Math.PI / 200);
      case this.isString(/rad$/):
        return this.getNumber();
      default:
        return this.getNumber() * (Math.PI / 180);
    }
  }
  getDefinition() {
    var e = this.getString(), t = /#([^)'"]+)/.exec(e);
    return t && (t = t[1]), t || (t = e), this.document.definitions[t];
  }
  getFillStyleDefinition(e, t) {
    var r = this.getDefinition();
    if (!r)
      return null;
    if (typeof r.createGradient == "function")
      return r.createGradient(this.document.ctx, e, t);
    if (typeof r.createPattern == "function") {
      if (r.getHrefAttribute().hasValue()) {
        var n = r.getAttribute("patternTransform");
        r = r.getHrefAttribute().getDefinition(), n.hasValue() && r.getAttribute("patternTransform", !0).setValue(n.value);
      }
      return r.createPattern(this.document.ctx, e, t);
    }
    return null;
  }
  getTextBaseline() {
    return this.hasValue() ? yt.textBaselineMapping[this.getString()] : null;
  }
  addOpacity(e) {
    for (var t = this.getColor(), r = t.length, n = 0, s = 0; s < r && (t[s] === "," && n++, n !== 3); s++)
      ;
    if (e.hasValue() && this.isString() && n !== 3) {
      var a = new HC(t);
      a.ok && (a.alpha = e.getNumber(), t = a.toRGBA());
    }
    return new yt(this.document, this.name, t);
  }
}
yt.textBaselineMapping = {
  baseline: "alphabetic",
  "before-edge": "top",
  "text-before-edge": "top",
  middle: "middle",
  central: "middle",
  "after-edge": "bottom",
  "text-after-edge": "bottom",
  ideographic: "ideographic",
  alphabetic: "alphabetic",
  hanging: "hanging",
  mathematical: "alphabetic"
};
class WO {
  constructor() {
    this.viewPorts = [];
  }
  clear() {
    this.viewPorts = [];
  }
  setCurrent(e, t) {
    this.viewPorts.push({
      width: e,
      height: t
    });
  }
  removeCurrent() {
    this.viewPorts.pop();
  }
  getCurrent() {
    var {
      viewPorts: e
    } = this;
    return e[e.length - 1];
  }
  get width() {
    return this.getCurrent().width;
  }
  get height() {
    return this.getCurrent().height;
  }
  computeSize(e) {
    return typeof e == "number" ? e : e === "x" ? this.width : e === "y" ? this.height : Math.sqrt(Math.pow(this.width, 2) + Math.pow(this.height, 2)) / Math.sqrt(2);
  }
}
class Ti {
  constructor(e, t) {
    this.x = e, this.y = t;
  }
  static parse(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0, [r = t, n = t] = ps(e);
    return new Ti(r, n);
  }
  static parseScale(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 1, [r = t, n = r] = ps(e);
    return new Ti(r, n);
  }
  static parsePath(e) {
    for (var t = ps(e), r = t.length, n = [], s = 0; s < r; s += 2)
      n.push(new Ti(t[s], t[s + 1]));
    return n;
  }
  angleTo(e) {
    return Math.atan2(e.y - this.y, e.x - this.x);
  }
  applyTransform(e) {
    var {
      x: t,
      y: r
    } = this, n = t * e[0] + r * e[2] + e[4], s = t * e[1] + r * e[3] + e[5];
    this.x = n, this.y = s;
  }
}
class YO {
  constructor(e) {
    this.screen = e, this.working = !1, this.events = [], this.eventElements = [], this.onClick = this.onClick.bind(this), this.onMouseMove = this.onMouseMove.bind(this);
  }
  isWorking() {
    return this.working;
  }
  start() {
    if (!this.working) {
      var {
        screen: e,
        onClick: t,
        onMouseMove: r
      } = this, n = e.ctx.canvas;
      n.onclick = t, n.onmousemove = r, this.working = !0;
    }
  }
  stop() {
    if (this.working) {
      var e = this.screen.ctx.canvas;
      this.working = !1, e.onclick = null, e.onmousemove = null;
    }
  }
  hasEvents() {
    return this.working && this.events.length > 0;
  }
  runEvents() {
    if (this.working) {
      var {
        screen: e,
        events: t,
        eventElements: r
      } = this, {
        style: n
      } = e.ctx.canvas;
      n && (n.cursor = ""), t.forEach((s, a) => {
        for (var {
          run: o
        } = s, A = r[a]; A; )
          o(A), A = A.parent;
      }), this.events = [], this.eventElements = [];
    }
  }
  checkPath(e, t) {
    if (!(!this.working || !t)) {
      var {
        events: r,
        eventElements: n
      } = this;
      r.forEach((s, a) => {
        var {
          x: o,
          y: A
        } = s;
        !n[a] && t.isPointInPath && t.isPointInPath(o, A) && (n[a] = e);
      });
    }
  }
  checkBoundingBox(e, t) {
    if (!(!this.working || !t)) {
      var {
        events: r,
        eventElements: n
      } = this;
      r.forEach((s, a) => {
        var {
          x: o,
          y: A
        } = s;
        !n[a] && t.isPointInBox(o, A) && (n[a] = e);
      });
    }
  }
  mapXY(e, t) {
    for (var {
      window: r,
      ctx: n
    } = this.screen, s = new Ti(e, t), a = n.canvas; a; )
      s.x -= a.offsetLeft, s.y -= a.offsetTop, a = a.offsetParent;
    return r.scrollX && (s.x += r.scrollX), r.scrollY && (s.y += r.scrollY), s;
  }
  onClick(e) {
    var {
      x: t,
      y: r
    } = this.mapXY(e.clientX, e.clientY);
    this.events.push({
      type: "onclick",
      x: t,
      y: r,
      run(n) {
        n.onClick && n.onClick();
      }
    });
  }
  onMouseMove(e) {
    var {
      x: t,
      y: r
    } = this.mapXY(e.clientX, e.clientY);
    this.events.push({
      type: "onmousemove",
      x: t,
      y: r,
      run(n) {
        n.onMouseMove && n.onMouseMove();
      }
    });
  }
}
var qO = typeof window < "u" ? window : null, ZO = typeof fetch < "u" ? fetch.bind(void 0) : null;
class Pg {
  constructor(e) {
    var {
      fetch: t = ZO,
      window: r = qO
    } = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    this.ctx = e, this.FRAMERATE = 30, this.MAX_VIRTUAL_PIXELS = 3e4, this.CLIENT_WIDTH = 800, this.CLIENT_HEIGHT = 600, this.viewPort = new WO(), this.mouse = new YO(this), this.animations = [], this.waits = [], this.frameDuration = 0, this.isReadyLock = !1, this.isFirstRender = !0, this.intervalId = null, this.window = r, this.fetch = t;
  }
  wait(e) {
    this.waits.push(e);
  }
  ready() {
    return this.readyPromise ? this.readyPromise : Promise.resolve();
  }
  isReady() {
    if (this.isReadyLock)
      return !0;
    var e = this.waits.every((t) => t());
    return e && (this.waits = [], this.resolveReady && this.resolveReady()), this.isReadyLock = e, e;
  }
  setDefaults(e) {
    e.strokeStyle = "rgba(0,0,0,0)", e.lineCap = "butt", e.lineJoin = "miter", e.miterLimit = 4;
  }
  setViewBox(e) {
    var {
      document: t,
      ctx: r,
      aspectRatio: n,
      width: s,
      desiredWidth: a,
      height: o,
      desiredHeight: A,
      minX: l = 0,
      minY: h = 0,
      refX: c,
      refY: u,
      clip: f = !1,
      clipX: g = 0,
      clipY: p = 0
    } = e, y = Mh(n).replace(/^defer\s/, ""), [v, w] = y.split(" "), C = v || "xMidYMid", E = w || "meet", S = s / a, M = o / A, T = Math.min(S, M), F = Math.max(S, M), k = a, $ = A;
    E === "meet" && (k *= T, $ *= T), E === "slice" && (k *= F, $ *= F);
    var I = new yt(t, "refX", c), L = new yt(t, "refY", u), P = I.hasValue() && L.hasValue();
    if (P && r.translate(-T * I.getPixels("x"), -T * L.getPixels("y")), f) {
      var Q = T * g, X = T * p;
      r.beginPath(), r.moveTo(Q, X), r.lineTo(s, X), r.lineTo(s, o), r.lineTo(Q, o), r.closePath(), r.clip();
    }
    if (!P) {
      var W = E === "meet" && T === M, q = E === "slice" && F === M, Z = E === "meet" && T === S, oe = E === "slice" && F === S;
      C.startsWith("xMid") && (W || q) && r.translate(s / 2 - k / 2, 0), C.endsWith("YMid") && (Z || oe) && r.translate(0, o / 2 - $ / 2), C.startsWith("xMax") && (W || q) && r.translate(s - k, 0), C.endsWith("YMax") && (Z || oe) && r.translate(0, o - $);
    }
    switch (!0) {
      case C === "none":
        r.scale(S, M);
        break;
      case E === "meet":
        r.scale(T, T);
        break;
      case E === "slice":
        r.scale(F, F);
        break;
    }
    r.translate(-l, -h);
  }
  start(e) {
    var {
      enableRedraw: t = !1,
      ignoreMouse: r = !1,
      ignoreAnimation: n = !1,
      ignoreDimensions: s = !1,
      ignoreClear: a = !1,
      forceRedraw: o,
      scaleWidth: A,
      scaleHeight: l,
      offsetX: h,
      offsetY: c
    } = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, {
      FRAMERATE: u,
      mouse: f
    } = this, g = 1e3 / u;
    if (this.frameDuration = g, this.readyPromise = new Promise((C) => {
      this.resolveReady = C;
    }), this.isReady() && this.render(e, s, a, A, l, h, c), !!t) {
      var p = Date.now(), y = p, v = 0, w = () => {
        p = Date.now(), v = p - y, v >= g && (y = p - v % g, this.shouldUpdate(n, o) && (this.render(e, s, a, A, l, h, c), f.runEvents())), this.intervalId = hh(w);
      };
      r || f.start(), this.intervalId = hh(w);
    }
  }
  stop() {
    this.intervalId && (hh.cancel(this.intervalId), this.intervalId = null), this.mouse.stop();
  }
  shouldUpdate(e, t) {
    if (!e) {
      var {
        frameDuration: r
      } = this, n = this.animations.reduce((s, a) => a.update(r) || s, !1);
      if (n)
        return !0;
    }
    return !!(typeof t == "function" && t() || !this.isReadyLock && this.isReady() || this.mouse.hasEvents());
  }
  render(e, t, r, n, s, a, o) {
    var {
      CLIENT_WIDTH: A,
      CLIENT_HEIGHT: l,
      viewPort: h,
      ctx: c,
      isFirstRender: u
    } = this, f = c.canvas;
    h.clear(), f.width && f.height ? h.setCurrent(f.width, f.height) : h.setCurrent(A, l);
    var g = e.getStyle("width"), p = e.getStyle("height");
    !t && (u || typeof n != "number" && typeof s != "number") && (g.hasValue() && (f.width = g.getPixels("x"), f.style && (f.style.width = "".concat(f.width, "px"))), p.hasValue() && (f.height = p.getPixels("y"), f.style && (f.style.height = "".concat(f.height, "px"))));
    var y = f.clientWidth || f.width, v = f.clientHeight || f.height;
    if (t && g.hasValue() && p.hasValue() && (y = g.getPixels("x"), v = p.getPixels("y")), h.setCurrent(y, v), typeof a == "number" && e.getAttribute("x", !0).setValue(a), typeof o == "number" && e.getAttribute("y", !0).setValue(o), typeof n == "number" || typeof s == "number") {
      var w = ps(e.getAttribute("viewBox").getString()), C = 0, E = 0;
      if (typeof n == "number") {
        var S = e.getStyle("width");
        S.hasValue() ? C = S.getPixels("x") / n : isNaN(w[2]) || (C = w[2] / n);
      }
      if (typeof s == "number") {
        var M = e.getStyle("height");
        M.hasValue() ? E = M.getPixels("y") / s : isNaN(w[3]) || (E = w[3] / s);
      }
      C || (C = E), E || (E = C), e.getAttribute("width", !0).setValue(n), e.getAttribute("height", !0).setValue(s);
      var T = e.getStyle("transform", !0, !0);
      T.setValue("".concat(T.getString(), " scale(").concat(1 / C, ", ").concat(1 / E, ")"));
    }
    r || c.clearRect(0, 0, y, v), e.render(c), u && (this.isFirstRender = !1);
  }
}
Pg.defaultWindow = qO;
Pg.defaultFetch = ZO;
var {
  defaultFetch: Fye
} = Pg, Lye = typeof DOMParser < "u" ? DOMParser : null;
class lm {
  constructor() {
    var {
      fetch: e = Fye,
      DOMParser: t = Lye
    } = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    this.fetch = e, this.DOMParser = t;
  }
  parse(e) {
    var t = this;
    return rA(function* () {
      return e.startsWith("<") ? t.parseFromString(e) : t.load(e);
    })();
  }
  parseFromString(e) {
    var t = new this.DOMParser();
    try {
      return this.checkDocument(t.parseFromString(e, "image/svg+xml"));
    } catch {
      return this.checkDocument(t.parseFromString(e, "text/xml"));
    }
  }
  checkDocument(e) {
    var t = e.getElementsByTagName("parsererror")[0];
    if (t)
      throw new Error(t.textContent);
    return e;
  }
  load(e) {
    var t = this;
    return rA(function* () {
      var r = yield t.fetch(e), n = yield r.text();
      return t.parseFromString(n);
    })();
  }
}
class JO {
  constructor(e, t) {
    this.type = "translate", this.point = null, this.point = Ti.parse(t);
  }
  apply(e) {
    var {
      x: t,
      y: r
    } = this.point;
    e.translate(t || 0, r || 0);
  }
  unapply(e) {
    var {
      x: t,
      y: r
    } = this.point;
    e.translate(-1 * t || 0, -1 * r || 0);
  }
  applyToPoint(e) {
    var {
      x: t,
      y: r
    } = this.point;
    e.applyTransform([1, 0, 0, 1, t || 0, r || 0]);
  }
}
class eU {
  constructor(e, t, r) {
    this.type = "rotate", this.angle = null, this.originX = null, this.originY = null, this.cx = 0, this.cy = 0;
    var n = ps(t);
    this.angle = new yt(e, "angle", n[0]), this.originX = r[0], this.originY = r[1], this.cx = n[1] || 0, this.cy = n[2] || 0;
  }
  apply(e) {
    var {
      cx: t,
      cy: r,
      originX: n,
      originY: s,
      angle: a
    } = this, o = t + n.getPixels("x"), A = r + s.getPixels("y");
    e.translate(o, A), e.rotate(a.getRadians()), e.translate(-o, -A);
  }
  unapply(e) {
    var {
      cx: t,
      cy: r,
      originX: n,
      originY: s,
      angle: a
    } = this, o = t + n.getPixels("x"), A = r + s.getPixels("y");
    e.translate(o, A), e.rotate(-1 * a.getRadians()), e.translate(-o, -A);
  }
  applyToPoint(e) {
    var {
      cx: t,
      cy: r,
      angle: n
    } = this, s = n.getRadians();
    e.applyTransform([
      1,
      0,
      0,
      1,
      t || 0,
      r || 0
      // this.p.y
    ]), e.applyTransform([Math.cos(s), Math.sin(s), -Math.sin(s), Math.cos(s), 0, 0]), e.applyTransform([
      1,
      0,
      0,
      1,
      -t || 0,
      -r || 0
      // -this.p.y
    ]);
  }
}
class tU {
  constructor(e, t, r) {
    this.type = "scale", this.scale = null, this.originX = null, this.originY = null;
    var n = Ti.parseScale(t);
    (n.x === 0 || n.y === 0) && (n.x = ch, n.y = ch), this.scale = n, this.originX = r[0], this.originY = r[1];
  }
  apply(e) {
    var {
      scale: {
        x: t,
        y: r
      },
      originX: n,
      originY: s
    } = this, a = n.getPixels("x"), o = s.getPixels("y");
    e.translate(a, o), e.scale(t, r || t), e.translate(-a, -o);
  }
  unapply(e) {
    var {
      scale: {
        x: t,
        y: r
      },
      originX: n,
      originY: s
    } = this, a = n.getPixels("x"), o = s.getPixels("y");
    e.translate(a, o), e.scale(1 / t, 1 / r || t), e.translate(-a, -o);
  }
  applyToPoint(e) {
    var {
      x: t,
      y: r
    } = this.scale;
    e.applyTransform([t || 0, 0, 0, r || 0, 0, 0]);
  }
}
class Ib {
  constructor(e, t, r) {
    this.type = "matrix", this.matrix = [], this.originX = null, this.originY = null, this.matrix = ps(t), this.originX = r[0], this.originY = r[1];
  }
  apply(e) {
    var {
      originX: t,
      originY: r,
      matrix: n
    } = this, s = t.getPixels("x"), a = r.getPixels("y");
    e.translate(s, a), e.transform(n[0], n[1], n[2], n[3], n[4], n[5]), e.translate(-s, -a);
  }
  unapply(e) {
    var {
      originX: t,
      originY: r,
      matrix: n
    } = this, s = n[0], a = n[2], o = n[4], A = n[1], l = n[3], h = n[5], c = 0, u = 0, f = 1, g = 1 / (s * (l * f - h * u) - a * (A * f - h * c) + o * (A * u - l * c)), p = t.getPixels("x"), y = r.getPixels("y");
    e.translate(p, y), e.transform(g * (l * f - h * u), g * (h * c - A * f), g * (o * u - a * f), g * (s * f - o * c), g * (a * h - o * l), g * (o * A - s * h)), e.translate(-p, -y);
  }
  applyToPoint(e) {
    e.applyTransform(this.matrix);
  }
}
class Rb extends Ib {
  constructor(e, t, r) {
    super(e, t, r), this.type = "skew", this.angle = null, this.angle = new yt(e, "angle", t);
  }
}
class rU extends Rb {
  constructor(e, t, r) {
    super(e, t, r), this.type = "skewX", this.matrix = [1, 0, Math.tan(this.angle.getRadians()), 1, 0, 0];
  }
}
class iU extends Rb {
  constructor(e, t, r) {
    super(e, t, r), this.type = "skewY", this.matrix = [1, Math.tan(this.angle.getRadians()), 0, 1, 0, 0];
  }
}
function Iye(i) {
  return Mh(i).trim().replace(/\)([a-zA-Z])/g, ") $1").replace(/\)(\s?,\s?)/g, ") ").split(/\s(?=[a-z])/);
}
function Rye(i) {
  var [e, t] = i.split("(");
  return [e.trim(), t.trim().replace(")", "")];
}
class vl {
  constructor(e, t, r) {
    this.document = e, this.transforms = [];
    var n = Iye(t);
    n.forEach((s) => {
      if (s !== "none") {
        var [a, o] = Rye(s), A = vl.transformTypes[a];
        typeof A < "u" && this.transforms.push(new A(this.document, o, r));
      }
    });
  }
  static fromElement(e, t) {
    var r = t.getStyle("transform", !1, !0), [n, s = n] = t.getStyle("transform-origin", !1, !0).split(), a = [n, s];
    return r.hasValue() ? new vl(e, r.getString(), a) : null;
  }
  apply(e) {
    for (var {
      transforms: t
    } = this, r = t.length, n = 0; n < r; n++)
      t[n].apply(e);
  }
  unapply(e) {
    for (var {
      transforms: t
    } = this, r = t.length, n = r - 1; n >= 0; n--)
      t[n].unapply(e);
  }
  // TODO: applyToPoint unused ... remove?
  applyToPoint(e) {
    for (var {
      transforms: t
    } = this, r = t.length, n = 0; n < r; n++)
      t[n].applyToPoint(e);
  }
}
vl.transformTypes = {
  translate: JO,
  rotate: eU,
  scale: tU,
  matrix: Ib,
  skewX: rU,
  skewY: iU
};
let xi = class eE {
  constructor(e, t) {
    var r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : !1;
    if (this.document = e, this.node = t, this.captureTextNodes = r, this.attributes = {}, this.styles = {}, this.stylesSpecificity = {}, this.animationFrozen = !1, this.animationFrozenValue = "", this.parent = null, this.children = [], !(!t || t.nodeType !== 1)) {
      if (Array.from(t.attributes).forEach((o) => {
        var A = jO(o.nodeName);
        this.attributes[A] = new yt(e, A, o.value);
      }), this.addStylesFromStyleDefinition(), this.getAttribute("style").hasValue()) {
        var n = this.getAttribute("style").getString().split(";").map((o) => o.trim());
        n.forEach((o) => {
          if (o) {
            var [A, l] = o.split(":").map((h) => h.trim());
            this.styles[A] = new yt(e, A, l);
          }
        });
      }
      var {
        definitions: s
      } = e, a = this.getAttribute("id");
      a.hasValue() && (s[a.getString()] || (s[a.getString()] = this)), Array.from(t.childNodes).forEach((o) => {
        if (o.nodeType === 1)
          this.addChild(o);
        else if (r && (o.nodeType === 3 || o.nodeType === 4)) {
          var A = e.createTextNode(o);
          A.getText().length > 0 && this.addChild(A);
        }
      });
    }
  }
  getAttribute(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !1, r = this.attributes[e];
    if (!r && t) {
      var n = new yt(this.document, e, "");
      return this.attributes[e] = n, n;
    }
    return r || yt.empty(this.document);
  }
  getHrefAttribute() {
    for (var e in this.attributes)
      if (e === "href" || e.endsWith(":href"))
        return this.attributes[e];
    return yt.empty(this.document);
  }
  getStyle(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !1, r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : !1, n = this.styles[e];
    if (n)
      return n;
    var s = this.getAttribute(e);
    if (s != null && s.hasValue())
      return this.styles[e] = s, s;
    if (!r) {
      var {
        parent: a
      } = this;
      if (a) {
        var o = a.getStyle(e);
        if (o != null && o.hasValue())
          return o;
      }
    }
    if (t) {
      var A = new yt(this.document, e, "");
      return this.styles[e] = A, A;
    }
    return n || yt.empty(this.document);
  }
  render(e) {
    if (!(this.getStyle("display").getString() === "none" || this.getStyle("visibility").getString() === "hidden")) {
      if (e.save(), this.getStyle("mask").hasValue()) {
        var t = this.getStyle("mask").getDefinition();
        t && (this.applyEffects(e), t.apply(e, this));
      } else if (this.getStyle("filter").getValue("none") !== "none") {
        var r = this.getStyle("filter").getDefinition();
        r && (this.applyEffects(e), r.apply(e, this));
      } else
        this.setContext(e), this.renderChildren(e), this.clearContext(e);
      e.restore();
    }
  }
  setContext(e) {
  }
  applyEffects(e) {
    var t = vl.fromElement(this.document, this);
    t && t.apply(e);
    var r = this.getStyle("clip-path", !1, !0);
    if (r.hasValue()) {
      var n = r.getDefinition();
      n && n.apply(e);
    }
  }
  clearContext(e) {
  }
  renderChildren(e) {
    this.children.forEach((t) => {
      t.render(e);
    });
  }
  addChild(e) {
    var t = e instanceof eE ? e : this.document.createElement(e);
    t.parent = this, eE.ignoreChildTypes.includes(t.type) || this.children.push(t);
  }
  matchesSelector(e) {
    var {
      node: t
    } = this;
    if (typeof t.matches == "function")
      return t.matches(e);
    var r = t.getAttribute("class");
    return !r || r === "" ? !1 : r.split(" ").some((n) => ".".concat(n) === e);
  }
  addStylesFromStyleDefinition() {
    var {
      styles: e,
      stylesSpecificity: t
    } = this.document;
    for (var r in e)
      if (!r.startsWith("@") && this.matchesSelector(r)) {
        var n = e[r], s = t[r];
        if (n)
          for (var a in n) {
            var o = this.stylesSpecificity[a];
            typeof o > "u" && (o = "000"), s >= o && (this.styles[a] = n[a], this.stylesSpecificity[a] = s);
          }
      }
  }
  removeStyles(e, t) {
    var r = t.reduce((n, s) => {
      var a = e.getStyle(s);
      if (!a.hasValue())
        return n;
      var o = a.getString();
      return a.setValue(""), [...n, [s, o]];
    }, []);
    return r;
  }
  restoreStyles(e, t) {
    t.forEach((r) => {
      var [n, s] = r;
      e.getStyle(n, !0).setValue(s);
    });
  }
};
xi.ignoreChildTypes = ["title"];
class nU extends xi {
  constructor(e, t, r) {
    super(e, t, r);
  }
}
function Mye(i) {
  var e = i.trim();
  return /^('|")/.test(e) ? e : '"'.concat(e, '"');
}
function Nye(i) {
  return typeof process > "u" ? i : i.trim().split(",").map(Mye).join(",");
}
function Pye(i) {
  if (!i)
    return "";
  var e = i.trim().toLowerCase();
  switch (e) {
    case "normal":
    case "italic":
    case "oblique":
    case "inherit":
    case "initial":
    case "unset":
      return e;
    default:
      return /^oblique\s+(-|)\d+deg$/.test(e) ? e : "";
  }
}
function Oye(i) {
  if (!i)
    return "";
  var e = i.trim().toLowerCase();
  switch (e) {
    case "normal":
    case "bold":
    case "lighter":
    case "bolder":
    case "inherit":
    case "initial":
    case "unset":
      return e;
    default:
      return /^[\d.]+$/.test(e) ? e : "";
  }
}
class Kn {
  constructor(e, t, r, n, s, a) {
    var o = a ? typeof a == "string" ? Kn.parse(a) : a : {};
    this.fontFamily = s || o.fontFamily, this.fontSize = n || o.fontSize, this.fontStyle = e || o.fontStyle, this.fontWeight = r || o.fontWeight, this.fontVariant = t || o.fontVariant;
  }
  static parse() {
    var e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "", t = arguments.length > 1 ? arguments[1] : void 0, r = "", n = "", s = "", a = "", o = "", A = Mh(e).trim().split(" "), l = {
      fontSize: !1,
      fontStyle: !1,
      fontWeight: !1,
      fontVariant: !1
    };
    return A.forEach((h) => {
      switch (!0) {
        case (!l.fontStyle && Kn.styles.includes(h)):
          h !== "inherit" && (r = h), l.fontStyle = !0;
          break;
        case (!l.fontVariant && Kn.variants.includes(h)):
          h !== "inherit" && (n = h), l.fontStyle = !0, l.fontVariant = !0;
          break;
        case (!l.fontWeight && Kn.weights.includes(h)):
          h !== "inherit" && (s = h), l.fontStyle = !0, l.fontVariant = !0, l.fontWeight = !0;
          break;
        case !l.fontSize:
          h !== "inherit" && ([a] = h.split("/")), l.fontStyle = !0, l.fontVariant = !0, l.fontWeight = !0, l.fontSize = !0;
          break;
        default:
          h !== "inherit" && (o += h);
      }
    }), new Kn(r, n, s, a, o, t);
  }
  toString() {
    return [
      Pye(this.fontStyle),
      this.fontVariant,
      Oye(this.fontWeight),
      this.fontSize,
      // Wrap fontFamily only on nodejs and only for canvas.ctx
      Nye(this.fontFamily)
    ].join(" ").trim();
  }
}
Kn.styles = "normal|italic|oblique|inherit";
Kn.variants = "normal|small-caps|inherit";
Kn.weights = "normal|bold|bolder|lighter|100|200|300|400|500|600|700|800|900|inherit";
class ra {
  constructor() {
    var e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : Number.NaN, t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : Number.NaN, r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : Number.NaN, n = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : Number.NaN;
    this.x1 = e, this.y1 = t, this.x2 = r, this.y2 = n, this.addPoint(e, t), this.addPoint(r, n);
  }
  get x() {
    return this.x1;
  }
  get y() {
    return this.y1;
  }
  get width() {
    return this.x2 - this.x1;
  }
  get height() {
    return this.y2 - this.y1;
  }
  addPoint(e, t) {
    typeof e < "u" && ((isNaN(this.x1) || isNaN(this.x2)) && (this.x1 = e, this.x2 = e), e < this.x1 && (this.x1 = e), e > this.x2 && (this.x2 = e)), typeof t < "u" && ((isNaN(this.y1) || isNaN(this.y2)) && (this.y1 = t, this.y2 = t), t < this.y1 && (this.y1 = t), t > this.y2 && (this.y2 = t));
  }
  addX(e) {
    this.addPoint(e, null);
  }
  addY(e) {
    this.addPoint(null, e);
  }
  addBoundingBox(e) {
    if (e) {
      var {
        x1: t,
        y1: r,
        x2: n,
        y2: s
      } = e;
      this.addPoint(t, r), this.addPoint(n, s);
    }
  }
  sumCubic(e, t, r, n, s) {
    return Math.pow(1 - e, 3) * t + 3 * Math.pow(1 - e, 2) * e * r + 3 * (1 - e) * Math.pow(e, 2) * n + Math.pow(e, 3) * s;
  }
  bezierCurveAdd(e, t, r, n, s) {
    var a = 6 * t - 12 * r + 6 * n, o = -3 * t + 9 * r - 9 * n + 3 * s, A = 3 * r - 3 * t;
    if (o === 0) {
      if (a === 0)
        return;
      var l = -A / a;
      0 < l && l < 1 && (e ? this.addX(this.sumCubic(l, t, r, n, s)) : this.addY(this.sumCubic(l, t, r, n, s)));
      return;
    }
    var h = Math.pow(a, 2) - 4 * A * o;
    if (!(h < 0)) {
      var c = (-a + Math.sqrt(h)) / (2 * o);
      0 < c && c < 1 && (e ? this.addX(this.sumCubic(c, t, r, n, s)) : this.addY(this.sumCubic(c, t, r, n, s)));
      var u = (-a - Math.sqrt(h)) / (2 * o);
      0 < u && u < 1 && (e ? this.addX(this.sumCubic(u, t, r, n, s)) : this.addY(this.sumCubic(u, t, r, n, s)));
    }
  }
  // from http://blog.hackers-cafe.net/2009/06/how-to-calculate-bezier-curves-bounding.html
  addBezierCurve(e, t, r, n, s, a, o, A) {
    this.addPoint(e, t), this.addPoint(o, A), this.bezierCurveAdd(!0, e, r, s, o), this.bezierCurveAdd(!1, t, n, a, A);
  }
  addQuadraticCurve(e, t, r, n, s, a) {
    var o = e + 0.6666666666666666 * (r - e), A = t + 2 / 3 * (n - t), l = o + 1 / 3 * (s - e), h = A + 1 / 3 * (a - t);
    this.addBezierCurve(e, t, o, l, A, h, s, a);
  }
  isPointInBox(e, t) {
    var {
      x1: r,
      y1: n,
      x2: s,
      y2: a
    } = this;
    return r <= e && e <= s && n <= t && t <= a;
  }
}
class $t extends Ie {
  constructor(e) {
    super(e.replace(/([+\-.])\s+/gm, "$1").replace(/[^MmZzLlHhVvCcSsQqTtAae\d\s.,+-].*/g, "")), this.control = null, this.start = null, this.current = null, this.command = null, this.commands = this.commands, this.i = -1, this.previousCommand = null, this.points = [], this.angles = [];
  }
  reset() {
    this.i = -1, this.command = null, this.previousCommand = null, this.start = new Ti(0, 0), this.control = new Ti(0, 0), this.current = new Ti(0, 0), this.points = [], this.angles = [];
  }
  isEnd() {
    var {
      i: e,
      commands: t
    } = this;
    return e >= t.length - 1;
  }
  next() {
    var e = this.commands[++this.i];
    return this.previousCommand = this.command, this.command = e, e;
  }
  getPoint() {
    var e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "x", t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "y", r = new Ti(this.command[e], this.command[t]);
    return this.makeAbsolute(r);
  }
  getAsControlPoint(e, t) {
    var r = this.getPoint(e, t);
    return this.control = r, r;
  }
  getAsCurrentPoint(e, t) {
    var r = this.getPoint(e, t);
    return this.current = r, r;
  }
  getReflectedControlPoint() {
    var e = this.previousCommand.type;
    if (e !== Ie.CURVE_TO && e !== Ie.SMOOTH_CURVE_TO && e !== Ie.QUAD_TO && e !== Ie.SMOOTH_QUAD_TO)
      return this.current;
    var {
      current: {
        x: t,
        y: r
      },
      control: {
        x: n,
        y: s
      }
    } = this, a = new Ti(2 * t - n, 2 * r - s);
    return a;
  }
  makeAbsolute(e) {
    if (this.command.relative) {
      var {
        x: t,
        y: r
      } = this.current;
      e.x += t, e.y += r;
    }
    return e;
  }
  addMarker(e, t, r) {
    var {
      points: n,
      angles: s
    } = this;
    r && s.length > 0 && !s[s.length - 1] && (s[s.length - 1] = n[n.length - 1].angleTo(r)), this.addMarkerAngle(e, t ? t.angleTo(e) : null);
  }
  addMarkerAngle(e, t) {
    this.points.push(e), this.angles.push(t);
  }
  getMarkerPoints() {
    return this.points;
  }
  getMarkerAngles() {
    for (var {
      angles: e
    } = this, t = e.length, r = 0; r < t; r++)
      if (!e[r]) {
        for (var n = r + 1; n < t; n++)
          if (e[n]) {
            e[r] = e[n];
            break;
          }
      }
    return e;
  }
}
class xl extends xi {
  constructor() {
    super(...arguments), this.modifiedEmSizeStack = !1;
  }
  calculateOpacity() {
    for (var e = 1, t = this; t; ) {
      var r = t.getStyle("opacity", !1, !0);
      r.hasValue(!0) && (e *= r.getNumber()), t = t.parent;
    }
    return e;
  }
  setContext(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !1;
    if (!t) {
      var r = this.getStyle("fill"), n = this.getStyle("fill-opacity"), s = this.getStyle("stroke"), a = this.getStyle("stroke-opacity");
      if (r.isUrlDefinition()) {
        var o = r.getFillStyleDefinition(this, n);
        o && (e.fillStyle = o);
      } else if (r.hasValue()) {
        r.getString() === "currentColor" && r.setValue(this.getStyle("color").getColor());
        var A = r.getColor();
        A !== "inherit" && (e.fillStyle = A === "none" ? "rgba(0,0,0,0)" : A);
      }
      if (n.hasValue()) {
        var l = new yt(this.document, "fill", e.fillStyle).addOpacity(n).getColor();
        e.fillStyle = l;
      }
      if (s.isUrlDefinition()) {
        var h = s.getFillStyleDefinition(this, a);
        h && (e.strokeStyle = h);
      } else if (s.hasValue()) {
        s.getString() === "currentColor" && s.setValue(this.getStyle("color").getColor());
        var c = s.getString();
        c !== "inherit" && (e.strokeStyle = c === "none" ? "rgba(0,0,0,0)" : c);
      }
      if (a.hasValue()) {
        var u = new yt(this.document, "stroke", e.strokeStyle).addOpacity(a).getString();
        e.strokeStyle = u;
      }
      var f = this.getStyle("stroke-width");
      if (f.hasValue()) {
        var g = f.getPixels();
        e.lineWidth = g || ch;
      }
      var p = this.getStyle("stroke-linecap"), y = this.getStyle("stroke-linejoin"), v = this.getStyle("stroke-miterlimit"), w = this.getStyle("stroke-dasharray"), C = this.getStyle("stroke-dashoffset");
      if (p.hasValue() && (e.lineCap = p.getString()), y.hasValue() && (e.lineJoin = y.getString()), v.hasValue() && (e.miterLimit = v.getNumber()), w.hasValue() && w.getString() !== "none") {
        var E = ps(w.getString());
        typeof e.setLineDash < "u" ? e.setLineDash(E) : typeof e.webkitLineDash < "u" ? e.webkitLineDash = E : typeof e.mozDash < "u" && !(E.length === 1 && E[0] === 0) && (e.mozDash = E);
        var S = C.getPixels();
        typeof e.lineDashOffset < "u" ? e.lineDashOffset = S : typeof e.webkitLineDashOffset < "u" ? e.webkitLineDashOffset = S : typeof e.mozDashOffset < "u" && (e.mozDashOffset = S);
      }
    }
    if (this.modifiedEmSizeStack = !1, typeof e.font < "u") {
      var M = this.getStyle("font"), T = this.getStyle("font-style"), F = this.getStyle("font-variant"), k = this.getStyle("font-weight"), $ = this.getStyle("font-size"), I = this.getStyle("font-family"), L = new Kn(T.getString(), F.getString(), k.getString(), $.hasValue() ? "".concat($.getPixels(!0), "px") : "", I.getString(), Kn.parse(M.getString(), e.font));
      T.setValue(L.fontStyle), F.setValue(L.fontVariant), k.setValue(L.fontWeight), $.setValue(L.fontSize), I.setValue(L.fontFamily), e.font = L.toString(), $.isPixels() && (this.document.emSize = $.getPixels(), this.modifiedEmSizeStack = !0);
    }
    t || (this.applyEffects(e), e.globalAlpha = this.calculateOpacity());
  }
  clearContext(e) {
    super.clearContext(e), this.modifiedEmSizeStack && this.document.popEmSize();
  }
}
class Or extends xl {
  constructor(e, t, r) {
    super(e, t, r), this.type = "path", this.pathParser = null, this.pathParser = new $t(this.getAttribute("d").getString());
  }
  path(e) {
    var {
      pathParser: t
    } = this, r = new ra();
    for (t.reset(), e && e.beginPath(); !t.isEnd(); )
      switch (t.next().type) {
        case $t.MOVE_TO:
          this.pathM(e, r);
          break;
        case $t.LINE_TO:
          this.pathL(e, r);
          break;
        case $t.HORIZ_LINE_TO:
          this.pathH(e, r);
          break;
        case $t.VERT_LINE_TO:
          this.pathV(e, r);
          break;
        case $t.CURVE_TO:
          this.pathC(e, r);
          break;
        case $t.SMOOTH_CURVE_TO:
          this.pathS(e, r);
          break;
        case $t.QUAD_TO:
          this.pathQ(e, r);
          break;
        case $t.SMOOTH_QUAD_TO:
          this.pathT(e, r);
          break;
        case $t.ARC:
          this.pathA(e, r);
          break;
        case $t.CLOSE_PATH:
          this.pathZ(e, r);
          break;
      }
    return r;
  }
  getBoundingBox(e) {
    return this.path();
  }
  getMarkers() {
    var {
      pathParser: e
    } = this, t = e.getMarkerPoints(), r = e.getMarkerAngles(), n = t.map((s, a) => [s, r[a]]);
    return n;
  }
  renderChildren(e) {
    this.path(e), this.document.screen.mouse.checkPath(this, e);
    var t = this.getStyle("fill-rule");
    e.fillStyle !== "" && (t.getString("inherit") !== "inherit" ? e.fill(t.getString()) : e.fill()), e.strokeStyle !== "" && (this.getAttribute("vector-effect").getString() === "non-scaling-stroke" ? (e.save(), e.setTransform(1, 0, 0, 1, 0, 0), e.stroke(), e.restore()) : e.stroke());
    var r = this.getMarkers();
    if (r) {
      var n = r.length - 1, s = this.getStyle("marker-start"), a = this.getStyle("marker-mid"), o = this.getStyle("marker-end");
      if (s.isUrlDefinition()) {
        var A = s.getDefinition(), [l, h] = r[0];
        A.render(e, l, h);
      }
      if (a.isUrlDefinition())
        for (var c = a.getDefinition(), u = 1; u < n; u++) {
          var [f, g] = r[u];
          c.render(e, f, g);
        }
      if (o.isUrlDefinition()) {
        var p = o.getDefinition(), [y, v] = r[n];
        p.render(e, y, v);
      }
    }
  }
  static pathM(e) {
    var t = e.getAsCurrentPoint();
    return e.start = e.current, {
      point: t
    };
  }
  pathM(e, t) {
    var {
      pathParser: r
    } = this, {
      point: n
    } = Or.pathM(r), {
      x: s,
      y: a
    } = n;
    r.addMarker(n), t.addPoint(s, a), e && e.moveTo(s, a);
  }
  static pathL(e) {
    var {
      current: t
    } = e, r = e.getAsCurrentPoint();
    return {
      current: t,
      point: r
    };
  }
  pathL(e, t) {
    var {
      pathParser: r
    } = this, {
      current: n,
      point: s
    } = Or.pathL(r), {
      x: a,
      y: o
    } = s;
    r.addMarker(s, n), t.addPoint(a, o), e && e.lineTo(a, o);
  }
  static pathH(e) {
    var {
      current: t,
      command: r
    } = e, n = new Ti((r.relative ? t.x : 0) + r.x, t.y);
    return e.current = n, {
      current: t,
      point: n
    };
  }
  pathH(e, t) {
    var {
      pathParser: r
    } = this, {
      current: n,
      point: s
    } = Or.pathH(r), {
      x: a,
      y: o
    } = s;
    r.addMarker(s, n), t.addPoint(a, o), e && e.lineTo(a, o);
  }
  static pathV(e) {
    var {
      current: t,
      command: r
    } = e, n = new Ti(t.x, (r.relative ? t.y : 0) + r.y);
    return e.current = n, {
      current: t,
      point: n
    };
  }
  pathV(e, t) {
    var {
      pathParser: r
    } = this, {
      current: n,
      point: s
    } = Or.pathV(r), {
      x: a,
      y: o
    } = s;
    r.addMarker(s, n), t.addPoint(a, o), e && e.lineTo(a, o);
  }
  static pathC(e) {
    var {
      current: t
    } = e, r = e.getPoint("x1", "y1"), n = e.getAsControlPoint("x2", "y2"), s = e.getAsCurrentPoint();
    return {
      current: t,
      point: r,
      controlPoint: n,
      currentPoint: s
    };
  }
  pathC(e, t) {
    var {
      pathParser: r
    } = this, {
      current: n,
      point: s,
      controlPoint: a,
      currentPoint: o
    } = Or.pathC(r);
    r.addMarker(o, a, s), t.addBezierCurve(n.x, n.y, s.x, s.y, a.x, a.y, o.x, o.y), e && e.bezierCurveTo(s.x, s.y, a.x, a.y, o.x, o.y);
  }
  static pathS(e) {
    var {
      current: t
    } = e, r = e.getReflectedControlPoint(), n = e.getAsControlPoint("x2", "y2"), s = e.getAsCurrentPoint();
    return {
      current: t,
      point: r,
      controlPoint: n,
      currentPoint: s
    };
  }
  pathS(e, t) {
    var {
      pathParser: r
    } = this, {
      current: n,
      point: s,
      controlPoint: a,
      currentPoint: o
    } = Or.pathS(r);
    r.addMarker(o, a, s), t.addBezierCurve(n.x, n.y, s.x, s.y, a.x, a.y, o.x, o.y), e && e.bezierCurveTo(s.x, s.y, a.x, a.y, o.x, o.y);
  }
  static pathQ(e) {
    var {
      current: t
    } = e, r = e.getAsControlPoint("x1", "y1"), n = e.getAsCurrentPoint();
    return {
      current: t,
      controlPoint: r,
      currentPoint: n
    };
  }
  pathQ(e, t) {
    var {
      pathParser: r
    } = this, {
      current: n,
      controlPoint: s,
      currentPoint: a
    } = Or.pathQ(r);
    r.addMarker(a, s, s), t.addQuadraticCurve(n.x, n.y, s.x, s.y, a.x, a.y), e && e.quadraticCurveTo(s.x, s.y, a.x, a.y);
  }
  static pathT(e) {
    var {
      current: t
    } = e, r = e.getReflectedControlPoint();
    e.control = r;
    var n = e.getAsCurrentPoint();
    return {
      current: t,
      controlPoint: r,
      currentPoint: n
    };
  }
  pathT(e, t) {
    var {
      pathParser: r
    } = this, {
      current: n,
      controlPoint: s,
      currentPoint: a
    } = Or.pathT(r);
    r.addMarker(a, s, s), t.addQuadraticCurve(n.x, n.y, s.x, s.y, a.x, a.y), e && e.quadraticCurveTo(s.x, s.y, a.x, a.y);
  }
  static pathA(e) {
    var {
      current: t,
      command: r
    } = e, {
      rX: n,
      rY: s,
      xRot: a,
      lArcFlag: o,
      sweepFlag: A
    } = r, l = a * (Math.PI / 180), h = e.getAsCurrentPoint(), c = new Ti(Math.cos(l) * (t.x - h.x) / 2 + Math.sin(l) * (t.y - h.y) / 2, -Math.sin(l) * (t.x - h.x) / 2 + Math.cos(l) * (t.y - h.y) / 2), u = Math.pow(c.x, 2) / Math.pow(n, 2) + Math.pow(c.y, 2) / Math.pow(s, 2);
    u > 1 && (n *= Math.sqrt(u), s *= Math.sqrt(u));
    var f = (o === A ? -1 : 1) * Math.sqrt((Math.pow(n, 2) * Math.pow(s, 2) - Math.pow(n, 2) * Math.pow(c.y, 2) - Math.pow(s, 2) * Math.pow(c.x, 2)) / (Math.pow(n, 2) * Math.pow(c.y, 2) + Math.pow(s, 2) * Math.pow(c.x, 2)));
    isNaN(f) && (f = 0);
    var g = new Ti(f * n * c.y / s, f * -s * c.x / n), p = new Ti((t.x + h.x) / 2 + Math.cos(l) * g.x - Math.sin(l) * g.y, (t.y + h.y) / 2 + Math.sin(l) * g.x + Math.cos(l) * g.y), y = jC([1, 0], [(c.x - g.x) / n, (c.y - g.y) / s]), v = [(c.x - g.x) / n, (c.y - g.y) / s], w = [(-c.x - g.x) / n, (-c.y - g.y) / s], C = jC(v, w);
    return Tv(v, w) <= -1 && (C = Math.PI), Tv(v, w) >= 1 && (C = 0), {
      currentPoint: h,
      rX: n,
      rY: s,
      sweepFlag: A,
      xAxisRotation: l,
      centp: p,
      a1: y,
      ad: C
    };
  }
  pathA(e, t) {
    var {
      pathParser: r
    } = this, {
      currentPoint: n,
      rX: s,
      rY: a,
      sweepFlag: o,
      xAxisRotation: A,
      centp: l,
      a1: h,
      ad: c
    } = Or.pathA(r), u = 1 - o ? 1 : -1, f = h + u * (c / 2), g = new Ti(l.x + s * Math.cos(f), l.y + a * Math.sin(f));
    if (r.addMarkerAngle(g, f - u * Math.PI / 2), r.addMarkerAngle(n, f - u * Math.PI), t.addPoint(n.x, n.y), e && !isNaN(h) && !isNaN(c)) {
      var p = s > a ? s : a, y = s > a ? 1 : s / a, v = s > a ? a / s : 1;
      e.translate(l.x, l.y), e.rotate(A), e.scale(y, v), e.arc(0, 0, p, h, h + c, !!(1 - o)), e.scale(1 / y, 1 / v), e.rotate(-A), e.translate(-l.x, -l.y);
    }
  }
  static pathZ(e) {
    e.current = e.start;
  }
  pathZ(e, t) {
    Or.pathZ(this.pathParser), e && t.x1 !== t.x2 && t.y1 !== t.y2 && e.closePath();
  }
}
class Mb extends Or {
  constructor(e, t, r) {
    super(e, t, r), this.type = "glyph", this.horizAdvX = this.getAttribute("horiz-adv-x").getNumber(), this.unicode = this.getAttribute("unicode").getString(), this.arabicForm = this.getAttribute("arabic-form").getString();
  }
}
class Cl extends xl {
  constructor(e, t, r) {
    super(e, t, new.target === Cl ? !0 : r), this.type = "text", this.x = 0, this.y = 0, this.measureCache = -1;
  }
  setContext(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !1;
    super.setContext(e, t);
    var r = this.getStyle("dominant-baseline").getTextBaseline() || this.getStyle("alignment-baseline").getTextBaseline();
    r && (e.textBaseline = r);
  }
  initializeCoordinates(e) {
    this.x = this.getAttribute("x").getPixels("x"), this.y = this.getAttribute("y").getPixels("y");
    var t = this.getAttribute("dx"), r = this.getAttribute("dy");
    t.hasValue() && (this.x += t.getPixels("x")), r.hasValue() && (this.y += r.getPixels("y")), this.x += this.getAnchorDelta(e, this, 0);
  }
  getBoundingBox(e) {
    if (this.type !== "text")
      return this.getTElementBoundingBox(e);
    this.initializeCoordinates(e);
    var t = null;
    return this.children.forEach((r, n) => {
      var s = this.getChildBoundingBox(e, this, this, n);
      t ? t.addBoundingBox(s) : t = s;
    }), t;
  }
  getFontSize() {
    var {
      document: e,
      parent: t
    } = this, r = Kn.parse(e.ctx.font).fontSize, n = t.getStyle("font-size").getNumber(r);
    return n;
  }
  getTElementBoundingBox(e) {
    var t = this.getFontSize();
    return new ra(this.x, this.y - t, this.x + this.measureText(e), this.y);
  }
  getGlyph(e, t, r) {
    var n = t[r], s = null;
    if (e.isArabic) {
      var a = t.length, o = t[r - 1], A = t[r + 1], l = "isolated";
      if ((r === 0 || o === " ") && r < a - 2 && A !== " " && (l = "terminal"), r > 0 && o !== " " && r < a - 2 && A !== " " && (l = "medial"), r > 0 && o !== " " && (r === a - 1 || A === " ") && (l = "initial"), typeof e.glyphs[n] < "u") {
        var h = e.glyphs[n];
        s = h instanceof Mb ? h : h[l];
      }
    } else
      s = e.glyphs[n];
    return s || (s = e.missingGlyph), s;
  }
  getText() {
    return "";
  }
  getTextFromNode(e) {
    var t = e || this.node, r = Array.from(t.parentNode.childNodes), n = r.indexOf(t), s = r.length - 1, a = Mh(
      // textNode.value
      // || textNode.text
      t.textContent || ""
    );
    return n === 0 && (a = VO(a)), n === s && (a = KO(a)), a;
  }
  renderChildren(e) {
    if (this.type !== "text") {
      this.renderTElementChildren(e);
      return;
    }
    this.initializeCoordinates(e), this.children.forEach((r, n) => {
      this.renderChild(e, this, this, n);
    });
    var {
      mouse: t
    } = this.document.screen;
    t.isWorking() && t.checkBoundingBox(this, this.getBoundingBox(e));
  }
  renderTElementChildren(e) {
    var {
      document: t,
      parent: r
    } = this, n = this.getText(), s = r.getStyle("font-family").getDefinition();
    if (s) {
      for (var {
        unitsPerEm: a
      } = s.fontFace, o = Kn.parse(t.ctx.font), A = r.getStyle("font-size").getNumber(o.fontSize), l = r.getStyle("font-style").getString(o.fontStyle), h = A / a, c = s.isRTL ? n.split("").reverse().join("") : n, u = ps(r.getAttribute("dx").getString()), f = c.length, g = 0; g < f; g++) {
        var p = this.getGlyph(s, c, g);
        e.translate(this.x, this.y), e.scale(h, -h);
        var y = e.lineWidth;
        e.lineWidth = e.lineWidth * a / A, l === "italic" && e.transform(1, 0, 0.4, 1, 0, 0), p.render(e), l === "italic" && e.transform(1, 0, -0.4, 1, 0, 0), e.lineWidth = y, e.scale(1 / h, -1 / h), e.translate(-this.x, -this.y), this.x += A * (p.horizAdvX || s.horizAdvX) / a, typeof u[g] < "u" && !isNaN(u[g]) && (this.x += u[g]);
      }
      return;
    }
    var {
      x: v,
      y: w
    } = this;
    e.fillStyle && e.fillText(n, v, w), e.strokeStyle && e.strokeText(n, v, w);
  }
  getAnchorDelta(e, t, r) {
    var n = this.getStyle("text-anchor").getString("start");
    if (n !== "start") {
      for (var {
        children: s
      } = t, a = s.length, o = null, A = 0, l = r; l < a && (o = s[l], !(l > r && o.getAttribute("x").hasValue() || o.getAttribute("text-anchor").hasValue())); l++)
        A += o.measureTextRecursive(e);
      return -1 * (n === "end" ? A : A / 2);
    }
    return 0;
  }
  adjustChildCoordinates(e, t, r, n) {
    var s = r.children[n];
    if (typeof s.measureText != "function")
      return s;
    e.save(), s.setContext(e, !0);
    var a = s.getAttribute("x"), o = s.getAttribute("y"), A = s.getAttribute("dx"), l = s.getAttribute("dy"), h = s.getAttribute("text-anchor").getString("start");
    if (n === 0 && s.type !== "textNode" && (a.hasValue() || a.setValue(t.getAttribute("x").getValue("0")), o.hasValue() || o.setValue(t.getAttribute("y").getValue("0")), A.hasValue() || A.setValue(t.getAttribute("dx").getValue("0")), l.hasValue() || l.setValue(t.getAttribute("dy").getValue("0"))), a.hasValue()) {
      if (s.x = a.getPixels("x") + t.getAnchorDelta(e, r, n), h !== "start") {
        var c = s.measureTextRecursive(e);
        s.x += -1 * (h === "end" ? c : c / 2);
      }
      A.hasValue() && (s.x += A.getPixels("x"));
    } else {
      if (h !== "start") {
        var u = s.measureTextRecursive(e);
        t.x += -1 * (h === "end" ? u : u / 2);
      }
      A.hasValue() && (t.x += A.getPixels("x")), s.x = t.x;
    }
    return t.x = s.x + s.measureText(e), o.hasValue() ? (s.y = o.getPixels("y"), l.hasValue() && (s.y += l.getPixels("y"))) : (l.hasValue() && (t.y += l.getPixels("y")), s.y = t.y), t.y = s.y, s.clearContext(e), e.restore(), s;
  }
  getChildBoundingBox(e, t, r, n) {
    var s = this.adjustChildCoordinates(e, t, r, n);
    if (typeof s.getBoundingBox != "function")
      return null;
    var a = s.getBoundingBox(e);
    return a ? (s.children.forEach((o, A) => {
      var l = t.getChildBoundingBox(e, t, s, A);
      a.addBoundingBox(l);
    }), a) : null;
  }
  renderChild(e, t, r, n) {
    var s = this.adjustChildCoordinates(e, t, r, n);
    s.render(e), s.children.forEach((a, o) => {
      t.renderChild(e, t, s, o);
    });
  }
  measureTextRecursive(e) {
    var t = this.children.reduce((r, n) => r + n.measureTextRecursive(e), this.measureText(e));
    return t;
  }
  measureText(e) {
    var {
      measureCache: t
    } = this;
    if (~t)
      return t;
    var r = this.getText(), n = this.measureTargetText(e, r);
    return this.measureCache = n, n;
  }
  measureTargetText(e, t) {
    if (!t.length)
      return 0;
    var {
      parent: r
    } = this, n = r.getStyle("font-family").getDefinition();
    if (n) {
      for (var s = this.getFontSize(), a = n.isRTL ? t.split("").reverse().join("") : t, o = ps(r.getAttribute("dx").getString()), A = a.length, l = 0, h = 0; h < A; h++) {
        var c = this.getGlyph(n, a, h);
        l += (c.horizAdvX || n.horizAdvX) * s / n.fontFace.unitsPerEm, typeof o[h] < "u" && !isNaN(o[h]) && (l += o[h]);
      }
      return l;
    }
    if (!e.measureText)
      return t.length * 10;
    e.save(), this.setContext(e, !0);
    var {
      width: u
    } = e.measureText(t);
    return this.clearContext(e), e.restore(), u;
  }
}
class Og extends Cl {
  constructor(e, t, r) {
    super(e, t, new.target === Og ? !0 : r), this.type = "tspan", this.text = this.children.length > 0 ? "" : this.getTextFromNode();
  }
  getText() {
    return this.text;
  }
}
class Uye extends Og {
  constructor() {
    super(...arguments), this.type = "textNode";
  }
}
class Xu extends xl {
  constructor() {
    super(...arguments), this.type = "svg", this.root = !1;
  }
  setContext(e) {
    var t, {
      document: r
    } = this, {
      screen: n,
      window: s
    } = r, a = e.canvas;
    if (n.setDefaults(e), a.style && typeof e.font < "u" && s && typeof s.getComputedStyle < "u") {
      e.font = s.getComputedStyle(a).getPropertyValue("font");
      var o = new yt(r, "fontSize", Kn.parse(e.font).fontSize);
      o.hasValue() && (r.rootEmSize = o.getPixels("y"), r.emSize = r.rootEmSize);
    }
    this.getAttribute("x").hasValue() || this.getAttribute("x", !0).setValue(0), this.getAttribute("y").hasValue() || this.getAttribute("y", !0).setValue(0);
    var {
      width: A,
      height: l
    } = n.viewPort;
    this.getStyle("width").hasValue() || this.getStyle("width", !0).setValue("100%"), this.getStyle("height").hasValue() || this.getStyle("height", !0).setValue("100%"), this.getStyle("color").hasValue() || this.getStyle("color", !0).setValue("black");
    var h = this.getAttribute("refX"), c = this.getAttribute("refY"), u = this.getAttribute("viewBox"), f = u.hasValue() ? ps(u.getString()) : null, g = !this.root && this.getStyle("overflow").getValue("hidden") !== "visible", p = 0, y = 0, v = 0, w = 0;
    f && (p = f[0], y = f[1]), this.root || (A = this.getStyle("width").getPixels("x"), l = this.getStyle("height").getPixels("y"), this.type === "marker" && (v = p, w = y, p = 0, y = 0)), n.viewPort.setCurrent(A, l), this.node && (!this.parent || ((t = this.node.parentNode) === null || t === void 0 ? void 0 : t.nodeName) === "foreignObject") && this.getStyle("transform", !1, !0).hasValue() && !this.getStyle("transform-origin", !1, !0).hasValue() && this.getStyle("transform-origin", !0, !0).setValue("50% 50%"), super.setContext(e), e.translate(this.getAttribute("x").getPixels("x"), this.getAttribute("y").getPixels("y")), f && (A = f[2], l = f[3]), r.setViewBox({
      ctx: e,
      aspectRatio: this.getAttribute("preserveAspectRatio").getString(),
      width: n.viewPort.width,
      desiredWidth: A,
      height: n.viewPort.height,
      desiredHeight: l,
      minX: p,
      minY: y,
      refX: h.getValue(),
      refY: c.getValue(),
      clip: g,
      clipX: v,
      clipY: w
    }), f && (n.viewPort.removeCurrent(), n.viewPort.setCurrent(A, l));
  }
  clearContext(e) {
    super.clearContext(e), this.document.screen.viewPort.removeCurrent();
  }
  /**
   * Resize SVG to fit in given size.
   * @param width
   * @param height
   * @param preserveAspectRatio
   */
  resize(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : e, r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : !1, n = this.getAttribute("width", !0), s = this.getAttribute("height", !0), a = this.getAttribute("viewBox"), o = this.getAttribute("style"), A = n.getNumber(0), l = s.getNumber(0);
    if (r)
      if (typeof r == "string")
        this.getAttribute("preserveAspectRatio", !0).setValue(r);
      else {
        var h = this.getAttribute("preserveAspectRatio");
        h.hasValue() && h.setValue(h.getString().replace(/^\s*(\S.*\S)\s*$/, "$1"));
      }
    if (n.setValue(e), s.setValue(t), a.hasValue() || a.setValue("0 0 ".concat(A || e, " ").concat(l || t)), o.hasValue()) {
      var c = this.getStyle("width"), u = this.getStyle("height");
      c.hasValue() && c.setValue("".concat(e, "px")), u.hasValue() && u.setValue("".concat(t, "px"));
    }
  }
}
class Nb extends Or {
  constructor() {
    super(...arguments), this.type = "rect";
  }
  path(e) {
    var t = this.getAttribute("x").getPixels("x"), r = this.getAttribute("y").getPixels("y"), n = this.getStyle("width", !1, !0).getPixels("x"), s = this.getStyle("height", !1, !0).getPixels("y"), a = this.getAttribute("rx"), o = this.getAttribute("ry"), A = a.getPixels("x"), l = o.getPixels("y");
    if (a.hasValue() && !o.hasValue() && (l = A), o.hasValue() && !a.hasValue() && (A = l), A = Math.min(A, n / 2), l = Math.min(l, s / 2), e) {
      var h = 4 * ((Math.sqrt(2) - 1) / 3);
      e.beginPath(), s > 0 && n > 0 && (e.moveTo(t + A, r), e.lineTo(t + n - A, r), e.bezierCurveTo(t + n - A + h * A, r, t + n, r + l - h * l, t + n, r + l), e.lineTo(t + n, r + s - l), e.bezierCurveTo(t + n, r + s - l + h * l, t + n - A + h * A, r + s, t + n - A, r + s), e.lineTo(t + A, r + s), e.bezierCurveTo(t + A - h * A, r + s, t, r + s - l + h * l, t, r + s - l), e.lineTo(t, r + l), e.bezierCurveTo(t, r + l - h * l, t + A - h * A, r, t + A, r), e.closePath());
    }
    return new ra(t, r, t + n, r + s);
  }
  getMarkers() {
    return null;
  }
}
class sU extends Or {
  constructor() {
    super(...arguments), this.type = "circle";
  }
  path(e) {
    var t = this.getAttribute("cx").getPixels("x"), r = this.getAttribute("cy").getPixels("y"), n = this.getAttribute("r").getPixels();
    return e && n > 0 && (e.beginPath(), e.arc(t, r, n, 0, Math.PI * 2, !1), e.closePath()), new ra(t - n, r - n, t + n, r + n);
  }
  getMarkers() {
    return null;
  }
}
class aU extends Or {
  constructor() {
    super(...arguments), this.type = "ellipse";
  }
  path(e) {
    var t = 4 * ((Math.sqrt(2) - 1) / 3), r = this.getAttribute("rx").getPixels("x"), n = this.getAttribute("ry").getPixels("y"), s = this.getAttribute("cx").getPixels("x"), a = this.getAttribute("cy").getPixels("y");
    return e && r > 0 && n > 0 && (e.beginPath(), e.moveTo(s + r, a), e.bezierCurveTo(s + r, a + t * n, s + t * r, a + n, s, a + n), e.bezierCurveTo(s - t * r, a + n, s - r, a + t * n, s - r, a), e.bezierCurveTo(s - r, a - t * n, s - t * r, a - n, s, a - n), e.bezierCurveTo(s + t * r, a - n, s + r, a - t * n, s + r, a), e.closePath()), new ra(s - r, a - n, s + r, a + n);
  }
  getMarkers() {
    return null;
  }
}
class oU extends Or {
  constructor() {
    super(...arguments), this.type = "line";
  }
  getPoints() {
    return [new Ti(this.getAttribute("x1").getPixels("x"), this.getAttribute("y1").getPixels("y")), new Ti(this.getAttribute("x2").getPixels("x"), this.getAttribute("y2").getPixels("y"))];
  }
  path(e) {
    var [{
      x: t,
      y: r
    }, {
      x: n,
      y: s
    }] = this.getPoints();
    return e && (e.beginPath(), e.moveTo(t, r), e.lineTo(n, s)), new ra(t, r, n, s);
  }
  getMarkers() {
    var [e, t] = this.getPoints(), r = e.angleTo(t);
    return [[e, r], [t, r]];
  }
}
class Pb extends Or {
  constructor(e, t, r) {
    super(e, t, r), this.type = "polyline", this.points = [], this.points = Ti.parsePath(this.getAttribute("points").getString());
  }
  path(e) {
    var {
      points: t
    } = this, [{
      x: r,
      y: n
    }] = t, s = new ra(r, n);
    return e && (e.beginPath(), e.moveTo(r, n)), t.forEach((a) => {
      var {
        x: o,
        y: A
      } = a;
      s.addPoint(o, A), e && e.lineTo(o, A);
    }), s;
  }
  getMarkers() {
    var {
      points: e
    } = this, t = e.length - 1, r = [];
    return e.forEach((n, s) => {
      s !== t && r.push([n, n.angleTo(e[s + 1])]);
    }), r.length > 0 && r.push([e[e.length - 1], r[r.length - 1][1]]), r;
  }
}
class AU extends Pb {
  constructor() {
    super(...arguments), this.type = "polygon";
  }
  path(e) {
    var t = super.path(e), [{
      x: r,
      y: n
    }] = this.points;
    return e && (e.lineTo(r, n), e.closePath()), t;
  }
}
class lU extends xi {
  constructor() {
    super(...arguments), this.type = "pattern";
  }
  createPattern(e, t, r) {
    var n = this.getStyle("width").getPixels("x", !0), s = this.getStyle("height").getPixels("y", !0), a = new Xu(this.document, null);
    a.attributes.viewBox = new yt(this.document, "viewBox", this.getAttribute("viewBox").getValue()), a.attributes.width = new yt(this.document, "width", "".concat(n, "px")), a.attributes.height = new yt(this.document, "height", "".concat(s, "px")), a.attributes.transform = new yt(this.document, "transform", this.getAttribute("patternTransform").getValue()), a.children = this.children;
    var o = this.document.createCanvas(n, s), A = o.getContext("2d"), l = this.getAttribute("x"), h = this.getAttribute("y");
    l.hasValue() && h.hasValue() && A.translate(l.getPixels("x", !0), h.getPixels("y", !0)), r.hasValue() ? this.styles["fill-opacity"] = r : Reflect.deleteProperty(this.styles, "fill-opacity");
    for (var c = -1; c <= 1; c++)
      for (var u = -1; u <= 1; u++)
        A.save(), a.attributes.x = new yt(this.document, "x", c * o.width), a.attributes.y = new yt(this.document, "y", u * o.height), a.render(A), A.restore();
    var f = e.createPattern(o, "repeat");
    return f;
  }
}
class hU extends xi {
  constructor() {
    super(...arguments), this.type = "marker";
  }
  render(e, t, r) {
    if (t) {
      var {
        x: n,
        y: s
      } = t, a = this.getAttribute("orient").getString("auto"), o = this.getAttribute("markerUnits").getString("strokeWidth");
      e.translate(n, s), a === "auto" && e.rotate(r), o === "strokeWidth" && e.scale(e.lineWidth, e.lineWidth), e.save();
      var A = new Xu(this.document, null);
      A.type = this.type, A.attributes.viewBox = new yt(this.document, "viewBox", this.getAttribute("viewBox").getValue()), A.attributes.refX = new yt(this.document, "refX", this.getAttribute("refX").getValue()), A.attributes.refY = new yt(this.document, "refY", this.getAttribute("refY").getValue()), A.attributes.width = new yt(this.document, "width", this.getAttribute("markerWidth").getValue()), A.attributes.height = new yt(this.document, "height", this.getAttribute("markerHeight").getValue()), A.attributes.overflow = new yt(this.document, "overflow", this.getAttribute("overflow").getValue()), A.attributes.fill = new yt(this.document, "fill", this.getAttribute("fill").getColor("black")), A.attributes.stroke = new yt(this.document, "stroke", this.getAttribute("stroke").getValue("none")), A.children = this.children, A.render(e), e.restore(), o === "strokeWidth" && e.scale(1 / e.lineWidth, 1 / e.lineWidth), a === "auto" && e.rotate(-r), e.translate(-n, -s);
    }
  }
}
class cU extends xi {
  constructor() {
    super(...arguments), this.type = "defs";
  }
  render() {
  }
}
class Qy extends xl {
  constructor() {
    super(...arguments), this.type = "g";
  }
  getBoundingBox(e) {
    var t = new ra();
    return this.children.forEach((r) => {
      t.addBoundingBox(r.getBoundingBox(e));
    }), t;
  }
}
class Ob extends xi {
  constructor(e, t, r) {
    super(e, t, r), this.attributesToInherit = ["gradientUnits"], this.stops = [];
    var {
      stops: n,
      children: s
    } = this;
    s.forEach((a) => {
      a.type === "stop" && n.push(a);
    });
  }
  getGradientUnits() {
    return this.getAttribute("gradientUnits").getString("objectBoundingBox");
  }
  createGradient(e, t, r) {
    var n = this;
    this.getHrefAttribute().hasValue() && (n = this.getHrefAttribute().getDefinition(), this.inheritStopContainer(n));
    var {
      stops: s
    } = n, a = this.getGradient(e, t);
    if (!a)
      return this.addParentOpacity(r, s[s.length - 1].color);
    if (s.forEach((y) => {
      a.addColorStop(y.offset, this.addParentOpacity(r, y.color));
    }), this.getAttribute("gradientTransform").hasValue()) {
      var {
        document: o
      } = this, {
        MAX_VIRTUAL_PIXELS: A,
        viewPort: l
      } = o.screen, [h] = l.viewPorts, c = new Nb(o, null);
      c.attributes.x = new yt(o, "x", -A / 3), c.attributes.y = new yt(o, "y", -A / 3), c.attributes.width = new yt(o, "width", A), c.attributes.height = new yt(o, "height", A);
      var u = new Qy(o, null);
      u.attributes.transform = new yt(o, "transform", this.getAttribute("gradientTransform").getValue()), u.children = [c];
      var f = new Xu(o, null);
      f.attributes.x = new yt(o, "x", 0), f.attributes.y = new yt(o, "y", 0), f.attributes.width = new yt(o, "width", h.width), f.attributes.height = new yt(o, "height", h.height), f.children = [u];
      var g = o.createCanvas(h.width, h.height), p = g.getContext("2d");
      return p.fillStyle = a, f.render(p), p.createPattern(g, "no-repeat");
    }
    return a;
  }
  inheritStopContainer(e) {
    this.attributesToInherit.forEach((t) => {
      !this.getAttribute(t).hasValue() && e.getAttribute(t).hasValue() && this.getAttribute(t, !0).setValue(e.getAttribute(t).getValue());
    });
  }
  addParentOpacity(e, t) {
    if (e.hasValue()) {
      var r = new yt(this.document, "color", t);
      return r.addOpacity(e).getColor();
    }
    return t;
  }
}
class uU extends Ob {
  constructor(e, t, r) {
    super(e, t, r), this.type = "linearGradient", this.attributesToInherit.push("x1", "y1", "x2", "y2");
  }
  getGradient(e, t) {
    var r = this.getGradientUnits() === "objectBoundingBox", n = r ? t.getBoundingBox(e) : null;
    if (r && !n)
      return null;
    !this.getAttribute("x1").hasValue() && !this.getAttribute("y1").hasValue() && !this.getAttribute("x2").hasValue() && !this.getAttribute("y2").hasValue() && (this.getAttribute("x1", !0).setValue(0), this.getAttribute("y1", !0).setValue(0), this.getAttribute("x2", !0).setValue(1), this.getAttribute("y2", !0).setValue(0));
    var s = r ? n.x + n.width * this.getAttribute("x1").getNumber() : this.getAttribute("x1").getPixels("x"), a = r ? n.y + n.height * this.getAttribute("y1").getNumber() : this.getAttribute("y1").getPixels("y"), o = r ? n.x + n.width * this.getAttribute("x2").getNumber() : this.getAttribute("x2").getPixels("x"), A = r ? n.y + n.height * this.getAttribute("y2").getNumber() : this.getAttribute("y2").getPixels("y");
    return s === o && a === A ? null : e.createLinearGradient(s, a, o, A);
  }
}
class fU extends Ob {
  constructor(e, t, r) {
    super(e, t, r), this.type = "radialGradient", this.attributesToInherit.push("cx", "cy", "r", "fx", "fy", "fr");
  }
  getGradient(e, t) {
    var r = this.getGradientUnits() === "objectBoundingBox", n = t.getBoundingBox(e);
    if (r && !n)
      return null;
    this.getAttribute("cx").hasValue() || this.getAttribute("cx", !0).setValue("50%"), this.getAttribute("cy").hasValue() || this.getAttribute("cy", !0).setValue("50%"), this.getAttribute("r").hasValue() || this.getAttribute("r", !0).setValue("50%");
    var s = r ? n.x + n.width * this.getAttribute("cx").getNumber() : this.getAttribute("cx").getPixels("x"), a = r ? n.y + n.height * this.getAttribute("cy").getNumber() : this.getAttribute("cy").getPixels("y"), o = s, A = a;
    this.getAttribute("fx").hasValue() && (o = r ? n.x + n.width * this.getAttribute("fx").getNumber() : this.getAttribute("fx").getPixels("x")), this.getAttribute("fy").hasValue() && (A = r ? n.y + n.height * this.getAttribute("fy").getNumber() : this.getAttribute("fy").getPixels("y"));
    var l = r ? (n.width + n.height) / 2 * this.getAttribute("r").getNumber() : this.getAttribute("r").getPixels(), h = this.getAttribute("fr").getPixels();
    return e.createRadialGradient(o, A, h, s, a, l);
  }
}
class dU extends xi {
  constructor(e, t, r) {
    super(e, t, r), this.type = "stop";
    var n = Math.max(0, Math.min(1, this.getAttribute("offset").getNumber())), s = this.getStyle("stop-opacity"), a = this.getStyle("stop-color", !0);
    a.getString() === "" && a.setValue("#000"), s.hasValue() && (a = a.addOpacity(s)), this.offset = n, this.color = a.getColor();
  }
}
class Dy extends xi {
  constructor(e, t, r) {
    super(e, t, r), this.type = "animate", this.duration = 0, this.initialValue = null, this.initialUnits = "", this.removed = !1, this.frozen = !1, e.screen.animations.push(this), this.begin = this.getAttribute("begin").getMilliseconds(), this.maxDuration = this.begin + this.getAttribute("dur").getMilliseconds(), this.from = this.getAttribute("from"), this.to = this.getAttribute("to"), this.values = new yt(e, "values", null);
    var n = this.getAttribute("values");
    n.hasValue() && this.values.setValue(n.getString().split(";"));
  }
  getProperty() {
    var e = this.getAttribute("attributeType").getString(), t = this.getAttribute("attributeName").getString();
    return e === "CSS" ? this.parent.getStyle(t, !0) : this.parent.getAttribute(t, !0);
  }
  calcValue() {
    var {
      initialUnits: e
    } = this, {
      progress: t,
      from: r,
      to: n
    } = this.getProgress(), s = r.getNumber() + (n.getNumber() - r.getNumber()) * t;
    return e === "%" && (s *= 100), "".concat(s).concat(e);
  }
  update(e) {
    var {
      parent: t
    } = this, r = this.getProperty();
    if (this.initialValue || (this.initialValue = r.getString(), this.initialUnits = r.getUnits()), this.duration > this.maxDuration) {
      var n = this.getAttribute("fill").getString("remove");
      if (this.getAttribute("repeatCount").getString() === "indefinite" || this.getAttribute("repeatDur").getString() === "indefinite")
        this.duration = 0;
      else if (n === "freeze" && !this.frozen)
        this.frozen = !0, t.animationFrozen = !0, t.animationFrozenValue = r.getString();
      else if (n === "remove" && !this.removed)
        return this.removed = !0, r.setValue(t.animationFrozen ? t.animationFrozenValue : this.initialValue), !0;
      return !1;
    }
    this.duration += e;
    var s = !1;
    if (this.begin < this.duration) {
      var a = this.calcValue(), o = this.getAttribute("type");
      if (o.hasValue()) {
        var A = o.getString();
        a = "".concat(A, "(").concat(a, ")");
      }
      r.setValue(a), s = !0;
    }
    return s;
  }
  getProgress() {
    var {
      document: e,
      values: t
    } = this, r = {
      progress: (this.duration - this.begin) / (this.maxDuration - this.begin)
    };
    if (t.hasValue()) {
      var n = r.progress * (t.getValue().length - 1), s = Math.floor(n), a = Math.ceil(n);
      r.from = new yt(e, "from", parseFloat(t.getValue()[s])), r.to = new yt(e, "to", parseFloat(t.getValue()[a])), r.progress = (n - s) / (a - s);
    } else
      r.from = this.from, r.to = this.to;
    return r;
  }
}
class gU extends Dy {
  constructor() {
    super(...arguments), this.type = "animateColor";
  }
  calcValue() {
    var {
      progress: e,
      from: t,
      to: r
    } = this.getProgress(), n = new HC(t.getColor()), s = new HC(r.getColor());
    if (n.ok && s.ok) {
      var a = n.r + (s.r - n.r) * e, o = n.g + (s.g - n.g) * e, A = n.b + (s.b - n.b) * e;
      return "rgb(".concat(Math.floor(a), ", ").concat(Math.floor(o), ", ").concat(Math.floor(A), ")");
    }
    return this.getAttribute("from").getColor();
  }
}
class pU extends Dy {
  constructor() {
    super(...arguments), this.type = "animateTransform";
  }
  calcValue() {
    var {
      progress: e,
      from: t,
      to: r
    } = this.getProgress(), n = ps(t.getString()), s = ps(r.getString()), a = n.map((o, A) => {
      var l = s[A];
      return o + (l - o) * e;
    }).join(" ");
    return a;
  }
}
class mU extends xi {
  constructor(e, t, r) {
    super(e, t, r), this.type = "font", this.glyphs = {}, this.horizAdvX = this.getAttribute("horiz-adv-x").getNumber();
    var {
      definitions: n
    } = e, {
      children: s
    } = this;
    for (var a of s)
      switch (a.type) {
        case "font-face": {
          this.fontFace = a;
          var o = a.getStyle("font-family");
          o.hasValue() && (n[o.getString()] = this);
          break;
        }
        case "missing-glyph":
          this.missingGlyph = a;
          break;
        case "glyph": {
          var A = a;
          A.arabicForm ? (this.isRTL = !0, this.isArabic = !0, typeof this.glyphs[A.unicode] > "u" && (this.glyphs[A.unicode] = {}), this.glyphs[A.unicode][A.arabicForm] = A) : this.glyphs[A.unicode] = A;
          break;
        }
      }
  }
  render() {
  }
}
class vU extends xi {
  constructor(e, t, r) {
    super(e, t, r), this.type = "font-face", this.ascent = this.getAttribute("ascent").getNumber(), this.descent = this.getAttribute("descent").getNumber(), this.unitsPerEm = this.getAttribute("units-per-em").getNumber();
  }
}
class yU extends Or {
  constructor() {
    super(...arguments), this.type = "missing-glyph", this.horizAdvX = 0;
  }
}
class _U extends Cl {
  constructor() {
    super(...arguments), this.type = "tref";
  }
  getText() {
    var e = this.getHrefAttribute().getDefinition();
    if (e) {
      var t = e.children[0];
      if (t)
        return t.getText();
    }
    return "";
  }
}
class wU extends Cl {
  constructor(e, t, r) {
    super(e, t, r), this.type = "a";
    var {
      childNodes: n
    } = t, s = n[0], a = n.length > 0 && Array.from(n).every((o) => o.nodeType === 3);
    this.hasText = a, this.text = a ? this.getTextFromNode(s) : "";
  }
  getText() {
    return this.text;
  }
  renderChildren(e) {
    if (this.hasText) {
      super.renderChildren(e);
      var {
        document: t,
        x: r,
        y: n
      } = this, {
        mouse: s
      } = t.screen, a = new yt(t, "fontSize", Kn.parse(t.ctx.font).fontSize);
      s.isWorking() && s.checkBoundingBox(this, new ra(r, n - a.getPixels("y"), r + this.measureText(e), n));
    } else if (this.children.length > 0) {
      var o = new Qy(this.document, null);
      o.children = this.children, o.parent = this, o.render(e);
    }
  }
  onClick() {
    var {
      window: e
    } = this.document;
    e && e.open(this.getHrefAttribute().getString());
  }
  onMouseMove() {
    var e = this.document.ctx;
    e.canvas.style.cursor = "pointer";
  }
}
function cR(i, e) {
  var t = Object.keys(i);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(i);
    e && (r = r.filter(function(n) {
      return Object.getOwnPropertyDescriptor(i, n).enumerable;
    })), t.push.apply(t, r);
  }
  return t;
}
function U0(i) {
  for (var e = 1; e < arguments.length; e++) {
    var t = arguments[e] != null ? arguments[e] : {};
    e % 2 ? cR(Object(t), !0).forEach(function(r) {
      Sb(i, r, t[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(i, Object.getOwnPropertyDescriptors(t)) : cR(Object(t)).forEach(function(r) {
      Object.defineProperty(i, r, Object.getOwnPropertyDescriptor(t, r));
    });
  }
  return i;
}
class xU extends Cl {
  constructor(e, t, r) {
    super(e, t, r), this.type = "textPath", this.textWidth = 0, this.textHeight = 0, this.pathLength = -1, this.glyphInfo = null, this.letterSpacingCache = [], this.measuresCache = /* @__PURE__ */ new Map([["", 0]]);
    var n = this.getHrefAttribute().getDefinition();
    this.text = this.getTextFromNode(), this.dataArray = this.parsePathData(n);
  }
  getText() {
    return this.text;
  }
  path(e) {
    var {
      dataArray: t
    } = this;
    e && e.beginPath(), t.forEach((r) => {
      var {
        type: n,
        points: s
      } = r;
      switch (n) {
        case $t.LINE_TO:
          e && e.lineTo(s[0], s[1]);
          break;
        case $t.MOVE_TO:
          e && e.moveTo(s[0], s[1]);
          break;
        case $t.CURVE_TO:
          e && e.bezierCurveTo(s[0], s[1], s[2], s[3], s[4], s[5]);
          break;
        case $t.QUAD_TO:
          e && e.quadraticCurveTo(s[0], s[1], s[2], s[3]);
          break;
        case $t.ARC: {
          var [a, o, A, l, h, c, u, f] = s, g = A > l ? A : l, p = A > l ? 1 : A / l, y = A > l ? l / A : 1;
          e && (e.translate(a, o), e.rotate(u), e.scale(p, y), e.arc(0, 0, g, h, h + c, !!(1 - f)), e.scale(1 / p, 1 / y), e.rotate(-u), e.translate(-a, -o));
          break;
        }
        case $t.CLOSE_PATH:
          e && e.closePath();
          break;
      }
    });
  }
  renderChildren(e) {
    this.setTextData(e), e.save();
    var t = this.parent.getStyle("text-decoration").getString(), r = this.getFontSize(), {
      glyphInfo: n
    } = this, s = e.fillStyle;
    t === "underline" && e.beginPath(), n.forEach((a, o) => {
      var {
        p0: A,
        p1: l,
        rotation: h,
        text: c
      } = a;
      e.save(), e.translate(A.x, A.y), e.rotate(h), e.fillStyle && e.fillText(c, 0, 0), e.strokeStyle && e.strokeText(c, 0, 0), e.restore(), t === "underline" && (o === 0 && e.moveTo(A.x, A.y + r / 8), e.lineTo(l.x, l.y + r / 5));
    }), t === "underline" && (e.lineWidth = r / 20, e.strokeStyle = s, e.stroke(), e.closePath()), e.restore();
  }
  getLetterSpacingAt() {
    var e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0;
    return this.letterSpacingCache[e] || 0;
  }
  findSegmentToFitChar(e, t, r, n, s, a, o, A, l) {
    var h = a, c = this.measureText(e, A);
    A === " " && t === "justify" && r < n && (c += (n - r) / s), l > -1 && (h += this.getLetterSpacingAt(l));
    var u = this.textHeight / 20, f = this.getEquidistantPointOnPath(h, u, 0), g = this.getEquidistantPointOnPath(h + c, u, 0), p = {
      p0: f,
      p1: g
    }, y = f && g ? Math.atan2(g.y - f.y, g.x - f.x) : 0;
    if (o) {
      var v = Math.cos(Math.PI / 2 + y) * o, w = Math.cos(-y) * o;
      p.p0 = U0(U0({}, f), {}, {
        x: f.x + v,
        y: f.y + w
      }), p.p1 = U0(U0({}, g), {}, {
        x: g.x + v,
        y: g.y + w
      });
    }
    return h += c, {
      offset: h,
      segment: p,
      rotation: y
    };
  }
  measureText(e, t) {
    var {
      measuresCache: r
    } = this, n = t || this.getText();
    if (r.has(n))
      return r.get(n);
    var s = this.measureTargetText(e, n);
    return r.set(n, s), s;
  }
  // This method supposes what all custom fonts already loaded.
  // If some font will be loaded after this method call, <textPath> will not be rendered correctly.
  // You need to call this method manually to update glyphs cache.
  setTextData(e) {
    if (!this.glyphInfo) {
      var t = this.getText(), r = t.split(""), n = t.split(" ").length - 1, s = this.parent.getAttribute("dx").split().map((E) => E.getPixels("x")), a = this.parent.getAttribute("dy").getPixels("y"), o = this.parent.getStyle("text-anchor").getString("start"), A = this.getStyle("letter-spacing"), l = this.parent.getStyle("letter-spacing"), h = 0;
      !A.hasValue() || A.getValue() === "inherit" ? h = l.getPixels() : A.hasValue() && A.getValue() !== "initial" && A.getValue() !== "unset" && (h = A.getPixels());
      var c = [], u = t.length;
      this.letterSpacingCache = c;
      for (var f = 0; f < u; f++)
        c.push(typeof s[f] < "u" ? s[f] : h);
      var g = c.reduce((E, S, M) => M === 0 ? 0 : E + S || 0, 0), p = this.measureText(e), y = Math.max(p + g, 0);
      this.textWidth = p, this.textHeight = this.getFontSize(), this.glyphInfo = [];
      var v = this.getPathLength(), w = this.getStyle("startOffset").getNumber(0) * v, C = 0;
      (o === "middle" || o === "center") && (C = -y / 2), (o === "end" || o === "right") && (C = -y), C += w, r.forEach((E, S) => {
        var {
          offset: M,
          segment: T,
          rotation: F
        } = this.findSegmentToFitChar(e, o, y, v, n, C, a, E, S);
        C = M, !(!T.p0 || !T.p1) && this.glyphInfo.push({
          // transposeX: midpoint.x,
          // transposeY: midpoint.y,
          text: r[S],
          p0: T.p0,
          p1: T.p1,
          rotation: F
        });
      });
    }
  }
  parsePathData(e) {
    if (this.pathLength = -1, !e)
      return [];
    var t = [], {
      pathParser: r
    } = e;
    for (r.reset(); !r.isEnd(); ) {
      var {
        current: n
      } = r, s = n ? n.x : 0, a = n ? n.y : 0, o = r.next(), A = o.type, l = [];
      switch (o.type) {
        case $t.MOVE_TO:
          this.pathM(r, l);
          break;
        case $t.LINE_TO:
          A = this.pathL(r, l);
          break;
        case $t.HORIZ_LINE_TO:
          A = this.pathH(r, l);
          break;
        case $t.VERT_LINE_TO:
          A = this.pathV(r, l);
          break;
        case $t.CURVE_TO:
          this.pathC(r, l);
          break;
        case $t.SMOOTH_CURVE_TO:
          A = this.pathS(r, l);
          break;
        case $t.QUAD_TO:
          this.pathQ(r, l);
          break;
        case $t.SMOOTH_QUAD_TO:
          A = this.pathT(r, l);
          break;
        case $t.ARC:
          l = this.pathA(r);
          break;
        case $t.CLOSE_PATH:
          Or.pathZ(r);
          break;
      }
      o.type !== $t.CLOSE_PATH ? t.push({
        type: A,
        points: l,
        start: {
          x: s,
          y: a
        },
        pathLength: this.calcLength(s, a, A, l)
      }) : t.push({
        type: $t.CLOSE_PATH,
        points: [],
        pathLength: 0
      });
    }
    return t;
  }
  pathM(e, t) {
    var {
      x: r,
      y: n
    } = Or.pathM(e).point;
    t.push(r, n);
  }
  pathL(e, t) {
    var {
      x: r,
      y: n
    } = Or.pathL(e).point;
    return t.push(r, n), $t.LINE_TO;
  }
  pathH(e, t) {
    var {
      x: r,
      y: n
    } = Or.pathH(e).point;
    return t.push(r, n), $t.LINE_TO;
  }
  pathV(e, t) {
    var {
      x: r,
      y: n
    } = Or.pathV(e).point;
    return t.push(r, n), $t.LINE_TO;
  }
  pathC(e, t) {
    var {
      point: r,
      controlPoint: n,
      currentPoint: s
    } = Or.pathC(e);
    t.push(r.x, r.y, n.x, n.y, s.x, s.y);
  }
  pathS(e, t) {
    var {
      point: r,
      controlPoint: n,
      currentPoint: s
    } = Or.pathS(e);
    return t.push(r.x, r.y, n.x, n.y, s.x, s.y), $t.CURVE_TO;
  }
  pathQ(e, t) {
    var {
      controlPoint: r,
      currentPoint: n
    } = Or.pathQ(e);
    t.push(r.x, r.y, n.x, n.y);
  }
  pathT(e, t) {
    var {
      controlPoint: r,
      currentPoint: n
    } = Or.pathT(e);
    return t.push(r.x, r.y, n.x, n.y), $t.QUAD_TO;
  }
  pathA(e) {
    var {
      rX: t,
      rY: r,
      sweepFlag: n,
      xAxisRotation: s,
      centp: a,
      a1: o,
      ad: A
    } = Or.pathA(e);
    return n === 0 && A > 0 && (A -= 2 * Math.PI), n === 1 && A < 0 && (A += 2 * Math.PI), [a.x, a.y, t, r, o, A, s, n];
  }
  calcLength(e, t, r, n) {
    var s = 0, a = null, o = null, A = 0;
    switch (r) {
      case $t.LINE_TO:
        return this.getLineLength(e, t, n[0], n[1]);
      case $t.CURVE_TO:
        for (s = 0, a = this.getPointOnCubicBezier(0, e, t, n[0], n[1], n[2], n[3], n[4], n[5]), A = 0.01; A <= 1; A += 0.01)
          o = this.getPointOnCubicBezier(A, e, t, n[0], n[1], n[2], n[3], n[4], n[5]), s += this.getLineLength(a.x, a.y, o.x, o.y), a = o;
        return s;
      case $t.QUAD_TO:
        for (s = 0, a = this.getPointOnQuadraticBezier(0, e, t, n[0], n[1], n[2], n[3]), A = 0.01; A <= 1; A += 0.01)
          o = this.getPointOnQuadraticBezier(A, e, t, n[0], n[1], n[2], n[3]), s += this.getLineLength(a.x, a.y, o.x, o.y), a = o;
        return s;
      case $t.ARC: {
        s = 0;
        var l = n[4], h = n[5], c = n[4] + h, u = Math.PI / 180;
        if (Math.abs(l - c) < u && (u = Math.abs(l - c)), a = this.getPointOnEllipticalArc(n[0], n[1], n[2], n[3], l, 0), h < 0)
          for (A = l - u; A > c; A -= u)
            o = this.getPointOnEllipticalArc(n[0], n[1], n[2], n[3], A, 0), s += this.getLineLength(a.x, a.y, o.x, o.y), a = o;
        else
          for (A = l + u; A < c; A += u)
            o = this.getPointOnEllipticalArc(n[0], n[1], n[2], n[3], A, 0), s += this.getLineLength(a.x, a.y, o.x, o.y), a = o;
        return o = this.getPointOnEllipticalArc(n[0], n[1], n[2], n[3], c, 0), s += this.getLineLength(a.x, a.y, o.x, o.y), s;
      }
    }
    return 0;
  }
  getPointOnLine(e, t, r, n, s) {
    var a = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : t, o = arguments.length > 6 && arguments[6] !== void 0 ? arguments[6] : r, A = (s - r) / (n - t + ch), l = Math.sqrt(e * e / (1 + A * A));
    n < t && (l *= -1);
    var h = A * l, c = null;
    if (n === t)
      c = {
        x: a,
        y: o + h
      };
    else if ((o - r) / (a - t + ch) === A)
      c = {
        x: a + l,
        y: o + h
      };
    else {
      var u = 0, f = 0, g = this.getLineLength(t, r, n, s);
      if (g < ch)
        return null;
      var p = (a - t) * (n - t) + (o - r) * (s - r);
      p /= g * g, u = t + p * (n - t), f = r + p * (s - r);
      var y = this.getLineLength(a, o, u, f), v = Math.sqrt(e * e - y * y);
      l = Math.sqrt(v * v / (1 + A * A)), n < t && (l *= -1), h = A * l, c = {
        x: u + l,
        y: f + h
      };
    }
    return c;
  }
  getPointOnPath(e) {
    var t = this.getPathLength(), r = 0, n = null;
    if (e < -5e-5 || e - 5e-5 > t)
      return null;
    var {
      dataArray: s
    } = this;
    for (var a of s) {
      if (a && (a.pathLength < 5e-5 || r + a.pathLength + 5e-5 < e)) {
        r += a.pathLength;
        continue;
      }
      var o = e - r, A = 0;
      switch (a.type) {
        case $t.LINE_TO:
          n = this.getPointOnLine(o, a.start.x, a.start.y, a.points[0], a.points[1], a.start.x, a.start.y);
          break;
        case $t.ARC: {
          var l = a.points[4], h = a.points[5], c = a.points[4] + h;
          if (A = l + o / a.pathLength * h, h < 0 && A < c || h >= 0 && A > c)
            break;
          n = this.getPointOnEllipticalArc(a.points[0], a.points[1], a.points[2], a.points[3], A, a.points[6]);
          break;
        }
        case $t.CURVE_TO:
          A = o / a.pathLength, A > 1 && (A = 1), n = this.getPointOnCubicBezier(A, a.start.x, a.start.y, a.points[0], a.points[1], a.points[2], a.points[3], a.points[4], a.points[5]);
          break;
        case $t.QUAD_TO:
          A = o / a.pathLength, A > 1 && (A = 1), n = this.getPointOnQuadraticBezier(A, a.start.x, a.start.y, a.points[0], a.points[1], a.points[2], a.points[3]);
          break;
      }
      if (n)
        return n;
      break;
    }
    return null;
  }
  getLineLength(e, t, r, n) {
    return Math.sqrt((r - e) * (r - e) + (n - t) * (n - t));
  }
  getPathLength() {
    return this.pathLength === -1 && (this.pathLength = this.dataArray.reduce((e, t) => t.pathLength > 0 ? e + t.pathLength : e, 0)), this.pathLength;
  }
  getPointOnCubicBezier(e, t, r, n, s, a, o, A, l) {
    var h = A * zC(e) + a * XC(e) + n * WC(e) + t * YC(e), c = l * zC(e) + o * XC(e) + s * WC(e) + r * YC(e);
    return {
      x: h,
      y: c
    };
  }
  getPointOnQuadraticBezier(e, t, r, n, s, a, o) {
    var A = a * qC(e) + n * ZC(e) + t * JC(e), l = o * qC(e) + s * ZC(e) + r * JC(e);
    return {
      x: A,
      y: l
    };
  }
  getPointOnEllipticalArc(e, t, r, n, s, a) {
    var o = Math.cos(a), A = Math.sin(a), l = {
      x: r * Math.cos(s),
      y: n * Math.sin(s)
    };
    return {
      x: e + (l.x * o - l.y * A),
      y: t + (l.x * A + l.y * o)
    };
  }
  // TODO need some optimisations. possibly build cache only for curved segments?
  buildEquidistantCache(e, t) {
    var r = this.getPathLength(), n = t || 0.25, s = e || r / 100;
    if (!this.equidistantCache || this.equidistantCache.step !== s || this.equidistantCache.precision !== n) {
      this.equidistantCache = {
        step: s,
        precision: n,
        points: []
      };
      for (var a = 0, o = 0; o <= r; o += n) {
        var A = this.getPointOnPath(o), l = this.getPointOnPath(o + n);
        !A || !l || (a += this.getLineLength(A.x, A.y, l.x, l.y), a >= s && (this.equidistantCache.points.push({
          x: A.x,
          y: A.y,
          distance: o
        }), a -= s));
      }
    }
  }
  getEquidistantPointOnPath(e, t, r) {
    if (this.buildEquidistantCache(t, r), e < 0 || e - this.getPathLength() > 5e-5)
      return null;
    var n = Math.round(e / this.getPathLength() * (this.equidistantCache.points.length - 1));
    return this.equidistantCache.points[n] || null;
  }
}
var Qye = /^\s*data:(([^/,;]+\/[^/,;]+)(?:;([^,;=]+=[^,;=]+))?)?(?:;(base64))?,(.*)$/i;
class CU extends xl {
  constructor(e, t, r) {
    super(e, t, r), this.type = "image", this.loaded = !1;
    var n = this.getHrefAttribute().getString();
    if (n) {
      var s = n.endsWith(".svg") || /^\s*data:image\/svg\+xml/i.test(n);
      e.images.push(this), s ? this.loadSvg(n) : this.loadImage(n), this.isSvg = s;
    }
  }
  loadImage(e) {
    var t = this;
    return rA(function* () {
      try {
        var r = yield t.document.createImage(e);
        t.image = r;
      } catch (n) {
        console.error('Error while loading image "'.concat(e, '":'), n);
      }
      t.loaded = !0;
    })();
  }
  loadSvg(e) {
    var t = this;
    return rA(function* () {
      var r = Qye.exec(e);
      if (r) {
        var n = r[5];
        r[4] === "base64" ? t.image = atob(n) : t.image = decodeURIComponent(n);
      } else
        try {
          var s = yield t.document.fetch(e), a = yield s.text();
          t.image = a;
        } catch (o) {
          console.error('Error while loading image "'.concat(e, '":'), o);
        }
      t.loaded = !0;
    })();
  }
  renderChildren(e) {
    var {
      document: t,
      image: r,
      loaded: n
    } = this, s = this.getAttribute("x").getPixels("x"), a = this.getAttribute("y").getPixels("y"), o = this.getStyle("width").getPixels("x"), A = this.getStyle("height").getPixels("y");
    if (!(!n || !r || !o || !A)) {
      if (e.save(), e.translate(s, a), this.isSvg) {
        var l = t.canvg.forkString(e, this.image, {
          ignoreMouse: !0,
          ignoreAnimation: !0,
          ignoreDimensions: !0,
          ignoreClear: !0,
          offsetX: 0,
          offsetY: 0,
          scaleWidth: o,
          scaleHeight: A
        });
        l.document.documentElement.parent = this, l.render();
      } else {
        var h = this.image;
        t.setViewBox({
          ctx: e,
          aspectRatio: this.getAttribute("preserveAspectRatio").getString(),
          width: o,
          desiredWidth: h.width,
          height: A,
          desiredHeight: h.height
        }), this.loaded && (typeof h.complete > "u" || h.complete) && e.drawImage(h, 0, 0);
      }
      e.restore();
    }
  }
  getBoundingBox() {
    var e = this.getAttribute("x").getPixels("x"), t = this.getAttribute("y").getPixels("y"), r = this.getStyle("width").getPixels("x"), n = this.getStyle("height").getPixels("y");
    return new ra(e, t, e + r, t + n);
  }
}
class EU extends xl {
  constructor() {
    super(...arguments), this.type = "symbol";
  }
  render(e) {
  }
}
class BU {
  constructor(e) {
    this.document = e, this.loaded = !1, e.fonts.push(this);
  }
  load(e, t) {
    var r = this;
    return rA(function* () {
      try {
        var {
          document: n
        } = r, s = yield n.canvg.parser.load(t), a = s.getElementsByTagName("font");
        Array.from(a).forEach((o) => {
          var A = n.createElement(o);
          n.definitions[e] = A;
        });
      } catch (o) {
        console.error('Error while loading font "'.concat(t, '":'), o);
      }
      r.loaded = !0;
    })();
  }
}
class Ub extends xi {
  constructor(e, t, r) {
    super(e, t, r), this.type = "style";
    var n = Mh(
      Array.from(t.childNodes).map((a) => a.textContent).join("").replace(/(\/\*([^*]|[\r\n]|(\*+([^*/]|[\r\n])))*\*+\/)|(^[\s]*\/\/.*)/gm, "").replace(/@import.*;/g, "")
      // remove imports
    ), s = n.split("}");
    s.forEach((a) => {
      var o = a.trim();
      if (o) {
        var A = o.split("{"), l = A[0].split(","), h = A[1].split(";");
        l.forEach((c) => {
          var u = c.trim();
          if (u) {
            var f = e.styles[u] || {};
            if (h.forEach((y) => {
              var v = y.indexOf(":"), w = y.substr(0, v).trim(), C = y.substr(v + 1, y.length - v).trim();
              w && C && (f[w] = new yt(e, w, C));
            }), e.styles[u] = f, e.stylesSpecificity[u] = XO(u), u === "@font-face") {
              var g = f["font-family"].getString().replace(/"|'/g, ""), p = f.src.getString().split(",");
              p.forEach((y) => {
                if (y.indexOf('format("svg")') > 0) {
                  var v = Lb(y);
                  v && new BU(e).load(g, v);
                }
              });
            }
          }
        });
      }
    });
  }
}
Ub.parseExternalUrl = Lb;
class bU extends xl {
  constructor() {
    super(...arguments), this.type = "use";
  }
  setContext(e) {
    super.setContext(e);
    var t = this.getAttribute("x"), r = this.getAttribute("y");
    t.hasValue() && e.translate(t.getPixels("x"), 0), r.hasValue() && e.translate(0, r.getPixels("y"));
  }
  path(e) {
    var {
      element: t
    } = this;
    t && t.path(e);
  }
  renderChildren(e) {
    var {
      document: t,
      element: r
    } = this;
    if (r) {
      var n = r;
      if (r.type === "symbol" && (n = new Xu(t, null), n.attributes.viewBox = new yt(t, "viewBox", r.getAttribute("viewBox").getString()), n.attributes.preserveAspectRatio = new yt(t, "preserveAspectRatio", r.getAttribute("preserveAspectRatio").getString()), n.attributes.overflow = new yt(t, "overflow", r.getAttribute("overflow").getString()), n.children = r.children, r.styles.opacity = new yt(t, "opacity", this.calculateOpacity())), n.type === "svg") {
        var s = this.getStyle("width", !1, !0), a = this.getStyle("height", !1, !0);
        s.hasValue() && (n.attributes.width = new yt(t, "width", s.getString())), a.hasValue() && (n.attributes.height = new yt(t, "height", a.getString()));
      }
      var o = n.parent;
      n.parent = this, n.render(e), n.parent = o;
    }
  }
  getBoundingBox(e) {
    var {
      element: t
    } = this;
    return t ? t.getBoundingBox(e) : null;
  }
  elementTransform() {
    var {
      document: e,
      element: t
    } = this;
    return vl.fromElement(e, t);
  }
  get element() {
    return this.cachedElement || (this.cachedElement = this.getHrefAttribute().getDefinition()), this.cachedElement;
  }
}
function Q0(i, e, t, r, n, s) {
  return i[t * r * 4 + e * 4 + s];
}
function D0(i, e, t, r, n, s, a) {
  i[t * r * 4 + e * 4 + s] = a;
}
function ji(i, e, t) {
  var r = i[e];
  return r * t;
}
function Io(i, e, t, r) {
  return e + Math.cos(i) * t + Math.sin(i) * r;
}
class Qb extends xi {
  constructor(e, t, r) {
    super(e, t, r), this.type = "feColorMatrix";
    var n = ps(this.getAttribute("values").getString());
    switch (this.getAttribute("type").getString("matrix")) {
      case "saturate": {
        var s = n[0];
        n = [0.213 + 0.787 * s, 0.715 - 0.715 * s, 0.072 - 0.072 * s, 0, 0, 0.213 - 0.213 * s, 0.715 + 0.285 * s, 0.072 - 0.072 * s, 0, 0, 0.213 - 0.213 * s, 0.715 - 0.715 * s, 0.072 + 0.928 * s, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1];
        break;
      }
      case "hueRotate": {
        var a = n[0] * Math.PI / 180;
        n = [Io(a, 0.213, 0.787, -0.213), Io(a, 0.715, -0.715, -0.715), Io(a, 0.072, -0.072, 0.928), 0, 0, Io(a, 0.213, -0.213, 0.143), Io(a, 0.715, 0.285, 0.14), Io(a, 0.072, -0.072, -0.283), 0, 0, Io(a, 0.213, -0.213, -0.787), Io(a, 0.715, -0.715, 0.715), Io(a, 0.072, 0.928, 0.072), 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1];
        break;
      }
      case "luminanceToAlpha":
        n = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0.2125, 0.7154, 0.0721, 0, 0, 0, 0, 0, 0, 1];
        break;
    }
    this.matrix = n, this.includeOpacity = this.getAttribute("includeOpacity").hasValue();
  }
  apply(e, t, r, n, s) {
    for (var {
      includeOpacity: a,
      matrix: o
    } = this, A = e.getImageData(0, 0, n, s), l = 0; l < s; l++)
      for (var h = 0; h < n; h++) {
        var c = Q0(A.data, h, l, n, s, 0), u = Q0(A.data, h, l, n, s, 1), f = Q0(A.data, h, l, n, s, 2), g = Q0(A.data, h, l, n, s, 3), p = ji(o, 0, c) + ji(o, 1, u) + ji(o, 2, f) + ji(o, 3, g) + ji(o, 4, 1), y = ji(o, 5, c) + ji(o, 6, u) + ji(o, 7, f) + ji(o, 8, g) + ji(o, 9, 1), v = ji(o, 10, c) + ji(o, 11, u) + ji(o, 12, f) + ji(o, 13, g) + ji(o, 14, 1), w = ji(o, 15, c) + ji(o, 16, u) + ji(o, 17, f) + ji(o, 18, g) + ji(o, 19, 1);
        a && (p = 0, y = 0, v = 0, w *= g / 255), D0(A.data, h, l, n, s, 0, p), D0(A.data, h, l, n, s, 1, y), D0(A.data, h, l, n, s, 2, v), D0(A.data, h, l, n, s, 3, w);
      }
    e.clearRect(0, 0, n, s), e.putImageData(A, 0, 0);
  }
}
class Ug extends xi {
  constructor() {
    super(...arguments), this.type = "mask";
  }
  apply(e, t) {
    var {
      document: r
    } = this, n = this.getAttribute("x").getPixels("x"), s = this.getAttribute("y").getPixels("y"), a = this.getStyle("width").getPixels("x"), o = this.getStyle("height").getPixels("y");
    if (!a && !o) {
      var A = new ra();
      this.children.forEach((g) => {
        A.addBoundingBox(g.getBoundingBox(e));
      }), n = Math.floor(A.x1), s = Math.floor(A.y1), a = Math.floor(A.width), o = Math.floor(A.height);
    }
    var l = this.removeStyles(t, Ug.ignoreStyles), h = r.createCanvas(n + a, s + o), c = h.getContext("2d");
    r.screen.setDefaults(c), this.renderChildren(c), new Qb(r, {
      nodeType: 1,
      childNodes: [],
      attributes: [{
        nodeName: "type",
        value: "luminanceToAlpha"
      }, {
        nodeName: "includeOpacity",
        value: "true"
      }]
    }).apply(c, 0, 0, n + a, s + o);
    var u = r.createCanvas(n + a, s + o), f = u.getContext("2d");
    r.screen.setDefaults(f), t.render(f), f.globalCompositeOperation = "destination-in", f.fillStyle = c.createPattern(h, "no-repeat"), f.fillRect(0, 0, n + a, s + o), e.fillStyle = f.createPattern(u, "no-repeat"), e.fillRect(0, 0, n + a, s + o), this.restoreStyles(t, l);
  }
  render(e) {
  }
}
Ug.ignoreStyles = ["mask", "transform", "clip-path"];
var uR = () => {
};
class SU extends xi {
  constructor() {
    super(...arguments), this.type = "clipPath";
  }
  apply(e) {
    var {
      document: t
    } = this, r = Reflect.getPrototypeOf(e), {
      beginPath: n,
      closePath: s
    } = e;
    r && (r.beginPath = uR, r.closePath = uR), Reflect.apply(n, e, []), this.children.forEach((a) => {
      if (!(typeof a.path > "u")) {
        var o = typeof a.elementTransform < "u" ? a.elementTransform() : null;
        o || (o = vl.fromElement(t, a)), o && o.apply(e), a.path(e), r && (r.closePath = s), o && o.unapply(e);
      }
    }), Reflect.apply(s, e, []), e.clip(), r && (r.beginPath = n, r.closePath = s);
  }
  render(e) {
  }
}
class Qg extends xi {
  constructor() {
    super(...arguments), this.type = "filter";
  }
  apply(e, t) {
    var {
      document: r,
      children: n
    } = this, s = t.getBoundingBox(e);
    if (s) {
      var a = 0, o = 0;
      n.forEach((v) => {
        var w = v.extraFilterDistance || 0;
        a = Math.max(a, w), o = Math.max(o, w);
      });
      var A = Math.floor(s.width), l = Math.floor(s.height), h = A + 2 * a, c = l + 2 * o;
      if (!(h < 1 || c < 1)) {
        var u = Math.floor(s.x), f = Math.floor(s.y), g = this.removeStyles(t, Qg.ignoreStyles), p = r.createCanvas(h, c), y = p.getContext("2d");
        r.screen.setDefaults(y), y.translate(-u + a, -f + o), t.render(y), n.forEach((v) => {
          typeof v.apply == "function" && v.apply(y, 0, 0, h, c);
        }), e.drawImage(p, 0, 0, h, c, u - a, f - o, h, c), this.restoreStyles(t, g);
      }
    }
  }
  render(e) {
  }
}
Qg.ignoreStyles = ["filter", "transform", "clip-path"];
class TU extends xi {
  constructor(e, t, r) {
    super(e, t, r), this.type = "feDropShadow", this.addStylesFromStyleDefinition();
  }
  apply(e, t, r, n, s) {
  }
}
class FU extends xi {
  constructor() {
    super(...arguments), this.type = "feMorphology";
  }
  apply(e, t, r, n, s) {
  }
}
class LU extends xi {
  constructor() {
    super(...arguments), this.type = "feComposite";
  }
  apply(e, t, r, n, s) {
  }
}
class IU extends xi {
  constructor(e, t, r) {
    super(e, t, r), this.type = "feGaussianBlur", this.blurRadius = Math.floor(this.getAttribute("stdDeviation").getNumber()), this.extraFilterDistance = this.blurRadius;
  }
  apply(e, t, r, n, s) {
    var {
      document: a,
      blurRadius: o
    } = this, A = a.window ? a.window.document.body : null, l = e.canvas;
    l.id = a.getUniqueId(), A && (l.style.display = "none", A.appendChild(l)), pye(l, t, r, n, s, o), A && A.removeChild(l);
  }
}
class RU extends xi {
  constructor() {
    super(...arguments), this.type = "title";
  }
}
class MU extends xi {
  constructor() {
    super(...arguments), this.type = "desc";
  }
}
var Dye = {
  svg: Xu,
  rect: Nb,
  circle: sU,
  ellipse: aU,
  line: oU,
  polyline: Pb,
  polygon: AU,
  path: Or,
  pattern: lU,
  marker: hU,
  defs: cU,
  linearGradient: uU,
  radialGradient: fU,
  stop: dU,
  animate: Dy,
  animateColor: gU,
  animateTransform: pU,
  font: mU,
  "font-face": vU,
  "missing-glyph": yU,
  glyph: Mb,
  text: Cl,
  tspan: Og,
  tref: _U,
  a: wU,
  textPath: xU,
  image: CU,
  g: Qy,
  symbol: EU,
  style: Ub,
  use: bU,
  mask: Ug,
  clipPath: SU,
  filter: Qg,
  feDropShadow: TU,
  feMorphology: FU,
  feComposite: LU,
  feColorMatrix: Qb,
  feGaussianBlur: IU,
  title: RU,
  desc: MU
};
function fR(i, e) {
  var t = Object.keys(i);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(i);
    e && (r = r.filter(function(n) {
      return Object.getOwnPropertyDescriptor(i, n).enumerable;
    })), t.push.apply(t, r);
  }
  return t;
}
function kye(i) {
  for (var e = 1; e < arguments.length; e++) {
    var t = arguments[e] != null ? arguments[e] : {};
    e % 2 ? fR(Object(t), !0).forEach(function(r) {
      Sb(i, r, t[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(i, Object.getOwnPropertyDescriptors(t)) : fR(Object(t)).forEach(function(r) {
      Object.defineProperty(i, r, Object.getOwnPropertyDescriptor(t, r));
    });
  }
  return i;
}
function Hye(i, e) {
  var t = document.createElement("canvas");
  return t.width = i, t.height = e, t;
}
function Gye(i) {
  return tE.apply(this, arguments);
}
function tE() {
  return tE = rA(function* (i) {
    var e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !1, t = document.createElement("img");
    return e && (t.crossOrigin = "Anonymous"), new Promise((r, n) => {
      t.onload = () => {
        r(t);
      }, t.onerror = (s, a, o, A, l) => {
        n(l);
      }, t.src = i;
    });
  }), tE.apply(this, arguments);
}
class zo {
  constructor(e) {
    var {
      rootEmSize: t = 12,
      emSize: r = 12,
      createCanvas: n = zo.createCanvas,
      createImage: s = zo.createImage,
      anonymousCrossOrigin: a
    } = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    this.canvg = e, this.definitions = {}, this.styles = {}, this.stylesSpecificity = {}, this.images = [], this.fonts = [], this.emSizeStack = [], this.uniqueId = 0, this.screen = e.screen, this.rootEmSize = t, this.emSize = r, this.createCanvas = n, this.createImage = this.bindCreateImage(s, a), this.screen.wait(this.isImagesLoaded.bind(this)), this.screen.wait(this.isFontsLoaded.bind(this));
  }
  bindCreateImage(e, t) {
    return typeof t == "boolean" ? (r, n) => e(r, typeof n == "boolean" ? n : t) : e;
  }
  get window() {
    return this.screen.window;
  }
  get fetch() {
    return this.screen.fetch;
  }
  get ctx() {
    return this.screen.ctx;
  }
  get emSize() {
    var {
      emSizeStack: e
    } = this;
    return e[e.length - 1];
  }
  set emSize(e) {
    var {
      emSizeStack: t
    } = this;
    t.push(e);
  }
  popEmSize() {
    var {
      emSizeStack: e
    } = this;
    e.pop();
  }
  getUniqueId() {
    return "canvg".concat(++this.uniqueId);
  }
  isImagesLoaded() {
    return this.images.every((e) => e.loaded);
  }
  isFontsLoaded() {
    return this.fonts.every((e) => e.loaded);
  }
  createDocumentElement(e) {
    var t = this.createElement(e.documentElement);
    return t.root = !0, t.addStylesFromStyleDefinition(), this.documentElement = t, t;
  }
  createElement(e) {
    var t = e.nodeName.replace(/^[^:]+:/, ""), r = zo.elementTypes[t];
    return typeof r < "u" ? new r(this, e) : new nU(this, e);
  }
  createTextNode(e) {
    return new Uye(this, e);
  }
  setViewBox(e) {
    this.screen.setViewBox(kye({
      document: this
    }, e));
  }
}
zo.createCanvas = Hye;
zo.createImage = Gye;
zo.elementTypes = Dye;
function dR(i, e) {
  var t = Object.keys(i);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(i);
    e && (r = r.filter(function(n) {
      return Object.getOwnPropertyDescriptor(i, n).enumerable;
    })), t.push.apply(t, r);
  }
  return t;
}
function Dl(i) {
  for (var e = 1; e < arguments.length; e++) {
    var t = arguments[e] != null ? arguments[e] : {};
    e % 2 ? dR(Object(t), !0).forEach(function(r) {
      Sb(i, r, t[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(i, Object.getOwnPropertyDescriptors(t)) : dR(Object(t)).forEach(function(r) {
      Object.defineProperty(i, r, Object.getOwnPropertyDescriptor(t, r));
    });
  }
  return i;
}
class ql {
  /**
   * Main constructor.
   * @param ctx - Rendering context.
   * @param svg - SVG Document.
   * @param options - Rendering options.
   */
  constructor(e, t) {
    var r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    this.parser = new lm(r), this.screen = new Pg(e, r), this.options = r;
    var n = new zo(this, r), s = n.createDocumentElement(t);
    this.document = n, this.documentElement = s;
  }
  /**
   * Create Canvg instance from SVG source string or URL.
   * @param ctx - Rendering context.
   * @param svg - SVG source string or URL.
   * @param options - Rendering options.
   * @returns Canvg instance.
   */
  static from(e, t) {
    var r = arguments;
    return rA(function* () {
      var n = r.length > 2 && r[2] !== void 0 ? r[2] : {}, s = new lm(n), a = yield s.parse(t);
      return new ql(e, a, n);
    })();
  }
  /**
   * Create Canvg instance from SVG source string.
   * @param ctx - Rendering context.
   * @param svg - SVG source string.
   * @param options - Rendering options.
   * @returns Canvg instance.
   */
  static fromString(e, t) {
    var r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, n = new lm(r), s = n.parseFromString(t);
    return new ql(e, s, r);
  }
  /**
   * Create new Canvg instance with inherited options.
   * @param ctx - Rendering context.
   * @param svg - SVG source string or URL.
   * @param options - Rendering options.
   * @returns Canvg instance.
   */
  fork(e, t) {
    var r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    return ql.from(e, t, Dl(Dl({}, this.options), r));
  }
  /**
   * Create new Canvg instance with inherited options.
   * @param ctx - Rendering context.
   * @param svg - SVG source string.
   * @param options - Rendering options.
   * @returns Canvg instance.
   */
  forkString(e, t) {
    var r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    return ql.fromString(e, t, Dl(Dl({}, this.options), r));
  }
  /**
   * Document is ready promise.
   * @returns Ready promise.
   */
  ready() {
    return this.screen.ready();
  }
  /**
   * Document is ready value.
   * @returns Is ready or not.
   */
  isReady() {
    return this.screen.isReady();
  }
  /**
   * Render only first frame, ignoring animations and mouse.
   * @param options - Rendering options.
   */
  render() {
    var e = arguments, t = this;
    return rA(function* () {
      var r = e.length > 0 && e[0] !== void 0 ? e[0] : {};
      t.start(Dl({
        enableRedraw: !0,
        ignoreAnimation: !0,
        ignoreMouse: !0
      }, r)), yield t.ready(), t.stop();
    })();
  }
  /**
   * Start rendering.
   * @param options - Render options.
   */
  start() {
    var e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, {
      documentElement: t,
      screen: r,
      options: n
    } = this;
    r.start(t, Dl(Dl({
      enableRedraw: !0
    }, n), e));
  }
  /**
   * Stop rendering.
   */
  stop() {
    this.screen.stop();
  }
  /**
   * Resize SVG to fit in given size.
   * @param width
   * @param height
   * @param preserveAspectRatio
   */
  resize(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : e, r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : !1;
    this.documentElement.resize(e, t, r);
  }
}
const $ye = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  AElement: wU,
  AnimateColorElement: gU,
  AnimateElement: Dy,
  AnimateTransformElement: pU,
  BoundingBox: ra,
  CB1: zC,
  CB2: XC,
  CB3: WC,
  CB4: YC,
  Canvg: ql,
  CircleElement: sU,
  ClipPathElement: SU,
  DefsElement: cU,
  DescElement: MU,
  Document: zo,
  Element: xi,
  EllipseElement: aU,
  FeColorMatrixElement: Qb,
  FeCompositeElement: LU,
  FeDropShadowElement: TU,
  FeGaussianBlurElement: IU,
  FeMorphologyElement: FU,
  FilterElement: Qg,
  Font: Kn,
  FontElement: mU,
  FontFaceElement: vU,
  GElement: Qy,
  GlyphElement: Mb,
  GradientElement: Ob,
  ImageElement: CU,
  LineElement: oU,
  LinearGradientElement: uU,
  MarkerElement: hU,
  MaskElement: Ug,
  Matrix: Ib,
  MissingGlyphElement: yU,
  Mouse: YO,
  PSEUDO_ZERO: ch,
  Parser: lm,
  PathElement: Or,
  PathParser: $t,
  PatternElement: lU,
  Point: Ti,
  PolygonElement: AU,
  PolylineElement: Pb,
  Property: yt,
  QB1: qC,
  QB2: ZC,
  QB3: JC,
  RadialGradientElement: fU,
  RectElement: Nb,
  RenderedElement: xl,
  Rotate: eU,
  SVGElement: Xu,
  SVGFontLoader: BU,
  Scale: tU,
  Screen: Pg,
  Skew: Rb,
  SkewX: rU,
  SkewY: iU,
  StopElement: dU,
  StyleElement: Ub,
  SymbolElement: EU,
  TRefElement: _U,
  TSpanElement: Og,
  TextElement: Cl,
  TextPathElement: xU,
  TitleElement: RU,
  Transform: vl,
  Translate: JO,
  UnknownElement: nU,
  UseElement: bU,
  ViewPort: WO,
  compressSpaces: Mh,
  default: ql,
  getSelectorSpecificity: XO,
  normalizeAttributeName: jO,
  normalizeColor: zO,
  parseExternalUrl: Lb,
  presets: _ye,
  toNumbers: ps,
  trimLeft: VO,
  trimRight: KO,
  vectorMagnitude: KC,
  vectorsAngle: jC,
  vectorsRatio: Tv
}, Symbol.toStringTag, { value: "Module" }));
export {
  tq as Animations,
  QW as Geometries,
  IY as Interactions,
  aj as Layers,
  v$ as Map,
  xW as MapControls,
  Fj as Sources,
  AY as Styles,
  qT as default,
  qT as install
};
