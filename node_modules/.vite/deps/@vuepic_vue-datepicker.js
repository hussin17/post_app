import {
  add,
  addDays,
  addMonths,
  addYears,
  differenceInCalendarDays,
  eachDayOfInterval,
  endOfWeek,
  format,
  getDay,
  getHours,
  getISOWeek,
  getMinutes,
  getMonth,
  getSeconds,
  getYear,
  isAfter,
  isBefore,
  isDate,
  isEqual,
  isValid,
  parse,
  set,
  setHours,
  setMilliseconds,
  setMinutes,
  setMonth,
  setSeconds,
  setYear,
  startOfWeek,
  sub,
  subMonths,
  subYears
} from "./chunk-3XGAISUZ.js";
import "./chunk-BYTJ6LW2.js";
import {
  Fragment,
  Teleport,
  Transition,
  computed,
  createBaseVNode,
  createBlock,
  createCommentVNode,
  createElementBlock,
  createSlots,
  createTextVNode,
  createVNode,
  defineComponent,
  getCurrentScope,
  guardReactiveProps,
  inject,
  isRef,
  mergeProps,
  nextTick,
  normalizeClass,
  normalizeProps,
  normalizeStyle,
  onBeforeUpdate,
  onMounted,
  onScopeDispose,
  onUnmounted,
  openBlock,
  provide,
  reactive,
  ref,
  renderList,
  renderSlot,
  resolveDynamicComponent,
  toDisplayString,
  toRef,
  unref,
  useSlots,
  watch,
  withCtx,
  withKeys,
  withModifiers
} from "./chunk-VBJ4LH5I.js";
import "./chunk-OROXOI2D.js";

// node_modules/@vuepic/vue-datepicker/dist/vue-datepicker.es.js
var ma = Object.defineProperty;
var pa = Object.defineProperties;
var va = Object.getOwnPropertyDescriptors;
var gn = Object.getOwnPropertySymbols;
var fa = Object.prototype.hasOwnProperty;
var ya = Object.prototype.propertyIsEnumerable;
var wn = (e, a, n) => a in e ? ma(e, a, { enumerable: true, configurable: true, writable: true, value: n }) : e[a] = n;
var X = (e, a) => {
  for (var n in a || (a = {}))
    fa.call(a, n) && wn(e, n, a[n]);
  if (gn)
    for (var n of gn(a))
      ya.call(a, n) && wn(e, n, a[n]);
  return e;
};
var De = (e, a) => pa(e, va(a));
var rt = (e, a) => {
  const n = e.__vccOpts || e;
  for (const [t, i] of a)
    n[t] = i;
  return n;
};
var _a = {};
var Va = { version: "1.1", xmlns: "http://www.w3.org/2000/svg", width: "32", height: "32", viewBox: "0 0 32 32", class: "dp__icon" };
var Ba = createBaseVNode("path", { d: "M29.333 8c0-2.208-1.792-4-4-4h-18.667c-2.208 0-4 1.792-4 4v18.667c0 2.208 1.792 4 4 4h18.667c2.208 0 4-1.792 4-4v-18.667zM26.667 8v18.667c0 0.736-0.597 1.333-1.333 1.333 0 0-18.667 0-18.667 0-0.736 0-1.333-0.597-1.333-1.333 0 0 0-18.667 0-18.667 0-0.736 0.597-1.333 1.333-1.333 0 0 18.667 0 18.667 0 0.736 0 1.333 0.597 1.333 1.333z" }, null, -1);
var Na = createBaseVNode("path", { d: "M20 2.667v5.333c0 0.736 0.597 1.333 1.333 1.333s1.333-0.597 1.333-1.333v-5.333c0-0.736-0.597-1.333-1.333-1.333s-1.333 0.597-1.333 1.333z" }, null, -1);
var Ia = createBaseVNode("path", { d: "M9.333 2.667v5.333c0 0.736 0.597 1.333 1.333 1.333s1.333-0.597 1.333-1.333v-5.333c0-0.736-0.597-1.333-1.333-1.333s-1.333 0.597-1.333 1.333z" }, null, -1);
var Ya = createBaseVNode("path", { d: "M4 14.667h24c0.736 0 1.333-0.597 1.333-1.333s-0.597-1.333-1.333-1.333h-24c-0.736 0-1.333 0.597-1.333 1.333s0.597 1.333 1.333 1.333z" }, null, -1);
var Fa = [Ba, Na, Ia, Ya];
function Ea(e, a) {
  return openBlock(), createElementBlock("svg", Va, Fa);
}
var Nt = rt(_a, [["render", Ea]]);
var La = {};
var Ha = { version: "1.1", xmlns: "http://www.w3.org/2000/svg", width: "32", height: "32", viewBox: "0 0 32 32", class: "dp__icon" };
var Ua = createBaseVNode("path", { d: "M23.057 7.057l-16 16c-0.52 0.52-0.52 1.365 0 1.885s1.365 0.52 1.885 0l16-16c0.52-0.52 0.52-1.365 0-1.885s-1.365-0.52-1.885 0z" }, null, -1);
var Ka = createBaseVNode("path", { d: "M7.057 8.943l16 16c0.52 0.52 1.365 0.52 1.885 0s0.52-1.365 0-1.885l-16-16c-0.52-0.52-1.365-0.52-1.885 0s-0.52 1.365 0 1.885z" }, null, -1);
var Wa = [Ua, Ka];
function ja(e, a) {
  return openBlock(), createElementBlock("svg", Ha, Wa);
}
var Ga = rt(La, [["render", ja]]);
var za = {};
var Xa = { version: "1.1", xmlns: "http://www.w3.org/2000/svg", width: "32", height: "32", viewBox: "0 0 32 32", class: "dp__icon" };
var qa = createBaseVNode("path", { d: "M20.943 23.057l-7.057-7.057c0 0 7.057-7.057 7.057-7.057 0.52-0.52 0.52-1.365 0-1.885s-1.365-0.52-1.885 0l-8 8c-0.521 0.521-0.521 1.365 0 1.885l8 8c0.52 0.52 1.365 0.52 1.885 0s0.52-1.365 0-1.885z" }, null, -1);
var Ja = [qa];
function Za(e, a) {
  return openBlock(), createElementBlock("svg", Xa, Ja);
}
var An = rt(za, [["render", Za]]);
var Qa = {};
var xa = { version: "1.1", xmlns: "http://www.w3.org/2000/svg", width: "32", height: "32", viewBox: "0 0 32 32", class: "dp__icon" };
var el = createBaseVNode("path", { d: "M12.943 24.943l8-8c0.521-0.521 0.521-1.365 0-1.885l-8-8c-0.52-0.52-1.365-0.52-1.885 0s-0.52 1.365 0 1.885l7.057 7.057c0 0-7.057 7.057-7.057 7.057-0.52 0.52-0.52 1.365 0 1.885s1.365 0.52 1.885 0z" }, null, -1);
var tl = [el];
function nl(e, a) {
  return openBlock(), createElementBlock("svg", xa, tl);
}
var Tn = rt(Qa, [["render", nl]]);
var al = {};
var ll = { version: "1.1", xmlns: "http://www.w3.org/2000/svg", width: "32", height: "32", viewBox: "0 0 32 32", class: "dp__icon" };
var rl = createBaseVNode("path", { d: "M16 1.333c-8.095 0-14.667 6.572-14.667 14.667s6.572 14.667 14.667 14.667c8.095 0 14.667-6.572 14.667-14.667s-6.572-14.667-14.667-14.667zM16 4c6.623 0 12 5.377 12 12s-5.377 12-12 12c-6.623 0-12-5.377-12-12s5.377-12 12-12z" }, null, -1);
var ol = createBaseVNode("path", { d: "M14.667 8v8c0 0.505 0.285 0.967 0.737 1.193l5.333 2.667c0.658 0.329 1.46 0.062 1.789-0.596s0.062-1.46-0.596-1.789l-4.596-2.298c0 0 0-7.176 0-7.176 0-0.736-0.597-1.333-1.333-1.333s-1.333 0.597-1.333 1.333z" }, null, -1);
var sl = [rl, ol];
function ul(e, a) {
  return openBlock(), createElementBlock("svg", ll, sl);
}
var Rn = rt(al, [["render", ul]]);
var il = {};
var dl = { version: "1.1", xmlns: "http://www.w3.org/2000/svg", width: "32", height: "32", viewBox: "0 0 32 32", class: "dp__icon" };
var cl = createBaseVNode("path", { d: "M24.943 19.057l-8-8c-0.521-0.521-1.365-0.521-1.885 0l-8 8c-0.52 0.52-0.52 1.365 0 1.885s1.365 0.52 1.885 0l7.057-7.057c0 0 7.057 7.057 7.057 7.057 0.52 0.52 1.365 0.52 1.885 0s0.52-1.365 0-1.885z" }, null, -1);
var ml = [cl];
function pl(e, a) {
  return openBlock(), createElementBlock("svg", dl, ml);
}
var On = rt(il, [["render", pl]]);
var vl = {};
var fl = { version: "1.1", xmlns: "http://www.w3.org/2000/svg", width: "32", height: "32", viewBox: "0 0 32 32", class: "dp__icon" };
var yl = createBaseVNode("path", { d: "M7.057 12.943l8 8c0.521 0.521 1.365 0.521 1.885 0l8-8c0.52-0.52 0.52-1.365 0-1.885s-1.365-0.52-1.885 0l-7.057 7.057c0 0-7.057-7.057-7.057-7.057-0.52-0.52-1.365-0.52-1.885 0s-0.52 1.365 0 1.885z" }, null, -1);
var hl = [yl];
function gl(e, a) {
  return openBlock(), createElementBlock("svg", fl, hl);
}
var _n = rt(vl, [["render", gl]]);
var Jt = (e, a) => {
  const n = parse(e, a.slice(0, e.length), new Date());
  return isValid(n) && isDate(n) ? n : null;
};
var Le = (e) => {
  let a = new Date(JSON.parse(JSON.stringify(e)));
  return a = setHours(a, 0), a = setMinutes(a, 0), a = setSeconds(a, 0), a = setMilliseconds(a, 0), a;
};
var Zt = (e) => Array.isArray(e) ? isValid(e[0]) && (e[1] ? isValid(e[1]) : true) : e ? isValid(e) : false;
var Pe = (e, a, n, t) => {
  let i = e ? new Date(e) : new Date();
  return (a || a === 0) && (i = setHours(i, +a)), (n || n === 0) && (i = setMinutes(i, +n)), (t || t === 0) && (i = setSeconds(i, +t)), setMilliseconds(i, 0);
};
var wl = (e) => {
  const a = addMonths(e, 1);
  return { month: getMonth(a), year: getYear(a) };
};
var ot = (e, a, n) => {
  let t = e ? new Date(e) : new Date();
  return (a || a === 0) && (t = setMonth(t, a)), n && (t = setYear(t, n)), t;
};
var Vn = (e, a) => e ? `HH:mm${a ? ":ss" : ""}` : `hh:mm${a ? ":ss" : ""} aa`;
var Bn = (e, a, n, t, i, p, v, f) => e || (t ? "MM/yyyy" : i ? Vn(a, n) : p ? "MM/dd/yyyy" : v ? "yyyy" : f ? `MM/dd/yyyy, ${Vn(a, n)}` : "MM/dd/yyyy");
var Qt = (e) => {
  const a = e || new Date();
  return { hours: getHours(a), minutes: getMinutes(a), seconds: getSeconds(a) };
};
var It = (e) => ({ month: getMonth(e), year: getYear(e) });
var Nn = (e) => Array.isArray(e) ? [It(e[0]), e[1] ? It(e[1]) : null] : It(e);
var xt = (e) => Array.isArray(e) ? [Qt(e[0]), Qt(e[1])] : Qt(e);
var en = (e, a, n) => n ? format(e, a, { locale: n }) : format(e, a);
var Yt = (e, a, n, t) => Array.isArray(e) ? `${en(e[0], a, n)} ${t || "-"} ${e[1] ? en(e[1], a, n) : ""}` : en(e, a, n);
var Ae = (e, a) => !e || !a ? false : isAfter(Le(e), Le(a));
var be = (e, a) => !e || !a ? false : isBefore(Le(e), Le(a));
var de = (e, a) => !e || !a ? false : isEqual(Le(e), Le(a));
var kl = (e, a) => add(set(new Date(), e), a);
var bl = (e, a) => sub(set(new Date(), e), a);
var tn = (e) => set(new Date(), { hours: getHours(e), minutes: getMinutes(e), seconds: getSeconds(e) });
var In = (e) => set(new Date(), { hours: +e.hours || 0, minutes: +e.minutes || 0, seconds: +e.seconds || 0 });
var nn = (e, a, n) => {
  let t = true;
  if (!e)
    return true;
  const i = Array.isArray(e) ? [e[0] ? tn(e[0]) : null, e[1] ? tn(e[1]) : null] : tn(e);
  if (a) {
    const p = In(a);
    Array.isArray(i) ? t = (i[0] ? i[0].getTime() <= p.getTime() : true) && (i[1] ? i[1].getTime() <= p.getTime() : true) : t = i.getTime() <= p.getTime();
  }
  if (n) {
    const p = In(n);
    Array.isArray(i) ? t = (i[0] ? i[0].getTime() >= p.getTime() : true) && (i[1] ? i[1].getTime() >= p.getTime() : true) && t : t = i.getTime() >= p.getTime() && t;
  }
  return t;
};
var $l = (e, a, n) => {
  let t = true;
  return a && n && (t = Ae(new Date(e), new Date(a)) && be(new Date(e), new Date(n))), a && (t = Ae(new Date(e), new Date(a))), n && (t = be(new Date(e), new Date(n))), t;
};
var Re = (e) => {
  const a = Date.UTC(e.getUTCFullYear(), e.getUTCMonth(), e.getUTCDate(), e.getUTCHours(), e.getUTCMinutes(), e.getUTCSeconds());
  return new Date(a).toISOString();
};
var Yn = (e, a, n) => e && e[0] && e[1] ? Ae(n, e[0]) && be(n, e[1]) : e && e[0] && a ? Ae(n, e[0]) && be(n, a) || be(n, e[0]) && Ae(n, a) : false;
var Ft = (e, a) => {
  const n = startOfWeek(e, { weekStartsOn: a }), t = endOfWeek(e, { weekStartsOn: a });
  return [n, t];
};
var Dl = (e, a, n, t, i, p, v, f) => {
  const h = n ? Ae(Re(e), Re(new Date(n))) : false, T = a ? be(Re(e), Re(new Date(a))) : false, N = typeof t == "function" ? t(e) : t.some((C) => de(Re(new Date(C)), Re(e))), g = (p.months.length ? p.months.map((C) => +C) : []).includes(getMonth(e)), R = v.length ? v.some((C) => +C === getDay(e)) : false, E = i.length ? !i.some((C) => de(Re(new Date(C)), Re(e))) : false, B = getYear(e), Y = B < +f[0] || B > +f[1];
  return !(h || T || N || g || Y || R || E);
};
var Fn = (e, a, n, t, i, p, v) => ({ validate: (f) => Dl(f, e, a, n, t, i, p, v) });
var Ml = (e, a, n) => {
  const t = new Date(JSON.parse(JSON.stringify(e))), i = [];
  for (let p = 0; p < 7; p++) {
    const v = addDays(t, p), f = getMonth(v) !== a;
    i.push({ text: n && f ? "" : v.getDate(), value: v, current: !f });
  }
  return i;
};
var Sl = (e, a, n, t) => {
  const i = [], p = new Date(a, e), v = new Date(a, e + 1, 0), f = startOfWeek(p, { weekStartsOn: n }), h = (T) => {
    const N = Ml(T, e, t);
    if (i.push({ days: N }), !i[i.length - 1].days.some((g) => de(Le(g.value), Le(v)))) {
      const g = addDays(T, 7);
      h(g);
    }
  };
  return h(f), i;
};
var Pl = (e, a = 3) => {
  const n = [];
  for (let t = 0; t < e.length; t += a)
    n.push([e[t], e[t + 1], e[t + 2]]);
  return n;
};
var Cl = (e, a) => {
  const n = [1, 2, 3, 4, 5, 6, 7].map((p) => new Intl.DateTimeFormat(e, { weekday: "short", timeZone: "UTC" }).format(new Date(`2017-01-0${p}T00:00:00+00:00`)).slice(0, 2)), t = n.slice(0, a), i = n.slice(a + 1, n.length);
  return [n[a]].concat(...i).concat(...t);
};
var Al = (e) => {
  const a = [];
  for (let n = +e[0]; n <= +e[1]; n++)
    a.push({ value: +n, text: `${n}` });
  return a;
};
var Tl = (e, a) => {
  const n = new Intl.DateTimeFormat(e, { month: a, timeZone: "UTC" });
  return [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12].map((t) => {
    const i = t < 10 ? `0${t}` : t;
    return new Date(`2017-${i}-01T00:00:00+00:00`);
  }).map((t, i) => ({ text: n.format(t), value: i }));
};
var Rl = (e) => [12, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11][e];
var Ol = () => ({ enterSubmit: true, tabSubmit: true, openMenu: true, rangeSeparator: " - " });
var _l = (e) => Object.assign({ months: [], years: [], times: { hours: [], minutes: [], seconds: [] } }, e);
var Vl = (e) => {
  function a(n) {
    let t = "";
    const i = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789", p = i.length;
    for (let v = 0; v < n; v++)
      t += i.charAt(Math.floor(Math.random() * p));
    return t + e;
  }
  return a(5);
};
var he = (e) => {
  var n;
  const a = unref(e);
  return (n = a == null ? void 0 : a.$el) != null ? n : a;
};
var Bl = (e) => Object.assign({ type: "dot" }, e);
var En = (e) => Object.assign({ menuAppear: "dp-menu-appear", open: "dp-slide-down", close: "dp-slide-up", next: "calendar-next", previous: "calendar-prev", vNext: "dp-slide-up", vPrevious: "dp-slide-down" }, e);
var Nl = (e) => Object.assign({ toggleOverlay: "Toggle overlay", menu: "Datepicker menu", input: "Datepicker input", calendarWrap: "Calendar wrapper", calendarDays: "Calendar days", openTimePicker: "Open time picker", closeTimePicker: "Close time Picker", incrementValue: (a) => `Increment ${a}`, decrementValue: (a) => `Decrement ${a}`, openTpOverlay: (a) => `Open ${a} overlay`, amPmButton: "Switch AM/PM mode", openYearsOverlay: "Open years overlay", openMonthsOverlay: "Open months overlay", nextMonth: "Next month", prevMonth: "Previous month" }, e);
var Xe = Symbol();
var Et = Symbol();
var an = Symbol();
var Ln = Symbol();
var Hn = Symbol();
var qe = Symbol();
var ln = { disabled: { type: Boolean, default: false }, readonly: { type: Boolean, default: false }, autoApply: { type: Boolean, default: false }, inline: { type: Boolean, default: false }, textInput: { type: Boolean, default: false } };
var rn = { range: { type: Boolean, default: false }, uid: { type: String, default: null } };
var Un = { enableSeconds: { type: Boolean, default: false }, is24: { type: Boolean, default: true }, noHoursOverlay: { type: Boolean, default: false }, noMinutesOverlay: { type: Boolean, default: false }, noSecondsOverlay: { type: Boolean, default: false }, hoursGridIncrement: { type: [String, Number], default: 1 }, minutesGridIncrement: { type: [String, Number], default: 5 }, secondsGridIncrement: { type: [String, Number], default: 5 }, hoursIncrement: { type: [Number, String], default: 1 }, minutesIncrement: { type: [Number, String], default: 1 }, secondsIncrement: { type: [Number, String], default: 1 } };
var Kn = De(X({}, Un), { fixedStart: { type: Boolean, default: false }, fixedEnd: { type: Boolean, default: false }, timePicker: { type: Boolean, default: false } });
var Wn = { name: { type: String, default: null }, placeholder: { type: String, default: "" }, hideInputIcon: { type: Boolean, default: false }, clearable: { type: Boolean, default: true }, state: { type: Boolean, default: null }, required: { type: Boolean, default: false }, autocomplete: { type: String, default: "off" }, inputClassName: { type: String, default: null }, inlineWithInput: { type: Boolean, default: false }, textInputOptions: { type: Object, default: () => null }, openMenuOnFocus: { type: Boolean, default: true } };
var jn = { minTime: { type: Object, default: null }, maxTime: { type: Object, default: null } };
var on = { minDate: { type: [Date, String], default: null }, maxDate: { type: [Date, String], default: null } };
var Gn = X({ selectText: { type: String, default: "Select" }, cancelText: { type: String, default: "Cancel" }, previewFormat: { type: [String, Function], default: () => "" }, multiDates: { type: Boolean, default: false } }, jn);
var sn = { monthPicker: { type: Boolean, default: false }, customProps: { type: Object, default: null }, yearPicker: { type: Boolean, default: false } };
var zn = { locale: { type: String, default: "en-Us" }, weekNumName: { type: String, default: "W" }, weekStart: { type: [Number, String], default: 1 }, weekNumbers: { type: Boolean, default: false }, calendarClassName: { type: String, default: null }, noSwipe: { type: Boolean, default: false } };
var Xn = De(X(X(X(X(X(X({}, Kn), Gn), sn), on), zn), rn), { vertical: { type: Boolean, default: false }, disableMonthYearSelect: { type: Boolean, default: false }, menuClassName: { type: String, default: null }, yearRange: { type: Array, default: () => [1900, 2100] }, multiCalendarsSolo: { type: Boolean, default: false }, calendarCellClassName: { type: String, default: null }, enableTimePicker: { type: Boolean, default: true }, autoApply: { type: Boolean, default: false }, disabledDates: { type: [Array, Function], default: () => [] }, monthNameFormat: { type: String, default: "short" }, startDate: { type: [Date, String], default: null }, startTime: { type: [Object, Array], default: null }, monthYearComponent: { type: Object, default: null }, timePickerComponent: { type: Object, default: null }, actionRowComponent: { type: Object, default: null }, hideOffsetDates: { type: Boolean, default: false }, autoRange: { type: [Number, String], default: null }, noToday: { type: Boolean, default: false }, disabledWeekDays: { type: Array, default: () => [] }, allowedDates: { type: Array, default: () => [] }, showNowButton: { type: Boolean, default: false }, nowButtonLabel: { type: String, default: "Now" }, monthChangeOnScroll: { type: [Boolean, String], default: true }, markers: { type: Array, default: () => [] }, modeHeight: { type: [Number, String], default: 255 }, escClose: { type: Boolean, default: true }, spaceConfirm: { type: Boolean, default: true }, monthChangeOnArrows: { type: Boolean, default: true }, presetRanges: { type: Array, default: () => [] }, flow: { type: Array, default: () => [] }, preventMinMaxNavigation: { type: Boolean, default: false }, minRange: { type: [Number, String], default: null }, maxRange: { type: [Number, String], default: null }, multiDatesLimit: { type: [Number, String], default: null }, reverseYears: { type: Boolean, default: false }, keepActionRow: { type: Boolean, default: false }, weekPicker: { type: Boolean, default: false }, filters: { type: Object, default: () => ({}) }, arrowNavigation: { type: Boolean, default: false }, multiStatic: { type: Boolean, default: true } });
var Il = De(X(X(X({}, Wn), ln), Xn), { multiCalendars: { type: [Boolean, Number, String], default: null }, modelValue: { type: [String, Date, Array, Object, Number], default: null }, position: { type: String, default: "center" }, dark: { type: Boolean, default: false }, format: { type: [String, Function], default: () => null }, closeOnScroll: { type: Boolean, default: false }, autoPosition: { type: Boolean, default: true }, closeOnAutoApply: { type: Boolean, default: true }, teleport: { type: [String, Object], default: "body" }, altPosition: { type: [Boolean, Function], default: false }, partialRange: { type: Boolean, default: true }, transitions: { type: [Boolean, Object], default: true }, formatLocale: { type: Object, default: null }, utc: { type: Boolean, default: false }, ariaLabels: { type: Object, default: () => ({}) } });
var qn = { range: { type: Boolean, default: false }, multiCalendars: { type: Number, default: 0 }, internalModelValue: { type: [Date, Array], default: null } };
var Jn = De(X(X({}, sn), qn), { vertical: { type: Boolean, default: false }, month: { type: Number, default: 0 }, year: { type: Number, default: 0 }, instance: { type: Number, default: 1 } });
var Lt = reactive({ menuFocused: false, shiftKeyInMenu: false });
var un = () => ({ setMenuFocused: (e) => {
  Lt.menuFocused = e;
}, getStore: () => Lt, setShiftKey: (e) => {
  Lt.shiftKeyInMenu !== e && (Lt.shiftKeyInMenu = e);
} });
var Yl = ["aria-label", "aria-disabled", "aria-readonly"];
var Fl = { key: 1, class: "dp__input_wrap" };
var El = ["id", "name", "placeholder", "disabled", "readonly", "required", "value", "autocomplete", "onKeydown"];
var Ll = { key: 4, class: "dp__clear_icon" };
var Hl = defineComponent({ props: De(X(X(X({}, Wn), ln), rn), { inputValue: { type: String, default: "" }, inline: { type: Boolean, default: false }, isMenuOpen: { type: Boolean, default: false }, pattern: { type: String, default: "" } }), emits: ["clear", "open", "update:inputValue", "setInputDate", "close", "selectDate", "setEmptyDate", "toggle", "focus-prev"], setup(e, { expose: a, emit: n }) {
  const t = e, i = ref(), p = ref(null), v = ref(false), f = inject(Xe), h = useSlots(), { getStore: T } = un(), N = computed(() => ({ dp__pointer: !t.disabled && !t.readonly && !t.textInput, dp__disabled: t.disabled, dp__input: true, dp__input_icon_pad: !t.hideInputIcon, dp__input_valid: t.state, dp__input_invalid: t.state === false, dp__input_focus: v.value || t.isMenuOpen, [t.inputClassName]: !!t.inputClassName })), g = (l) => {
    const { value: $ } = l.target, { format: U, rangeSeparator: Z } = t.textInputOptions;
    if ($ !== "") {
      if (t.range) {
        const [ae, le] = $.split(`${Z}`);
        if (ae && le) {
          const x = Jt(ae.trim(), U || t.pattern), se = Jt(le.trim(), U || t.pattern);
          i.value = x && se ? [x, se] : null;
        }
      } else
        i.value = Jt($, U || t.pattern);
      n("setInputDate", i.value);
    } else
      n("setInputDate", null), t.autoApply && (n("setEmptyDate"), i.value = null);
    n("update:inputValue", $);
  }, R = () => {
    var l, $;
    ((l = t.textInputOptions) == null ? void 0 : l.enterSubmit) && Zt(i.value) && t.inputValue !== "" ? (n("setInputDate", i.value, true), i.value = null) : (($ = t.textInputOptions) == null ? void 0 : $.enterSubmit) && t.inputValue === "" && (i.value = null, n("clear"));
  }, E = () => {
    var l, $;
    ((l = t.textInputOptions) == null ? void 0 : l.tabSubmit) && Zt(i.value) && t.inputValue !== "" ? (n("setInputDate", i.value, true), i.value = null) : (($ = t.textInputOptions) == null ? void 0 : $.tabSubmit) && t.inputValue === "" && (i.value = null, n("clear")), n("close");
  }, B = () => {
    var l;
    if (T().shiftKeyInMenu && t.openMenuOnFocus)
      return n("close"), n("focus-prev");
    !t.inline && (t.textInput ? t.textInput && ((l = t.textInputOptions) == null ? void 0 : l.openMenu) : true) && (v.value = true, t.openMenuOnFocus && !t.isMenuOpen ? n("open") : t.isMenuOpen && !T().menuFocused && (j(), n("close")));
  }, Y = () => {
    var l;
    !t.openMenuOnFocus || h["dp-input"] || h.trigger ? t.textInput && ((l = t.textInputOptions) == null ? void 0 : l.openMenu) && !t.isMenuOpen ? n("open") : t.textInput || n("toggle") : t.textInput || v.value && n("toggle");
  }, C = () => {
    v.value = false, t.autoApply && t.textInput && i.value && (n("setInputDate", i.value), n("selectDate"), i.value = null);
  }, s = () => {
    n("clear");
  }, j = () => {
    v.value = false;
    const l = he(p);
    l && l.blur();
  };
  return a({ unFocus: j }), (l, $) => (openBlock(), createElementBlock("div", { onClick: Y, "aria-label": unref(f).input, role: "textbox", "aria-multiline": "false", "aria-disabled": l.disabled, "aria-readonly": l.readonly }, [l.$slots.trigger && !l.$slots["dp-input"] && !e.inline ? renderSlot(l.$slots, "trigger", { key: 0 }) : createCommentVNode("", true), !l.$slots.trigger && (!e.inline || l.inlineWithInput) ? (openBlock(), createElementBlock("div", Fl, [l.$slots["dp-input"] && !l.$slots.trigger && !e.inline ? renderSlot(l.$slots, "dp-input", { key: 0, value: e.inputValue, onInput: g, onEnter: R, onTab: E, onClear: s }) : createCommentVNode("", true), l.$slots["dp-input"] ? createCommentVNode("", true) : (openBlock(), createElementBlock("input", { key: 1, ref_key: "inputRef", ref: p, id: l.uid ? `dp-input-${l.uid}` : void 0, name: l.name, class: normalizeClass(unref(N)), placeholder: l.placeholder, disabled: l.disabled, readonly: l.readonly || !l.textInput, required: l.required, value: e.inputValue, autocomplete: l.autocomplete, onInput: g, onKeydown: [withKeys(R, ["enter"]), withKeys(E, ["tab"])], onBlur: C, onFocus: B }, null, 42, El)), l.$slots["input-icon"] && !l.hideInputIcon ? (openBlock(), createElementBlock("span", { key: 2, class: "dp__input_icon", onClick: $[0] || ($[0] = (U) => n("toggle")) }, [renderSlot(l.$slots, "input-icon")])) : createCommentVNode("", true), !l.$slots["input-icon"] && !l.hideInputIcon && !l.$slots["dp-input"] ? (openBlock(), createBlock(unref(Nt), { key: 3, class: "dp__input_icon dp__input_icons", onClick: $[1] || ($[1] = (U) => n("toggle")) })) : createCommentVNode("", true), l.$slots["clear-icon"] && e.inputValue && l.clearable && !l.disabled && !l.readonly ? (openBlock(), createElementBlock("span", Ll, [renderSlot(l.$slots, "clear-icon", { clear: s })])) : createCommentVNode("", true), l.clearable && !l.$slots["clear-icon"] && e.inputValue && !l.disabled && !l.readonly ? (openBlock(), createBlock(unref(Ga), { key: 5, class: "dp__clear_icon dp__input_icons", onClick: withModifiers(s, ["stop", "prevent"]) }, null, 8, ["onClick"])) : createCommentVNode("", true)])) : createCommentVNode("", true)], 8, Yl));
} });
var ie = reactive({ monthYear: [], calendar: [], time: [], actionRow: [], selectionGrid: [], timePicker: { "0": [], "1": [] }, monthPicker: [] });
var dn = ref(null);
var Ht = ref(false);
var cn = ref(false);
var mn = ref(false);
var pn = ref(false);
var $e = ref(0);
var we = ref(0);
var Je = () => {
  const e = computed(() => Ht.value ? [...ie.selectionGrid, ie.actionRow].filter((g) => g.length) : cn.value ? [...ie.timePicker[0], ...ie.timePicker[1], pn.value ? [] : [dn.value], ie.actionRow].filter((g) => g.length) : mn.value ? [...ie.monthPicker, ie.actionRow] : [ie.monthYear, ...ie.calendar, ie.time, ie.actionRow].filter((g) => g.length)), a = (g) => {
    $e.value = g ? $e.value + 1 : $e.value - 1;
    let R = null;
    e.value[we.value] && (R = e.value[we.value][$e.value]), R || ($e.value = g ? $e.value - 1 : $e.value + 1);
  }, n = (g) => {
    we.value === 0 && !g || we.value === e.value.length && g || (we.value = g ? we.value + 1 : we.value - 1, e.value[we.value] ? e.value[we.value] && !e.value[we.value][$e.value] && $e.value !== 0 && ($e.value = e.value[we.value].length - 1) : we.value = g ? we.value - 1 : we.value + 1);
  }, t = (g) => {
    let R = null;
    e.value[we.value] && (R = e.value[we.value][$e.value]), R ? R.focus({ preventScroll: !Ht.value }) : $e.value = g ? $e.value - 1 : $e.value + 1;
  }, i = () => {
    a(true), t(true);
  }, p = () => {
    a(false), t(false);
  }, v = () => {
    n(false), t(true);
  }, f = () => {
    n(true), t(true);
  }, h = (g, R) => {
    ie[R] = g;
  }, T = (g, R) => {
    ie[R] = g;
  }, N = () => {
    $e.value = 0, we.value = 0;
  };
  return { buildMatrix: h, buildMultiLevelMatrix: T, setTimePickerBackRef: (g) => {
    dn.value = g;
  }, setSelectionGrid: (g) => {
    Ht.value = g, N(), g || (ie.selectionGrid = []);
  }, setTimePicker: (g, R = false) => {
    cn.value = g, pn.value = R, N(), g || (ie.timePicker[0] = [], ie.timePicker[1] = []);
  }, setTimePickerElements: (g, R = 0) => {
    ie.timePicker[R] = g;
  }, arrowRight: i, arrowLeft: p, arrowUp: v, arrowDown: f, clearArrowNav: () => {
    ie.monthYear = [], ie.calendar = [], ie.time = [], ie.actionRow = [], ie.selectionGrid = [], ie.timePicker[0] = [], ie.timePicker[1] = [], Ht.value = false, cn.value = false, pn.value = false, mn.value = false, N(), dn.value = null;
  }, setMonthPicker: (g) => {
    mn.value = g, N();
  } };
};
var Ul = ["aria-label"];
var Kl = { class: "dp__calendar_header", role: "row" };
var Wl = { key: 0, class: "dp__calendar_header_item", role: "gridcell" };
var jl = createBaseVNode("div", { class: "dp__calendar_header_separator" }, null, -1);
var Gl = ["aria-label"];
var zl = { key: 0, role: "gridcell", class: "dp__calendar_item dp__week_num" };
var Xl = { class: "dp__cell_inner" };
var ql = ["aria-selected", "aria-disabled", "onClick", "onKeydown", "onMouseover"];
var Jl = createBaseVNode("div", { class: "dp__arrow_bottom_tp" }, null, -1);
var Zl = defineComponent({ props: De(X(X({}, Jn), zn), { mappedDates: { type: Array, default: () => [] }, getWeekNum: { type: Function, default: () => "" }, modeHeight: { type: [Number, String], default: 255 }, specificMode: { type: Boolean, default: false } }), emits: ["selectDate", "setHoverDate", "handleScroll", "mount", "handleSwipe"], setup(e, { expose: a, emit: n }) {
  const t = e, i = ref(null), p = ref({ bottom: "", left: "", transform: "" }), v = ref([]), f = ref(null), h = ref(true), T = inject(Et), N = inject(Xe), g = inject(qe), R = ref(""), E = ref({ startX: 0, endX: 0, startY: 0, endY: 0 }), B = computed(() => Cl(t.locale, +t.weekStart)), { buildMultiLevelMatrix: Y } = Je();
  onMounted(() => {
    n("mount", { cmp: "calendar", refs: v }), t.noSwipe || f.value && (f.value.addEventListener("touchstart", le), f.value.addEventListener("touchend", x), f.value.addEventListener("touchmove", se));
  });
  const C = (u, D) => {
    if (T != null && T.value) {
      const S = Le(ot(new Date(), t.month, t.year));
      R.value = Ae(Le(ot(new Date(), u, D)), S) ? T.value[t.vertical ? "vNext" : "next"] : T.value[t.vertical ? "vPrevious" : "previous"], h.value = false, nextTick(() => {
        h.value = true;
      });
    }
  }, s = computed(() => ({ dp__calendar_wrap: true, [t.calendarClassName]: !!t.calendarClassName })), j = computed(() => (u) => {
    const D = Bl(u);
    return { dp__marker_dot: D.type === "dot", dp__marker_line: D.type === "line" };
  }), l = computed(() => (u) => de(u, i.value)), $ = computed(() => ({ dp__calendar: true, dp__calendar_next: t.multiCalendars > 0 && t.instance !== 0 })), U = computed(() => t.specificMode ? { height: `${t.modeHeight}px` } : null), Z = (u, D, S) => {
    var G, F;
    if (n("setHoverDate", u), (F = (G = u.marker) == null ? void 0 : G.tooltip) != null && F.length) {
      const ne = he(v.value[D][S]);
      if (ne) {
        const { width: Q, height: w } = ne.getBoundingClientRect();
        p.value = { bottom: `${w}px`, left: `${Q / 2}px`, transform: "translateX(-50%)" }, i.value = u.value;
      }
    }
  }, ae = () => {
    i.value = null;
  }, le = (u) => {
    E.value.startX = u.changedTouches[0].screenX, E.value.startY = u.changedTouches[0].screenY;
  }, x = (u) => {
    E.value.endX = u.changedTouches[0].screenX, E.value.endY = u.changedTouches[0].screenY, d();
  }, se = (u) => {
    u.preventDefault();
  }, d = () => {
    const u = t.vertical ? "Y" : "X";
    Math.abs(E.value[`start${u}`] - E.value[`end${u}`]) > 10 && n("handleSwipe", E.value[`start${u}`] > E.value[`end${u}`] ? "right" : "left");
  }, I = (u, D, S) => {
    u && (Array.isArray(v.value[D]) ? v.value[D][S] = u : v.value[D] = [u]), g != null && g.value && Y(v.value, "calendar");
  };
  return a({ triggerTransition: C }), (u, D) => (openBlock(), createElementBlock("div", { class: normalizeClass(unref($)) }, [createBaseVNode("div", { style: normalizeStyle(unref(U)) }, [e.specificMode ? createCommentVNode("", true) : (openBlock(), createElementBlock("div", { key: 0, ref_key: "calendarWrapRef", ref: f, class: normalizeClass(unref(s)), role: "grid", "aria-label": unref(N).calendarWrap, onWheel: D[1] || (D[1] = withModifiers((S) => u.$emit("handleScroll", S), ["prevent"])) }, [createBaseVNode("div", Kl, [u.weekNumbers ? (openBlock(), createElementBlock("div", Wl, toDisplayString(u.weekNumName), 1)) : createCommentVNode("", true), (openBlock(true), createElementBlock(Fragment, null, renderList(unref(B), (S, G) => (openBlock(), createElementBlock("div", { class: "dp__calendar_header_item", role: "gridcell", key: G }, [u.$slots["calendar-header"] ? renderSlot(u.$slots, "calendar-header", { key: 0, day: S, index: G }) : createCommentVNode("", true), u.$slots["calendar-header"] ? createCommentVNode("", true) : (openBlock(), createElementBlock(Fragment, { key: 1 }, [createTextVNode(toDisplayString(S), 1)], 64))]))), 128))]), jl, createVNode(Transition, { name: R.value, css: !!unref(T) }, { default: withCtx(() => [h.value ? (openBlock(), createElementBlock("div", { key: 0, class: "dp__calendar", role: "grid", "aria-label": unref(N).calendarDays }, [(openBlock(true), createElementBlock(Fragment, null, renderList(e.mappedDates, (S, G) => (openBlock(), createElementBlock("div", { class: "dp__calendar_row", role: "row", key: G }, [u.weekNumbers ? (openBlock(), createElementBlock("div", zl, [createBaseVNode("div", Xl, toDisplayString(e.getWeekNum(S.days)), 1)])) : createCommentVNode("", true), (openBlock(true), createElementBlock(Fragment, null, renderList(S.days, (F, ne) => (openBlock(), createElementBlock("div", { role: "gridcell", class: "dp__calendar_item", ref_for: true, ref: (Q) => I(Q, G, ne), key: ne + G, "aria-selected": F.classData.dp__active_date || F.classData.dp__range_start || F.classData.dp__range_start, "aria-disabled": F.classData.dp__cell_disabled, tabindex: "0", onClick: withModifiers((Q) => u.$emit("selectDate", F), ["stop", "prevent"]), onKeydown: withKeys((Q) => u.$emit("selectDate", F), ["enter"]), onMouseover: (Q) => Z(F, G, ne), onMouseleave: ae }, [createBaseVNode("div", { class: normalizeClass(["dp__cell_inner", F.classData]) }, [u.$slots.day ? renderSlot(u.$slots, "day", { key: 0, day: +F.text, date: F.value }) : createCommentVNode("", true), u.$slots.day ? createCommentVNode("", true) : (openBlock(), createElementBlock(Fragment, { key: 1 }, [createTextVNode(toDisplayString(F.text), 1)], 64)), F.marker ? (openBlock(), createElementBlock("div", { key: 2, class: normalizeClass(unref(j)(F.marker)), style: normalizeStyle(F.marker.color ? { backgroundColor: F.marker.color } : {}) }, null, 6)) : createCommentVNode("", true), unref(l)(F.value) ? (openBlock(), createElementBlock("div", { key: 3, class: "dp__marker_tooltip", style: normalizeStyle(p.value) }, [createBaseVNode("div", { class: "dp__tooltip_content", onClick: D[0] || (D[0] = withModifiers(() => {
  }, ["stop"])) }, [(openBlock(true), createElementBlock(Fragment, null, renderList(F.marker.tooltip, (Q, w) => (openBlock(), createElementBlock("div", { key: w, class: "dp__tooltip_text" }, [u.$slots["marker-tooltip"] ? renderSlot(u.$slots, "marker-tooltip", { key: 0, tooltop: Q, day: F.value }) : createCommentVNode("", true), u.$slots["marker-tooltip"] ? createCommentVNode("", true) : (openBlock(), createElementBlock(Fragment, { key: 1 }, [createBaseVNode("div", { class: "dp__tooltip_mark", style: normalizeStyle(Q.color ? { backgroundColor: Q.color } : {}) }, null, 4), createBaseVNode("div", null, toDisplayString(Q.text), 1)], 64))]))), 128)), Jl])], 4)) : createCommentVNode("", true)], 2)], 40, ql))), 128))]))), 128))], 8, Gl)) : createCommentVNode("", true)]), _: 3 }, 8, ["name", "css"])], 42, Ul))], 4)], 2));
} });
var Ql = (e) => typeof e == "object";
var Zn = (e, a) => a;
var xl = (e) => Array.isArray(e) && e.length === 2;
var er = (e) => Array.isArray(e);
var tr = (e) => typeof e == "object";
var Dt = (e) => Array.isArray(e);
var Ie = (e) => Array.isArray(e);
var Ut = (e) => Array.isArray(e) && e.length === 2;
var nr = (e, a) => a ? Array.isArray(e) : Ut(e);
var ar = (e) => Array.isArray(e);
var lr = (e) => typeof e == "string" || typeof e == "object";
var Qn = (e) => typeof e == "string";
var rr = { class: "dp__selection_preview" };
var or = { class: "dp__action_buttons" };
var sr = ["onKeydown"];
var ur = defineComponent({ props: De(X(X(X(X(X({}, Gn), on), jn), sn), qn), { inline: { type: Boolean, default: false }, timePicker: { type: Boolean, default: false }, calendarWidth: { type: Number, default: 0 }, menuMount: { type: Boolean, default: false }, enableTimePicker: { type: Boolean, default: true } }), emits: ["closePicker", "selectDate"], setup(e, { emit: a }) {
  const n = e, { buildMatrix: t } = Je(), i = inject(Hn), p = inject(qe), v = ref(null), f = ref(null);
  onMounted(() => {
    p != null && p.value && t([he(v), he(f)], "actionRow");
  });
  const h = computed(() => ({ dp__action: true, dp__select: true, dp__action_disabled: !T.value || !N.value })), T = computed(() => n.enableTimePicker ? nn(n.internalModelValue, n.maxTime, n.minTime) : true), N = computed(() => n.monthPicker ? $l(n.internalModelValue, n.minDate, n.maxDate) : true), g = (B) => Yt(B, n.previewFormat, i == null ? void 0 : i.value), R = computed(() => !n.internalModelValue || !n.menuMount ? "" : typeof n.previewFormat == "string" ? Dt(n.internalModelValue) ? n.internalModelValue.length === 2 && n.internalModelValue[1] ? n.multiCalendars > 0 ? `${g(n.internalModelValue[0])} - ${g(n.internalModelValue[1])}` : [g(n.internalModelValue[0]), g(n.internalModelValue[1])] : n.multiDates ? n.internalModelValue.map((B) => `${g(B)}`) : `${g(n.internalModelValue[0])} -` : Yt(n.internalModelValue, n.previewFormat, i == null ? void 0 : i.value) : n.timePicker ? n.previewFormat(xt(n.internalModelValue)) : n.monthPicker ? n.previewFormat(It(n.internalModelValue)) : n.previewFormat(n.internalModelValue)), E = () => {
    T.value && N.value && a("selectDate");
  };
  return (B, Y) => (openBlock(), createElementBlock("div", { class: "dp__action_row", style: normalizeStyle(e.calendarWidth ? { width: `${e.calendarWidth}px` } : {}) }, [createBaseVNode("div", rr, [B.$slots["action-preview"] ? renderSlot(B.$slots, "action-preview", { key: 0, value: B.internalModelValue }) : createCommentVNode("", true), B.$slots["action-preview"] ? createCommentVNode("", true) : (openBlock(), createElementBlock(Fragment, { key: 1 }, [Array.isArray(unref(R)) ? createCommentVNode("", true) : (openBlock(), createElementBlock(Fragment, { key: 0 }, [createTextVNode(toDisplayString(unref(R)), 1)], 64)), Array.isArray(unref(R)) ? (openBlock(true), createElementBlock(Fragment, { key: 1 }, renderList(unref(R), (C, s) => (openBlock(), createElementBlock("div", { key: s }, toDisplayString(C), 1))), 128)) : createCommentVNode("", true)], 64))]), createBaseVNode("div", or, [B.$slots["action-select"] ? renderSlot(B.$slots, "action-select", { key: 0, value: B.internalModelValue }) : createCommentVNode("", true), B.$slots["action-select"] ? createCommentVNode("", true) : (openBlock(), createElementBlock(Fragment, { key: 1 }, [e.inline ? createCommentVNode("", true) : (openBlock(), createElementBlock("span", { key: 0, class: "dp__action dp__cancel", ref_key: "cancelButtonRef", ref: v, tabindex: "0", onClick: Y[0] || (Y[0] = (C) => B.$emit("closePicker")), onKeydown: Y[1] || (Y[1] = withKeys((C) => B.$emit("closePicker"), ["enter"])) }, toDisplayString(B.cancelText), 545)), createBaseVNode("span", { class: normalizeClass(unref(h)), tabindex: "0", onKeydown: withKeys(E, ["enter"]), onClick: E, ref_key: "selectButtonRef", ref: f }, toDisplayString(B.selectText), 43, sr)], 64))])], 4));
} });
var ir = { class: "dp__overlay_container", role: "grid" };
var dr = { class: "dp__selection_grid_header" };
var cr = ["aria-selected", "aria-disabled", "onClick", "onKeydown", "onMouseover"];
var mr = ["aria-label", "onKeydown"];
var Mt = defineComponent({ props: { items: { type: Array, default: () => [] }, modelValue: { type: [String, Number], default: null }, multiModelValue: { type: Array, default: () => [] }, disabledValues: { type: Array, default: () => [] }, minValue: { type: [Number, String], default: null }, maxValue: { type: [Number, String], default: null }, year: { type: Number, default: 0 }, skipActive: { type: Boolean, default: false }, headerRefs: { type: Array, default: () => [] }, skipButtonRef: { type: Boolean, default: false } }, emits: ["update:modelValue", "selected", "toggle", "reset-flow"], setup(e, { expose: a, emit: n }) {
  const t = e, i = ref(false), p = ref(null), v = ref(null), f = ref([]), h = inject(an, false), T = inject(Ln, ref(false)), N = inject(Xe), g = inject(qe), R = ref(), E = ref(), { setSelectionGrid: B, buildMultiLevelMatrix: Y, setMonthPicker: C } = Je();
  onBeforeUpdate(() => {
    p.value = null;
  }), onMounted(() => {
    nextTick().then(() => le()), j(), s(true);
  }), onUnmounted(() => s(false));
  const s = (u) => {
    var D;
    g != null && g.value && ((D = t.headerRefs) != null && D.length ? C(u) : B(u));
  }, j = () => {
    const u = he(v);
    u && (T.value || u.focus({ preventScroll: true }), i.value = u.clientHeight < u.scrollHeight);
  }, l = computed(() => ({ dp__overlay: true })), $ = computed(() => ({ dp__overlay_col: true })), U = computed(() => t.items.map((u) => u.filter((D) => D).map((D) => {
    var F, ne, Q;
    const S = t.disabledValues.some((w) => w === D.value) || ae(D.value), G = (F = t.multiModelValue) != null && F.length ? (ne = t.multiModelValue) == null ? void 0 : ne.some((w) => de(w, setYear(setMonth(new Date(), D.value), t.year))) : t.skipActive ? false : D.value === t.modelValue;
    return De(X({}, D), { className: { dp__overlay_cell_active: G, dp__overlay_cell: !G, dp__overlay_cell_disabled: S, dp__overlay_cell_active_disabled: S && G, dp__overlay_cell_pad: true, dp__cell_in_between: (Q = t.multiModelValue) != null && Q.length ? se(D.value) : false } });
  }))), Z = computed(() => ({ dp__button: true, dp__overlay_action: true, dp__over_action_scroll: i.value, dp__button_bottom: h })), ae = (u) => {
    const D = t.maxValue ? +u > +t.maxValue : false, S = t.minValue ? +u < +t.minValue : false;
    return D || S;
  }, le = () => {
    const u = he(p);
    if (u) {
      const D = he(v);
      D && (D.scrollTop = u.offsetTop - D.offsetTop - (D.getBoundingClientRect().height / 2 - u.getBoundingClientRect().height));
    }
  }, x = (u) => {
    !t.disabledValues.some((D) => D === u) && (t.minValue ? +t.minValue <= u : true) && (t.maxValue ? +t.maxValue >= u : true) && (n("update:modelValue", u), n("selected"));
  }, se = (u) => Yn(t.multiModelValue, setYear(setMonth(new Date(), R.value || 0), t.year), setYear(setMonth(new Date(), u), t.year)), d = () => {
    n("toggle"), n("reset-flow");
  }, I = (u, D, S, G) => {
    var F, ne;
    if (u && (D.value === +t.modelValue && !t.disabledValues.includes(D.value) && (p.value = u), g != null && g.value)) {
      Array.isArray(f.value[S]) ? f.value[S][G] = u : f.value[S] = [u];
      const Q = (F = t.headerRefs) != null && F.length ? [t.headerRefs].concat(f.value) : f.value.concat([t.skipButtonRef ? [] : [E.value]]);
      Y(Q, (ne = t.headerRefs) != null && ne.length ? "monthPicker" : "selectionGrid");
    }
  };
  return a({ focusGrid: j }), (u, D) => (openBlock(), createElementBlock("div", { ref_key: "gridWrapRef", ref: v, class: normalizeClass(unref(l)), role: "dialog", tabindex: "0" }, [createBaseVNode("div", ir, [createBaseVNode("div", dr, [renderSlot(u.$slots, "header")]), (openBlock(true), createElementBlock(Fragment, null, renderList(unref(U), (S, G) => (openBlock(), createElementBlock("div", { class: "dp__overlay_row", key: unref(Vl)(G), role: "row" }, [(openBlock(true), createElementBlock(Fragment, null, renderList(S, (F, ne) => (openBlock(), createElementBlock("div", { role: "gridcell", class: normalizeClass(unref($)), key: F.value, "aria-selected": F.value === e.modelValue && !e.disabledValues.includes(F.value), "aria-disabled": F.className.dp__overlay_cell_disabled, ref_for: true, ref: (Q) => I(Q, F, G, ne), tabindex: "0", onClick: (Q) => x(F.value), onKeydown: withKeys((Q) => x(F.value), ["enter"]), onMouseover: (Q) => R.value = F.value }, [createBaseVNode("div", { class: normalizeClass(F.className) }, [u.$slots.item ? renderSlot(u.$slots, "item", { key: 0, item: F }) : createCommentVNode("", true), u.$slots.item ? createCommentVNode("", true) : (openBlock(), createElementBlock(Fragment, { key: 1 }, [createTextVNode(toDisplayString(F.text), 1)], 64))], 2)], 42, cr))), 128))]))), 128)), u.$slots["button-icon"] ? (openBlock(), createElementBlock("div", { key: 0, role: "button", "aria-label": unref(N).toggleOverlay, class: normalizeClass(unref(Z)), tabindex: "0", ref_key: "toggleButton", ref: E, onClick: d, onKeydown: withKeys(d, ["enter"]) }, [renderSlot(u.$slots, "button-icon")], 42, mr)) : createCommentVNode("", true)])], 2));
} });
var Kt = () => {
  const e = inject(Et);
  return { transitionName: computed(() => (a) => e != null && e.value ? a ? e.value.open : e.value.close : ""), showTransition: !!(e != null && e.value) };
};
var pr = { key: 0, class: "dp__time_input" };
var vr = createTextVNode(" : ");
var fr = ["aria-label", "onKeydown", "onClick"];
var yr = ["aria-label", "onKeydown", "onClick"];
var hr = ["aria-label", "onKeydown", "onClick"];
var gr = { key: 0 };
var wr = ["aria-label", "onKeydown"];
var kr = defineComponent({ props: De(X({}, Un), { hours: { type: Number, default: 0 }, minutes: { type: Number, default: 0 }, seconds: { type: Number, default: 0 }, filters: { type: Object, default: () => ({}) }, disabled: { type: Boolean, default: false }, closeTimePickerBtn: { type: Object, default: null }, order: { type: Number, default: 0 } }), emits: ["setHours", "setMinutes", "update:hours", "update:minutes", "update:seconds", "reset-flow", "mounted", "overlay-closed"], setup(e, { expose: a, emit: n }) {
  const t = e, i = reactive({ hours: false, minutes: false, seconds: false }), p = ref("AM"), v = ref(null), f = inject(Xe), h = inject(qe), T = ref([]), { transitionName: N, showTransition: g } = Kt(), { setTimePickerElements: R, setTimePickerBackRef: E } = Je();
  onMounted(() => {
    n("mounted");
  });
  const B = computed(() => ({ dp__time_col: true, dp__time_col_reg: !t.enableSeconds && t.is24, dp__time_col_reg_with_button: !t.enableSeconds && !t.is24, dp__time_col_sec: t.enableSeconds && t.is24, dp__time_col_sec_with_button: t.enableSeconds && !t.is24 })), Y = computed(() => {
    const d = [{ type: "hours" }, "separator", { type: "minutes" }];
    return t.enableSeconds ? d.concat(["separator", { type: "seconds" }]) : d;
  }), C = computed(() => Y.value.filter((d) => typeof d != "string")), s = computed(() => (d) => {
    if (d === "hours") {
      const I = Z(t.hours);
      return { text: I < 10 ? `0${I}` : `${I}`, value: I };
    }
    return { text: t[d] < 10 ? `0${t[d]}` : `${t[d]}`, value: t[d] };
  }), j = (d) => {
    const I = d === "hours" ? t.is24 ? 24 : 12 : 60, u = +t[`${d}GridIncrement`], D = [];
    for (let S = 0; S < I; S += u)
      D.push({ value: S, text: S < 10 ? `0${S}` : `${S}` });
    return Pl(D);
  }, l = (d) => t[`no${d[0].toUpperCase() + d.slice(1)}Overlay`], $ = (d) => {
    l(d) || (i[d] = !i[d], i[d] || n("overlay-closed"));
  }, U = (d, I = true) => {
    const u = d === "hours" ? getHours : d === "minutes" ? getMinutes : getSeconds, D = I ? kl : bl;
    n(`update:${d}`, u(D({ [d]: +t[d] }, { [d]: +t[`${d}Increment`] })));
  }, Z = (d) => t.is24 ? d : (d >= 12 ? p.value = "PM" : p.value = "AM", Rl(d)), ae = () => {
    p.value === "PM" ? (p.value = "AM", n("update:hours", t.hours - 12)) : (p.value = "PM", n("update:hours", t.hours + 12));
  }, le = (d) => {
    i[d] = true;
  }, x = (d, I, u) => {
    if (d && (h == null ? void 0 : h.value)) {
      Array.isArray(T.value[I]) ? T.value[I][u] = d : T.value[I] = [d];
      let D = T.value.reduce((S, G) => G.map((F, ne) => [...S[ne] || [], G[ne]]), []);
      E(t.closeTimePickerBtn), v.value && (D[1] = D[1].concat(v.value)), R(D, t.order);
    }
  }, se = (d, I) => d === "hours" && !t.is24 ? n(`update:${d}`, p.value === "PM" ? I + 12 : I) : n(`update:${d}`, I);
  return a({ openChildCmp: le }), (d, I) => e.disabled ? createCommentVNode("", true) : (openBlock(), createElementBlock("div", pr, [(openBlock(true), createElementBlock(Fragment, null, renderList(unref(Y), (u, D) => (openBlock(), createElementBlock("div", { key: D, class: normalizeClass(unref(B)) }, [u === "separator" ? (openBlock(), createElementBlock(Fragment, { key: 0 }, [vr], 64)) : (openBlock(), createElementBlock(Fragment, { key: 1 }, [createBaseVNode("div", { class: "dp__inc_dec_button", role: "button", "aria-label": unref(f).incrementValue(u.type), tabindex: "0", onKeydown: withKeys((S) => U(u.type), ["enter"]), onClick: (S) => U(u.type), ref_for: true, ref: (S) => x(S, D, 0) }, [d.$slots["arrow-up"] ? renderSlot(d.$slots, "arrow-up", { key: 0 }) : createCommentVNode("", true), d.$slots["arrow-up"] ? createCommentVNode("", true) : (openBlock(), createBlock(unref(On), { key: 1 }))], 40, fr), createBaseVNode("div", { role: "button", "aria-label": unref(f).openTpOverlay(u.type), class: normalizeClass(l(u.type) ? "" : "dp__time_display"), tabindex: "0", onKeydown: withKeys((S) => $(u.type), ["enter"]), onClick: (S) => $(u.type), ref_for: true, ref: (S) => x(S, D, 1) }, [d.$slots[u.type] ? renderSlot(d.$slots, u.type, { key: 0, text: unref(s)(u.type).text, value: unref(s)(u.type).value }) : createCommentVNode("", true), d.$slots[u.type] ? createCommentVNode("", true) : (openBlock(), createElementBlock(Fragment, { key: 1 }, [createTextVNode(toDisplayString(unref(s)(u.type).text), 1)], 64))], 42, yr), createBaseVNode("div", { class: "dp__inc_dec_button", role: "button", "aria-label": unref(f).decrementValue(u.type), tabindex: "0", onKeydown: withKeys((S) => U(u.type, false), ["enter"]), onClick: (S) => U(u.type, false), ref_for: true, ref: (S) => x(S, D, 2) }, [d.$slots["arrow-down"] ? renderSlot(d.$slots, "arrow-down", { key: 0 }) : createCommentVNode("", true), d.$slots["arrow-down"] ? createCommentVNode("", true) : (openBlock(), createBlock(unref(_n), { key: 1 }))], 40, hr)], 64))], 2))), 128)), d.is24 ? createCommentVNode("", true) : (openBlock(), createElementBlock("div", gr, [d.$slots["am-pm-button"] ? renderSlot(d.$slots, "am-pm-button", { key: 0, toggle: ae, value: p.value }) : createCommentVNode("", true), d.$slots["am-pm-button"] ? createCommentVNode("", true) : (openBlock(), createElementBlock("button", { key: 1, ref_key: "amPmButton", ref: v, type: "button", class: "dp__pm_am_button", role: "button", "aria-label": unref(f).amPmButton, tabindex: "0", onClick: ae, onKeydown: withKeys(withModifiers(ae, ["prevent"]), ["enter"]) }, toDisplayString(p.value), 41, wr))])), (openBlock(true), createElementBlock(Fragment, null, renderList(unref(C), (u, D) => (openBlock(), createBlock(Transition, { key: D, name: unref(N)(unref(i)[u.type]), css: unref(g) }, { default: withCtx(() => [unref(i)[u.type] ? (openBlock(), createBlock(Mt, { key: 0, items: j(u.type), "disabled-values": e.filters.times[u.type], "onUpdate:modelValue": (S) => se(u.type, S), onSelected: (S) => $(u.type), onToggle: (S) => $(u.type), onResetFlow: I[0] || (I[0] = (S) => d.$emit("reset-flow")) }, createSlots({ "button-icon": withCtx(() => [d.$slots["clock-icon"] ? renderSlot(d.$slots, "clock-icon", { key: 0 }) : createCommentVNode("", true), d.$slots["clock-icon"] ? createCommentVNode("", true) : (openBlock(), createBlock(unref(Rn), { key: 1 }))]), _: 2 }, [d.$slots[`${u.type}-overlay`] ? { name: "item", fn: withCtx(({ item: S }) => [renderSlot(d.$slots, `${u.type}-overlay`, { text: S.text, value: S.value })]) } : void 0]), 1032, ["items", "disabled-values", "onUpdate:modelValue", "onSelected", "onToggle"])) : createCommentVNode("", true)]), _: 2 }, 1032, ["name", "css"]))), 128))]));
} });
var St = [{ name: "clock-icon", use: ["time", "calendar"] }, { name: "arrow-left", use: ["month-year", "calendar"] }, { name: "arrow-right", use: ["month-year", "calendar"] }, { name: "arrow-up", use: ["time", "calendar"] }, { name: "arrow-down", use: ["time", "calendar"] }, { name: "calendar-icon", use: ["month-year", "time", "calendar"] }, { name: "day", use: ["calendar"] }, { name: "month-overlay", use: ["calendar", "month-year"] }, { name: "year-overlay", use: ["calendar", "month-year"] }, { name: "hours-overlay", use: ["calendar", "time"] }, { name: "minutes-overlay", use: ["calendar", "time"] }, { name: "seconds-overlay", use: ["calendar", "time"] }, { name: "hours", use: ["calendar", "time"] }, { name: "minutes", use: ["calendar", "time"] }, { name: "month", use: ["calendar", "month-year"] }, { name: "year", use: ["calendar", "month-year"] }, { name: "action-select", use: ["action"] }, { name: "action-preview", use: ["action"] }, { name: "calendar-header", use: ["calendar"] }, { name: "marker-tooltip", use: ["calendar"] }, { name: "now-button", use: [] }, { name: "time-picker-overlay", use: ["calendar", "time"] }, { name: "am-pm-button", use: ["calendar", "time"] }];
var br = [{ name: "trigger" }, { name: "input-icon" }, { name: "clear-icon" }, { name: "dp-input" }];
var $r = { all: () => St, monthYear: () => St.filter((e) => e.use.includes("month-year")), input: () => br, timePicker: () => St.filter((e) => e.use.includes("time")), action: () => St.filter((e) => e.use.includes("action")), calendar: () => St.filter((e) => e.use.includes("calendar")) };
var st = (e, a) => {
  const n = [];
  return $r[a]().forEach((t) => {
    e[t.name] && n.push(t.name);
  }), n;
};
var Dr = ["aria-label"];
var Mr = { class: "dp__overlay_container" };
var Sr = { key: 1, class: "dp__overlay_row" };
var Pr = ["aria-label"];
var Cr = defineComponent({ props: De(X({}, Kn), { range: { type: Boolean, default: false }, filters: { type: Object, default: () => ({}) }, hours: { type: [Number, Array], default: 0 }, minutes: { type: [Number, Array], default: 0 }, seconds: { type: [Number, Array], default: 0 }, customProps: { type: Object, default: null } }), emits: ["update:hours", "update:minutes", "update:seconds", "mount", "reset-flow", "overlay-closed"], setup(e, { expose: a, emit: n }) {
  const t = e, i = useSlots(), p = ref(null), v = ref(null), f = inject(an, false), h = ref([]), T = ref(null), N = inject(Xe), g = inject(qe), { transitionName: R, showTransition: E } = Kt(), { buildMatrix: B, setTimePicker: Y } = Je();
  onMounted(() => {
    n("mount"), !t.timePicker && (g == null ? void 0 : g.value) ? B([he(p.value)], "time") : Y(true, t.timePicker);
  });
  const C = ref(false), s = (d) => ({ hours: Array.isArray(t.hours) ? t.hours[d] : t.hours, minutes: Array.isArray(t.minutes) ? t.minutes[d] : t.minutes, seconds: Array.isArray(t.seconds) ? t.seconds[d] : t.seconds }), j = computed(() => {
    const d = [];
    if (t.range)
      for (let I = 0; I < 2; I++)
        d.push(s(I));
    else
      d.push(s(0));
    return d;
  }), l = (d, I = false, u = "") => {
    I || n("reset-flow"), C.value = d, g != null && g.value && (Y(d), d || n("overlay-closed")), nextTick(() => {
      u !== "" && h.value[0] && h.value[0].openChildCmp(u);
    });
  }, $ = computed(() => ({ dp__button: true, dp__button_bottom: f })), U = st(i, "timePicker"), Z = (d, I, u) => t.range ? I === 0 ? [d, j.value[1][u]] : [j.value[0][u], d] : d, ae = (d) => {
    n("update:hours", d);
  }, le = (d) => {
    n("update:minutes", d);
  }, x = (d) => {
    n("update:seconds", d);
  }, se = () => {
    T.value && (g == null ? void 0 : g.value) && T.value.focus({ preventScroll: true });
  };
  return a({ toggleTimePicker: l }), (d, I) => (openBlock(), createElementBlock("div", null, [d.timePicker ? createCommentVNode("", true) : (openBlock(), createElementBlock("div", { key: 0, class: normalizeClass(unref($)), role: "button", "aria-label": unref(N).openTimePicker, tabindex: "0", ref_key: "openTimePickerBtn", ref: p, onKeydown: I[0] || (I[0] = withKeys((u) => l(true), ["enter"])), onClick: I[1] || (I[1] = (u) => l(true)) }, [d.$slots["clock-icon"] ? renderSlot(d.$slots, "clock-icon", { key: 0 }) : createCommentVNode("", true), d.$slots["clock-icon"] ? createCommentVNode("", true) : (openBlock(), createBlock(unref(Rn), { key: 1 }))], 42, Dr)), createVNode(Transition, { name: unref(R)(C.value), css: unref(E) }, { default: withCtx(() => [C.value || d.timePicker ? (openBlock(), createElementBlock("div", { key: 0, class: "dp__overlay", ref_key: "overlayRef", ref: T, tabindex: "0" }, [createBaseVNode("div", Mr, [d.$slots["time-picker-overlay"] ? renderSlot(d.$slots, "time-picker-overlay", { key: 0, range: e.range, hours: e.hours, minutes: e.minutes, seconds: e.seconds, setHours: ae, setMinutes: le, setSeconds: x }) : createCommentVNode("", true), d.$slots["time-picker-overlay"] ? createCommentVNode("", true) : (openBlock(), createElementBlock("div", Sr, [(openBlock(true), createElementBlock(Fragment, null, renderList(unref(j), (u, D) => (openBlock(), createBlock(kr, mergeProps({ key: D, disabled: D === 0 ? d.fixedStart : d.fixedEnd, hours: u.hours, minutes: u.minutes, seconds: u.seconds, filters: e.filters, ref_for: true, ref_key: "timeInputRefs", ref: h }, { is24: d.is24, hoursGridIncrement: d.hoursGridIncrement, minutesGridIncrement: d.minutesGridIncrement, secondsGridIncrement: d.secondsGridIncrement, hoursIncrement: d.hoursIncrement, minutesIncrement: d.minutesIncrement, secondsIncrement: d.secondsIncrement, filters: e.filters, noHoursOverlay: d.noHoursOverlay, noMinutesOverlay: d.noMinutesOverlay, noSecondsOverlay: d.noSecondsOverlay, enableSeconds: d.enableSeconds, closeTimePickerBtn: v.value, order: D }, { "onUpdate:hours": (S) => ae(Z(S, D, "hours")), "onUpdate:minutes": (S) => le(Z(S, D, "minutes")), "onUpdate:seconds": (S) => x(Z(S, D, "seconds")), onMounted: se, onOverlayClosed: se }), createSlots({ _: 2 }, [renderList(unref(U), (S, G) => ({ name: S, fn: withCtx((F) => [renderSlot(d.$slots, S, normalizeProps(guardReactiveProps(F)))]) }))]), 1040, ["disabled", "hours", "minutes", "seconds", "filters", "onUpdate:hours", "onUpdate:minutes", "onUpdate:seconds"]))), 128))])), d.timePicker ? createCommentVNode("", true) : (openBlock(), createElementBlock("div", { key: 2, ref_key: "closeTimePickerBtn", ref: v, class: normalizeClass(unref($)), role: "button", "aria-label": unref(N).closeTimePicker, tabindex: "0", onKeydown: I[2] || (I[2] = withKeys((u) => l(false), ["enter"])), onClick: I[3] || (I[3] = (u) => l(false)) }, [d.$slots["calendar-icon"] ? renderSlot(d.$slots, "calendar-icon", { key: 0 }) : createCommentVNode("", true), d.$slots["calendar-icon"] ? createCommentVNode("", true) : (openBlock(), createBlock(unref(Nt), { key: 1 }))], 42, Pr))])], 512)) : createCommentVNode("", true)]), _: 3 }, 8, ["name", "css"])]));
} });
var Ar = ["aria-label"];
var vn = defineComponent({ props: { ariaLabel: { type: String, default: "" } }, emits: ["activate", "setRef"], setup(e, { emit: a }) {
  const n = ref(null);
  return onMounted(() => a("setRef", n)), (t, i) => (openBlock(), createElementBlock("div", { class: "dp__month_year_col_nav", onClick: i[0] || (i[0] = (p) => t.$emit("activate")), onKeydown: i[1] || (i[1] = withKeys((p) => t.$emit("activate"), ["enter"])), tabindex: "0", ref_key: "elRef", ref: n }, [createBaseVNode("div", { class: "dp__inner_nav", role: "button", "aria-label": e.ariaLabel }, [renderSlot(t.$slots, "default")], 8, Ar)], 544));
} });
var Tr = ["aria-label"];
var xn = defineComponent({ props: { ariaLabel: { type: String, default: "" }, showSelectionGrid: { type: Boolean, default: false }, modelValue: { type: Number, default: null }, items: { type: Array, default: () => [] }, disabledValues: { type: Array, default: () => [] }, minValue: { type: Number, default: null }, maxValue: { type: Number, default: null }, slotName: { type: String, default: "" }, headerRefs: { type: Array, default: () => [] } }, emits: ["update:model-value", "toggle", "setRef"], setup(e, { emit: a }) {
  const { transitionName: n, showTransition: t } = Kt(), i = ref(null);
  return onMounted(() => a("setRef", i)), (p, v) => (openBlock(), createElementBlock(Fragment, null, [createBaseVNode("div", { class: "dp__month_year_select", onClick: v[0] || (v[0] = (f) => p.$emit("toggle")), onKeydown: v[1] || (v[1] = withKeys((f) => p.$emit("toggle"), ["enter"])), role: "button", "aria-label": e.ariaLabel, tabindex: "0", ref_key: "elRef", ref: i }, [renderSlot(p.$slots, "default")], 40, Tr), createVNode(Transition, { name: unref(n)(e.showSelectionGrid), css: unref(t) }, { default: withCtx(() => [e.showSelectionGrid ? (openBlock(), createBlock(Mt, mergeProps({ key: 0 }, { modelValue: e.modelValue, items: e.items, disabledValues: e.disabledValues, minValue: e.minValue, maxValue: e.maxValue }, { "header-refs": [], "onUpdate:modelValue": v[2] || (v[2] = (f) => p.$emit("update:model-value", f)), onToggle: v[3] || (v[3] = (f) => p.$emit("toggle")) }), createSlots({ "button-icon": withCtx(() => [p.$slots["calendar-icon"] ? renderSlot(p.$slots, "calendar-icon", { key: 0 }) : createCommentVNode("", true), p.$slots["calendar-icon"] ? createCommentVNode("", true) : (openBlock(), createBlock(unref(Nt), { key: 1 }))]), _: 2 }, [p.$slots[e.slotName] ? { name: "item", fn: withCtx(({ item: f }) => [renderSlot(p.$slots, e.slotName, { item: f })]) } : void 0]), 1040)) : createCommentVNode("", true)]), _: 3 }, 8, ["name", "css"])], 64));
} });
var Wt = (e, a, n) => [set(new Date(e), { date: 1 }), set(new Date(), { month: a, year: n, date: 1 })];
var ea = (e, a, n) => be(...Wt(e, a, n)) || de(...Wt(e, a, n));
var ta = (e, a, n) => Ae(...Wt(e, a, n)) || de(...Wt(e, a, n));
var na = (e, a, n, t, i, p) => {
  let v = false;
  return p ? e && a ? (a && i && ta(a, n, t) && (v = true), e && !i && ea(e, n, t) && (v = true)) : (e && ea(e, n, t) || a && ta(a, n, t)) && (v = true) : v = true, v;
};
var Rr = (e, a) => {
  const n = (v, f) => {
    let h = v;
    return e.filters.months.includes(getMonth(h)) ? (h = f ? addMonths(v, 1) : subMonths(v, 1), n(h, f)) : h;
  }, t = (v, f) => {
    let h = v;
    return e.filters.years.includes(getYear(h)) ? (h = f ? addYears(v, 1) : subYears(v, 1), t(h, f)) : h;
  }, i = (v) => {
    const f = set(new Date(), { month: e.month, year: e.year });
    let h = v ? addMonths(f, 1) : subMonths(f, 1), T = getMonth(h), N = getYear(h);
    e.filters.months.includes(T) && (h = n(h, v), T = getMonth(h), N = getYear(h)), e.filters.years.includes(N) && (h = t(h, v), N = getYear(h)), na(e.minDate, e.maxDate, T, N, v, e.preventMinMaxNavigation) && p(T, N);
  }, p = (v, f) => {
    a("update:month", v), a("update:year", f);
  };
  return { handleMonthYearChange: i };
};
var Or = { class: "dp__month_year_row" };
var _r = { class: "dp__month_picker_header" };
var Vr = ["aria-label"];
var Br = ["aria-label", "onKeydown"];
var Nr = ["aria-label"];
var Ir = defineComponent({ props: De(X(X({}, Jn), on), { preventMinMaxNavigation: { type: Boolean, default: false }, reverseYears: { type: Boolean, default: false }, years: { type: Array, default: () => [] }, months: { type: Array, default: () => [] }, filters: { type: Object, default: () => ({}) }, multiCalendarsSolo: { type: Boolean, default: false }, yearPicker: { type: Boolean, default: false } }), emits: ["update:month", "update:year", "monthYearSelect", "mount", "reset-flow", "overlay-closed"], setup(e, { expose: a, emit: n }) {
  const t = e, { transitionName: i, showTransition: p } = Kt(), { buildMatrix: v } = Je(), f = ref(false), h = ref(false), T = ref([null, null, null, null]), N = ref(null), g = ref(null), R = ref(null), E = inject(Xe), B = inject(qe), { handleMonthYearChange: Y } = Rr(t, n);
  onMounted(() => {
    n("mount");
  });
  const C = (w) => ({ get: () => t[w], set: (_) => {
    n(`update:${w}`, _), n("monthYearSelect", w === "year"), w === "month" ? S(true) : G(true);
  } }), s = computed(C("month")), j = computed(C("year")), l = computed(() => (w) => {
    const _ = w === "month";
    return { showSelectionGrid: (_ ? f : h).value, items: (_ ? d : I).value, disabledValues: t.filters[_ ? "months" : "years"], minValue: (_ ? Z : $).value, maxValue: (_ ? ae : U).value, headerRefs: _ && t.monthPicker ? [N.value, g.value, R.value] : [] };
  }), $ = computed(() => t.minDate ? getYear(new Date(t.minDate)) : null), U = computed(() => t.maxDate ? getYear(new Date(t.maxDate)) : null), Z = computed(() => {
    if (t.minDate && $.value) {
      if ($.value > t.year)
        return 12;
      if ($.value === t.year)
        return getMonth(new Date(t.minDate));
    }
    return null;
  }), ae = computed(() => {
    if (t.maxDate && U.value) {
      if (U.value < t.year)
        return -1;
      if (U.value === t.year)
        return getMonth(new Date(t.maxDate));
    }
    return null;
  }), le = computed(() => t.range && t.internalModelValue && t.monthPicker ? t.internalModelValue : []), x = (w, _ = false) => {
    const V = [];
    for (let ke = 0; ke < w.length; ke += 3) {
      const Ye = [w[ke], w[ke + 1], w[ke + 2]];
      V.push(_ ? Ye.reverse() : Ye);
    }
    return _ ? V.reverse() : V;
  }, se = computed(() => {
    const w = t.months.find((_) => _.value === t.month);
    return w || { text: "", value: 0 };
  }), d = computed(() => x(t.months)), I = computed(() => x(t.years, t.reverseYears)), u = computed(() => t.multiCalendars ? t.multiCalendarsSolo ? true : t.instance === 0 : true), D = computed(() => t.multiCalendars ? t.multiCalendarsSolo ? true : t.instance === t.multiCalendars - 1 : true), S = (w = false) => {
    F(w), f.value = !f.value, f.value || n("overlay-closed");
  }, G = (w = false) => {
    F(w), h.value = !h.value, h.value || n("overlay-closed");
  }, F = (w) => {
    w || n("reset-flow");
  }, ne = (w = false) => {
    n("update:year", w ? t.year + 1 : t.year - 1);
  }, Q = (w, _) => {
    B != null && B.value && (T.value[_] = he(w), v(T.value, "monthYear"));
  };
  return a({ toggleMonthPicker: S, toggleYearPicker: G }), (w, _) => (openBlock(), createElementBlock("div", Or, [!w.monthPicker && !e.yearPicker ? (openBlock(), createElementBlock(Fragment, { key: 0 }, [unref(u) && !w.vertical ? (openBlock(), createBlock(vn, { key: 0, "aria-label": unref(E).prevMonth, onActivate: _[0] || (_[0] = (V) => unref(Y)(false)), onSetRef: _[1] || (_[1] = (V) => Q(V, 0)) }, { default: withCtx(() => [w.$slots["arrow-left"] ? renderSlot(w.$slots, "arrow-left", { key: 0 }) : createCommentVNode("", true), w.$slots["arrow-left"] ? createCommentVNode("", true) : (openBlock(), createBlock(unref(An), { key: 1 }))]), _: 3 }, 8, ["aria-label"])) : createCommentVNode("", true), createVNode(xn, mergeProps({ "aria-label": unref(E).openMonthsOverlay, "slot-name": "month-overlay", modelValue: unref(s), "onUpdate:modelValue": _[2] || (_[2] = (V) => isRef(s) ? s.value = V : null) }, unref(l)("month"), { onToggle: S, onSetRef: _[3] || (_[3] = (V) => Q(V, 1)) }), createSlots({ default: withCtx(() => [w.$slots.month ? renderSlot(w.$slots, "month", normalizeProps(mergeProps({ key: 0 }, unref(se)))) : createCommentVNode("", true), w.$slots.month ? createCommentVNode("", true) : (openBlock(), createElementBlock(Fragment, { key: 1 }, [createTextVNode(toDisplayString(unref(se).text), 1)], 64))]), _: 2 }, [w.$slots["calendar-icon"] ? { name: "calendar-icon", fn: withCtx(() => [renderSlot(w.$slots, "calendar-icon")]) } : void 0, w.$slots["month-overlay"] ? { name: "month-overlay", fn: withCtx(({ item: V }) => [renderSlot(w.$slots, "month-overlay", { text: V.text, value: V.value })]) } : void 0]), 1040, ["aria-label", "modelValue"]), createVNode(xn, mergeProps({ "aria-label": unref(E).openYearsOverlay, "slot-name": "year-overlay", modelValue: unref(j), "onUpdate:modelValue": _[4] || (_[4] = (V) => isRef(j) ? j.value = V : null) }, unref(l)("year"), { onToggle: G, onSetRef: _[5] || (_[5] = (V) => Q(V, 2)) }), createSlots({ default: withCtx(() => [w.$slots.year ? renderSlot(w.$slots, "year", { key: 0, year: w.year }) : createCommentVNode("", true), w.$slots.year ? createCommentVNode("", true) : (openBlock(), createElementBlock(Fragment, { key: 1 }, [createTextVNode(toDisplayString(w.year), 1)], 64))]), _: 2 }, [w.$slots["calendar-icon"] ? { name: "calendar-icon", fn: withCtx(() => [renderSlot(w.$slots, "calendar-icon")]) } : void 0, w.$slots["year-overlay"] ? { name: "year-overlay", fn: withCtx(({ item: V }) => [renderSlot(w.$slots, "year-overlay", { text: V.text, value: V.value })]) } : void 0]), 1040, ["aria-label", "modelValue"]), unref(u) && w.vertical ? (openBlock(), createBlock(vn, { key: 1, "aria-label": unref(E).prevMonth, onActivate: _[6] || (_[6] = (V) => unref(Y)(false)) }, { default: withCtx(() => [w.$slots["arrow-up"] ? renderSlot(w.$slots, "arrow-up", { key: 0 }) : createCommentVNode("", true), w.$slots["arrow-up"] ? createCommentVNode("", true) : (openBlock(), createBlock(unref(On), { key: 1 }))]), _: 3 }, 8, ["aria-label"])) : createCommentVNode("", true), unref(D) ? (openBlock(), createBlock(vn, { key: 2, "arial-label": unref(E).nextMonth, onActivate: _[7] || (_[7] = (V) => unref(Y)(true)), ref: "rightIcon", onSetRef: _[8] || (_[8] = (V) => Q(V, 3)) }, { default: withCtx(() => [w.$slots[w.vertical ? "arrow-down" : "arrow-right"] ? renderSlot(w.$slots, w.vertical ? "arrow-down" : "arrow-right", { key: 0 }) : createCommentVNode("", true), w.$slots[w.vertical ? "arrow-down" : "arrow-right"] ? createCommentVNode("", true) : (openBlock(), createBlock(resolveDynamicComponent(w.vertical ? unref(_n) : unref(Tn)), { key: 1 }))]), _: 3 }, 8, ["arial-label"])) : createCommentVNode("", true)], 64)) : createCommentVNode("", true), w.monthPicker ? (openBlock(), createBlock(Mt, mergeProps({ key: 1 }, unref(l)("month"), { "skip-active": t.range, year: w.year, "multi-model-value": unref(le), modelValue: unref(s), "onUpdate:modelValue": _[15] || (_[15] = (V) => isRef(s) ? s.value = V : null), onToggle: S, onSelected: _[16] || (_[16] = (V) => w.$emit("overlay-closed")) }), createSlots({ header: withCtx(() => [createBaseVNode("div", _r, [createBaseVNode("div", { class: "dp__month_year_col_nav", tabindex: "0", ref_key: "mpPrevIconRef", ref: N, onClick: _[9] || (_[9] = (V) => ne(false)), onKeydown: _[10] || (_[10] = withKeys((V) => ne(false), ["enter"])) }, [createBaseVNode("div", { class: "dp__inner_nav", role: "button", "aria-label": unref(E).prevMonth }, [w.$slots["arrow-left"] ? renderSlot(w.$slots, "arrow-left", { key: 0 }) : createCommentVNode("", true), w.$slots["arrow-left"] ? createCommentVNode("", true) : (openBlock(), createBlock(unref(An), { key: 1 }))], 8, Vr)], 544), createBaseVNode("div", { class: "dp__pointer", role: "button", ref_key: "mpYearButtonRef", ref: g, "aria-label": unref(E).openYearsOverlay, tabindex: "0", onClick: G, onKeydown: withKeys(G, ["enter"]) }, [w.$slots.year ? renderSlot(w.$slots, "year", { key: 0, year: w.year }) : createCommentVNode("", true), w.$slots.year ? createCommentVNode("", true) : (openBlock(), createElementBlock(Fragment, { key: 1 }, [createTextVNode(toDisplayString(w.year), 1)], 64))], 40, Br), createBaseVNode("div", { class: "dp__month_year_col_nav", tabindex: "0", ref_key: "mpNextIconRef", ref: R, onClick: _[11] || (_[11] = (V) => ne(true)), onKeydown: _[12] || (_[12] = withKeys((V) => ne(true), ["enter"])) }, [createBaseVNode("div", { class: "dp__inner_nav", role: "button", "aria-label": unref(E).nextMonth }, [w.$slots["arrow-right"] ? renderSlot(w.$slots, "arrow-right", { key: 0 }) : createCommentVNode("", true), w.$slots["arrow-right"] ? createCommentVNode("", true) : (openBlock(), createBlock(unref(Tn), { key: 1 }))], 8, Nr)], 544)]), createVNode(Transition, { name: unref(i)(h.value), css: unref(p) }, { default: withCtx(() => [h.value ? (openBlock(), createBlock(Mt, mergeProps({ key: 0 }, unref(l)("year"), { modelValue: unref(j), "onUpdate:modelValue": _[13] || (_[13] = (V) => isRef(j) ? j.value = V : null), onToggle: G, onSelected: _[14] || (_[14] = (V) => w.$emit("overlay-closed")) }), createSlots({ "button-icon": withCtx(() => [w.$slots["calendar-icon"] ? renderSlot(w.$slots, "calendar-icon", { key: 0 }) : createCommentVNode("", true), w.$slots["calendar-icon"] ? createCommentVNode("", true) : (openBlock(), createBlock(unref(Nt), { key: 1 }))]), _: 2 }, [w.$slots["year-overlay"] ? { name: "item", fn: withCtx(({ item: V }) => [renderSlot(w.$slots, "year-overlay", { text: V.text, value: V.value })]) } : void 0]), 1040, ["modelValue"])) : createCommentVNode("", true)]), _: 3 }, 8, ["name", "css"])]), _: 2 }, [w.$slots["month-overlay"] ? { name: "item", fn: withCtx(({ item: V }) => [renderSlot(w.$slots, "month-overlay", { text: V.text, value: V.value })]) } : void 0]), 1040, ["skip-active", "year", "multi-model-value", "modelValue"])) : createCommentVNode("", true), e.yearPicker ? (openBlock(), createBlock(Mt, mergeProps({ key: 2 }, unref(l)("year"), { modelValue: unref(j), "onUpdate:modelValue": _[17] || (_[17] = (V) => isRef(j) ? j.value = V : null), "skip-button-ref": "", onToggle: G, onSelected: _[18] || (_[18] = (V) => w.$emit("overlay-closed")) }), createSlots({ _: 2 }, [w.$slots["year-overlay"] ? { name: "item", fn: withCtx(({ item: V }) => [renderSlot(w.$slots, "year-overlay", { text: V.text, value: V.value })]) } : void 0]), 1040, ["modelValue"])) : createCommentVNode("", true)]));
} });
var Yr = (e, a, n, t) => {
  const i = ref(new Date()), p = ref(), v = ref([{ month: getMonth(new Date()), year: getYear(new Date()) }]), f = ref(e.range ? [getHours(new Date()), getHours(new Date())] : getHours(new Date())), h = ref(e.range ? [getMinutes(new Date()), getMinutes(new Date())] : getMinutes(new Date())), T = ref(e.range ? [0, 0] : 0);
  watch(v, () => {
    setTimeout(() => {
      e.openOnTop && a("dpOpen");
    }, 0);
  }, { deep: true }), onMounted(() => {
    x(), s.value || (e.startDate && (v.value[0].month = getMonth(new Date(e.startDate)), v.value[0].year = getYear(new Date(e.startDate)), e.multiCalendars && V(0)), e.startTime && C());
  });
  const N = computed(() => (r) => v.value[r] ? v.value[r].month : 0), g = computed(() => (r) => v.value[r] ? v.value[r].year : 0), R = (r, k, P) => {
    v.value[r].month = k, v.value[r].year = P;
  }, E = (r, k) => v.value[r].month = k, B = (r, k) => v.value[r].year = k, Y = (r = true) => e.enableSeconds ? Array.isArray(T.value) ? r ? T.value[0] : T.value[1] : T.value : 0, C = () => {
    e.startTime && (ar(e.startTime) ? (f.value = [+e.startTime[0].hours, +e.startTime[1].hours], h.value = [+e.startTime[0].minutes, +e.startTime[1].minutes], e.enableSeconds && (T.value = [+e.startTime[0].seconds, +e.startTime[1].seconds])) : (f.value = +e.startTime.hours, h.value = +e.startTime.minutes, e.enableSeconds && (T.value = +e.startTime.seconds)));
  }, s = computed({ get: () => e.internalModelValue, set: (r) => {
    !e.readonly && !e.disabled && a("update:internalModelValue", r);
  } });
  watch(s, () => x());
  const j = (r) => {
    const { validate: k } = Fn(e.minDate, e.maxDate, e.disabledDates, e.allowedDates, e.filters, e.disabledWeekDays, e.yearRange);
    return !k(r);
  }, l = (r) => !s.value || e.hideOffsetDates && !r.current || e.range ? false : e.multiDates && Array.isArray(s.value) ? s.value.some((k) => de(k, r.value)) : de(r.value, s.value ? s.value : i.value), $ = (r) => Yn(s.value, p.value, r.value), U = (r) => {
    if ((!e.multiCalendars || !e.multiStatic) && (E(0, getMonth(r)), B(0, getYear(r))), e.multiCalendars)
      for (let k = 1; k <= e.multiCalendars; k++) {
        const P = set(new Date(), { month: N.value(k - 1), year: g.value(k - 1) }), q = add(P, { months: 1 });
        v.value[k] = { month: getMonth(q), year: getYear(q) };
      }
  }, Z = () => {
    if (Array.isArray(s.value) && s.value.length === 2) {
      const r = new Date(s.value[1] ? s.value[1] : addMonths(s.value[0], 1)), [k, P] = [getMonth(s.value[0]), getYear(s.value[0])], [q, Ee] = [getMonth(s.value[1]), getYear(s.value[1])];
      (k !== q || k === q && P !== Ee) && e.multiCalendarsSolo && (E(1, getMonth(r)), B(1, getYear(r)));
    }
  }, ae = (r) => {
    U(r), f.value = getHours(r), h.value = getMinutes(r), T.value = getSeconds(r);
  }, le = () => Array.isArray(s.value) && s.value.length ? s.value[s.value.length - 1] : null, x = () => {
    if (s.value)
      if (Dt(s.value)) {
        if (s.value.length === 2 && !e.multiDates)
          U(s.value[0]), f.value = [getHours(s.value[0]), s.value[1] ? getHours(s.value[1]) : getHours(new Date())], h.value = [getMinutes(s.value[0]), s.value[1] ? getMinutes(s.value[1]) : getMinutes(new Date())], T.value = [getSeconds(s.value[0]), s.value[1] ? getSeconds(s.value[1]) : getSeconds(new Date())];
        else if (Dt(s.value) && e.multiDates) {
          const r = s.value[s.value.length - 1];
          r && ae(r);
        }
        e.multiCalendars && e.multiCalendarsSolo && Z();
      } else
        ae(s.value);
    else
      e.timePicker ? (C(), e.range ? Ie(f.value) && Ie(h.value) && (s.value = [Pe(new Date(), f.value[0], h.value[0], Y()), Pe(new Date(), f.value[1], h.value[1], Y(false))]) : s.value = Pe(new Date(), f.value, h.value, Y())) : e.monthPicker && !e.range ? s.value = ot(new Date(), N.value(0), g.value(0)) : e.multiCalendars ? U(new Date()) : e.yearPicker && (s.value = new Date());
  }, se = (r) => {
    const k = getMonth(new Date(r)), P = getYear(new Date(r));
    if (E(0, k), B(0, P), e.multiCalendars > 0)
      for (let q = 1; q < e.multiCalendars; q++) {
        const Ee = wl(set(new Date(r), { year: N.value(q - 1), month: g.value(q - 1) }));
        E(q, Ee.month), B(q, Ee.year);
      }
  }, d = (r) => {
    if (s.value && Array.isArray(s.value))
      if (s.value.some((k) => de(r, k))) {
        const k = s.value.filter((P) => !de(P, r));
        s.value = k.length ? k : null;
      } else
        (e.multiDatesLimit && +e.multiDatesLimit > s.value.length || !e.multiDatesLimit) && s.value.push(r);
    else
      s.value = [r];
  }, I = (r) => {
    if (Array.isArray(s.value) && s.value[0]) {
      const k = differenceInCalendarDays(r, s.value[0]), P = Math.abs(k < 0 ? k + 1 : k - 1);
      if (e.minRange && e.maxRange)
        return P >= +e.minRange && P <= +e.maxRange;
      if (e.minRange)
        return P >= +e.minRange;
      if (e.maxRange)
        return P <= +e.maxRange;
    }
    return true;
  }, u = (r) => Array.isArray(s.value) && s.value.length === 2 ? e.fixedStart && (Ae(r, s.value[0]) || de(r, s.value[0])) ? [s.value[0], r] : e.fixedEnd && (be(r, s.value[1]) || de(r, s.value[1])) ? [r, s.value[1]] : s.value : [], D = () => {
    e.autoApply && a("autoApply");
  }, S = (r) => !eachDayOfInterval({ start: r[0], end: r[1] }).some((k) => j(k)), G = (r, k = false) => {
    if (!j(r.value) && !(!r.current && e.hideOffsetDates)) {
      if (e.weekPicker)
        return s.value = Ft(new Date(r.value), +e.weekStart), D();
      if (!e.range && !Ie(f.value) && !Ie(h.value)) {
        const P = Pe(new Date(r.value), f.value, h.value, Y());
        e.multiDates ? d(P) : s.value = P, n(), D();
      } else if (Ie(f.value) && Ie(h.value) && !e.multiDates) {
        let P = s.value ? s.value.slice() : [];
        if (P.length === 2 && !(e.fixedStart || e.fixedEnd) && (P = []), e.autoRange) {
          const q = [new Date(r.value), addDays(new Date(r.value), +e.autoRange)];
          S(q) && (k && se(r.value), P = q);
        } else
          e.fixedStart || e.fixedEnd ? P = u(new Date(r.value)) : P[0] ? I(new Date(r.value)) && (be(new Date(r.value), new Date(P[0])) ? P.unshift(new Date(r.value)) : P[1] = new Date(r.value)) : P[0] = new Date(r.value);
        P.length && (P[0] && !P[1] ? P[0] = Pe(P[0], f.value[0], h.value[0], Y()) : (P[0] = Pe(P[0], f.value[0], h.value[0], Y()), P[1] = Pe(P[1], f.value[1], h.value[1], Y(false)), n()), s.value = P, P[0] && P[1] && e.autoApply && a("autoApply"));
      }
    }
  }, F = (r) => {
    const k = r.find((P) => P.current);
    return k ? getISOWeek(k.value) : "";
  }, ne = (r) => {
    !r.current && e.hideOffsetDates || (p.value = r.value);
  }, Q = (r) => {
    if (e.autoRange || e.weekPicker) {
      if (p.value) {
        if (e.hideOffsetDates && !r.current)
          return false;
        const k = addDays(p.value, +e.autoRange), P = Ft(new Date(p.value), +e.weekStart);
        return e.weekPicker ? de(P[1], new Date(r.value)) : de(k, new Date(r.value));
      }
      return false;
    }
    return false;
  }, w = (r) => {
    if (e.autoRange || e.weekPicker) {
      if (p.value) {
        const k = addDays(p.value, +e.autoRange);
        if (e.hideOffsetDates && !r.current)
          return false;
        const P = Ft(new Date(p.value), +e.weekStart);
        return e.weekPicker ? Ae(r.value, P[0]) && be(r.value, P[1]) : Ae(r.value, p.value) && be(r.value, k);
      }
      return false;
    }
    return false;
  }, _ = (r) => {
    if (e.autoRange || e.weekPicker) {
      if (p.value) {
        if (e.hideOffsetDates && !r.current)
          return false;
        const k = Ft(new Date(p.value), +e.weekStart);
        return e.weekPicker ? de(k[0], r.value) : de(p.value, r.value);
      }
      return false;
    }
    return false;
  }, V = (r) => {
    for (let k = r - 1; k >= 0; k--) {
      const P = subMonths(set(new Date(), { month: N.value(k + 1), year: g.value(k + 1) }), 1);
      R(k, getMonth(P), getYear(P));
    }
    for (let k = r + 1; k <= e.multiCalendars - 1; k++) {
      const P = addMonths(set(new Date(), { month: N.value(k - 1), year: g.value(k - 1) }), 1);
      R(k, getMonth(P), getYear(P));
    }
  }, ke = (r) => ot(new Date(), N.value(r), g.value(r)), Ye = (r, k, P = true) => {
    if (P ? E(r, k) : B(r, k), e.multiCalendars && !e.multiCalendarsSolo && V(r), e.monthPicker)
      if (e.range) {
        if (P) {
          let q = s.value ? s.value.slice() : [];
          q.length === 2 && q[1] !== null && (q = []), q.length ? be(ke(r), q[0]) ? q.unshift(ke(r)) : q[1] = ke(r) : q = [ke(r)], s.value = q;
        }
      } else
        s.value = ke(r);
    n(), a("updateMonthYear", { instance: r, value: k, isMonth: P }), Pt(e.multiCalendarsSolo ? r : void 0);
  }, Ze = (r) => Pe(r, f.value, h.value, Y()), He = (r) => {
    Dt(r) && Dt(s.value) && Ie(f.value) && Ie(h.value) ? (r[0] && s.value[0] && (s.value[0] = Pe(r[0], f.value[0], h.value[0], Y())), r[1] && s.value[1] && (s.value[1] = Pe(r[1], f.value[1], h.value[1], Y(false)))) : e.multiDates && Array.isArray(s.value) ? s.value[s.value.length - 1] = Ze(r) : !e.range && !Ut(r) && (s.value = Ze(r)), a("timeUpdate");
  }, Oe = (r, k = true, P = false) => {
    const q = k ? r : f.value, Ee = !k && !P ? r : h.value, ht = P ? r : T.value;
    if (e.range && Ut(s.value) && Ie(q) && Ie(Ee) && Ie(ht)) {
      const nt = (We) => Pe(s.value[We], q[We], Ee[We], ht[We]), Ct = (We) => setMilliseconds(s.value[We], 0);
      if (de(s.value[0], s.value[1]) && (isAfter(nt(0), Ct(1)) || isBefore(nt(1), Ct(0))))
        return;
    }
    if (f.value = q, h.value = Ee, T.value = ht, s.value)
      if (e.multiDates) {
        const nt = le();
        nt && He(nt);
      } else
        He(s.value);
    else
      e.timePicker && He(e.range ? [new Date(), new Date()] : new Date());
    n();
  }, Qe = () => {
    p.value = null;
  }, pt = (r) => Zn(s.value, e.range) && s.value[0] && p.value ? r ? Ae(p.value, s.value[0]) : be(p.value, s.value[0]) : true, Fe = (r, k = true) => (e.range || e.weekPicker) && Ut(s.value) ? e.hideOffsetDates && !r.current ? false : de(new Date(r.value), s.value[k ? 0 : 1]) : e.range ? de(new Date(r.value), s.value && Array.isArray(s.value) ? k ? s.value[0] || null : s.value[1] : null) && (k ? !be(p.value || null, Array.isArray(s.value) ? s.value[0] : null) : true) || de(r.value, Array.isArray(s.value) ? s.value[0] : null) && pt(k) : false, Ce = (r, k) => Array.isArray(e.internalModelValue) && e.internalModelValue.length || e.weekPicker ? false : !r && !l(k) && !(!k.current && e.hideOffsetDates) && (e.range ? !Fe(k) && !Fe(k, false) : true), vt = (r, k, P) => Array.isArray(e.internalModelValue) && e.internalModelValue[0] && e.internalModelValue.length === 1 ? r ? false : P ? Ae(e.internalModelValue[0], k.value) : be(e.internalModelValue[0], k.value) : false, xe = (r = false) => {
    r && e.yearPicker && (s.value = setYear(new Date(), v.value[0].year), e.autoApply && a("autoApply")), e.autoApply && e.monthPicker && nextTick().then(() => {
      e.range ? a("autoApply", r || !s.value || s.value.length === 1) : a("autoApply", r);
    });
  }, et = (r, k) => {
    const P = set(new Date(), { month: N.value(k), year: g.value(k) }), q = r < 0 ? addMonths(P, 1) : subMonths(P, 1);
    na(e.minDate, e.maxDate, getMonth(q), getYear(q), r < 0, e.preventMinMaxNavigation) && (R(k, getMonth(q), getYear(q)), e.multiCalendars && !e.multiCalendarsSolo && V(k), Pt());
  }, ft = (r, k) => {
    e.monthChangeOnScroll && et(e.monthChangeOnScroll !== "inverse" ? -r.deltaY : r.deltaY, k);
  }, m = (r, k, P = false) => {
    e.monthChangeOnArrows && e.vertical === P && re(r, k);
  }, re = (r, k) => {
    et(r === "right" ? -1 : 1, k);
  }, fe = (r) => e.markers.find((k) => de(Re(new Date(r.value)), Re(new Date(k.date)))), yt = () => {
    e.range ? Zn(s.value, e.range) && (s.value && s.value[0] ? s.value = be(new Date(), s.value[0]) ? [new Date(), s.value[0]] : [s.value[0], new Date()] : s.value = [new Date()]) : a("update:internalModelValue", new Date()), e.autoApply && a("selectDate");
  }, tt = (r) => {
    r.length && r.length <= 2 && e.range && (s.value = r.map((k) => new Date(k)), e.autoApply && a("selectDate"));
  }, Pt = (r) => {
    r || r === 0 ? t.value[r].triggerTransition(N.value(r), g.value(r)) : t.value.forEach((k, P) => k.triggerTransition(N.value(P), g.value(P)));
  };
  return { today: i, hours: f, minutes: h, seconds: T, month: N, year: g, monthYearSelect: xe, isDisabled: j, updateTime: Oe, setHoverDate: ne, getWeekNum: F, selectDate: G, rangeActive: $, isActiveDate: l, updateMonthYear: Ye, isHoverRangeEnd: Q, isAutoRangeInBetween: w, isAutoRangeStart: _, clearHoverDate: Qe, rangeActiveStartEnd: Fe, handleScroll: ft, getMarker: fe, handleArrow: m, handleSwipe: re, selectCurrentDate: yt, isHoverDate: Ce, isHoverDateStartEnd: vt, presetDateRange: tt };
};
var Fr = ["id", "aria-label", "onKeydown"];
var Er = { key: 0, class: "dp__preset_ranges" };
var Lr = ["onClick"];
var Hr = { key: 1, class: "dp__now_wrap" };
var Ur = defineComponent({ props: De(X(X(X({}, Xn), rn), ln), { internalModelValue: { type: [Date, Array], default: null }, multiCalendars: { type: Number, default: 0 }, openOnTop: { type: Boolean, default: false } }), emits: ["update:internalModelValue", "closePicker", "selectDate", "dpOpen", "autoApply", "timeUpdate", "flow-step", "updateMonthYear"], setup(e, { emit: a }) {
  const n = e, t = useSlots(), i = ref(null), p = reactive({ timePicker: !!(!n.enableTimePicker || n.timePicker || n.monthPicker), monthYearInput: !!n.timePicker, calendar: false }), v = ref([]), f = ref([]), h = ref(null), T = ref(null), N = ref(0), g = ref(false), R = ref(0), E = inject(Et), B = inject(Xe), Y = inject(qe), { setMenuFocused: C, setShiftKey: s } = un();
  onMounted(() => {
    var W;
    g.value = true, (W = n.presetRanges) != null && W.length || P();
    const c = he(T);
    if (c && !n.textInput && !n.inline && (C(true), Z()), c) {
      const H = (J) => {
        J.stopImmediatePropagation(), J.stopPropagation();
      };
      c.addEventListener("pointerdown", H), c.addEventListener("mousedown", H);
    }
    document.addEventListener("resize", P);
  }), onUnmounted(() => {
    document.removeEventListener("resize", P);
  });
  const { arrowRight: j, arrowLeft: l, arrowDown: $, arrowUp: U } = Je(), Z = () => {
    const c = he(T);
    c && c.focus({ preventScroll: true });
  }, ae = () => {
    var c;
    ((c = n.flow) == null ? void 0 : c.length) && R.value !== -1 && (R.value += 1, a("flow-step", R.value), hn());
  }, le = () => {
    R.value = -1;
  }, { updateTime: x, updateMonthYear: se, today: d, month: I, year: u, hours: D, minutes: S, seconds: G, isDisabled: F, isActiveDate: ne, selectDate: Q, getWeekNum: w, setHoverDate: _, isHoverRangeEnd: V, isAutoRangeInBetween: ke, isAutoRangeStart: Ye, rangeActive: Ze, clearHoverDate: He, rangeActiveStartEnd: Oe, monthYearSelect: Qe, handleScroll: pt, handleArrow: Fe, handleSwipe: Ce, getMarker: vt, selectCurrentDate: xe, isHoverDateStartEnd: et, isHoverDate: ft, presetDateRange: m } = Yr(n, a, ae, f), re = st(t, "calendar"), fe = st(t, "action"), yt = st(t, "timePicker"), tt = st(t, "monthYear"), Pt = computed(() => n.openOnTop ? "dp__arrow_bottom" : "dp__arrow_top"), r = computed(() => Al(n.yearRange)), k = computed(() => Tl(n.locale, n.monthNameFormat)), P = () => {
    const c = he(i);
    c && (N.value = c.getBoundingClientRect().width);
  }, q = computed(() => (c) => Sl(I.value(c), u.value(c), +n.weekStart, n.hideOffsetDates)), Ee = computed(() => n.multiCalendars > 0 && n.range ? [...Array(n.multiCalendars).keys()] : [0]), ht = computed(() => (c) => c === 1), nt = computed(() => n.monthPicker || n.timePicker || n.yearPicker), Ct = computed(() => ({ dp__flex_display: n.multiCalendars > 0 })), We = computed(() => ({ dp__instance_calendar: n.multiCalendars > 0 })), aa = computed(() => ({ dp__menu_disabled: n.disabled, dp__menu_readonly: n.readonly })), la = computed(() => (c) => sa(q, c)), ra = computed(() => ({ locale: n.locale, weekNumName: n.weekNumName, weekStart: n.weekStart, weekNumbers: n.weekNumbers, customProps: n.customProps, calendarClassName: n.calendarClassName, specificMode: nt.value, getWeekNum: w, multiCalendars: n.multiCalendars, modeHeight: n.modeHeight, internalModelValue: n.internalModelValue, noSwipe: n.noSwipe, vertical: n.vertical })), oa = computed(() => ({ dp__menu: true, dp__menu_index: !n.inline, dp__relative: n.inline, [n.menuClassName]: !!n.menuClassName })), sa = (c, W) => c.value(W).map((H) => De(X({}, H), { days: H.days.map((J) => {
    const z = F(J.value), gt = ft(z, J), ut = (n.range || n.weekPicker) && (n.multiCalendars > 0 ? J.current : true) && !z && !(!J.current && n.hideOffsetDates) && !ne(J) ? Ze(J) : false;
    return J.marker = vt(J), J.classData = { dp__cell_offset: !J.current, dp__pointer: !z && !(!J.current && n.hideOffsetDates), dp__active_date: n.range ? false : ne(J), dp__date_hover: gt, dp__date_hover_start: et(gt, J, true), dp__date_hover_end: et(gt, J, false), dp__range_between: ut && !n.weekPicker, dp__range_between_week: ut && n.weekPicker, dp__today: !n.noToday && de(J.value, d.value) && J.current, dp__cell_disabled: z, dp__cell_auto_range: ke(J), dp__cell_auto_range_start: Ye(J), dp__cell_auto_range_end: V(J), dp__range_start: n.multiCalendars > 0 ? J.current && Oe(J) : Oe(J), dp__range_end: n.multiCalendars > 0 ? J.current && Oe(J, false) : Oe(J, false), [n.calendarCellClassName]: !!n.calendarCellClassName }, J;
  }) })), ua = (c) => {
    c.stopPropagation(), c.preventDefault(), c.stopImmediatePropagation();
  }, ia = () => {
    n.escClose && a("closePicker");
  }, da = (c) => {
    c.stopImmediatePropagation(), c.preventDefault(), n.spaceConfirm && a("selectDate");
  }, Gt = (c) => {
    var W;
    (W = n.flow) != null && W.length && (p[c] = true, Object.keys(p).filter((H) => !p[H]).length || hn());
  }, hn = () => {
    n.flow[R.value] === "month" && v.value[0] && v.value[0].toggleMonthPicker(true), n.flow[R.value] === "year" && v.value && v.value[0].toggleYearPicker(true), n.flow[R.value] === "calendar" && h.value && h.value.toggleTimePicker(false, true), n.flow[R.value] === "time" && h.value && h.value.toggleTimePicker(true, true);
    const c = n.flow[R.value];
    (c === "hours" || c === "minutes" || c === "seconds") && h.value && h.value.toggleTimePicker(true, true, c);
  }, At = (c) => {
    if (Y != null && Y.value) {
      if (c === "up")
        return U();
      if (c === "down")
        return $();
      if (c === "left")
        return l();
      if (c === "right")
        return j();
    } else
      c === "left" || c === "up" ? Fe("left", 0, c === "up") : Fe("right", 0, c === "down");
  }, ca = (c) => {
    s(c.shiftKey);
  };
  return (c, W) => (openBlock(), createBlock(Transition, { appear: "", name: unref(E).menuAppear, mode: "out-in", css: !!unref(E) }, { default: withCtx(() => [createBaseVNode("div", { id: c.uid ? `dp-menu-${c.uid}` : void 0, tabindex: "0", ref_key: "dpMenuRef", ref: T, role: "dialog", "aria-label": unref(B).menu, class: normalizeClass(unref(oa)), onMouseleave: W[11] || (W[11] = (...H) => unref(He) && unref(He)(...H)), onClick: ua, onKeydown: [withKeys(ia, ["esc"]), withKeys(da, ["space"]), W[12] || (W[12] = withKeys(withModifiers((H) => At("left"), ["prevent"]), ["left"])), W[13] || (W[13] = withKeys(withModifiers((H) => At("up"), ["prevent"]), ["up"])), W[14] || (W[14] = withKeys(withModifiers((H) => At("down"), ["prevent"]), ["down"])), W[15] || (W[15] = withKeys(withModifiers((H) => At("right"), ["prevent"]), ["right"])), ca] }, [(c.disabled || c.readonly) && c.inline ? (openBlock(), createElementBlock("div", { key: 0, class: normalizeClass(unref(aa)) }, null, 2)) : createCommentVNode("", true), c.inline ? createCommentVNode("", true) : (openBlock(), createElementBlock("div", { key: 1, class: normalizeClass(unref(Pt)) }, null, 2)), createBaseVNode("div", { class: normalizeClass(c.presetRanges.length ? "dp__menu_content_wrapper" : null) }, [c.presetRanges.length ? (openBlock(), createElementBlock("div", Er, [(openBlock(true), createElementBlock(Fragment, null, renderList(c.presetRanges, (H, J) => (openBlock(), createElementBlock("div", { key: J, class: "dp__preset_range", onClick: (z) => unref(m)(H.range) }, toDisplayString(H.label), 9, Lr))), 128))])) : createCommentVNode("", true), createBaseVNode("div", { class: "dp__instance_calendar", ref_key: "calendarWrapperRef", ref: i, role: "document" }, [createBaseVNode("div", { class: normalizeClass(unref(Ct)) }, [(openBlock(true), createElementBlock(Fragment, null, renderList(unref(Ee), (H, J) => (openBlock(), createElementBlock("div", { key: H, class: normalizeClass(unref(We)) }, [!c.disableMonthYearSelect && !c.timePicker ? (openBlock(), createBlock(resolveDynamicComponent(c.monthYearComponent ? c.monthYearComponent : Ir), mergeProps({ key: 0, ref_for: true, ref: (z) => {
    z && (v.value[J] = z);
  } }, { months: unref(k), years: unref(r), filters: c.filters, monthPicker: c.monthPicker, month: unref(I)(H), year: unref(u)(H), customProps: c.customProps, multiCalendars: e.multiCalendars, multiCalendarsSolo: c.multiCalendarsSolo, instance: H, minDate: c.minDate, maxDate: c.maxDate, preventMinMaxNavigation: c.preventMinMaxNavigation, internalModelValue: e.internalModelValue, range: c.range, reverseYears: c.reverseYears, vertical: c.vertical, yearPicker: c.yearPicker }, { onMount: W[0] || (W[0] = (z) => Gt("monthYearInput")), onResetFlow: le, "onUpdate:month": (z) => unref(se)(H, z, true), "onUpdate:year": (z) => unref(se)(H, z, false), onMonthYearSelect: unref(Qe), onOverlayClosed: Z }), createSlots({ _: 2 }, [renderList(unref(tt), (z, gt) => ({ name: z, fn: withCtx((ut) => [renderSlot(c.$slots, z, normalizeProps(guardReactiveProps(ut)))]) }))]), 1040, ["onUpdate:month", "onUpdate:year", "onMonthYearSelect"])) : createCommentVNode("", true), createVNode(Zl, mergeProps({ ref_for: true, ref: (z) => {
    z && (f.value[J] = z);
  } }, unref(ra), { "flow-step": R.value, "onUpdate:flow-step": W[1] || (W[1] = (z) => R.value = z), instance: H, "mapped-dates": unref(la)(H), month: unref(I)(H), year: unref(u)(H), onSelectDate: (z) => unref(Q)(z, !unref(ht)(H)), onSetHoverDate: W[2] || (W[2] = (z) => unref(_)(z)), onHandleScroll: (z) => unref(pt)(z, H), onHandleSwipe: (z) => unref(Ce)(z, H), onMount: W[3] || (W[3] = (z) => Gt("calendar")), onResetFlow: le }), createSlots({ _: 2 }, [renderList(unref(re), (z, gt) => ({ name: z, fn: withCtx((ut) => [renderSlot(c.$slots, z, normalizeProps(guardReactiveProps(X({}, ut))))]) }))]), 1040, ["flow-step", "instance", "mapped-dates", "month", "year", "onSelectDate", "onHandleScroll", "onHandleSwipe"])], 2))), 128))], 2), createBaseVNode("div", null, [c.enableTimePicker && !c.monthPicker && !c.weekPicker ? (openBlock(), createBlock(resolveDynamicComponent(c.timePickerComponent ? c.timePickerComponent : Cr), mergeProps({ key: 0, ref_key: "timePickerRef", ref: h }, { is24: c.is24, hoursIncrement: c.hoursIncrement, minutesIncrement: c.minutesIncrement, hoursGridIncrement: c.hoursGridIncrement, secondsIncrement: c.secondsIncrement, minutesGridIncrement: c.minutesGridIncrement, secondsGridIncrement: c.secondsGridIncrement, noHoursOverlay: c.noHoursOverlay, noMinutesOverlay: c.noMinutesOverlay, noSecondsOverlay: c.noSecondsOverlay, range: c.range, filters: c.filters, timePicker: c.timePicker, hours: unref(D), minutes: unref(S), seconds: unref(G), customProps: c.customProps, enableSeconds: c.enableSeconds, fixedStart: c.fixedStart, fixedEnd: c.fixedEnd }, { onMount: W[4] || (W[4] = (H) => Gt("timePicker")), "onUpdate:hours": W[5] || (W[5] = (H) => unref(x)(H)), "onUpdate:minutes": W[6] || (W[6] = (H) => unref(x)(H, false)), "onUpdate:seconds": W[7] || (W[7] = (H) => unref(x)(H, false, true)), onResetFlow: le, onOverlayClosed: Z }), createSlots({ _: 2 }, [renderList(unref(yt), (H, J) => ({ name: H, fn: withCtx((z) => [renderSlot(c.$slots, H, normalizeProps(guardReactiveProps(z)))]) }))]), 1040)) : createCommentVNode("", true)])], 512), c.showNowButton ? (openBlock(), createElementBlock("div", Hr, [c.$slots["now-button"] ? renderSlot(c.$slots, "now-button", { key: 0, selectCurrentDate: unref(xe) }) : createCommentVNode("", true), c.$slots["now-button"] ? createCommentVNode("", true) : (openBlock(), createElementBlock("button", { key: 1, type: "button", role: "button", class: "dp__now_button", onClick: W[8] || (W[8] = (...H) => unref(xe) && unref(xe)(...H)) }, toDisplayString(c.nowButtonLabel), 1))])) : createCommentVNode("", true)], 2), !c.autoApply || c.keepActionRow ? (openBlock(), createBlock(resolveDynamicComponent(c.actionRowComponent ? c.actionRowComponent : ur), mergeProps({ key: 2 }, { calendarWidth: N.value, selectText: c.selectText, cancelText: c.cancelText, internalModelValue: e.internalModelValue, range: c.range, previewFormat: c.previewFormat, inline: c.inline, monthPicker: c.monthPicker, timePicker: c.timePicker, customProps: c.customProps, multiCalendars: e.multiCalendars, menuMount: g.value, maxTime: c.maxTime, minTime: c.minTime, enableTimePicker: c.enableTimePicker, minDate: c.minDate, maxDate: c.maxDate, multiDates: c.multiDates }, { onClosePicker: W[9] || (W[9] = (H) => c.$emit("closePicker")), onSelectDate: W[10] || (W[10] = (H) => c.$emit("selectDate")) }), createSlots({ _: 2 }, [renderList(unref(fe), (H, J) => ({ name: H, fn: withCtx((z) => [renderSlot(c.$slots, H, normalizeProps(guardReactiveProps(X({}, z))))]) }))]), 1040)) : createCommentVNode("", true)], 42, Fr)]), _: 3 }, 8, ["name", "css"]));
} });
var jt = ((e) => (e.center = "center", e.left = "left", e.right = "right", e))(jt || {});
var Kr = (e, a, n, t, i, p, v) => {
  const f = ref({ top: "0", left: "0", transform: "none" }), h = ref(false), T = 10, N = 390, g = (l) => {
    const $ = l.getBoundingClientRect();
    return { left: $.left + window.scrollX, top: $.top + window.scrollY };
  }, R = (l) => {
    const $ = l.getBoundingClientRect();
    let U = 0, Z = 0;
    for (; l && !isNaN(l.offsetLeft) && !isNaN(l.offsetTop); )
      U += l.offsetLeft - l.scrollLeft, Z = $.top + l.scrollTop, l = l.offsetParent;
    return { top: Z, left: U };
  }, E = (l, $) => {
    f.value.left = `${l + $}px`, f.value.transform = "translateX(-100%)";
  }, B = (l) => {
    f.value.left = `${l}px`, f.value.transform = "translateX(0)";
  }, Y = (l, $) => {
    e === jt.left && B(l), e === jt.right && E(l, $), e === jt.center && (f.value.left = `${l + $ / 2}px`, f.value.transform = "translateX(-50%)");
  }, C = () => {
    const l = he(i);
    if (l) {
      const $ = window.innerHeight, { top: U } = a ? R(l) : g(l), { left: Z, width: ae, top: le, height: x } = l.getBoundingClientRect(), se = $ - le - x;
      f.value.top = le > se ? `${U - N}px` : `${U}px`, Y(Z, ae);
    }
  }, s = (l = true) => {
    if (!p) {
      const $ = he(i);
      if (a && typeof a != "boolean")
        f.value = a($);
      else if ($) {
        const { left: U, width: Z, height: ae } = $.getBoundingClientRect(), { top: le } = a ? R($) : g($);
        f.value.top = `${ae + le + T}px`, Y(U, Z), l && n && j();
      }
    }
  }, j = () => {
    const l = he(i);
    if (l && n && !p) {
      const { height: $, top: U, left: Z, width: ae } = l.getBoundingClientRect(), { top: le } = a ? R(l) : g(l), x = window.innerHeight - U - $, se = he(t);
      if (se) {
        const { height: d, left: I, right: u } = se.getBoundingClientRect(), D = d + $;
        D > U && D > x ? U < x && (s(false), h.value = false) : D > x ? (f.value.top = `${le - d - T}px`, h.value = true) : (s(false), h.value = false), I < 0 ? B(Z) : u > document.documentElement.clientWidth && E(Z, ae);
      }
    }
    v("recalculatePosition");
  };
  return { openOnTop: h, menuPosition: f, setMenuPosition: s, setInitialPosition: C, recalculatePosition: j };
};
var Wr = (e, a, n, t, i, p, v, f, h, T, N, g, R, E, B) => {
  const Y = ref(""), C = ref();
  watch(C, () => {
    B("internalModelChange", C.value);
  });
  const s = (l) => {
    let $ = null;
    l ? a ? xl(l) && "hours" in l[0] && "minutes" in l[0] ? $ = [Pe(null, +l[0].hours, +l[0].minutes, +l[0].seconds), Pe(null, +l[1].hours, +l[1].minutes, +l[1].seconds)] : Ql(l) && ($ = Pe(null, +l.hours, +l.minutes, +l.seconds)) : n ? er(l) && "month" in l[0] && "year" in l[0] ? ($ = [ot(null, +l[0].month, +l[0].year)], l[1] ? $[1] = ot(null, +l[1].month, +l[1].year) : !l[1] && i && ($[1] = null)) : tr(l) && "month" in l && "year" in l && ($ = ot(null, +l.month, +l.year)) : R ? $ = setYear(new Date(), l) : T && Array.isArray(l) ? $ = l.map((U) => new Date(U)) : g && Array.isArray(l) ? $ = [new Date(l[0]), new Date(l[1])] : t ? nr(l, i) && ($ = [new Date(l[0]), l[1] ? new Date(l[1]) : null]) : lr(l) && ($ = new Date(l)) : $ = null, Zt($) ? (C.value = $, j()) : (C.value = null, Y.value = "");
  }, j = () => {
    if (!C.value)
      Y.value = "";
    else if (!e || typeof e == "string") {
      const l = Bn(e, p, f, n, a, g, R, v);
      Array.isArray(C.value) && T ? Y.value = C.value.map(($) => Yt($, l, h == null ? void 0 : h.value)).join("; ") : Y.value = Yt(C.value, l, h == null ? void 0 : h.value, E == null ? void 0 : E.rangeSeparator);
    } else
      a ? Y.value = e(xt(C.value)) : n ? Y.value = e(Nn(C.value)) : Y.value = e(C.value);
  };
  return { parseExternalModelValue: s, formatInputValue: j, internalModelValue: C, inputValue: Y, emitModelValue: () => {
    if (n)
      B("update:modelValue", Nn(C.value));
    else if (a)
      B("update:modelValue", xt(C.value));
    else if (g)
      B("update:modelValue", C.value);
    else if (R)
      B("update:modelValue", getYear(C.value));
    else {
      C.value && t && i && C.value.length === 1 && C.value.push(null);
      const l = N ? Array.isArray(C.value) ? C.value.map(($) => $ && Re($)) : Re(C.value) : C.value;
      B("update:modelValue", l);
    }
    j();
  }, checkBeforeEmit: () => C.value ? t ? i ? C.value.length >= 1 : C.value.length === 2 : !!C.value : false };
};
var jr = typeof window < "u" ? window : void 0;
var fn = () => {
};
var Gr = (e) => getCurrentScope() ? (onScopeDispose(e), true) : false;
var zr = (e, a, n, t) => {
  if (!e)
    return fn;
  let i = fn;
  const p = watch(() => unref(e), (f) => {
    i(), f && (f.addEventListener(a, n, t), i = () => {
      f.removeEventListener(a, n, t), i = fn;
    });
  }, { immediate: true, flush: "post" }), v = () => {
    p(), i();
  };
  return Gr(v), v;
};
var Xr = (e, a, n, t = {}) => {
  const { window: i = jr, event: p = "pointerdown" } = t;
  return i ? zr(i, p, (v) => {
    const f = he(e), h = he(a);
    !f || !h || f === v.target || v.composedPath().includes(f) || v.composedPath().includes(h) || n(v);
  }, { passive: true }) : void 0;
};
var qr = defineComponent({ props: X({}, Il), emits: ["update:modelValue", "textSubmit", "closed", "cleared", "open", "focus", "blur", "internalModelChange", "recalculatePosition", "flow-step", "focus-prev", "updateMonthYear"], setup(e, { expose: a, emit: n }) {
  const t = e, i = useSlots(), p = ref(false), v = toRef(t, "modelValue"), f = ref(null), h = ref(null), T = ref(null), N = ref(null);
  provide(an, t.autoApply);
  const g = computed(() => t.formatLocale);
  provide(Hn, g), provide(Ln, toRef(t, "textInput")), provide(qe, toRef(t, "arrowNavigation")), onMounted(() => {
    U(t.modelValue), t.inline || (window.addEventListener("scroll", V), window.addEventListener("resize", ke)), t.inline && (p.value = true);
  }), onUnmounted(() => {
    t.inline || (window.removeEventListener("scroll", V), window.removeEventListener("resize", ke));
  });
  const R = st(i, "all"), E = st(i, "input");
  watch(v, () => {
    U(v.value);
  }, { deep: true });
  const { openOnTop: B, menuPosition: Y, setMenuPosition: C, recalculatePosition: s, setInitialPosition: j } = Kr(t.position, t.altPosition, t.autoPosition, f, h, t.inline, n), { internalModelValue: l, inputValue: $, parseExternalModelValue: U, emitModelValue: Z, checkBeforeEmit: ae, formatInputValue: le } = Wr(t.format, t.timePicker, t.monthPicker, t.range, t.partialRange, t.is24, t.enableTimePicker, t.enableSeconds, g, t.multiDates, t.utc, t.weekPicker, t.yearPicker, t.textInputOptions, n), { clearArrowNav: x } = Je(), { setMenuFocused: se, setShiftKey: d } = un(), I = computed(() => ({ dp__main: true, dp__theme_dark: t.dark, dp__theme_light: !t.dark, dp__flex_display: t.inline, dp__flex_display_with_input: t.inlineWithInput })), u = computed(() => Qn(t.format) ? t.format : Bn(null, t.is24, t.enableSeconds, t.monthPicker, t.timePicker, t.weekPicker, t.yearPicker, t.enableTimePicker)), D = computed(() => t.previewFormat ? t.previewFormat : Qn(u.value) ? u.value : t.format), S = computed(() => typeof t.transitions == "boolean" ? t.transitions ? En({}) : false : En(t.transitions));
  provide(Et, S);
  const G = computed(() => t.dark ? "dp__theme_dark" : "dp__theme_light"), F = computed(() => Object.assign(Ol(), t.textInputOptions)), ne = computed(() => Nl(t.ariaLabels));
  provide(Xe, ne);
  const Q = computed(() => _l(t.filters)), w = computed(() => {
    const m = (re) => {
      const fe = { hours: getHours(new Date()), minutes: getMinutes(new Date()), seconds: getSeconds(new Date()) };
      return Object.assign(fe, re);
    };
    return t.range ? t.startTime && Array.isArray(t.startTime) ? [m(t.startTime[0]), m(t.startTime[1])] : null : t.startTime && !Array.isArray(t.startTime) ? m(t.startTime) : null;
  }), _ = computed(() => t.multiCalendars === null ? 0 : typeof t.multiCalendars == "boolean" ? t.multiCalendars ? 2 : 0 : +t.multiCalendars >= 2 ? +t.multiCalendars : 2), V = () => {
    p.value && (t.closeOnScroll ? Ce() : t.autoPosition ? C() : window.removeEventListener("scroll", V));
  }, ke = () => {
    p.value && C();
  }, Ye = () => {
    !t.disabled && !t.readonly && (j(), p.value = true, nextTick().then(() => {
      C(), p.value && (n("open"), n("focus"));
    }), p.value || Fe(), U(t.modelValue));
  }, Ze = () => {
    $.value = "", Fe(), n("update:modelValue", null), n("cleared"), Ce();
  }, He = () => {
    const { validate: m } = Fn(t.minDate, t.maxDate, t.disabledDates, t.allowedDates, Q.value, t.disabledWeekDays, t.yearRange), re = l.value;
    return !Array.isArray(re) && m(re) ? true : Array.isArray(re) ? re.length === 2 && m(re[0]) && m(re[1]) ? true : !!m(re[0]) : false;
  }, Oe = () => {
    ae() && He() && (Z(), Ce());
  }, Qe = (m) => {
    Z(), t.closeOnAutoApply && !m && Ce();
  }, pt = (m = false) => {
    t.autoApply && (!t.enableTimePicker || t.monthPicker || t.yearPicker ? true : nn(l.value, t.maxTime, t.minTime)) && He() && (t.range && Array.isArray(l.value) ? (t.partialRange || l.value.length === 2) && Qe(m) : Qe(m));
  }, Fe = () => {
    l.value = null;
  }, Ce = () => {
    t.inline || (p.value && (p.value = false, se(false), d(false), x(), n("closed"), n("blur"), j(), $.value && U(v.value)), Fe(), h.value && h.value.unFocus(), et());
  }, vt = (m, re) => {
    if (!m) {
      l.value = null;
      return;
    }
    l.value = m, re && (Oe(), n("textSubmit"));
  }, xe = () => {
    t.autoApply && nn(l.value, t.maxTime, t.minTime) && Z();
  }, et = () => {
    T.value && T.value.focus({ preventScroll: true });
  }, ft = () => p.value ? Ce() : Ye();
  return Xr(f, h, Ce), a({ closeMenu: Ce, selectDate: Oe, clearValue: Ze, openMenu: Ye, onScroll: V, formatInputValue: le }), (m, re) => (openBlock(), createElementBlock("div", { class: normalizeClass(unref(I)) }, [createBaseVNode("span", { tabindex: "-1", ref_key: "focusRefBefore", ref: N }, null, 512), createVNode(Hl, mergeProps({ ref_key: "inputRef", ref: h }, { placeholder: m.placeholder, hideInputIcon: m.hideInputIcon, readonly: m.readonly, disabled: m.disabled, inputClassName: m.inputClassName, clearable: m.clearable, state: m.state, inline: m.inline, inlineWithInput: m.inlineWithInput, textInput: m.textInput, textInputOptions: unref(F), range: m.range, isMenuOpen: p.value, pattern: unref(u), autoApply: m.autoApply, uid: m.uid, openMenuOnFocus: m.openMenuOnFocus, required: m.required, name: m.name, autocomplete: m.autocomplete }, { "input-value": unref($), "onUpdate:input-value": re[0] || (re[0] = (fe) => isRef($) ? $.value = fe : null), onClear: Ze, onOpen: Ye, onSetInputDate: vt, onSetEmptyDate: unref(Z), onSelectDate: Oe, onToggle: ft, onClose: Ce, onFocusPrev: re[1] || (re[1] = (fe) => m.$emit("focus-prev")) }), createSlots({ _: 2 }, [renderList(unref(E), (fe, yt) => ({ name: fe, fn: withCtx((tt) => [renderSlot(m.$slots, fe, normalizeProps(guardReactiveProps(tt)))]) }))]), 1040, ["input-value", "onSetEmptyDate"]), createBaseVNode("span", { tabindex: "-1", ref_key: "focusRef", ref: T }, null, 512), p.value ? (openBlock(), createBlock(Teleport, { key: 0, to: m.teleport, disabled: m.inline }, [p.value ? (openBlock(), createBlock(Ur, mergeProps({ key: 0, ref_key: "dpMenuRef", ref: f, class: unref(G), style: unref(Y) }, { weekNumbers: m.weekNumbers, weekStart: m.weekStart, disableMonthYearSelect: m.disableMonthYearSelect, menuClassName: m.menuClassName, calendarClassName: m.calendarClassName, yearRange: m.yearRange, range: m.range, multiCalendars: unref(_), multiCalendarsSolo: m.multiCalendarsSolo, multiStatic: m.multiStatic, calendarCellClassName: m.calendarCellClassName, enableTimePicker: m.enableTimePicker, is24: m.is24, hoursIncrement: m.hoursIncrement, minutesIncrement: m.minutesIncrement, hoursGridIncrement: m.hoursGridIncrement, minutesGridIncrement: m.minutesGridIncrement, minDate: m.minDate, maxDate: m.maxDate, autoApply: m.autoApply, selectText: m.selectText, cancelText: m.cancelText, previewFormat: unref(D), locale: m.locale, weekNumName: m.weekNumName, disabledDates: m.disabledDates, filters: unref(Q), minTime: m.minTime, maxTime: m.maxTime, inline: m.inline, openOnTop: unref(B), monthPicker: m.monthPicker, timePicker: m.timePicker, monthNameFormat: m.monthNameFormat, startDate: m.startDate, startTime: unref(w), monthYearComponent: m.monthYearComponent, timePickerComponent: m.timePickerComponent, actionRowComponent: m.actionRowComponent, customProps: m.customProps, hideOffsetDates: m.hideOffsetDates, autoRange: m.autoRange, noToday: m.noToday, noHoursOverlay: m.noHoursOverlay, noMinutesOverlay: m.noMinutesOverlay, disabledWeekDays: m.disabledWeekDays, allowedDates: m.allowedDates, showNowButton: m.showNowButton, nowButtonLabel: m.nowButtonLabel, monthChangeOnScroll: m.monthChangeOnScroll, markers: m.markers, uid: m.uid, modeHeight: m.modeHeight, enableSeconds: m.enableSeconds, secondsIncrement: m.secondsIncrement, secondsGridIncrement: m.secondsGridIncrement, noSecondsOverlay: m.noSecondsOverlay, escClose: m.escClose, spaceConfirm: m.spaceConfirm, monthChangeOnArrows: m.monthChangeOnArrows, textInput: m.textInput, disabled: m.disabled, readonly: m.readonly, multiDates: m.multiDates, presetRanges: m.presetRanges, flow: m.flow, preventMinMaxNavigation: m.preventMinMaxNavigation, minRange: m.minRange, maxRange: m.maxRange, fixedStart: m.fixedStart, fixedEnd: m.fixedEnd, multiDatesLimit: m.multiDatesLimit, reverseYears: m.reverseYears, keepActionRow: m.keepActionRow, weekPicker: m.weekPicker, noSwipe: m.noSwipe, vertical: m.vertical, arrowNavigation: m.arrowNavigation, yearPicker: m.yearPicker }, { internalModelValue: unref(l), "onUpdate:internalModelValue": re[2] || (re[2] = (fe) => isRef(l) ? l.value = fe : null), onClosePicker: Ce, onSelectDate: Oe, onDpOpen: unref(s), onAutoApply: pt, onTimeUpdate: xe, onFlowStep: re[3] || (re[3] = (fe) => m.$emit("flow-step", fe)), onUpdateMonthYear: re[4] || (re[4] = (fe) => m.$emit("updateMonthYear", fe)) }), createSlots({ _: 2 }, [renderList(unref(R), (fe, yt) => ({ name: fe, fn: withCtx((tt) => [renderSlot(m.$slots, fe, normalizeProps(guardReactiveProps(X({}, tt))))]) }))]), 1040, ["class", "style", "internalModelValue", "onDpOpen"])) : createCommentVNode("", true)], 8, ["to", "disabled"])) : createCommentVNode("", true)], 2));
} });
var yn = (() => {
  const e = qr;
  return e.install = (a) => {
    a.component("Vue3DatePicker", e);
  }, e;
})();
var Jr = Object.freeze(Object.defineProperty({ __proto__: null, default: yn }, Symbol.toStringTag, { value: "Module" }));
Object.entries(Jr).forEach(([e, a]) => {
  e !== "default" && (yn[e] = a);
});

// dep:@vuepic_vue-datepicker
var vuepic_vue_datepicker_default = yn;
export {
  vuepic_vue_datepicker_default as default
};
//# sourceMappingURL=@vuepic_vue-datepicker.js.map
