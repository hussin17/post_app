import "./chunk-BYTJ6LW2.js";
import {
  Comment,
  Fragment,
  computed,
  createBlock,
  createCommentVNode,
  createVNode,
  defineComponent,
  inject,
  onBeforeUnmount,
  onMounted,
  openBlock,
  popScopeId,
  provide,
  pushScopeId,
  ref,
  renderSlot,
  toRef,
  vShow,
  watch,
  withDirectives,
  withScopeId
} from "./chunk-VBJ4LH5I.js";
import "./chunk-OROXOI2D.js";

// node_modules/vue3-google-map/dist/es/index.js
var p = Symbol("map");
var q = Symbol("api");
var r = Symbol("marker");
var t = Symbol("mapTilesLoaded");
var u = ref(null);
var v = "click dblclick drag dragend dragstart mousedown mousemove mouseout mouseover mouseup rightclick".split(" ");
var x = function w(a, b) {
  if (a === b)
    return true;
  if (a && b && "object" == typeof a && "object" == typeof b) {
    if (a.constructor !== b.constructor)
      return false;
    var c;
    if (Array.isArray(a)) {
      var d = a.length;
      if (d != b.length)
        return false;
      for (c = d; 0 !== c--; )
        if (!w(a[c], b[c]))
          return false;
      return true;
    }
    if (a.constructor === RegExp)
      return a.source === b.source && a.flags === b.flags;
    if (a.valueOf !== Object.prototype.valueOf)
      return a.valueOf() === b.valueOf();
    if (a.toString !== Object.prototype.toString)
      return a.toString() === b.toString();
    var g = Object.keys(a);
    d = g.length;
    if (d !== Object.keys(b).length)
      return false;
    for (c = d; 0 !== c--; )
      if (!Object.prototype.hasOwnProperty.call(b, g[c]))
        return false;
    for (c = d; 0 !== c--; )
      if (d = g[c], !w(a[d], b[d]))
        return false;
    return true;
  }
  return a !== a && b !== b;
};
var y = class {
  constructor({ apiKey: a, channel: b, client: e, id: c = "__googleMapsScriptId", libraries: d = [], language: g, region: f, version: m, mapIds: h, nonce: n, retries: k = 3, url: l = "https://maps.googleapis.com/maps/api/js" }) {
    this.CALLBACK = "__googleMapsCallback";
    this.callbacks = [];
    this.loading = this.done = false;
    this.errors = [];
    this.version = m;
    this.apiKey = a;
    this.channel = b;
    this.client = e;
    this.id = c || "__googleMapsScriptId";
    this.libraries = d;
    this.language = g;
    this.region = f;
    this.mapIds = h;
    this.nonce = n;
    this.retries = k;
    this.url = l;
    if (y.instance) {
      if (!x(
        this.options,
        y.instance.options
      ))
        throw Error(`Loader must not be called again with different options. ${JSON.stringify(this.options)} !== ${JSON.stringify(y.instance.options)}`);
      return y.instance;
    }
    y.instance = this;
  }
  get options() {
    return { version: this.version, apiKey: this.apiKey, channel: this.channel, client: this.client, id: this.id, libraries: this.libraries, language: this.language, region: this.region, mapIds: this.mapIds, nonce: this.nonce, url: this.url };
  }
  get failed() {
    return this.done && !this.loading && this.errors.length >= this.retries + 1;
  }
  createUrl() {
    let a = this.url;
    a += `?callback=${this.CALLBACK}`;
    this.apiKey && (a += `&key=${this.apiKey}`);
    this.channel && (a += `&channel=${this.channel}`);
    this.client && (a += `&client=${this.client}`);
    0 < this.libraries.length && (a += `&libraries=${this.libraries.join(",")}`);
    this.language && (a += `&language=${this.language}`);
    this.region && (a += `&region=${this.region}`);
    this.version && (a += `&v=${this.version}`);
    this.mapIds && (a += `&map_ids=${this.mapIds.join(",")}`);
    return a;
  }
  deleteScript() {
    let a = document.getElementById(this.id);
    a && a.remove();
  }
  load() {
    return this.loadPromise();
  }
  loadPromise() {
    return new Promise((a, b) => {
      this.loadCallback((e) => {
        e ? b(e.error) : a(window.google);
      });
    });
  }
  loadCallback(a) {
    this.callbacks.push(a);
    this.execute();
  }
  setScript() {
    if (document.getElementById(this.id))
      this.callback();
    else {
      var a = this.createUrl(), b = document.createElement("script");
      b.id = this.id;
      b.type = "text/javascript";
      b.src = a;
      b.onerror = this.loadErrorCallback.bind(this);
      b.defer = true;
      b.async = true;
      this.nonce && (b.nonce = this.nonce);
      document.head.appendChild(b);
    }
  }
  reset() {
    this.deleteScript();
    this.loading = this.done = false;
    this.errors = [];
    this.onerrorEvent = null;
  }
  resetIfRetryingFailed() {
    this.failed && this.reset();
  }
  loadErrorCallback(a) {
    this.errors.push(a);
    this.errors.length <= this.retries ? (a = this.errors.length * Math.pow(2, this.errors.length), console.log(`Failed to load Google Maps script, retrying in ${a} ms.`), setTimeout(() => {
      this.deleteScript();
      this.setScript();
    }, a)) : (this.onerrorEvent = a, this.callback());
  }
  setCallback() {
    window.__googleMapsCallback = this.callback.bind(this);
  }
  callback() {
    this.done = true;
    this.loading = false;
    this.callbacks.forEach((a) => {
      a(this.onerrorEvent);
    });
    this.callbacks = [];
  }
  execute() {
    this.resetIfRetryingFailed();
    this.done ? this.callback() : window.google && window.google.maps && window.google.maps.version ? (console.warn("Google Maps already loaded outside @googlemaps/js-api-loader.This may result in undesirable behavior as options and script parameters may not match."), this.callback()) : this.loading || (this.loading = true, this.setCallback(), this.setScript());
  }
};
var z = "bounds_changed center_changed click dblclick drag dragend dragstart heading_changed idle maptypeid_changed mousemove mouseout mouseover projection_changed resize rightclick tilesloaded tilt_changed zoom_changed".split(" ");
var A = defineComponent({ props: {
  apiKey: { type: String, default: "" },
  version: { type: String, default: "weekly" },
  libraries: { type: Array, default: () => ["places"] },
  region: { type: String, required: false },
  language: { type: String, required: false },
  backgroundColor: { type: String, required: false },
  center: { type: Object, default: () => ({ lat: 0, lng: 0 }) },
  clickableIcons: { type: Boolean, required: false, default: void 0 },
  controlSize: { type: Number, required: false },
  disableDefaultUi: { type: Boolean, required: false, default: void 0 },
  disableDoubleClickZoom: {
    type: Boolean,
    required: false,
    default: void 0
  },
  draggable: { type: Boolean, required: false, default: void 0 },
  draggableCursor: { type: String, required: false },
  draggingCursor: { type: String, required: false },
  fullscreenControl: { type: Boolean, required: false, default: void 0 },
  fullscreenControlPosition: { type: String, required: false },
  gestureHandling: { type: String, required: false },
  heading: { type: Number, required: false },
  keyboardShortcuts: { type: Boolean, required: false, default: void 0 },
  mapTypeControl: { type: Boolean, required: false, default: void 0 },
  mapTypeControlOptions: { type: Object, required: false },
  mapTypeId: { type: [Number, String], required: false },
  maxZoom: { type: Number, required: false },
  minZoom: { type: Number, required: false },
  noClear: { type: Boolean, required: false, default: void 0 },
  panControl: { type: Boolean, required: false, default: void 0 },
  panControlPosition: { type: String, required: false },
  restriction: { type: Object, required: false },
  rotateControl: { type: Boolean, required: false, default: void 0 },
  rotateControlPosition: { type: String, required: false },
  scaleControl: { type: Boolean, required: false, default: void 0 },
  scaleControlStyle: { type: Number, required: false },
  scrollwheel: { type: Boolean, required: false, default: void 0 },
  streetView: { type: Object, required: false },
  streetViewControl: { type: Boolean, required: false, default: void 0 },
  streetViewControlPosition: { type: String, required: false },
  styles: { type: Array, required: false },
  tilt: { type: Number, required: false },
  zoom: { type: Number, required: false },
  zoomControl: { type: Boolean, required: false, default: void 0 },
  zoomControlPosition: { type: String, required: false }
}, emits: z, setup(a, { emit: b }) {
  let e = ref(null), c = ref(false), d = ref(null), g = ref(null), f = ref(false);
  provide(p, d);
  provide(
    q,
    g
  );
  provide(t, f);
  let m = () => {
    const b2 = { ...a };
    Object.keys(b2).forEach((a2) => {
      void 0 === b2[a2] && delete b2[a2];
    });
    var l = (a2) => {
      var b3;
      return a2 ? { position: null === (b3 = g.value) || void 0 === b3 ? void 0 : b3.ControlPosition[a2] } : {};
    };
    l = {
      scaleControlOptions: a.scaleControlStyle ? { style: a.scaleControlStyle } : {},
      panControlOptions: l(a.panControlPosition),
      zoomControlOptions: l(a.zoomControlPosition),
      rotateControlOptions: l(a.rotateControlPosition),
      streetViewControlOptions: l(a.streetViewControlPosition),
      fullscreenControlOptions: l(a.fullscreenControlPosition),
      disableDefaultUI: a.disableDefaultUi
    };
    return { ...b2, ...l };
  }, h = watch([g, d], ([a2, b2]) => {
    a2 && b2 && (a2.event.addListenerOnce(b2, "tilesloaded", () => {
      f.value = true;
    }), setTimeout(h, 0));
  }, { immediate: true }), n = () => {
    try {
      const { apiKey: b2, region: l, version: c2, language: d2, libraries: e2 } = a;
      u.value = new y({ apiKey: b2, region: l, version: c2, language: d2, libraries: e2 });
    } catch (k) {
      console.error(k);
    }
  };
  onMounted(() => {
    n();
    u.value.load().then(() => {
      g.value = google.maps;
      d.value = new google.maps.Map(e.value, m());
      z.forEach((a2) => {
        var c2;
        null === (c2 = d.value) || void 0 === c2 ? void 0 : c2.addListener(a2, (c3) => b(a2, c3));
      });
      c.value = true;
      let k = Object.keys(a).filter((a2) => !["center", "zoom"].includes(a2)).map((b2) => toRef(a, b2));
      watch([() => a.center, () => a.zoom, ...k], ([a2, b2], [c2, e2]) => {
        var l, k2, f2;
        let { center: g2, zoom: h2, ...n2 } = m();
        null === (l = d.value) || void 0 === l ? void 0 : l.setOptions(n2);
        void 0 !== b2 && b2 !== e2 && (null === (k2 = d.value) || void 0 === k2 ? void 0 : k2.setZoom(b2));
        b2 = !c2 || a2.lng !== c2.lng || a2.lat !== c2.lat;
        a2 && b2 && (null === (f2 = d.value) || void 0 === f2 ? void 0 : f2.panTo(a2));
      });
    });
  });
  onBeforeUnmount(() => {
    var a2;
    f.value = false;
    d.value && (null === (a2 = g.value) || void 0 === a2 ? void 0 : a2.event.clearInstanceListeners(d.value));
  });
  return { mapRef: e, ready: c, map: d, api: g, mapTilesLoaded: f };
} });
function B(a, b) {
  void 0 === b && (b = {});
  b = b.insertAt;
  if (a && "undefined" !== typeof document) {
    var e = document.head || document.getElementsByTagName("head")[0], c = document.createElement("style");
    c.type = "text/css";
    "top" === b ? e.firstChild ? e.insertBefore(c, e.firstChild) : e.appendChild(c) : e.appendChild(c);
    c.styleSheet ? c.styleSheet.cssText = a : c.appendChild(document.createTextNode(a));
  }
}
B("\n.mapdiv[data-v-177d06e3] {\n  width: 100%;\n  height: 100%;\n}\n");
var C = withScopeId("data-v-177d06e3");
pushScopeId("data-v-177d06e3");
var D = { ref: "mapRef", class: "mapdiv" };
popScopeId();
var E = C((a) => (openBlock(), createBlock("div", null, [createVNode("div", D, null, 512), renderSlot(a.$slots, "default", { ready: a.ready, map: a.map, api: a.api, mapTilesLoaded: a.mapTilesLoaded }, void 0, true)])));
A.render = E;
A.__scopeId = "data-v-177d06e3";
var F = (a, b, e, c) => {
  let d = null;
  const g = ref(null), f = inject(p, ref(null)), m = inject(q, ref(null));
  watch([f, e], (h, [n, k]) => {
    h = JSON.stringify(e.value) !== JSON.stringify(k) || f.value !== n;
    f.value && m.value && h && (d ? (d.setOptions(e.value), d.setMap(f.value)) : (g.value = d = new m.value[a]({ ...e.value, map: f.value }), b.forEach((a2) => {
      null === d || void 0 === d ? void 0 : d.addListener(a2, (b2) => c(a2, b2));
    })));
  }, { immediate: true });
  onBeforeUnmount(() => {
    var a2;
    d && (null === (a2 = m.value) || void 0 === a2 ? void 0 : a2.event.clearInstanceListeners(d), d.setMap(null));
  });
  return g;
};
var G = "animation_changed click dblclick rightclick dragstart dragend drag mouseover mousedown mouseout mouseup draggable_changed clickable_changed contextmenu cursor_changed flat_changed rightclick zindex_changed icon_changed position_changed shape_changed title_changed visible_changed".split(" ");
var H = defineComponent({ name: "Marker", props: { options: { type: Object, required: true } }, emits: G, setup(a, { emit: b, expose: e, slots: c }) {
  a = toRef(a, "options");
  b = F("Marker", G, a, b);
  provide(r, b);
  e({ marker: b });
  return () => {
    var a2;
    return null === (a2 = c.default) || void 0 === a2 ? void 0 : a2.call(c);
  };
} });
var I = defineComponent({ name: "Polyline", props: { options: { type: Object, required: true } }, emits: v, setup(a, { emit: b }) {
  a = toRef(a, "options");
  return { polyline: F("Polyline", v, a, b) };
}, render: () => null });
var K = defineComponent({ name: "Polygon", props: { options: {
  type: Object,
  required: true
} }, emits: v, setup(a, { emit: b }) {
  a = toRef(a, "options");
  return { polygon: F("Polygon", v, a, b) };
}, render: () => null });
var L = v.concat(["bounds_changed"]);
var M = defineComponent({ name: "Rectangle", props: { options: { type: Object, required: true } }, emits: L, setup(a, { emit: b }) {
  a = toRef(a, "options");
  return { rectangle: F("Rectangle", L, a, b) };
}, render: () => null });
var N = v.concat(["center_changed", "radius_changed"]);
var O = defineComponent({ name: "Circle", props: { options: { type: Object, required: true } }, emits: N, setup(a, { emit: b }) {
  a = toRef(a, "options");
  return { circle: F("Circle", N, a, b) };
}, render: () => null });
var P = defineComponent({ props: { position: { type: String, required: true }, index: { type: Number, default: 1 } }, emits: ["content:loaded"], setup(a, { emit: b }) {
  let e = ref(null), c = inject(p, ref(null)), d = inject(q, ref(null)), g = inject(t, ref(false)), f = ref(false), m = watch(
    [g, d, e],
    ([c2, d2, e2]) => {
      d2 && c2 && e2 && (h(a.position), f.value = true, b("content:loaded"), setTimeout(m, 0));
    },
    { immediate: true }
  ), h = (a2) => {
    c.value && d.value && e.value && c.value.controls[d.value.ControlPosition[a2]].push(e.value);
  }, n = (a2) => {
    if (c.value && d.value) {
      let b2 = null;
      a2 = d.value.ControlPosition[a2];
      c.value.controls[a2].forEach((a3, c2) => {
        a3 === e.value && (b2 = c2);
      });
      null !== b2 && c.value.controls[a2].removeAt(b2);
    }
  };
  onBeforeUnmount(() => n(a.position));
  watch(() => a.position, (a2, b2) => {
    n(b2);
    h(a2);
  });
  watch(() => a.index, (b2) => {
    b2 && e.value && (e.value.index = a.index);
  });
  return { controlRef: e, showContent: f };
} });
var Q = { ref: "controlRef" };
P.render = function(a) {
  return openBlock(), createBlock(Fragment, null, [createCommentVNode("\n    v-show must be used instead of v-if otherwise there\n    would be no rendered content pushed to the map controls\n  "), withDirectives(createVNode("div", Q, [renderSlot(a.$slots, "default")], 512), [[vShow, a.showContent]])], 2112);
};
var R = "closeclick content_changed domready position_changed visible zindex_changed".split(" ");
var S = defineComponent({ props: { options: { type: Object, default: () => ({}) } }, emits: R, setup(a, { slots: b, emit: e }) {
  let c, d = ref(), g = ref(), f = inject(p, ref(null)), m = inject(q, ref(null)), h = inject(r, ref(null)), n, k = computed(() => {
    var a2;
    return null === (a2 = b.default) || void 0 === a2 ? void 0 : a2.call(b).some((a3) => a3.type !== Comment);
  });
  onMounted(() => {
    watch([f, () => a.options], ([, a2], [b2, J]) => {
      b2 = JSON.stringify(a2) !== JSON.stringify(J) || f.value !== b2;
      f.value && m.value && b2 && (c ? (c.setOptions({ ...a2, content: k.value ? g.value : a2.content }), h.value || c.open({ map: f.value })) : (d.value = c = new m.value.InfoWindow({ ...a2, content: k.value ? g.value : a2.content }), h.value ? n = h.value.addListener("click", () => {
        c.open({ map: f.value, anchor: h.value });
      }) : c.open({ map: f.value }), R.forEach((a3) => {
        null === c || void 0 === c ? void 0 : c.addListener(a3, (b3) => e(a3, b3));
      })));
    }, { immediate: true });
  });
  onBeforeUnmount(() => {
    var a2;
    n && n.remove();
    c && (null === (a2 = m.value) || void 0 === a2 ? void 0 : a2.event.clearInstanceListeners(c), c.close());
  });
  return { infoWindow: d, infoWindowRef: g, hasSlotContent: k, anchor: h };
} });
B("\n.info-window-content[data-v-5b373d6e] {\n  display: none;\n}\n.mapdiv .info-window-content[data-v-5b373d6e] {\n  display: block;\n}\n");
var T = withScopeId("data-v-5b373d6e");
pushScopeId("data-v-5b373d6e");
var U = { key: 0, ref: "infoWindowRef", class: "info-window-content" };
popScopeId();
var V = T((a) => a.hasSlotContent ? (openBlock(), createBlock("div", U, [renderSlot(a.$slots, "default", {}, void 0, true)], 512)) : createCommentVNode("v-if", true));
S.render = V;
S.__scopeId = "data-v-5b373d6e";
export {
  O as Circle,
  P as CustomControl,
  A as GoogleMap,
  S as InfoWindow,
  H as Marker,
  K as Polygon,
  I as Polyline,
  M as Rectangle
};
//# sourceMappingURL=vue3-google-map.js.map
